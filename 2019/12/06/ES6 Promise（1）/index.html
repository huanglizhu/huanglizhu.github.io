<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>ES6 Promise（1） | 珠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="前端,程序员,软件开发,面试,CSS,JavaScript,JS,ES6,HTML,Node.js,React,Vue">
  
  
  
  
  <meta name="description" content="复习：同步与异步  同步任务会阻塞程序执行（alert、for、…） 异步任务不会阻塞程序执行（setTimeout、fs.readFile、…） 可参考笔记[异步和单线程]中的例子来帮助理解。">
<meta name="keywords" content="ES6">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 Promise（1）">
<meta property="og:url" content="http://yoursite.com/2019/12/06/ES6 Promise（1）/index.html">
<meta property="og:site_name" content="珠">
<meta property="og:description" content="复习：同步与异步  同步任务会阻塞程序执行（alert、for、…） 异步任务不会阻塞程序执行（setTimeout、fs.readFile、…） 可参考笔记[异步和单线程]中的例子来帮助理解。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz9jm0as0j30le0flahy.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz98gq1q6j30m90g5n57.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz9ru5cq1j30gi08zwj7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz9v1bp0dj30gr0bjag5.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gbza0ybhylj30mx08aq7q.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gbza03eityj30ix093q7b.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gby2pdvwxgj30q10ksgzd.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gby2xhr8g2j30r70i0ws2.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gby5qy35hpj30ur0k9wv6.jpg">
<meta property="og:updated_time" content="2020-02-17T08:52:19.347Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ES6 Promise（1）">
<meta name="twitter:description" content="复习：同步与异步  同步任务会阻塞程序执行（alert、for、…） 异步任务不会阻塞程序执行（setTimeout、fs.readFile、…） 可参考笔记[异步和单线程]中的例子来帮助理解。">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz9jm0as0j30le0flahy.jpg">
  
    <link rel="alternate" href="/atom.xml" title="珠" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/sx.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


        <header id="allheader" class="site-header" role="banner"  >
                <div class="clearfix container">
                    <div class="site-branding">

                        <h1 class="site-title">
                            
                                    <a href="/" title="珠" rel="home">
                                        珠
                                    </a>
                                    
                        </h1>

                        
                            <div class="site-description">
                                Record every bit of front-end learning.
                            </div>
                            

                                <nav id="main-navigation" class="main-navigation" role="navigation">
                                    <a class="nav-open">Menu</a>
                                    <a class="nav-close">Close</a>

                                    <div class="clearfix sf-menu">
                                        <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                                            
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/">
                                                        主页
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/archives">
                                                        归档
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/categories">
                                                        分类
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/tags">
                                                        标签
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/about">
                                                        关于
                                                    </a>
                                                </li>
                                                
                                        </ul>
                                    </div>
                                </nav>

                    </div>
                </div>
        </header>

  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-ES6 Promise（1）" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      ES6 Promise（1）
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/12/06/ES6 Promise（1）/" class="article-date">
	  <time datetime="2019-12-06T04:29:23.000Z" itemprop="datePublished">十二月 6, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6学习/">ES6学习</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>复习：同步与异步</strong></p>
<ul>
<li><strong>同步任务会阻塞</strong>程序执行（alert、for、…）</li>
<li><strong>异步任务不会阻塞</strong>程序执行（setTimeout、fs.readFile、…）</li>
<li>可参考笔记[异步和单线程]中的例子来帮助理解。<a id="more"></a>
</li>
</ul>
<hr>
<h1 id="Promise对象"><a href="#Promise对象" class="headerlink" title="Promise对象"></a><code>Promise</code>对象</h1><blockquote>
<p>Promise对象用于表示一个异步操作的最终状态（完成或失败）以及其返回的值。–MDN</p>
</blockquote>
<ul>
<li>Promise，简单说就是一个<strong>容器</strong>，里面<strong>保存</strong>着某个未来才会结束的事件（通常是一个<strong>异步操作</strong>）的<strong>结果</strong>。</li>
<li>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，<strong>避免了层层嵌套的回调函数</strong>。</li>
</ul>
<h2 id="Promise对象三种状态和特点"><a href="#Promise对象三种状态和特点" class="headerlink" title="Promise对象三种状态和特点"></a><code>Promise</code>对象三种状态和特点</h2><ol>
<li><strong>对象的状态不受外界影响</strong>。Promise对象代表一个异步操作，有三种状态：<strong>pending（进行中）、fulfilled（已成功）和rejected（已失败）</strong>。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。<strong>(后面的resolved统一只指fulfilled状态，不包含rejected状态。)</strong></li>
<li><strong>一旦状态改变，就不会再变，任何时候都可以得到这个结果</strong>。Promise对象的状态改变，只有两种可能：<strong>从pending变为fulfilled 或 从pending变为rejected</strong>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。<strong>这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的</strong>。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li><strong>Promise 新建后就会立即执行，无法中途取消</strong>。</li>
<li><strong>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部</strong></li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ol>
<p>更多资料可参考<a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">阮一峰《ES6入门》中关于“promise”的描述</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener">MDN“使用promise”</a></p>
<h2 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise()构造函数"></a><code>Promise()</code>构造函数</h2><ul>
<li>ES6 规定，<strong><code>Promise()</code>是一个构造函数，用来生成Promise实例</strong>。</li>
<li><code>Promise()</code>的参数是一个回调函数，<strong>一般我们在这个回调函数中放置异步任务</strong>，这个回调函数又接收两个回调函数（<code>resolve</code>和<code>reject</code>）作为参数，当<strong>异步任务成功时执行回调函数<code>resolve</code></strong>，当异步任务失败是执行回调函数<code>reject</code>。</li>
<li><code>Promise（）</code>新建后就会<strong>立即执行</strong>。</li>
<li><strong><code>then</code>方法的参数（回调函数）将在当前脚本所有同步任务执行完才会执行</strong></li>
<li><strong>注意，调用resolve()或reject()并不会终结 Promise 的参数函数的执行</strong>。</li>
<li><strong>注意：</strong>在<strong>Promise构造函数的内部，执行顺序是同步的</strong>。等内部执行完成后，再选择调用<code>then</code>或<code>catch</code>方法，<strong>then方法执行是异步的</strong>。在事件循环中要<strong>注意执行顺序</strong>。（可以参考笔记[ES6 Promise（3）]）</li>
</ul>
<h3 id="参数resolve和reject"><a href="#参数resolve和reject" class="headerlink" title="参数resolve和reject"></a>参数<code>resolve</code>和<code>reject</code></h3><ul>
<li><strong><code>Promise</code>构造函数</strong>接收一个<strong>函数作为参数</strong>，<strong>该函数的两个参数</strong> 分别是<strong><code>resolve</code>和<code>reject</code></strong>，它们 <strong>也是两个函数</strong> ，由 JavaScript 引擎提供，不用自己部署。</li>
</ul>
<p><strong>【参数名可自定义，<code>resolve</code>和<code>reject</code>是约定俗成的参数名】</strong></p>
<ul>
<li><code>resolve()</code>或<code>reject()</code>总是<strong>晚于本轮循环的同步任务</strong>。</li>
<li><code>resolve()</code>使<code>Promise</code>对象的状态从 <code>pending</code> 变为 <code>resolved</code>。而<code>reject()</code>使<code>Promise</code>对象的状态从 <code>pending</code> 变为 <code>rejected</code>。<strong>状态一旦改变就不可逆转</strong>。</li>
<li>可以<strong>通过<code>resolve()</code>或<code>reject()</code>传参给<code>then()</code>或<code>catch（）</code></strong>。</li>
<li>一般来说，<strong>调用<code>resolve</code>或<code>reject</code>以后</strong>，Promise 的使命就完成了，<strong>后继操作应该放到<code>then</code>或<code>catch</code>方法里面</strong>，而不应该直接写在<code>resolve</code>或<code>reject</code>的后面。所以，最好在<code>resolve</code>或<code>reject</code>前面加上return语句，这样函数就结束了，后面语句自然也就不会执行了（<code>return resolve();</code>）。</li>
</ul>
<hr>
<h4 id="帮助理解resolve-和reject"><a href="#帮助理解resolve-和reject" class="headerlink" title="帮助理解resolve()和reject()"></a>帮助理解<code>resolve()</code>和<code>reject()</code></h4><ul>
<li>调用<code>resolve()</code>或<code>reject()</code><strong>并不会终结 Promise 的参数函数的执行</strong>。</li>
<li>但是<strong>调用<code>resolve()</code></strong>时会将 <strong>Promise 对象的状态</strong>会从“未完成”变为“成功”（即<strong>从 <code>pending</code> 变为 <code>resolved</code></strong>），那么<strong><code>then()</code>方法的第一参数（函数）就会执行</strong>。</li>
<li>而<strong>调用<code>reject()</code></strong>时会将<strong><code>Promise</code>对象的状态</strong>从“未完成”变为“失败”（即<strong>从 <code>pending</code> 变为 <code>rejected</code></strong>），那么<strong><code>then()</code>方法的第二参数（函数）或者<code>catch()</code>就会执行</strong>。</li>
<li>也就是说，调用<code>resolve()</code>或<code>reject()</code>不会终结 Promise 的参数函数的执行,但它可以告诉我们接下来运行<code>then()</code>还是<code>catch()</code>，所以为了防止<code>resolve()</code>或<code>reject()</code>后面的函数还继续执行，<strong>最好在<code>resolve</code>或<code>reject</code>前面加上return语句，这样函数就结束了，后面语句自然也就不会执行了（<code>return resolve();</code>）</strong>。</li>
</ul>
<p><strong><code>resolve</code>函数</strong>：</p>
<ol>
<li>在<strong>异步操作成功时调用</strong>，并<strong>将 异步操作的结果 作为 参数 传递出去</strong>。</li>
<li><strong>作用</strong>：是将<strong>Promise对象的状态</strong>从“未完成”变为“成功”（即<strong>从 <code>pending</code> 变为 <code>resolved</code></strong>）。</li>
<li>可传参，通过resolve()传递的参数会在then()的第一个参数（函数）中接收到。（但<strong>只能传递一个参数</strong>）</li>
</ol>
<p><strong><code>reject</code>函数</strong>：</p>
<ol>
<li>在<strong>异步操作失败时调用</strong>，并<strong>将 异步操作报出的错误 作为 参数 传递出去</strong>。</li>
<li><strong>作用</strong>：将<strong><code>Promise</code>对象的状态</strong>从“未完成”变为“失败”（即<strong>从 <code>pending</code> 变为 <code>rejected</code></strong>）。</li>
<li>可传参，通过 reject()传递的参数会在then()的第二个参数（函数）/catch()中接收到。（但<strong>只能传递一个参数</strong>）</li>
</ol>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>下面代码<strong>创造了一个Promise实例</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="加上then方法"><a href="#加上then方法" class="headerlink" title="加上then方法"></a>加上<code>then</code>方法</h3><p><code>Promise</code>实例生成以后，可以用<strong><code>then</code>方法</strong>分别<strong>指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数</strong>:</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> &#123;</span></span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong><code>then</code>方法可以接受两个回调函数作为参数</strong>。第一个回调函数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用，第二个回调函数是<code>Promise</code>对象的状态变为<code>rejected</code>时调用。其中，<strong>第二个函数是可选的</strong>，不一定要提供。<strong>这两个函数都接受Promise对象传出的值作为参数</strong>。</p>
<h2 id="例子-Promise新建后立即执行"><a href="#例子-Promise新建后立即执行" class="headerlink" title="例子:Promise新建后立即执行"></a>例子:<code>Promise</code>新建后立即执行</h2><p><strong><code>Promise</code>新建后就会立即执行</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise</code> 新建后立即执行，所以首先输出的是<code>Promise</code>。然后，<strong><code>then</code>方法的参数（回调函数）将在当前脚本所有同步任务执行完才会执行</strong>，所以<code>resolved</code>最后输出。</p>
<h2 id="例子-Promise对象的then"><a href="#例子-Promise对象的then" class="headerlink" title="例子:Promise对象的then()"></a>例子:Promise对象的<code>then()</code></h2><p>下面是一个<strong>Promise对象的简单例子</strong>:</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve, reject)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//m</span>s毫秒之后调用resolve函数并将参数`<span class="javascript"><span class="string">"done"</span></span>`传给`<span class="javascript">resolve</span>`函数</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span><span class="keyword">then</span>的第一个参数是`<span class="javascript"><span class="built_in">Promise</span></span>`对象的状态变为`<span class="javascript">resolved</span>`时调用的回调函数（即promise执行函数成功执行以后会调用的函数），这里省略了第二个参数</span><br><span class="line">timeout(<span class="number">100</span>).<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>timeout(100)</code>：调用<code>timeout</code>方法时传入<code>ms</code>为100，然后<code>timeout</code>方法返回一个<code>Promise</code>实例，表示ms(也就是100)毫秒之后调用<code>resolve</code>函数并将参数<code>&quot;done&quot;</code>传给<code>resolve</code>函数。<br>过了100毫秒（ms参数）以后，<strong><code>Promise</code>实例的状态变为<code>resolved</code></strong>，接着触发<code>then</code>方法绑定的回调函数,打印<code>value</code>。【<strong><code>then()</code>的第一个参数是<code>Promise</code>对象的状态变为<code>resolved</code>时调用的回调函数</strong>（即promise执行函数成功执行以后会调用的函数），这里省略了第二个参数】。</p>
<hr>
<h2 id="例子-异步加载图片"><a href="#例子-异步加载图片" class="headerlink" title="例子:异步加载图片"></a>例子:异步加载图片</h2><p><strong>复习</strong>：DOM事件<code>onload</code>会等到<strong>图片加载完成后立即执行</strong>（<a href="https://huanglizhu.github.io/2020/01/09/JS_DOM%E4%BA%8B%E4%BB%B6/" target="_blank" rel="noopener">参考笔记</a>）。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAsync</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//onload:图片加载完成后立即执行</span></span><br><span class="line">    image.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(image);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Could not load image at '</span> + <span class="built_in">url</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    image.src = <span class="built_in">url</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，使用Promise包装了一个图片加载的异步操作。<strong>如果加载成功，就调用resolve方法，否则就调用reject方法</strong>。</p>
<hr>
<h2 id="例子-resolve-参数是Promise对象"><a href="#例子-resolve-参数是Promise对象" class="headerlink" title="例子:resolve()参数是Promise对象"></a>例子:<code>resolve()</code>参数是Promise对象</h2><p><strong><code>resolve()</code>的参数是另一个Promise对象的情况</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</li>
<li><strong>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。</strong>如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。</li>
</ul>
<hr>
<h1 id="Promise-prototype-then-与-链式操作"><a href="#Promise-prototype-then-与-链式操作" class="headerlink" title="Promise.prototype.then()与 链式操作"></a><code>Promise.prototype.then()</code>与 链式操作</h1><ul>
<li><p>每个<strong>Promise实例都拥有<code>then()</code>，<code>then()</code>根据调用它的promise对象的状态决定使用哪个参数（回调函数）。</strong></p>
</li>
<li><p><code>then()</code>为 <code>Promise</code> 实例 添加状态改变时的 回调函数。</p>
</li>
<li><p><code>then</code>方法的 <strong>第一个参数</strong> 是 <strong>resolved状态的回调函数</strong> ，<strong>第二个参数（可选</strong>）是 <strong>rejected状态的回调函数</strong>。</p>
</li>
<li><p><strong>then()中的参数（回调函数）获取到的参数是由调用它的Promise对象在决议为成功/失败的同时返回的数据。</strong></p>
</li>
<li><p><strong><code>then</code>方法的参数（回调函数）将在当前脚本所有同步任务执行完才会执行</strong></p>
</li>
<li><p><code>then</code>方法<strong>返回</strong>的是<strong>一个新的Promise实例</strong>（注意，不是原来那个Promise实例）。因此可以采用<strong>链式写法</strong>，即<strong>then方法后面再调用另一个then方法</strong>。</p>
</li>
<li><p>采用链式的<code>then</code>，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个<code>Promise</code>对象（即有异步操作），这时后一个回调函数，就会等待该<code>Promise</code>对象的状态发生变化，才会被调用。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(post)</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(comments)</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">"resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span>&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="string">"rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。</p>
</li>
</ul>
<h2 id="resolve-reject-传参"><a href="#resolve-reject-传参" class="headerlink" title="resolve()/reject()传参"></a><code>resolve()</code>/<code>reject()</code>传参</h2><p><strong>then()中的参数（回调函数）获取到的参数是由调用它的Promise对象在决议为成功/失败的同时返回的数据。</strong></p>
<p>通过<code>resolve()</code>传递的参数可在<code>then()</code>第一个参数（回调函数）中通过<code>data</code>获取，通过<code>reject()</code>传递的参数可在<code>then()</code>第二个参数（回调函数）中通过<code>e</code>获取：<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz9jm0as0j30le0flahy.jpg" alt="例子"></p>
<p><strong>注意：回调函数只能传一个参数</strong>，传两个参数时是获取不到第二个参数的：<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz98gq1q6j30m90g5n57.jpg" alt="例子"></p>
<hr>
<h1 id="Promise-prototype-catch-处理失败"><a href="#Promise-prototype-catch-处理失败" class="headerlink" title="Promise.prototype.catch()处理失败"></a><code>Promise.prototype.catch()</code>处理失败</h1><ul>
<li><strong>catch() 方法</strong>同样<strong>返回一个Promise实例</strong>，并且<strong>处理拒绝的情况</strong>。它的行为<strong>与调用<code>Promise.prototype.then()</code>第二个参数（回调函数） 相同</strong>。</li>
<li>由于catch()中处理错误以后返回的还是Promise实例，所以还可以继续调用then()。</li>
<li><strong>一般来说，不要在<code>then</code>方法里面定义 <code>Reject</code> 状态的回调函数（即then的第二个参数），总是使用<code>catch</code>方法。</strong></li>
<li>promise是异步的，then()也是异步的，对异步来说<code>try...catch</code>是没有用的。</li>
</ul>
<p><strong>结合上一个例子：</strong><br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz9ru5cq1j30gi08zwj7.jpg" alt="结合上一个例子"><br>在第二个then()中并没有对错误的处理，所以会继续往下执行，直到遇到catch()。<br>如果catch()前面有then()对错误进行处理，则catch()不执行：<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gbz9v1bp0dj30gr0bjag5.jpg" alt="错误已经处理，catch()不执行"></p>
<p><strong>例子：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// Error: fail</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</li>
<li><strong>注意，调用resolve或reject并不会终结 Promise 的参数函数的执行</strong>。</li>
</ul>
<hr>
<h1 id="Promise-prototype-finally-一定执行"><a href="#Promise-prototype-finally-一定执行" class="headerlink" title="Promise.prototype.finally()一定执行"></a>Promise.prototype.finally()一定执行</h1><p><strong>不论Promise对象的异步操作结果成功还是失败，finally中的内容一定会执行</strong>。</p>
<p><strong>例子</strong>：<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gbza0ybhylj30mx08aq7q.jpg" alt="代码1"><br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gbza03eityj30ix093q7b.jpg" alt="代码2"></p>
<hr>
<h1 id="比较传统的-回调函数-与-promise"><a href="#比较传统的-回调函数-与-promise" class="headerlink" title="比较传统的 回调函数 与 promise"></a>比较传统的 回调函数 与 promise</h1><ul>
<li>使用 回调函数 和 promise 分别实现同样的功能，进行对比。</li>
<li><strong>使用回调函数</strong>写出来的函数像一个“箭头”，层层嵌套，后期修改十分麻烦。</li>
<li><strong>使用promise</strong>方法来写是<strong>链式写法</strong>，后期修改管理都很方便，直接复制粘贴即可。</li>
</ul>
<h2 id="复习逻辑与-amp-amp"><a href="#复习逻辑与-amp-amp" class="headerlink" title="复习逻辑与&amp;&amp;"></a>复习逻辑与<code>&amp;&amp;</code></h2><p><strong>&amp;&amp;：前后都为真才是真，只要有一个是假的就是假</strong>。所以只要有第一个表达式是假的我们就不用继续判断了，返回第一个表达式。如果第一个表达式是真的我们就继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。</p>
<p><strong>明确</strong>：<code>&amp;&amp;</code>和<code>||</code>返回的是<strong>表达式</strong>，<code>!</code>返回的是布尔值！</p>
<p>会被<strong>转换为 false 的表达式</strong>有：<br>null； NaN； 0； 空字符串（”” or ‘’ or ``）； undefined。</p>
<p>所以在下面“回调方法用于请求数据（模拟）”的例子中，<strong><code>cb &amp;&amp; cb()</code>表示“如果存在cb就调用cb()”</strong></p>
<hr>
<h2 id="回调方法用于请求数据（模拟）"><a href="#回调方法用于请求数据（模拟）" class="headerlink" title="回调方法用于请求数据（模拟）"></a>回调方法用于请求数据（模拟）</h2><ul>
<li><strong>回调函数</strong>：将函数b作为参数传到函数a里，当函数a执行完之后，再执行传进去的函数b，这个过程就叫做回调，<strong>回调的就是作为参数的函数b</strong>。</li>
</ul>
<p><strong>使用回调函数用于请求数据的例子</strong>：</p>
<ul>
<li>注意：<strong>调用回调函数时是不需要<code>()</code>的，直接使用函数名！</strong></li>
<li>实现功能：分别间隔一秒打印1,2,3,4</li>
<li>可以看到回调函数的形式来写是<strong>一层层嵌套的金字塔形</strong>，不方便后期的修改：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回调函数就是放在参数里调用的函数，cb就是回调函数</span></span><br><span class="line"><span class="comment">//写一个函数f()用于请求数据</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        cb &amp;&amp; cb();<span class="comment">//如果存在cb就调用cb(),注意cb必须是函数</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用f(),其中cb为匿名函数，间隔一秒打印1,2,3,4</span></span><br><span class="line">f(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//在匿名函数中再嵌套一个f()</span></span><br><span class="line">    f(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//再嵌套一个f()</span></span><br><span class="line">        f(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">            <span class="comment">//再嵌套一个f()</span></span><br><span class="line">            f(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h2 id="promise方法用于请求数据（模拟）"><a href="#promise方法用于请求数据（模拟）" class="headerlink" title="promise方法用于请求数据（模拟）"></a>promise方法用于请求数据（模拟）</h2><ul>
<li>实现同样的功能，使用promise方法来写则是<strong>链式写法</strong>（有关<code>then()</code>和链式操作可参考上面的相关笔记）</li>
<li>后期修改只需要复制粘贴，十分方便。</li>
<li>在例子中，f()返回一个Promise实例，规定了Promise执行成功时执行的函数（1秒后执行resolve()），<strong><code>then()</code>中使用的是第一个参数（回调函数），相当于<code>Promise（）</code>中的<code>resolve</code>函数</strong>。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> f();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> f();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> f();</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> f();</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="实例对比回调与Promise的流程控制"><a href="#实例对比回调与Promise的流程控制" class="headerlink" title="实例对比回调与Promise的流程控制"></a>实例对比回调与Promise的流程控制</h1><p><strong>实现效果</strong>：点击 按钮 后 绿色方块“哦” 分别间隔一秒进行几次平移后回到原始位置。</p>
<p><code>index.html</code>:<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gby2pdvwxgj30q10ksgzd.jpg" alt="index.html"></p>
<h2 id="回调函数实现平移动画"><a href="#回调函数实现平移动画" class="headerlink" title="回调函数实现平移动画"></a>回调函数实现平移动画</h2><p>(<strong>模板字符串</strong>相关知识可参考笔记<a href="https://huanglizhu.github.io/2019/11/07/ES6%E6%89%A9%E5%B1%95%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95/#模版字符串" target="_blank" rel="noopener">ES6扩展 字符串扩展</a>)</p>
<p><code>main.js</code>:<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gby2xhr8g2j30r70i0ws2.jpg" alt="main.js"></p>
<h2 id="使用Promise实现平移动画"><a href="#使用Promise实现平移动画" class="headerlink" title="使用Promise实现平移动画"></a>使用Promise实现平移动画</h2><p><code>main.js</code>:<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gby5qy35hpj30ur0k9wv6.jpg" alt="main.js"><br>（<code>.then()</code>中也可以不用<code>return</code>然后继续<code>.then()</code>并在其中调用<code>moveTo()</code>）</p>
<hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6学习/">ES6学习</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/">ES6</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/12/06/CSS非布局样式：背景/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          CSS非布局样式：背景
        
      </div>
    </a>
  
  
    <a href="/2019/12/05/CSS选择器 知识点汇总/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">CSS选择器 知识点汇总</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise对象"><span class="nav-number">1.</span> <span class="nav-text">Promise对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise对象三种状态和特点"><span class="nav-number">1.1.</span> <span class="nav-text">Promise对象三种状态和特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-构造函数"><span class="nav-number">1.2.</span> <span class="nav-text">Promise()构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#参数resolve和reject"><span class="nav-number">1.2.1.</span> <span class="nav-text">参数resolve和reject</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#帮助理解resolve-和reject"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">帮助理解resolve()和reject()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子"><span class="nav-number">1.3.</span> <span class="nav-text">例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#加上then方法"><span class="nav-number">1.3.1.</span> <span class="nav-text">加上then方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-Promise新建后立即执行"><span class="nav-number">1.4.</span> <span class="nav-text">例子:Promise新建后立即执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-Promise对象的then"><span class="nav-number">1.5.</span> <span class="nav-text">例子:Promise对象的then()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-异步加载图片"><span class="nav-number">1.6.</span> <span class="nav-text">例子:异步加载图片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#例子-resolve-参数是Promise对象"><span class="nav-number">1.7.</span> <span class="nav-text">例子:resolve()参数是Promise对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise-prototype-then-与-链式操作"><span class="nav-number">2.</span> <span class="nav-text">Promise.prototype.then()与 链式操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#resolve-reject-传参"><span class="nav-number">2.1.</span> <span class="nav-text">resolve()/reject()传参</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise-prototype-catch-处理失败"><span class="nav-number">3.</span> <span class="nav-text">Promise.prototype.catch()处理失败</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Promise-prototype-finally-一定执行"><span class="nav-number">4.</span> <span class="nav-text">Promise.prototype.finally()一定执行</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#比较传统的-回调函数-与-promise"><span class="nav-number">5.</span> <span class="nav-text">比较传统的 回调函数 与 promise</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#复习逻辑与-amp-amp"><span class="nav-number">5.1.</span> <span class="nav-text">复习逻辑与&amp;&amp;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回调方法用于请求数据（模拟）"><span class="nav-number">5.2.</span> <span class="nav-text">回调方法用于请求数据（模拟）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#promise方法用于请求数据（模拟）"><span class="nav-number">5.3.</span> <span class="nav-text">promise方法用于请求数据（模拟）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例对比回调与Promise的流程控制"><span class="nav-number">6.</span> <span class="nav-text">实例对比回调与Promise的流程控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#回调函数实现平移动画"><span class="nav-number">6.1.</span> <span class="nav-text">回调函数实现平移动画</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Promise实现平移动画"><span class="nav-number">6.2.</span> <span class="nav-text">使用Promise实现平移动画</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
    

                <div class="clearfix container">
                    <div class="site-info">
                        &copy;
                        2020
                            珠 All Rights Reserved.
                                
                                    <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量
                                    <span id="busuanzi_value_site_pv"></span>次
                                    </span>
                                    
                    </div>
                    <div class="site-credit">
                        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
                    </div>
                </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
