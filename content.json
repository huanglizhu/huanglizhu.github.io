{"meta":{"title":"珠","subtitle":null,"description":"Record every bit of front-end learning.","author":"黄丽珠","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于我","date":"2019-09-16T04:23:50.000Z","updated":"2020-01-18T05:00:18.340Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"作者： HLZ 出处： http://huanglizhu.github.io/ 邮箱： 651526410@qq.com 本文基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载、演绎,但是必须保留本文的署名 HLZ及链接。"},{"title":"分类","date":"2019-09-16T04:23:41.000Z","updated":"2019-09-16T08:55:15.762Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-09-16T04:23:28.000Z","updated":"2019-09-16T04:25:08.820Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React 高级内容（3）","slug":"React高级内容（3）","date":"2020-02-06T08:27:03.000Z","updated":"2020-02-06T08:28:19.821Z","comments":true,"path":"2020/02/06/React高级内容（3）/","link":"","permalink":"http://yoursite.com/2020/02/06/React高级内容（3）/","excerpt":"render函数必须存在所有的生命周期函数都可以没有，但render函数必须存在，否则报错。原因：组件时继承自react的Component的，其中内置了其他所有的生命周期函数，唯独没有render函数。所以我们的render函数是必须自己定义的。","text":"render函数必须存在所有的生命周期函数都可以没有，但render函数必须存在，否则报错。原因：组件时继承自react的Component的，其中内置了其他所有的生命周期函数，唯独没有render函数。所以我们的render函数是必须自己定义的。 React生命周期函数的使用场景在http://localhost:3000/中**设置 highlight，那么页面上被 重新渲染的 组件 就会被框起来：可以发现输入input框时不仅父组件被渲染，子组件也被渲染**： 利用它做性能优化需优化原因需优化原因：父组件数据更新 子组件render也被执行 例子：子组件TodoItem在子组件TodoItem的render函数中加一个打印语句： 1console.log(\"child render\"); 提交11时第一次执行Todoltem的render函数,在父组件的输入框中输入9个数字时不仅执行父组件的render函数9次，还执行了子组件Todoltem的render函数9次： 这就是我们之前讲的“当父组件的render函数被运行时，它的子组件的render都将被重新运行一次”。可实际上并不需要执行子组件的render，所以我们可以使用生命周期函数来做性能优化。 使用shouldComponentUpdate注意： shouldComponentUpdate 应该需要自带两个参数(nextProps, nextState)，他们代表即将更新的两个数据。 在上一篇笔记 React高级内容（2） 的“React的生命周期函数”中我们提到过，不管state还是props更新都要先通过shouldComponentUpdate来判断是否需要更新。 在子组件TodoItem中使用 shouldComponentUpdate 做性能优化，避免content无变化时被父组件更新带动执行子组件render： 1234567shouldComponentUpdate(nextProps, nextState) &#123; if (nextProps.content !== this.props.content) &#123; return true; &#125; else &#123; return false; &#125;&#125; 可以看到子组件的render仅在提交1时执行了一次，后面父组件的10次改动都并未执行子组件的render： 总结：我们使用 shouldComponentUpdate 函数减少了虚拟DOM的比对，实现了性能优化。 发生 AJAX请求 列表数据如果我们希望通过AJAX请求得到输入框下面的 列表数据 ，我们需要明确：首先，不能把AJAX请求放在render函数中，因为数据更新时render会被再次执行。所以我们需要放在组件中一个 只会被执行一次的函数 中，那么我们可以在父组件中添加 componentDidMount 函数，在页面渲染好（render函数执行后）触发 AJAX请求。 使用componentDidMount函数为什么 我们需要放在组件中一个 只会被执行一次的函数 中。 componentWillMount函数 也只执行一次，但是到了react native或者更深的时候放在componentWillMount函数中就会报错，所以我们默认将AJAX请求 放在 componentDidMount里。 虽然constructor构造函数也只执行一次，但还是建议将AJAX请求 放在 componentDidMount里。 例子：TodoList中发送AJAX请求借助axios模块React并不像jquery那样封装了AJAX发送的内置功能，所以我们需要借助 第三方模块axios。 安装第三方模块axios：在程序终端输入yarn add axios,加载完成后输入npm start重启服务器: 在父组件TodoList中引用axios： 1import axios from \"axios\"; 通过axios发送AJAX请求获取接口内容： 12345678// render执行后发生AJAX请求componentDidMount() &#123; // 通过axios发送AJAX请求获取接口内容 axios.get(\"/api/todolist\") // 请求成功则执行then，失败执行catch .then(() =&gt; &#123; alert(\"成功\"); &#125;) .catch(() =&gt; &#123; alert('失败'); &#125;)&#125; 当然并没有这个接口，所以最后会显示： 但是我们点开network可以发现确实发送了一个 http://localhost:3000/api/todolist 的请求，只不过404了： 回顾学过的性能优化（面试） 在constructor函数里绑定 事件函数 的 this指向（bind），而不是在事件函数内绑定，这样可以保证整个程序里只绑定一次，且可以避免 子组件 的无谓渲染。（后面会细讲） React的底层内置的setState是异步的，可以把多次的数据改变结合成一次来做，降低了 虚拟DOM 的比对频率。 React的底层用了虚拟DOM的概念，替代了之前的 真实的DOM（JS对象）。 React的 diff算法： 同层比对、key值的运用 来提升 虚拟DOM 比对的速度。 借助生命周期函数shouldComponentUpdate来提高组件性能，避免不必要的子组件render函数的渲染更新。 使用Charles实现本地接口数据mock在上面我们调用接口获取数据时因为接口不存在所以爆出404，但是前端开发和后端是分离的，所以我们就需要在没有接口的情况下 使用 Charles 进行接口数据模拟 。 Charles 是一个抓包工具，他可以抓住我们的浏览器向外发送的请求并进行处理。 工作原理：我们可以在tools里的map local中进行设置，Charles抓取到“map from”中的地址请求就会返回“map to”中选择的文件的数据。Charles就是一个中间代理服务器。 比如：他看到我们请求的接口地址是“http://http://localhost.charlesproxy.com:3000/api/todolist”，那么通过Charles我们可以设置 当接收这个地址的请求时就返回我们桌面的todolist.json文件内的数据，这也就起到了接口模拟数据的作用。 下载安装 Charles 下载地址：https://www.charlesproxy.com/latest-release/download.do 安装：一路next，然后选择路径。 破解：https://www.zzzmode.com/mytools/charles/（替换本地lib中的jar包） 重启，就不会显示需要破解的相关信息了 Charles代理ChromeCharles在Windows下，默认只代理IE浏览器，对 Chrome 需要设置后才能抓包。SwitchySharp工具下载地址Chrome设置教程 Charles抓localhost的包弄好之后可以发现确实可以抓取chrome的包，但并不能抓取localhost的包，Charles官方对不能捕获localhost本地网页的说明，以及解决方法。全文大致意思如下： Localhost流量不会出现在Charles中某些系统被硬编码为不使用代理进行本地主机流量，因此当您连接到http：// localhost /时，它不会显示在Charles中。解决方法是连接到http://localhost.charlesproxy.com/。这指向IP地址127.0.0.1，因此它应该与localhost完全相同，但它的优势在于它将通过Charles。无论Charles是在跑还是你在使用Charles，这都会有效。如果您使用其他端口，例如8080，只需像往常一样添加它，例如localhost.charlesproxy.com:8080。您还可以在该域前放置任何内容，例如myapp.localhost.charlesproxy.com，它也将始终解析为127.0.0.1。或者，您可以尝试添加.在localhost之后，或用本机名称替换localhost，或使用本地链接IP地址（例如192.168.1.2）。如果Charles正在运行并且您使用Charles作为代理，那么您也可以使用local.charles作为localhost的替代方案。请注意，这仅在您使用Charles作为代理时才有效，因此上述方法是首选方法，除非您特别希望请求在不使用Charles时失败。 解决方法：原本的网址：http://localhost:3000/现在换成：http://localhost.charlesproxy.com:3000/成功抓包（例子可看下方） 例子（TodoList）需要实现的功能：在TodoList中发送的AJAX请求（接口）获取到桌面上todolist.json文件内的内容并显示在输入框下作为默认的无序列表。 获取到todolist.json内数据桌面右键新建文件todolist.json并放入数据（这就是接口的模拟数据）: 1[\"你好呀\",\"你叫什么名字？\",\"我是胡萝卜\"] 在http://localhost.charlesproxy.com:3000/中我们可以看到**AJAX请求的接口地址**： 希望在 TodoList.js组件中发送AJAX请求时将桌面上的todolist.json文件内的数据返回过来，则需要借助 Charles 进行设置。打开 Charles,进行设置，抓取到请求的接口地址是“http://localhost.charlesproxy.com:3000/api/todolist”时就返回`todolist.json`文件的数据： 发送的AJAX请求 数据获取成功： 可以看到获取到的数据： 显示在页面上我们先修改TodoList.js的代码，打印看看成功接收到的数据res： 123456789componentDidMount() &#123; // 通过axios发送AJAX请求获取接口内容 axios.get(\"/api/todolist\") // 请求成功则执行then，失败执行catch .then((res) =&gt; &#123; console.log(res); &#125;) .catch(() =&gt; &#123; alert('失败'); &#125;)&#125; 可以注意到res里面有一个 数组data 包含我们想要的数据： 修改then函数中的打印语句： 1console.log(res.data); 可以看到data就是我们想要显示在页面上的数据： 我们知道，在React中，修改state数据页面就会重新渲染，而state中的列表是保存在list: []中的，所以我们可以使用setState改变state中的list数据使data数组成为无序列表显示在输入框下。复习：setState（）中最好传入一个函数作为参数，记得return： 12345678910111213componentDidMount() &#123; // 通过axios发送AJAX请求获取接口内容 axios.get(\"/api/todolist\") // 请求成功则执行then，失败执行catch .then((res) =&gt; &#123; this.setState(() =&gt; &#123; return &#123; list: res.data &#125; &#125;); &#125;) .catch(() =&gt; &#123; alert('获取失败'); &#125;)&#125; 结果：todolist.json文件中的内容显示在输入框下面，并且可以实现点击删除，也可以提交新的数据 思路：state中的list更新后， 父组件TodoList 就会重新执行 render函数 ，那么 render函数 中的 getTodoItem函数 也会被重新执行，在getTodoItem函数中会遍历list中的每一个数据并把他们依次传入 子组件TodoItem 中，在 子组件TodoItem 中每一项都会实现 点击删除 的功能，返回的子组件们就会在父组件的ul标签中形成无序列表。 优化代码当函数中返回的代码只有一句时，我们可以使用()包裹代码从而代替函数的{}return:（相关原因可看笔记”函数相关知识点补充“中的 箭头函数） 我们之前把data放到list中list: res.data，但最好使用扩展运算符将其复制到list中： list: [...res.data]，以免因为数据的改动产生不好的影响。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Charles代理Chrome抓取localhost的包","slug":"Charles代理Chrome抓取localhost的包","date":"2020-02-06T07:44:55.000Z","updated":"2020-02-06T07:46:21.296Z","comments":true,"path":"2020/02/06/Charles代理Chrome抓取localhost的包/","link":"","permalink":"http://yoursite.com/2020/02/06/Charles代理Chrome抓取localhost的包/","excerpt":"慕课实战遇到的问题在React中想使用Charles实现接口数据模拟。发现两个问题： Charles无法代理Chrome，所以一开始没抓到chrome的包。 Charles无法抓localhost的包，导致无法实现接口模拟。","text":"慕课实战遇到的问题在React中想使用Charles实现接口数据模拟。发现两个问题： Charles无法代理Chrome，所以一开始没抓到chrome的包。 Charles无法抓localhost的包，导致无法实现接口模拟。 解决：Charles代理ChromeCharles在Windows下，默认只代理IE浏览器，对 Chrome 需要设置后才能抓包。SwitchySharp工具下载地址Chrome设置教程 解决：Charles抓localhost的包弄好之后可以发现确实可以抓取chrome的包，但并不能抓取localhost的包。 官方解释Charles官方对不能捕获localhost本地网页的说明，以及解决方法。全文大致意思如下： Localhost流量不会出现在Charles中某些系统被硬编码为不使用代理进行本地主机流量，因此当您连接到http：// localhost /时，它不会显示在Charles中。解决方法是连接到http://localhost.charlesproxy.com/。这指向IP地址127.0.0.1，因此它应该与localhost完全相同，但它的优势在于它将通过Charles。无论Charles是在跑还是你在使用Charles，这都会有效。如果您使用其他端口，例如8080，只需像往常一样添加它，例如localhost.charlesproxy.com:8080。您还可以在该域前放置任何内容，例如myapp.localhost.charlesproxy.com，它也将始终解析为127.0.0.1。或者，您可以尝试添加.在localhost之后，或用本机名称替换localhost，或使用本地链接IP地址（例如192.168.1.2）。如果Charles正在运行并且您使用Charles作为代理，那么您也可以使用local.charles作为localhost的替代方案。请注意，这仅在您使用Charles作为代理时才有效，因此上述方法是首选方法，除非您特别希望请求在不使用Charles时失败。 解决方法原本想抓取的网址：http://localhost:3000/现在换成：http://localhost.charlesproxy.com:3000/成功抓包（例子可看下方） 接口模拟例子桌面右键新建文件todolist.json并放入数据（这就是接口的模拟数据）: 1[\"你好呀\",\"你叫什么名字？\",\"我是胡萝卜\"] 在http://localhost.charlesproxy.com:3000/中我们可以看到在父组件TodoList.js中设置的**AJAX请求的接口地址**： 希望在 TodoList.js组件中发送AJAX请求时将桌面上的todolist.json文件内的数据返回过来，则需要借助 Charles 进行设置。打开 Charles,进行设置，抓取到请求的接口地址是“http://localhost.charlesproxy.com:3000/api/todolist”时就返回`todolist.json`文件的数据： 发送的AJAX请求 数据获取成功： 可以看到获取到的数据：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React 高级内容（2）","slug":"React高级内容（2）","date":"2020-02-05T11:39:11.000Z","updated":"2020-02-06T03:27:33.870Z","comments":true,"path":"2020/02/05/React高级内容（2）/","link":"","permalink":"http://yoursite.com/2020/02/05/React高级内容（2）/","excerpt":"React中ref的使用（尽量不用）ref-&gt;reference 引用在React中我们可以使用ref来直接完成DOM的引用。","text":"React中ref的使用（尽量不用）ref-&gt;reference 引用在React中我们可以使用ref来直接完成DOM的引用。 但是尽量不要使用ref来获取页面上的DOM，要时刻记得我们要减少去操作DOM，我们在React中应该直接去操作state数据，十分复杂的情况下可使用（比如动画）。 有时候同时使用ref和setState时数据的获取会有延迟，是因为setState是异步的，他并不是马上处理的，所以会停留在上一次的数据。此时可以 将获取DOM的这段代码放在setState的第二个参数的函数里，那么她就会在页面完全渲染好以后再进行DOM元素的获取。 使用e.target引用对应的DOM元素TodoList中: 123456&lt;input id=\"inserArea\" className=\"input\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125;/&gt; 我们可以通过e.target来获取元素对应的DOM，也可以通过ref来获取元素对应的DOM。 使用ref引用对应的DOM元素在react16的语法中，ref等于一个函数，这个函数自动接收一个参数，参数名可以自定义:ref={(input) =&gt; { this.input = input }} 可改写 TodoList，render函数中: 12345678&lt;input id=\"inserArea\" className=\"input\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; //`this.input` 指input对应的DOM元素 ref=&#123;(refInput) =&gt; &#123; this.input = refInput &#125;&#125;/&gt; 同时修改TodoList中的handleInputChange： 1234567handleInputChange() &#123; // this.input相当于e.target const value = this.input.value; this.setState(() =&gt; (&#123; inputValue: value &#125;));&#125; 效果和上面使用e.target是一样的，但其实并不推荐使用ref。【原代码改回e.target再继续下一节课的学习】 同时使用ref和setState时的问题与解决有时候同时使用ref和setState时数据的获取会有延迟，是因为setState是异步的，他并不是马上处理的，所以会停留在上一次的数据。此时可以 将获取DOM的这段代码放在setState的第二个参数的函数里，那么她就会在页面完全渲染好以后再进行DOM元素的获取。 例子在TodoList的render中，我们给&lt;ul&gt;增加一个ref去获取对应的DOM节点（也就是ul元素）： 1234//this.ul指向对应的ul元素，refUl是自定义的&lt;ul ref=&#123;(refUl) =&gt; &#123; this.ul = refUl &#125;&#125;&gt; &#123;this.getTodoItem()&#125;&lt;/ul&gt; 然后在点击“提交”按钮的绑定事件函数 handleBtnClick 中增加一个打印语句，打印ul元素下的所有div标签的长度。 12345678910handleBtnClick() &#123; // prevState：修改数据前的那一次的数据，相当于this.state，但更靠谱 this.setState((prevState) =&gt; (&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...prevState.list, prevState.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;)); console.log(this.ul.querySelectorAll(\"div\").length);&#125; handleBtnClick函数主要作用就是把输入框中的内容加到列表中*（state的list中）并清空输入框，按理说每输入一次div标签就会增加一个。那么输入1时长度应该是1，再次输入2时长度应该是2，可结果明显是DOM元素的获取有延迟：这是因为setState是异步的，并不会马上执行，所以获取的数据有所延迟，此时可以 将获取DOM的这段代码放在setState的第二个参数的函数里，那么她就会在页面完全渲染好以后再进行DOM元素的获取： 1234567891011handleBtnClick() &#123; // prevState：修改数据前的那一次的数据，相当于this.state，但更靠谱 this.setState((prevState) =&gt; (&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...prevState.list, prevState.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;), () =&gt; &#123; console.log(this.ul.querySelectorAll(\"div\").length); &#125;);&#125; 结果： React 的 生命周期函数生命周期函数指在某一时刻组件会自动调用执行的函数。 React 的 生命周期函数 非常重要，建议每天回顾记忆。 例子： “当props或state发生改变时，组件自动调用render函数进行页面挂载。”那么render函数其实就是生命周期函数。 “当组件被创建时，会自动调用 constructor函数 （构造函数）。”所以你也可以认为 constructor函数 是生命周期函数，但是 constructor函数 并不是React独有的，他是ES6自带的，所以我们不把 constructor函数 归类为 生命周期函数 ，但实际上没区别。 组件/DOM第一次挂载的流程（mounting）理解：mount 挂载 -&gt; 将组件放到页面上 -&gt; 渲染页面（第一次） 组件第一次挂载的流程：UNSAFE_componentWillMount函数 -&gt; render函数 -&gt;componentDidMount函数 被React弃用并需要替代的函数们使用componentWillMount时报出警告: 1Warning: componentWillMount has been renamed, and is not recommended for use. React 宣布 生命周期方法重命名为： componentWillMount → UNSAFE_componentWillMount componentWillReceiveProps → UNSAFE_componentWillReceiveProps componentWillUpdate → UNSAFE_componentWillUpdate UNSAFE_componentWillMount函数该函数只在页面即将被挂载时执行，也就是只在第一次将组件放（渲染）到页面上之前才会执行，后续在输入框内输入任何数据都不涉及组件挂载，也就不会执行该函数了。 例子：在TodoList.js中添加： render函数（进行页面挂载）当props或state发生改变时，组件自动调用render函数进行页面挂载，将页面渲染出来。 componentDidMount函数在render函数下方添加componentDidMount函数： 123componentDidMount() &#123; console.log(\"componentDidMount\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 可以看到执行顺序是：UNSAFE_componentWillMount函数 -&gt; render函数 -&gt;componentDidMount函数 清空console框，再次输入数据，此时只有render函数被执行。说明只在组件第一次挂载时才执行UNSAFE_componentWillMount函数 和 componentDidMount函数： 组件更新的流程更新state数据的流程：shouldComponentUpdate函数 判断是否需要更新，不需要（false）则不再执行下面的函数，需要则顺序执行UNSAFE_componentWillUpdate函数 -&gt; componentDidUpdate函数 。 更新props数据的流程：比起更新state数据的流程要在最前方多出一个函数：componentWillReceiveProps函数 当一个组件他自己是顶层组件，没有父组件的情况下，他没有接收到props参数，那么就不会执行 函数，比如TodoList中就没有props参数。 shouldComponentUpdate函数在组件更新之前会被运行，该函数要求返回一个布尔值。“我的组件需要被更改吗？”返回的布尔值相当于给他一个回答，当返回false时不论你怎么修改state数据，组件都在执行该函数后明白你不需要更新，那么render函数就不会被执行，页面也就不会产生任何的反馈。 注意：shouldComponentUpdate函数其实应该自带两个参数（nextProps，nextState）表示即将更新的state和props，具体可看笔记“React高级内容（3）”中的（使用shouldComponentUpdate做性能优化） 例子：【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 一样在TodoList中做演示：当我们鼠标一点进input框就会执行该函数：如果将返回值设为false，则不论你怎么修改state数据，组件都在执行该函数后明白你不需要更新，那么render函数就不会被执行，页面也就不会产生任何的反馈： UNSAFE_componentWillUpdate函数componentWillUpdate函数被弃用，使用会报警告，应使用UNSAFE_componentWillUpdate函数替代: 1react-dom.development.js:12449 Warning: componentWillUpdate has been renamed, and is not recommended for use. 组件被更新之前，他会自动执行，但是他在shouldComponentUpdate之后执行 如果shouldComponentUpdate返回true他才执行 如果返回false，这个函数就不会被执行了 在TodoList中添加： 123UNSAFE_componentWillUpdate() &#123; console.log(\"UNSAFE_componentWillUpdate\");&#125; componentDidUpdate函数组件更新完成后，他会被执行 在TodoList中添加： 123componentDidUpdate() &#123; console.log(\"componentDidUpdate\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 shouldComponentUpdate函数返回值为true时的流程： shouldComponentUpdate函数返回值为false时的流程： UNSAFE_componentWillReceiveProps函数componentWillReceiveProps函数已经被React弃用， 我们需要使用UNSAFE_componentWillReceiveProps函数代替他。 执行条件：一个组件要从父组件接受参数如果这个组件是第一次存在于父组件中，则该函数不会被执行如果这个组件之前已经存在于父组件中，该函数就会执行 在TodoList中添加该函数： 123UNSAFE_componentWillReceiveProps()&#123; console.log(\"UNSAFE_componentWillReceiveProps\");&#125; 然而并无反应，因为TodoList就是顶层函数，他没有父组件，也就不会接受props参数，自然也不存在props更新。 在TodoItem中添加该函数： 123UNSAFE_componentWillReceiveProps()&#123; console.log(\"child UNSAFE_componentWillReceiveProps\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 首先我们要明确，TodoItem这个子组件控制的是输入框下面的ul列表。 当我们输入1并提交，第一次往TodoItem中放入数据时，UNSAFE_componentWillReceiveProps函数并没被执行，这是因为 这个组件必须之前已经存在于父组件中，该函数才会执行：当我们再次输入2并点击提交时，完美符合执行条件，该函数被执行： 把组件从页面去除的流程（unmounting）当这个组件即将从页面中剔除时，该生命周期函数会被执行。 componentWillUnmount函数在TodoItem中添加该函数： 123componentWillUnmount() &#123; console.log(\"child componentWillUnmount\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 输入并提交1以后删除无序列表中的“你好呀-1”： 依次输入并提交1、2，再删除无序列表中的“你好呀-2”： 结果2的原因：TodoList中放在ul标签中的getTodoItem告诉我们，遍历list列表后数组中的每一项都会返回一个子组件TodoItem，所以该无序列表中的每一项都是一个子组件！","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React中的虚拟DOM","slug":"React中的虚拟DOM","date":"2020-02-04T11:40:02.000Z","updated":"2020-02-05T01:10:05.843Z","comments":true,"path":"2020/02/04/React中的虚拟DOM/","link":"","permalink":"http://yoursite.com/2020/02/04/React中的虚拟DOM/","excerpt":"面试： 虚拟DOM 是什么，有什么用总结： 虚拟DOM 就是一个JS对象，用它来描述 真实的DOM。 使用 虚拟DOM 有助于极大提升性能：React对性能的提升在于减少了 真实DOM对象 的生成与比较，取而代之的是使用 虚拟DOM(JS对象) 来完成数据改变后的生成与比较。而用JS形成一个 JS对象 性能损耗非常小，生成一个 DOM元素 性能损耗大，涉及DOM的操作都很耗性能。（具体可看下面 例子 的“第二次优化”） 有了 虚拟DOM 使得跨端应用（React Native）得以实现。（因为像是Android、ios、React Native这些原生应用里是没有 真实DOM 的 ）","text":"面试： 虚拟DOM 是什么，有什么用总结： 虚拟DOM 就是一个JS对象，用它来描述 真实的DOM。 使用 虚拟DOM 有助于极大提升性能：React对性能的提升在于减少了 真实DOM对象 的生成与比较，取而代之的是使用 虚拟DOM(JS对象) 来完成数据改变后的生成与比较。而用JS形成一个 JS对象 性能损耗非常小，生成一个 DOM元素 性能损耗大，涉及DOM的操作都很耗性能。（具体可看下面 例子 的“第二次优化”） 有了 虚拟DOM 使得跨端应用（React Native）得以实现。（因为像是Android、ios、React Native这些原生应用里是没有 真实DOM 的 ） 例子我们通过假设没有 React 来渲染来一步步梳理优化来看看React在背后做了哪些工作。 假设没有 React 来渲染，我们需要做的是： state 数据 JSX 模版 数据 + 模版 结合，生成 真实的DOM ，来挂载在页面上 state 数据 发生改变 数据 + 模版 结合，生成 真实的DOM ，替换 原始的DOM 缺陷：第一次生成了一个完整的DOM片段第二次又生成了一个完整的DOM片段第二次的DOM替换第一次的DOM，非常耗性能 第一次优化 state 数据 JSX 模版 数据 + 模版 结合，生成 真实的DOM ，来挂载在页面上 state 数据 发生改变 数据 + 模版 结合，生成 新的 真实的DOM ，并不替换 原始的DOM 新的DOM（实际上是JS上的DocumentFragment（文档碎片））和 原始的DOM 做比对，找差异 找出只有input框发生了变化 只用 新的DOM中的input元素 替换 原始的DOM中的input元素 缺陷：性能提升并不明显 第二次优化（注意这并不是React完全正确的顺序，请看下面的“深入了解 虚拟DOM”） state 数据 JSX 模版 数据 + 模版 结合，生成 真实的DOM ，来挂载在页面上&lt;div id=&quot;abc&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; 生成 虚拟的DOM (虚拟DOM就是一个JS对象，用它来描述 真实的DOM)[&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;hello world&quot;]]（可以理解为一个 数组结构的对象 ） 【损耗了一点性能：用JS形成一个 JS对象 性能损耗非常小，生成一个 DOM元素 性能损耗大】 state 数据 发生改变 数据 + 模版 结合，生成 新的 虚拟的DOM [&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;bye bye&quot;]] 【极大的提升了性能：因为上一次优化在数据改变后生成的是新的DOM元素，而现在我们让他生成的虚拟DOM实际上是JS对象。】 比较 原始虚拟DOM 和 新的虚拟DOM 的区别，找到区别是 span中的内容 【上一次优化是将两个DOM做对比，而涉及DOM的操作就很耗性能。在这里我们对比的是虚拟DOM（JS对象），提升了性能】 直接操作DOM，改变span中的内容 补充：数组类型的对象对象数组 就是数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋给数组就行了。 注意： 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。（具体可以看笔记“js对象 学习笔记（1）”） 数组中每一项都可以存放不同类型的数据。 深入了解 虚拟DOM 只有页面需要渲染的时候才会生成真实的DOM。 在这里我们明白了render函数中的标签其实并不是页面上的DOM元素，他们是步骤中的 JSX 模版。 第三次优化【注意和之前的“真实DOM”“虚拟DOM”顺序相反】 state 数据 JSX 模版 数据 + 模版 结合，生成 虚拟的DOM[&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;hello world&quot;]] 用 虚拟的DOM 的结构 生成 真实的DOM ，显示在页面上&lt;div id=&quot;abc&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; state 数据 发生改变 数据 + 模版 结合，生成 新的 虚拟的DOM [&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;bye bye&quot;]] 比较 原始虚拟DOM 和 新的虚拟DOM 的区别，找到区别是 span中的内容 直接操作DOM，改变span中的内容 优点： 性能提升了。 有了 虚拟DOM 使得跨端应用（React Native）得以实现。（因为像是Android、ios、React Native这些原生应用里是没有 真实DOM 的 ） React真实的操作顺序JSX -&gt; createElement -&gt; JS 对象（虚拟DOM） -&gt; 真实DOM帮助理解：下面两个return返回的内容其实是一样的： 1234render（）&#123; return &lt;div&gt;item&lt;/div&gt; return React.createElement(\"div\",&#123;&#125;,\"item\");&#125; 虚拟DOM中的Diff算法（Diff-&gt;difference-&gt;找不同） 在上面第7步中我们说去 “当state数据发生改变时，比较 原始虚拟DOM 和 新的虚拟DOM 的区别”， 这里的“比较”采用的就是Diff算法。Diff算法大大提升了两个虚拟DOM之间进行比对的性能。 下面的同层比较 和 key值匹配 就是 Diff算法 的一部分。 为什么setState是异步的（回答之前的笔记“TodoList代码优化”中的问题） （关于什么是异步可参考笔记“JS中的同步与异步”）setState之所以是异步，是因为要提高React底层的性能。提高性能主要靠减少比对次数：如果不是异步的，短时间内修改3次state，则react需要进行3次 虚拟DOM 的比对，而异步则可以把3次比对合并，react只需要进行1次 虚拟DOM 的比对。 异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。我的理解：也就是说如果短时间内多次修改，他会等你停止修改以后才通知主线程可以对我进行比对啦。 同层比较React的 虚拟DOM 采用的是 同层比较 的算法。逐层比对，如果第一层就不同，react就不会往下比对，而是直接使用 新的虚拟DOM 去生成真实的DOM。虽然可能会造成DOM节点渲染的浪费，但同层比对的算法简单，效率快，大大减少了两个虚拟DOM之间比对的性能消耗。 为什么index不能作为key值（回答之前的笔记“TodoList代码优化”中的问题） key值需要是稳定的，可变的key值也就失去了它存在的意义。 原理在React中我们会根据key值给 虚拟DOM 命名，数据修改后 新的 虚拟DOM 就会根据key值和 原始的 虚拟DOM 进行快速比对，多出来的就是修改的DOM。这会大大提升性能。 之前的 TodoList 的例子如果我们使用数组下标index作为key值，我们就没办法保证 新的 虚拟DOM 和 原始的 虚拟DOM 的 名字（key值）一致，也就没办法快速匹配了。所以使用一个稳定的内容作为key值才是稳妥的做法，数组下标index是会因为列表的变化而发生改变的，他是不稳定的。 结合我们之前的 TodoList 的例子，我们将数组下标index作为key值：当我们在页面上依次输入“a,b,c”时，他们对应的key分别是“0 a,1 b,2 c”,而当我们点击a时，a被从list中删除掉，bc对应的key分别是“0 b,1 c”,可以发现如果我们将index作为key则key是可变的。但我们必须保证 新的 虚拟DOM 到了与 原始DOM 比对的树上时它的名字（key值）是没有变的，否则无法快速匹配。可变的key值也就失去了它存在的意义。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"数组结构的对象（对象数组）","slug":"数组结构的对象","date":"2020-02-04T05:52:22.000Z","updated":"2020-02-04T05:54:25.318Z","comments":true,"path":"2020/02/04/数组结构的对象/","link":"","permalink":"http://yoursite.com/2020/02/04/数组结构的对象/","excerpt":"数组类型的对象对象数组 就是数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋给数组就行了。","text":"数组类型的对象对象数组 就是数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋给数组就行了。 注意 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。（具体可以看笔记“js对象 学习笔记（1）”） 数组中每一项都可以存放不同类型的数据。（具体可以看笔记“JS对象之数组(1)”） 例子在React.js中，我们说“ 虚拟DOM 就是一个 JS对象 ，用它来描述 真实的DOM。”(其中的 JS对象 可以理解为一个 数组类型的对象) 我们假设真实的DOM是： 1&lt;div id=\"abc&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; 那么对应的虚拟DOM就是（数组类型的对象）： 1[\"div\",&#123;id:\"abc\"&#125;,[\"span\",&#123;&#125;,\"hello world\"]]","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"React 高级内容（1）","slug":"React高级内容(1)","date":"2020-02-03T13:54:06.000Z","updated":"2020-02-04T12:46:06.879Z","comments":true,"path":"2020/02/03/React高级内容(1)/","link":"","permalink":"http://yoursite.com/2020/02/03/React高级内容(1)/","excerpt":"安装React开发调试工具（React Developer Tools）安装步骤（需要科学上网）：","text":"安装React开发调试工具（React Developer Tools）安装步骤（需要科学上网）： 安装成功：在通过React开发并处于本地开发的页面上图标会显示为红色，说明安装成功： 通过React开发并处于线上版本的网页，图标会显示为黑色： 非React开发的页面上图标会显示为灰色： React Developer Tools 的好处 方便进行 组件结构 的查询、 在组件传值调试时不需要反复通过 console.log 来打印信息，直接看 开发者工具 右侧 state 中是否有相关信息即可。 使用React Developer Tools进入原始页面，打开 开发者工具 ，可以看到新增的 Component ：在输入框内依次输入a b，可以看到右方 state 实时产生变化： 可以很方便的进行 组件结构 查询： PropTypes与DefaultProps的应用PropTypes 强校验子组件在接受父组件传过来的值（即 属性 ）时进行强校验。他可以要求父组件给子组件传的值是什么类型的。如若不是也并不会报错，只会在 开发者工具 中给出警告。 使用步骤 脚手架工具中已经有 prop-types 的包，所以我们可以直接在 子组件 中顶部引入 PropTypes ： 1import PropTypes from 'prop-types'; 在 子组件 export default 顶上使用 propTypes （注意是小写）限制父组件传过来的值的类型（更多值的类型可以看下面”PropTypes不同的验证函数“）： 1234567// 使用propTypes限制父组件传过来的值的类型TodoItem.propTypes = &#123; // 注意PropTypes大小写，上面必须小写，下面是import中自定义的名字 content: PropTypes.string, deleteItem: PropTypes.func, index: PropTypes.number&#125; 如果将 index 的 PropTypes要求 改为 string ，则一旦提交输入内容后就会给出 警告 ，告诉我们子组件接收 index 时希望得到的是 string 类型的而不是 number ： isRequired强制传值总结： 当父组件没有向子组件传某个值时，某个值对应的propTypes是不生效的。 使用isRequired可以强制要求父组件向子组件传递某个值，如果父组件并未传值就会报出 警告 。 例子1：子组件上增加 test （实际上父组件并未传 test ）：对子组件上 test 进行强校验：然而到页面上输入时并未报出警告，也就是说test: PropTypes.string是没有生效的。 例子2：在 propTypes 中使用isRequired强制要求父组件向子组件传递test值:父组件并未传值，报出 警告： DefaultProps 设置默认值当父组件没有向子组件传递某个值，而子组件使用了该值时，可以在子组件中设置DefaultProps来规定该值的默认值。 注意：上面强校验时引入了PropTypes是因为需要使用PropTypes内的类型（string、func、number等），而DefaultProps不需要另外引入别的包。 有时候你使用isRequired强制要求父组件传过来的值实际上没办法传，这时候就需要用到默认值来解决报错问题，结合上面的例子，我们在子组件中给test一个默认值： 官网深入学习 打开英文官网https://reactjs.org/。（中文官网较为滞后，推荐英文官网） Docs（文档）=&gt; ADVANCED GUIDES（高级指南）=&gt; typechecking-with-proptypes PropTypes 直接拉到中间看 PropTypes使用方法的 demo： 再往下看可以看到 PropTypes 可以使用的各种值： 还可以 使用instanceOf来判断接收的值是不是Message的一个实例 等，PropTypes可以做非常丰富的代码检测： 假设我们希望例子中的content可以是number或者string类型，我们可以使用文档中给出的oneOfType来完成“或者”的语法： 12345// content 可以是number或者string类型content: PropTypes.oneOfType([ PropTypes.number, PropTypes.string]), 延伸：要求content为由number或者string类型组成的数组（数组中的每一项可以是不同的类型）： 12345// content 可以是由number或者string类型组成的数组content: PropTypes.arrayof( PropTypes.number, PropTypes.string), PropTypes不同的验证函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // 你可以声明一个道具是一个特定的JS类型。默认情况下，这些都是可选的。 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可以渲染的东西：数字，字符串，元素或数组（或片段）。 optionalNode: PropTypes.node, // React元素 optionalElement: PropTypes.element, // 一个React元素类型(即MyComponent)。 optionalElementType: PropTypes.elementType, // 你也可以声明prop是某个类的实例。 内部使用的是JS的instanceof运算符。 //使用instanceOf来判断接收的值是不是Message的一个实例 optionalMessage: PropTypes.instanceOf(Message), // 你可以通过将它作为枚举来确保你的prop值仅限于特定的值。 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 可以是许多类型之一的对象 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 某种特定类型的数组(数组元素为number的数组) optionalArrayOf: React.PropTypes.arrayOf(PropTypes.number), // 具有某种特定类型的属性值的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 采取特定样式的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 你可以用`isRequired`来连接到上面的任何一个类型，以确保如果没有提供该props的话会显示一个警告。 requiredFunc: PropTypes.func.isRequired, // 任何数据类型 requiredAny: PropTypes.any.isRequired, // 您还可以指定自定义验证器。如果验证失败，它应该返回一个Error对象。 不要`console.warn`或`throw`，因为这在`oneOfType`中不起作用。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 您还可以为`arrayOf`和`objectOf`提供自定义类型检查器。 如果检查失败，它应该返回一个Error对象。 // 检查器将为数组或对象中的每个键调用验证函数。 // 检查器有两个参数，第一个参数是数组或对象本身，第二个是当前项的键。 customArrayProp: React.PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; defaultPropsdefaultProps 使用方法的 demo： 123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 指定name的默认值:StrangerGreeting.defaultProps = &#123; name: 'Stranger'&#125;;// 显示 “你好,陌生人”:ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example')); props，state与render函数的关系之所以state中的数据一变页面就会自动发生变化是因为页面是通过render函数渲染出来的，而每当组件的state或者props发生改变时，render函数就会重新执行。（props发生改变，归根到底还是父组件的state发生了变化，所以我们也可以理解为state或者props发生改变时父子组件的render函数都会重新执行）当父组件的render函数被运行时，它的子组件的render都将被重新运行一次。 state与render函数的关系：每当组件的state内数据发生改变时，render函数就会重新执行。可以看TodoList.js来帮助理解。 props与render函数的关系：每当组件的props内的数据发生改变时，render函数就会重新执行。总结：当父组件的render函数被运行时，它的子组件的render都将被重新运行一次。 例子 在父组件中引入子组件Test：import Test from &quot;./Test&quot; 在父组件中将子组件Test放在无序列表下方位置并将state中的inputValue传过去，每当父组件的render函数被运行时就会打印”render”： 新建一个子组件Test.js，每当子组件的render函数被运行时就会打印”Test render”并在页面上显示父组件传过来的content（即state中的inputValue值）:123456789101112import React, &#123; Component &#125; from 'react'//imrcclass Test extends Component &#123; render() &#123; console.log(\"Test render\"); return ( &lt;div&gt;&#123;this.props.content&#125;&lt;/div&gt; ) &#125;&#125;export default Test; 结果： 解释： 最初的时候父组件需要渲染，子组件也需要渲染，所以 开发者工具 中显示了“render”和“Test render”。 输入1后，inputValue发生改变，父组件的state发生改变，所以父组件render函数重新运行，多打出来一行“render”。 输入1后inputValue一变content就会变（因为父组件传值&lt;Test content={this.state.inputValue} /&gt;），content一变props就变了（因为子组件中&lt;div&gt;{this.props.content}&lt;/div&gt;），props发生改变时，render函数就会重新执行，所以显示“Test render”。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"hexo deploy中报错：unable to auto-detect email address","slug":"hexo deploy email address","date":"2020-02-03T05:02:18.000Z","updated":"2020-02-03T05:08:06.679Z","comments":true,"path":"2020/02/03/hexo deploy email address/","link":"","permalink":"http://yoursite.com/2020/02/03/hexo deploy email address/","excerpt":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。","text":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。 回到 git bush 中发现给出如下提示： 1234567891011121314*** Please tell me who you are.Run git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\"to set your account's default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got 'HLZ@DESKTOP-0N6K07S.(none)')Everything up-to-dateBranch 'master' set up to track remote branch 'master' from 'git@github.com:huanglizhu/huanglizhu.github.io.git'.INFO Deploy done: git 提示分析提示中出现了“unable to auto-detect email address”，也就是说他“无法自动检测电子邮件地址”。,并给出了解决方案： 12git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\" 解决问题 结果","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"围绕 React 衍生出的思考","slug":"围绕 React 衍生出的思考","date":"2020-02-02T09:57:35.000Z","updated":"2020-02-02T10:00:00.814Z","comments":true,"path":"2020/02/02/围绕 React 衍生出的思考/","link":"","permalink":"http://yoursite.com/2020/02/02/围绕 React 衍生出的思考/","excerpt":"声名式开发不同于原生 JS 的 命令式开发 ， React 是声名式开发。 命令式开发 更关注 DOM 的每一步挂载，而 声名式开发 更在意数据的改变，只操作 数据，不关心 具体要如何 操作 DOM，改变数据以后 React 会自动帮你完成 DOM 挂载等步骤。","text":"声名式开发不同于原生 JS 的 命令式开发 ， React 是声名式开发。 命令式开发 更关注 DOM 的每一步挂载，而 声名式开发 更在意数据的改变，只操作 数据，不关心 具体要如何 操作 DOM，改变数据以后 React 会自动帮你完成 DOM 挂载等步骤。 帮助理解命令式：操作 DOM 使用 JS 去找到需要操作的 DOM 节点，然后 操作它。声明式：编码好 数据 与 界面的 关系，只操作 数据，不关心 具体要如何 操作 DOM ,把 DOM 都交给 React。 可以与其他框架并存React可以与其他框架并存，也就是说public文件夹下index.html内的不同节点可以被不同的库所管理。（vue、jQuery等）每一个库只管理自己对应的DOM，只要不影响外部DOM节点即可。 例子在src文件夹下的index.js中我们将一个 由React管理的组件 挂载在index.html的DOM节点root上： 在public文件夹下的index.html中我们可以放入由不同库进行管理的DOM节点： 组件化使用class定义一个组件名继承自react的Component来自定义组件。自定义组件命名以大写字母开头，调用形式类似h5标签（比如&lt;TodoItem /&gt;）。父子组件的通信： 父组件通过（子组件的）属性向子组件传值（数据或方法）。 子组件想修改父组件数据的步骤：首先需要父组件向子组件传递一个方法，然后子组件通过调用该方法间接的操作父组件的数据。 面试常问：React中如何做父子组件的通信父组件向子组件传值（数据或方法）:父组件通过在子组件上添加属性的方式将数据（或方法）传给子组件（属性名是自定义的，属性值为需要传递的数据）子组件内使用父组件数据：在子组件内需要使用父组件传递过来的数据的位置通过{this.props.属性名}来接受对应属性值（数据）。 子组件内修改父组件的数据（子组件向父组件传值）：首先需要父组件向子组件传递一个方法，然后子组件通过调用该方法间接的操作父组件的数据。（子组件向父组件传的值可以通过调用父组件传过来的方法的参数传回去） 更多细节和注意事项以及例子可以看详细笔记 单向数据流在React中只允许父组件向子组件传值，在子组件可以使用父组件传过来的值，但不能在子组件中直接去修改父组件传过来的值。但是子组件可以通过调用父组件穿过来的方法间接的操作父组件的数据。 好处：对代码调试很友好，一旦父组件的某个数据出现问题，所有对该数据的操作都是集中在父组件的某个方法中的，不会涉及到多个子组件身上。 例子完整例子 删除功能实际上就是想办法在子组件中修改父组件的list数据：正确的思路是 父组件是将item和index以及删除的方法handleItemDelete（在父组件的handleItemDelete（）中进行list数据的删除）传给子组件TodoItem，然后子组件通过调用父组件的方法对list数据进行删除： 错误的思路：在父组件中将list数据传到子组件中并在子组件中直接进行修改： 视图层框架React并未把自己定位为大型框架，它只是一个视图层框架，只帮助我们解决数据和渲染之间的问题，至于组件之间怎么传值它并不负责。在小型项目中光是依靠React来进行传值也是可以的（比如之前的TodoList，只有两层组件）。但在大型项目时，光用 React 是不够的，必须结合一些数据层框架（比如redux），解决复杂传值的问题。 例子在一个大型项目中，组件之间呈树状分布，如果React去负责组件之间的传值将非常困难，假设我们紫色的组件想传值给最顶上的组件，就需要层层传递，非常复杂： 函数式编程例子：在React中我们使用的是一块一块的函数，比如TodoList.js中的constructor构造函数、render函数、getTodoItem函数等等： 好处：给前端自动化测试带来很大便捷性。只需要给函数一个输入值，看看函数输出的时候符合预期即可。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"TodoList代码优化","slug":"TodoList代码优化","date":"2020-02-01T10:20:02.000Z","updated":"2020-02-05T01:13:39.219Z","comments":true,"path":"2020/02/01/TodoList代码优化/","link":"","permalink":"http://yoursite.com/2020/02/01/TodoList代码优化/","excerpt":"使用ES6的解构赋值进行优化TodoItem.js中第一处代码优化调用 父组件传递过来的数据 时可以进行代码优化，使用ES6的解构赋值：","text":"使用ES6的解构赋值进行优化TodoItem.js中第一处代码优化调用 父组件传递过来的数据 时可以进行代码优化，使用ES6的解构赋值： 解释 父组件传递到子组件的数据是存放在属性中的，而众属性是放在props中的。假设this.props={AA:&#39;AA值&#39;,BB:&#39;BB值&#39;,CC:&#39;CC值&#39;,..};使用ES6的解构赋值,可以一次性赋值多个变量:1const &#123;AA,BB,CC,...&#125;=this.props; 在此基础上，接下来需要调用属性时直接使用AA即可。 const { content } = this.props;相当于const content = this.props.content; 在return()中属性名content被{}包裹是因为JSX语法中调用JS变量需要使用{}。 TodoItem.js中第二处代码优化原本的代码： 123handelClick() &#123; this.props.deleteItem(this.props.index)&#125; 同样进行优化后： 12345handelClick() &#123; // index也是父组件传过来的，可以一起解构赋值 const &#123; deleteItem, index &#125; = this.props; deleteItem(index);&#125; 引用顺序的优化TodoList.js中第一处代码优化原本的代码： 123import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */import \"./style.css\"import TodoItem from \"./TodoItem\" 一般我们将组件的引用放在前面，样式的引用放在后面，进行优化后： 123import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */import TodoItem from \"./TodoItem\"import \"./style.css\" 在构造函数中绑定this指向（bind）TodoList.js中第二处代码优化原本在return()中绑定事件函数的this指向： 但是为了性能优化我们应该在构造函数constructor中绑定this指向： 附加：属性内容较长时可分行 TodoList.js中第三处代码优化将父组件的handleItemDelete方法传给子组件前我们需要绑定this指向，防止传过去以后this指向子组件以至于找不到该方法而报错： 同样的，我们可以将绑定这个动作放到构造函数中完成， 在构造函数中绑定this指向 ： JSX语法JSX语法实际上是写一些页面上显示的东西用的，但是在TodoList.js中出现了一些逻辑代码： TodoList.js中第四处代码优化我们另外写一个getTodoItem()来存放这些逻辑代码，然后在原本需要逻辑代码的位置使用JS表达式调用getTodoItem()即可（注意JS表达式需要{}包裹）：注意：getTodoItem()中需要另外写一个return用于将函数结果返回，否则调用函数以后是没有结果的。 setState（）中参数改为函数新版的React中，setState（）参数 可以是一个 函数 而不是 对象 ，而这个函数最终返回（return）一个对象。 TodoList.js中第五处代码优化原本的代码： 12345handleInputChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;)&#125; 解释：target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue，react中改变状态中的数据需要调用组件的setState方法 优化后： 1234567handleInputChange(e) &#123; this.setState(() =&gt; &#123; return &#123; inputValue: e.target.value &#125; &#125;)&#125; 结合ES6 return 简写，再次优化： 12345handleInputChange(e) &#123; this.setState(()=&gt;(&#123; inputValue: e.target.value &#125;));&#125; 会发现报错TypeError: Cannot read property &#39;value&#39; of null：原因：这是因为setState方法如果传一个函数，它实际上是异步的写法，在后面讲“虚拟DOM”时将会讲解，主要是为了提升性能。（补充回答：笔记“React的虚拟DOM”）解决方案：此时需要将e.target.value放在setState（）的外部保存一下，再在内部进行调用： 123456handleInputChange(e) &#123; const value = e.target.value; this.setState(() =&gt; (&#123; inputValue: value &#125;));&#125; 注意：箭头函数返回对象时若想省略return则需要用()包裹对象。（具体可参考笔记“函数相关知识点补充”中箭头函数部分） 使用 prevState 代替 this.state我们像上面一样优化TodoList.js中的handleBtnClick（）：运行起来没问题，但其实有更加靠谱的优化方法（如下）。 TodoList.js中第六处代码优化setState（）中参数改为函数后，该参数内的函数可传入一个参数prevState。prevState指的是你修改数据前的那一次是怎么样的，相当于this.state，使用prevState可以避免你不小心改变state的状态： 123456789handleBtnClick() &#123; // prevState相当于this.state，但更靠谱 this.setState((prevState)=&gt;(&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...prevState.list, prevState.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;));&#125; TodoList.js中第七处代码优化原本的代码: 1234567handleItemDelete(index) &#123; const list = [...this.state.list] list.splice(index, 1); this.setState(&#123; list: list &#125;)&#125; setState（）中参数改为函数，第一次优化后： 1234567handleItemDelete(index) &#123; const list = [...this.state.list] list.splice(index, 1); this.setState(() =&gt; &#123; return &#123; list: list &#125; &#125;)&#125; 使用prevState代替this.state,第二次优化后： 1234567handleItemDelete(index) &#123; this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1); return &#123; list: list &#125;; &#125;);&#125; 其中，按照ES6的语法，list:list可简写为list（笔记“ES6对象简写”中有详细解释）： 1234567handleItemDelete(index) &#123; this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1); return &#123; list &#125;; &#125;);&#125; 解决key值问题涉及到循环时每一项都应该有自己独立的key值，没有不会报错，但会警告。 key值需要加在被循环的子项最外层上需要注意：index作为key值是不靠谱的，暂且用着，后期再改。 关于“为什么index作为key值不靠谱”可参考笔记“React中的虚拟DOM” key值需要加在被循环的子项最外层上，所以有&lt;div&gt;时需要放在&lt;div&gt;上： 删去div写在 子组件TodoItem 也可以： 12345678910111213getTodoItem() &#123; return this.state.list.map((item, index) =&gt; &#123; return ( /* 注意return中只能有一个父元素，注释也会被当成子元素 */ &lt;TodoItem key=&#123;index&#125; content=&#123;item&#125; index=&#123;index&#125; deleteItem=&#123;this.handleItemDelete&#125; /&gt; ) &#125;)&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"ES6对象简写","slug":"ES6对象简写","date":"2020-02-01T10:03:13.000Z","updated":"2020-02-01T10:08:57.632Z","comments":true,"path":"2020/02/01/ES6对象简写/","link":"","permalink":"http://yoursite.com/2020/02/01/ES6对象简写/","excerpt":"基本原则 属性名与属性值相同时，可省略其中一个。 对象中包含的方法的: function 可省略不写。","text":"基本原则 属性名与属性值相同时，可省略其中一个。 对象中包含的方法的: function 可省略不写。 例子ES5中： 12345678910var studentES5 = &#123; name: '珠', age: 2, sex: '女', getName: function () &#123; return this.name; &#125;&#125;console.log('ES5', studentES5);console.log('ES5'studentES5.getName()); ES6中： 1234567891011121314const name = '珠';const age = 2;const sex = '女';const studentES6 = &#123; //同名的属性可以省略不写 name, age, sex, getName() &#123;//可以省略方法中的 :function return this.name; &#125;&#125;;console.log('ES6', studentES6);console.log('ES6',studentES6.getName());","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"React.js基础精讲(2)","slug":"React.js基础精讲（2）","date":"2020-01-31T08:39:57.000Z","updated":"2020-02-02T08:54:36.693Z","comments":true,"path":"2020/01/31/React.js基础精讲（2）/","link":"","permalink":"http://yoursite.com/2020/01/31/React.js基础精讲（2）/","excerpt":"JSX语法细节补充注释语句在JSX中写注释相当于写js语句，所以一样需要{}将注释括起来。第一种注释语法很好理解，但是第二种注释语法需要注意：必须换行，否则结尾的花括号会被注释以至于无法包裹注释语句。","text":"JSX语法细节补充注释语句在JSX中写注释相当于写js语句，所以一样需要{}将注释括起来。第一种注释语法很好理解，但是第二种注释语法需要注意：必须换行，否则结尾的花括号会被注释以至于无法包裹注释语句。 第一种注释语法： 1&#123;/*注释语句*/&#125; 第二种注释语法：必须换行，否则结尾的花括号会被注释以至于无法包裹注释语句。 123&#123;//注释语句&#125; 外联CSS样式表及其注意事项引入外联样式表的方法 在src下新建样式表style.css并给input设置红色边框的样式 在组件页面TodoList.js顶部引入样式表import &quot;./style.css&quot;即可 使用className代替classreact中会混淆 标签样式定义类class 与 组件class TodoList extends Component{}中的class，给标签定义样式类名时使用class虽然不会报错，但控制台会提示警告: 12345&lt;inputclass=\"input\"value=&#123;this.state.inputValue&#125;onChange=&#123;this.handleInputChange.bind(this)&#125;/&gt; 所以我们在定义样式表class名称时需要使用className代替class: 12345&lt;inputclassName=\"input\"value=&#123;this.state.inputValue&#125;onChange=&#123;this.handleInputChange.bind(this)&#125;/&gt; dangerouslySetInnerHTML使JSX中部分内容不转译 如果在JSX中不希望内容被转译可使用 dangerouslySetInnerHTML(也就是希望输入框中输入的html标签可以被识别使用) 虽然这样做存在被XSS攻击的可能，但有时候也需要这样不转译的设置页面内容的情况。 例子： 原代码： 123456&lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt; &#123;item&#125;&lt;/li&gt; 使用 dangerouslySetInnerHTML 后: 123456&lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125; dangerouslySetInnerHTML=&#123;&#123;__html:item&#125;&#125;&gt;&lt;/li&gt; __html属性设置的是需要不转译显示在页面上的内容，这里设置为当前item，则li标签中间的{item}key省去（外层{}是代表里面写的是js表达式，内层{}代表是个js对象） 使用htmlFor代替属性for在react中，会混淆 元素标签的for属性 与 for循环，使用 for属性 会报出警告提示，所以我们需要属性for时应使用htmlFor代替属性for。比如：在&lt;label&gt;中使用 for属性 使点击 “输入内容” 时鼠标自动聚焦于输入框内时，使用 for属性 : 1234567&lt;label for=\"inserArea\"&gt;输入内容&lt;/label&gt;&lt;input id=\"inserArea\" className=\"input\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125;/&gt; 使用htmlFor代替属性for：&lt;label htmlFor=&quot;inserArea&quot;&gt;输入内容&lt;/label&gt; 组件拆分 与 组件之间的传值总结 在render函数的return（）括号中只允许存在1个最外层标签，否则报错。（也就是说所有标签都必须包含在1个父元素下）return（）中的注释也会被当成一个子元素！（可以看：“父组件向子组件传递数据”的例子） 自定义组件名首字母大写。 定义组件后不要忘记在js文件最后export default 组件名;,一定要导出组件它才能在外部被引用。 组件的使用方式和JSX元素标签的使用方式类似。比如自定义子组件为TodoItem,在父组件TodoList的return（）中通过&lt;TodoItem /&gt;来引用。（不要忘记在父组件TodoList顶部引入子组件） 在JSX中想要使用变量或者js表达式时必须用{}括起来，参数与属性名则不需要。（比如：“父组件向子组件传递数据”的例子中TodoList.js中的&lt;TodoItem content={item} /&gt;,item就是变量，必须用{}括起来） 绑定事件函数要记得到组件的构造函数中使用bind()绑定this指向，否则绑定事件函数的方法内部的this会丢失指向。（参考另一篇笔记的传送门） 在父组件内通过在子组件标签上添加属性的方式将数据或者方法传给子组件。属性名是自定义的，属性值为需要传递的数据或者方法，注意 数据变量 与 方法 都需要{}括起来， 方法 不要忘记this.方法名。 子组件如果想要调用父组件的方法，在父组件中通过属性传递该方法时必须先通过bind()绑定该方法的this永远指向父组件,否则报错。因为通过this.方法名传过去后this变为子组件，而子组件中并无该方法。（可参考下方“子组件向父组件传递数据”中例子） 组件拆分网页可拆分为多个不同的父组件与子组件，子组件又可以嵌套其他的子组件形成树形结构。 组件之间的传值原本我们把列表的 增加 和 删除 功能都写在 TodoList.js 中，现在我们把列表中的子项放在 子组件TodoItem.js 中，增加 和 删除 功能的逻辑写在 子组件TodoItem.js 中，最后再在 TodoList.js 中调用 子组件TodoItem.js 。 往列表中增加数据： 父组件TodoList通过标签的形式引用子组件并以属性的方式将数据item传给子组件TodoItem（&lt;TodoItem content={item}&gt;） 子组件内通过{this.props.属性名}来获取从父组件传递过来的数据（对应属性值）。 点击子项后删除子项：原本是写在TodoList.js的&lt;li&gt;标签上的onClick事件绑定函数handleItemDelete上的，现在组件化后去掉了&lt;li&gt;标签，但我们可以让子组件调用父组件的handleItemDelete方法来实现改功能。 在父组件中通过 子组件属性 的方式将 数据item 、 数组下标index 、方法handleItemDelete 都传递到子组件中 子组件中，点击子组件时触动onClick事件绑定的函数handelClick，在函数handelClick内 将父组件传递过来的index值作为参数 通过属性名的方式调用父组件的deleteItem方法（即父组件的handleItemDelete方法）完成点击数据即删除的功能。 父组件向子组件传递数据（或方法） 父组件通过类似html标签的方式引用子组件，同时使用在子组件标签上添加属性的方式将数据传给子组件（属性名是自定义的，属性值为需要传递的数据）注意数据变量与方法都需要{}括起来（也就是属性值需要{}括起来），方法不要忘记this.方法名。 在子组件内需要使用父组件传递过来的数据的位置通过{this.props.属性名}来接受对应属性值（数据）。 注意：父组件向子组件传递方法时，必须在父组件中通过属性传递该方法的同时通过bind()绑定该方法的this永远指向父组件,否则报错。因为通过this.方法名传过去后this变为子组件，而子组件中并无该方法。在父组件中通过属性传递该方法时必须先通过bind()绑定该方法的this永远指向父组件,否则报错。因为通过this.方法名传过去后this变为子组件，而子组件中并无该方法。（可参考下方“子组件向父组件传递数据”中例子） 例子：点击按钮以后希望列表中显示输入框中内容则需要父组件将数据传给子组件，也就是 父组件TodoList 将输入框中得到的 item数据 传给 子组件TodoItem： 定义子组件并导出： 在父组件中引入子组件： 父组件向子组件传递数据： 子组件内通过{this.props.属性名}来获取从父组件传递过来的数据（对应属性值）： 子组件向父组件传递数据（子组件调用父组件的方法修改父组件的数据） 在父组件中通过属性的方式将 数据item 、 数组下标index 、方法handleItemDelete 都传递到子组件中： 注意：在父组件中将handleItemDelete传给子组件之前必须使用bind绑定this永远指向父组件，否则在子组件中调用this.props.deleteItem时实际上相当于调用this.handleItemDelete,但在子组件中this指向子组件，子组件中并没有handleItemDelete函数，因此报错。 子组件中，点击子组件时触动onClick事件绑定的函数handelClick，在函数handelClick内 将父组件传递过来的index值作为参数 通过属性名调用父组件的deleteItem方法（即父组件的handleItemDelete方法）完成点击数据即删除的功能： 需要修改state数据的方法可以保留在父组件中，在子组件中通过调用父组件方法来修改数据。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Node.js函数引用与解构赋值","slug":"Node.js函数引用与解构赋值","date":"2020-01-23T14:00:10.000Z","updated":"2020-01-27T08:05:28.277Z","comments":true,"path":"2020/01/23/Node.js函数引用与解构赋值/","link":"","permalink":"http://yoursite.com/2020/01/23/Node.js函数引用与解构赋值/","excerpt":"函数引用什么时候要使用{}进行解构赋值？什么时候引用外部js文件中的函数时要使用{}进行解构赋值？输出时使用了{}来包裹的在外部js文件中引用时需要使用{}将变量括起。（具体可看下面的事例）","text":"函数引用什么时候要使用{}进行解构赋值？什么时候引用外部js文件中的函数时要使用{}进行解构赋值？输出时使用了{}来包裹的在外部js文件中引用时需要使用{}将变量括起。（具体可看下面的事例） 我的理解是：输出的时候是以 对象的属性 的形式输出，那么引用时就要使用 解构赋值 的方法将这些 属性 都分解出来再赋给变量，自然就会用上 解构赋值 。而输出时就以变量形式输出的引用时就变量形式引用即可。 例子1在js文件顶部引用controller文件夹下blog.js文件内的getList函数时使用的是： 1const &#123; getList &#125; = require(\"../controller/blog\") 其实相当于： 1const getList = require(\"../controller/blog\").getList 之所以需要这样引用应该是输出的原因: 1234//接下来还会有函数需要输出，所以先使用对象的方式进行返回module.exports = &#123; getList&#125; 反观输出时采用module.exports = handleBlogRouter的引用时使用const handleBlogRouter = require(&quot;./src/router/blog&quot;)即可。 例子2在resModel.js中输出： 12345//输出module.exports = &#123; SuccessModel, ErrorModel&#125; 在blog.js中引用resModel.js中的SuccessModel、ErrorModel两个模块： 12//引入resModel.js中的两个模块const &#123; SuccessModel, ErrorModel &#125; = require(\"../model/resModel\") 例子3在blog.js中输出handleBlogRouter： 12/* 不要忘记输出函数 */module.exports = handleBlogRouter 在app.js中引用handleBlogRouter路由组件： 12// 引用路由组件const handleBlogRouter = require(\"./src/router/blog\")","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"JSON方法","slug":"JSON方法","date":"2020-01-20T14:14:18.000Z","updated":"2020-01-20T14:15:02.300Z","comments":true,"path":"2020/01/20/JSON方法/","link":"","permalink":"http://yoursite.com/2020/01/20/JSON方法/","excerpt":"parse()将JSON字符串转换为 JS 对象（接受服务器数据）JSON 通常用于与服务端交换数据。在接收服务器数据时一般是JSON字符串（JSON字符串长的很像JS对象）。","text":"parse()将JSON字符串转换为 JS 对象（接受服务器数据）JSON 通常用于与服务端交换数据。在接收服务器数据时一般是JSON字符串（JSON字符串长的很像JS对象）。我们可以使用 JSON.parse() 方法将JSON字符串数据转换为 JavaScript 对象。 语法JSON.parse(text[, reviver])参数：text:必需， 一个有效的 JSON 字符串。（确保你的数据是标准的 JSON 格式，否则会解析出错）reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。(例子在下面“JSON 不能存储 Date 对象的解决方法”中) 例子例如我们从服务器接收了这样的JSON字符串数据： 1&#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" &#125; 使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象： 1var obj = JSON.parse('&#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" &#125;'); 注意：解析前要确保你的数据是标准的 JSON 格式，否则会解析出错。可以使用在线工具检测：https://c.runoob.com/front-end/53。完整例子 从服务端接收 JSON 数据123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myObj = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myObj.name; &#125;&#125;;xmlhttp.open(\"GET\", \"/try/ajax/json_demo.txt\", true);xmlhttp.send(); 可以使用 AJAX 从服务器请求 JSON 数据，并解析为 JavaScript 对象。完整例子 从服务端接收数组的 JSON 数据123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myArr = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myArr[1]; &#125;&#125;;xmlhttp.open(\"GET\", \"/try/ajax/json_demo_array.txt\", true);xmlhttp.send(); 完整例子 JSON 不能存储 Date 对象的解决方法JSON 不能存储 Date 对象。如果你需要存储 Date 对象，需要将其转换为字符串,之后再将字符串转换为 Date 对象。 例子（完整例子点击这里）： 12345var text = '&#123; \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"&#125;';var obj = JSON.parse(text);//将其转换为字符串obj.initDate = new Date(obj.initDate);//再将字符串转换为 Date 对象 document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期: \" + obj.initDate;//Runoob创建日期: Sat Dec 14 2013 08:00:00 GMT+0800 (中国标准时间) 可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数： 1234567891011var text = '&#123; \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"&#125;';//将其转换为字符串var obj = JSON.parse(text, function (key, value) &#123;//每个对象都走一遍，遇到initDate时将字符串值转换为 Date 对象 if (key == \"initDate\") &#123; return new Date(value); &#125; else &#123; return value;&#125;&#125;); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期：\" + obj.initDate; （完整例子点击这里） JSON解析函数的方法首先，不建议在 JSON 中使用函数。JSON 不允许包含函数！！但你可以将函数作为字符串存储，之后再将字符串转换为函数： 12345var text = '&#123; \"name\":\"Runoob\", \"alexa\":\"function () &#123;return 10000;&#125;\", \"site\":\"www.runoob.com\"&#125;';var obj = JSON.parse(text);obj.alexa = eval(\"(\" + obj.alexa + \")\"); document.getElementById(\"demo\").innerHTML = obj.name + \" Alexa 排名：\" + obj.alexa(); 完整例子 stringify()将 JS 对象转换为JSON字符串(向服务器发送数据)JSON 通常用于与服务端交换数据。在向服务器发送数据时一般是JSON字符串。我们可以使用JSON.stringify() 方法将 JavaScript 对象转换为JSON字符串。 语法1JSON.stringify(value[, replacer[, space]]) value:必需， 要转换的 JavaScript 值（通常为对象或数组）。 replacer:可选。用于转换结果的函数或数组。如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。 space:可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。 JavaScript 对象转换为JSON字符串例如我们向服务器发送以下JS对象数据： 1var obj = &#123; name:\"hlz\", alexa:10000, site:\"www.baidu.com\"&#125;; 使用 JSON.stringify() 方法处理以上JS对象，将其转换为字符串： 1var myJSON = JSON.stringify(obj); myJSON 为JSON字符串。 完整例子: 123var obj = &#123; name:\"hlz\", alexa:10000, site:\"www.baidu.com\"&#125;;var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"hlz\",\"alexa\":10000,\"site\":\"www.baidu.com\"&#125; JavaScript 数组转换为 JSON 字符串也可以将 JavaScript 数组转换为 JSON 字符串,myJSON 为JSON字符串： 123var arr = [ \"Google\", \"Runoob\", \"Taobao\", \"Facebook\" ];var myJSON = JSON.stringify(arr);document.getElementById(\"demo\").innerHTML = myJSON; (完整例子) JSON 不能存储 Date 对象的解决方法JSON 不能存储 Date 对象。可以使用 JSON.stringify() 将所有日期转换为JSON字符串myJSON： 123var obj = &#123; name:\"Runoob\", initDate:new Date(), site:\"www.runoob.com\"&#125;;//obj是一个JS对象var myJSON = JSON.stringify(obj);//将所有日期转换为JSON字符串myJSONdocument.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"Runoob\",\"initDate\":\"2020-01-20T14:04:12.438Z\",\"site\":\"www.runoob.com\"&#125; 之后可以再将JSON字符串myJSON转换为 Date 对象。（完整例子）。 解析函数的方法JSON 不允许包含函数,不建议在 JSON 中使用函数。JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value(完整例子): 1234var obj = &#123; name:\"Runoob\", alexa:function () &#123;return 10000;&#125;, site:\"www.runoob.com\"&#125;;var myJSON = JSON.stringify(obj); document.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"Runoob\",\"site\":\"www.runoob.com\"&#125; 可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免以上问题的发生(完整例子)： 12345var obj = &#123; name:\"Runoob\", alexa:function () &#123;return 10000;&#125;, site:\"www.runoob.com\"&#125;;obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"Runoob\",\"alexa\":\"function () &#123;return 10000;&#125;\",\"site\":\"www.runoob.com\"&#125;","categories":[{"name":"JSON学习","slug":"JSON学习","permalink":"http://yoursite.com/categories/JSON学习/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"JS Date 对象","slug":"JS_Date对象","date":"2020-01-20T13:38:57.000Z","updated":"2020-01-20T13:39:39.544Z","comments":true,"path":"2020/01/20/JS_Date对象/","link":"","permalink":"http://yoursite.com/2020/01/20/JS_Date对象/","excerpt":"Date 对象Date 对象用于处理日期与时间。创建 Date 对象：new Date()","text":"Date 对象Date 对象用于处理日期与时间。创建 Date 对象：new Date() 以下四种方法同样可以创建 Date 对象： 1234var d = new Date();var d = new Date(milliseconds);var d = new Date(dateString);var d = new Date(year, month, day, hours, minutes, seconds, milliseconds); 可参考 更多实例 getTime() 方法getTime() 方法可返回距 1970 年 1 月 1 日之间的毫秒数。 12var d = new Date();var n = d.getTime(); n 输出结果:1568630422651","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JSON基础","slug":"JSON基础","date":"2020-01-20T11:05:55.000Z","updated":"2020-01-22T04:46:22.914Z","comments":true,"path":"2020/01/20/JSON基础/","link":"","permalink":"http://yoursite.com/2020/01/20/JSON基础/","excerpt":"JSON (用于接收 web 服务端的数据) JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是存储和交换文本信息的语法。","text":"JSON (用于接收 web 服务端的数据) JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是存储和交换文本信息的语法。 JSON 类似 XML，但它比 XML 更小、更快、更易解析。 JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON 文件的文件类型是 “.json”。JSON 文本的 MIME 类型是 “application/json”。(http返回的请求中设置返回格式为json就实用了&quot;Content-type&quot;:&quot;application/json&quot;) JSON 与 XML 的异同JSON 和 XML 都用于接收 web 服务端的数据。 JSON 与 XML 的相同之处： JSON 和 XML 数据具有“自我描述性”，易于理解（人类可读） JSON 和 XML 数据具有层级结构（值中存在值） JSON 和 XML 数据可通过 JavaScript 进行解析，可以被大多数编程语言使用 JSON 和 XML 数据数据可使用 AJAX 进行传输 JSON 相比 XML 的不同之处： JSON 不需要结束标签 JSON 更短 JSON 读写的速度更快 JSON 能够使用内建的 JavaScript eval()方法进行解析 JSON 可以使用数组 JSON 不使用保留字 最大的不同：XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析：JSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。JSON.stringify(): 于将 JavaScript 值转换为 JSON 字符串。 为什么使用 JSONXML 比 JSON 更难解析。JSON 可以直接使用现有的 JavaScript 对象解析。对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML 需要: 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON： 读取 JSON 字符串 JSON.Parse() 解析 JSON 字符串 JSON 语法JSON 语法是 JavaScript 语法的子集。 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 书写格式JSON 数据的书写格式是：名称/值对，也就是&quot;名称&quot;:值，注意JSON对象需要使用花括号比如：{&quot;name&quot; : &quot;我就是你想放进去的值呀&quot;}等价于这条 JavaScript 语句：name = &quot;我就是你想放进去的值呀&quot; JSON 值JSON 值可以是（注意JSON对象需要使用花括号）：数字（整数或浮点数）:{&quot;age&quot;:233}字符串（在双引号中）:{&quot;name&quot;:&quot;aaaaaa&quot;}逻辑值（true 或 false）:{&quot;flag&quot;:true}数组（在中括号中）:例子在下面对象（在大括号中）:例子在下面null:{&quot;name&quot;:null} JSON 对象语法JSON 对象放在大括号{}中。对象可以包含多个 key/value（键/值）对，key 和 value 中使用冒号:分割。key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。多个 key/value对 之间使用逗号,分割。 例子： 1234&#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125; 与之等价的 JavaScript 语句： 12name = \"菜鸟教程\"url = \"www.runoob.com\" 访问对象值(.或[])可以使用点号.来访问对象的值： 123var myObj, x;myObj = &#123; \"name\":\"hlz\", \"alexa\":10000, \"site\":null &#125;;x = myObj.name;//hlz 也可以使用中括号[]来访问对象的值(记住带上双引号)： 123var myObj, x;myObj = &#123; \"name\":\"hlz\", \"alexa\":10000, \"site\":null &#125;;x = myObj[\"name\"];//hlz 循环对象的属性与值( for-in )注意：在 for-in 循环对象的属性时，不能使用.来访问属性的值（循环不到）！需要使用中括号[]来访问属性的值。 使用 for-in 来循环对象的属性： 123456&lt;script&gt; var myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;; for (x in myObj) &#123; document.getElementById(\"demo\").innerHTML += x + \"&lt;br&gt;\";//name alexa site &#125;&lt;/script&gt; 在 for-in 循环对象的属性时，使用中括号[]来访问属性的值(注意不能使用.来访问属性的值)： 123456&lt;script&gt; var myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;; for (x in myObj) &#123; document.getElementById(\"demo\").innerHTML += myObj[x] + \"&lt;br&gt;\";//runoob 10000 null &#125;&lt;/script&gt; 嵌套 JSON 对象JSON 对象中可以包含另外一个 JSON 对象： 123456789myObj = &#123; \"name\":\"hlz\", \"alexa\":10000, \"sites\": &#123; \"site1\":\"www.baidu.com\", \"site2\":\"m.baidu.com\", \"site3\":\"c.baidu.com\" &#125;&#125; 可以使用点号.或者中括号[]来访问嵌套的 JSON 对象: 1234x = myObj.sites.site1;//www.baidu.comx = myObj.sites[\"site1\"];//www.baidu.comx = myObj[\"sites\"][\"site1\"];//www.baidu.comx = myObj[\"sites\"].site1;//www.baidu.com 实际运行起来的例子 修改对象的值(.或[])使用点号.来修改 JSON 对象的值,比如修改myObj对象中的sites对象的site1属性值：myObj.sites.site1 = &quot;www.google.com&quot;;(例子)可以使用中括号[]来修改 JSON 对象的值：myObj.sites[&quot;site1&quot;] = &quot;www.google.com&quot;;(例子)(至于访问嵌套对象的值的多种方法可以看上面“嵌套 JSON 对象”) 删除对象属性(delete 关键字)可以使用 delete 关键字来删除 JSON 对象的属性。比如删除myObj对象中的sites对象的site1属性值（不同的调用属性值方法都是可以的）：delete myObj.sites.site1;(例子)或者delete myObj.sites[&quot;site1&quot;](例子) JSON 数组语法JSON 数组放在中括号中，数组值（数组元素）必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。数组元素之间使用逗号分隔。 JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 undefined。 例子：对象属性的值可以是一个数组： 12345&#123;\"name\":\"网站\",\"num\":3,\"sites\":[ \"Google\", \"Runoob\", \"Taobao\" ]&#125; 可以使用索引值来访问数组(完整例子)： 1x = myObj.sites[0];//Google 数组元素为对象的数组例子：JSON 数组放在中括号中，数组可包含多个对象,数据由逗号分隔： 1234567&#123; \"sites\": [ &#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125;, &#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;, &#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125; ]&#125; 在上面的例子中，对象 “sites”是包含三个对象的数组,每个对象代表一条关于某个网站（name、url）的记录。 循环数组（for-in或for 循环）可以使用 for-in 来访问数组(例子)： 123for (i in myObj.sites) &#123; x += myObj.sites[i] + \"&lt;br&gt;\";&#125; 也可以使用 for 循环(例子)： 123for (i = 0; i &lt; myObj.sites.length; i++) &#123; x += myObj.sites[i] + \"&lt;br&gt;\";&#125; 嵌套 JSON 对象中的数组JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象,但是记住了：JSON值可以是任意符合要求的（可以是另外一个数组/对象），但是JSON名称必须是字符串！ 例子： 123456789myObj = &#123; \"name\":\"网站\", \"num\":3, \"sites\": [ &#123; \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] &#125;, &#123; \"name\":\"Runoob\", \"info\":[ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] &#125;, &#123; \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] &#125; ]&#125; 可以使用 for-in 来循环访问每个数组： 123456for (i in myObj.sites) &#123; x += \"&lt;h1&gt;\" + myObj.sites[i].name + \"&lt;/h1&gt;\"; for (j in myObj.sites[i].info) &#123; x += myObj.sites[i].info[j] + \"&lt;br&gt;\"; &#125;&#125; 完整例子 修改数组值可以使用索引值来修改数组值(完整例子)： 1myObj.sites[1] = \"Github\"; 删除数组元素可以使用 delete 关键字来删除数组元素(完整例子)： 1delete myObj.sites[1]; JSON 使用 JavaScript 语法JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。但使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。在下面的章节，将学会如何把 JSON 文本转换为 JavaScript 对象。","categories":[{"name":"JSON学习","slug":"JSON学习","permalink":"http://yoursite.com/categories/JSON学习/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"开发博客项目之接口(2)","slug":"Node.js开发博客项目之接口(2)","date":"2020-01-19T12:50:35.000Z","updated":"2020-01-19T12:50:38.815Z","comments":true,"path":"2020/01/19/Node.js开发博客项目之接口(2)/","link":"","permalink":"http://yoursite.com/2020/01/19/Node.js开发博客项目之接口(2)/","excerpt":"4-5 搭建开发环境从0开始搭建，不适用任何框架使用nodemon监测文件变化，自动重启node（不需要像之前那样使用node xxx.js来手动重启node）使用cross-env设置环境变量，兼容mac linux和windows","text":"4-5 搭建开发环境从0开始搭建，不适用任何框架使用nodemon监测文件变化，自动重启node（不需要像之前那样使用node xxx.js来手动重启node）使用cross-env设置环境变量，兼容mac linux和windows 开始搭建根据上一篇笔记的“模块化规范”初始npm环境，并在package.json文件中继续以下步骤：安装nodemon：npm install nodemon --save或者npm i nodemon -D启动nodemon:nodemon app.js(用nodemon替换node去启动项目的入口文件机会将项目改变成自动重启服务器)当你看到每次保存以后终端都自动更新，说明自启动成功： 安装cross-env：npm install cross-env --save-dev或者npm i cross-env -D手动补齐package.json： 123456789101112131415161718&#123; \"name\": \"blog-1\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"bin/www.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"cross-env NODE_ENV=dev nodemon ./bin/www.js\", \"prd\": \"cross-env NODE_ENV=production nodemon ./bin/www.js\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"cross-env\": \"^6.0.3\", \"nodemon\": \"^2.0.2\" &#125;&#125; app.js: 12345678910111213141516const serverHandle = (req, res) =&gt; &#123; //设置返回格式 JSON res.setHeader(\"Content-type\", \"application/json\") const resData = &#123; name: \"Hlz\", site: \"imooc\", env: process.env.NODE_ENV &#125; res.end( JSON.stringify(resData) )&#125;module.exports = serverHandle ./bin/www.js: 1234567const http = require(\"http\")const PORT = 8000const serverHandle = require(\"../app\")const server = http.createServer(serverHandle)server.listen(PORT) 千万不要忘记终端执行npm run dev！！ 测试 4-6 初始化路由 开发接口初始化路由：根据之前技术方案的设计，做出路由返回假数据：将路由和数据处理分离，以符合设计原则 思路我们先不管接口内容，去把各个接口跑通。blog.js和user.js中存放的是路由组件，app.js用来设置系统比较基础的功能或者参数，还是不涉及业务逻辑的处理，在blog.js和user.js中通过判断以后返回的是对象，所以在app.js中得到的blogData也是一个对象，但res.end返回的需要是字符串，所以需要通过JSON.stringify（）来转换一下，此时注意需要return来结束。注意： 路由组件（函数）写好后需要通过module. exports输出出去，然后再在需要调用的js文件顶部通过require调用后才能使用。(app.js中的serverHandle不是路由组件，但是注意，函数都需要输出！) 千万不要忘记在终端执行npm run dev！！(否则就不会去监听8000端口) 设置接口路径时前面前往不要忘记api前面的\\! 代码 www.js开启 Server,监听8000端口: 12345678const http = require(\"http\")const PORT = 8000const serverHandle = require(\"../app\")const server = http.createServer(serverHandle)//启动监听服务server.listen(PORT) app.js处理逻辑: 123456789101112131415161718192021222324252627282930313233343536373839// 引用路由组件const handleBlogRouter = require(\"./src/router/blog\")const handleUserRouter = require(\"./src/router/user\")const serverHandle = (req, res) =&gt; &#123; //设置返回格式 JSON res.setHeader(\"Content-type\", \"application/json\") //处理blog路由，blogData是通过调用函数handleBlogRouter得到的对象 const blogData = handleBlogRouter(req, res) if (blogData) &#123; res.end( //记住end是一句字符串，故必须把对象转换为字符串 JSON.stringify(blogData) ) //记住要使用return来结束 return &#125; //处理user路由(当路由命中handleUserRouter时) const userData = handleUserRouter(req, res) if (userData) &#123; res.end( //记住end是一句字符串，故必须把对象转换为字符串 JSON.stringify(userData) ) //记住要使用return来结束 return &#125; //未命中路由，返回404（这个了解即可，使用不多） res.writeHead(404, &#123; \"Content-type\": \"text/plain\" &#125;) res.write(\"404 Not Found\\n\") res.end()&#125;//函数也需要输出module.exports = serverHandle//process.env.NODE_ENV blog.js5个路由接口: 1234567891011121314151617181920212223242526272829303132333435363738394041424344const handleBlogRouter = (req, res) =&gt; &#123; const method = req.method//GET POST const url = req.url const path = url.split(\"?\")[0] //获取博客列表,api前面千万不要漏掉 / !!! if (method === \"GET\" &amp;&amp; path === \"/api/blog/list\") &#123; return &#123; msg: \"这是获取博客列表的接口\" &#125; &#125; //获取博客详情 if (method === \"GET\" &amp;&amp; path === \"/api/blog/detail\") &#123; return &#123; msg: \"这是获取博客详情的接口\" &#125; &#125; //新建一篇博客 if (method === \"POST\" &amp;&amp; path === \"/api/blog/new\") &#123; return &#123; msg: \"这是新建一篇博客的接口\" &#125; &#125; //更新一篇博客 if (method === \"POST\" &amp;&amp; path === \"/api/blog/update\") &#123; return &#123; msg: \"这是更新一篇博客的接口\" &#125; &#125; //删除一篇博客 if (method === \"POST\" &amp;&amp; path === \"/api/blog/del\") &#123; return &#123; msg: \"这是删除一篇博客的接口\" &#125; &#125;&#125;/* 不要忘记输出函数 */module.exports = handleBlogRouter user.js一个登录接口： 12345678910111213const handleUserRouter = (req, res) =&gt; &#123; const method = req.method//GET POST const url = req.url const path = url.split(\"?\")[0] //登录 if (method === \"POST\" &amp;&amp; path === \"/api/user/login\") &#123; return &#123; msg: \"这是登陆的接口\" &#125; &#125;&#125;module.exports = handleUserRouter 测试结果直接输入http://localhost:8000/,未命中设定好的任何一个路由，触发设定好的404： 输入http://localhost:8000/api/blog/list?author=hlz&amp;keyword=hahaha,命中其中一个接口： 打开postman测试post请求，如下图所示：再测试一个user的登录接口： 简化 补充：constructor构造方法constructor 是一种用于创建和初始化class创建的对象的特殊方法。在一个构造方法中可以使用super关键字来调用一个父类的构造方法。MDN中关于constructor构造方法的解释和例子 补充：JSON.parse()JSON.parse() 方法用于将一个 JSON 字符串转换为对象。参考 4-7 开发路由（博客列表路由）在src下新建model文件夹，在该文件夹下新建resModel.js文件。BaseModel中data是一个对象类型，message是一个字符串类型的消息。 注意：this.message才是BaseModel的message。data和message都只是传入的参数。(不清楚可以看MDN中的例子)最后记得输出两个模块（SuccessModel和ErrorModel）。 代码思路：假设传入的第一个参数data是字符串类型且没有传入第二个参数message，为使其兼容则需将参数data赋给BaseModel的message，且data和message都不要了。在resModel.js中我们需要设立两个模块用于app.js中 的res.end。 resModel.js: 12345678910111213141516171819202122232425262728293031323334353637class BaseModel &#123; //constructor 是一种用于创建和初始化class创建的对象的特殊方法。 constructor(data, message) &#123; if (typeof data === \"string\") &#123; this.message = data //注意，this.message才是BaseModel的message。data和message都只是传入的参数 data = null message = null &#125; if (data) &#123; this.data = data &#125; if (message) &#123; this.message = message &#125; &#125;&#125;class SuccessModel extends BaseModel &#123; constructor(data, message) &#123; //super相当于执行了BaseModel的constructor,统一将data和message传过去放在父类BaseModel中处理 super(data, message) this.errno = 0 &#125;&#125;class ErrorModel extends BaseModel &#123; constructor(data, message) &#123; super(data, message) this.errno = -1 &#125;&#125;//记得输出module.exports = &#123; SuccessModel, ErrorModel&#125; 所有公共的参数都放到app.js中进行解析(比如query的解析)：app.js中顶部增添: 12//引用js原生模块querystringconst querystring = require(\"querystring\") app.js的serverHandle中增添: 12//解析query,parse方法用于将一个 JSON 字符串转换为对象req.query = querystring.parse(url.split(\"?\")[1]) 在src下新建controller文件夹，在该文件夹下新建blog.js文件。blog.js文件中先返回假数据（格式是正确的），此时虽然author和keyword没有使用，但我们假装他使用了并返回了很多的元素（博客）。由于接下来还要建很多个函数，所以返回（输出）的是对象（方便增加返回的函数）。controller文件夹内的blog.js: 12345678910111213141516171819202122232425const getList = (author, keyword) =&gt; &#123; //虽然author,keyword没有使用，但先返回假数据（格式是正确的） //返回的是数组，数组元素为博客文章 return [ &#123; id: 1, title: \"标题A\", content: \"内容A\", createTime: 1579421639661, author: \"hlz\" &#125;, &#123; id: 2, title: \"标题B\", content: \"内容B\", createTime: 1579421789492, author: \"lv\" &#125; ]&#125;//接下来还会有函数需要输出，所以先使用对象的方式进行返回module.exports = &#123; getList&#125; 其中，createTime可以在网页上获取一个来使用： 在controller文件夹内的blog.js文件中定义的函数可以在router文件夹内的blog.js文件中通过解构赋值的方式进行引用。router文件夹内的blog.js顶部： 1234//通过解构赋值的方式引用controller/blog.js中的getList函数const &#123; getList &#125; = require(\"../controller/blog\")//引入resModel.js中的两个模块const &#123; SuccessModel, ErrorModel &#125; = require(\"../model/resModel\") 将router文件夹内的blog.js中“获取博客列表”的部分进行修改： 12345678910//获取博客列表,api前面千万不要漏掉 / !!!if (method === \"GET\" &amp;&amp; req.path === \"/api/blog/list\") &#123; //从app.js中解析的query中读取author、keyword，没有则空 const author = req.query.author || \" \" const keyword = req.query.keyword || \" \" //将读取到的author, keyword传到controller/blog.js中的getList函数，获取返回的博客列表数据listData const listData = getList(author, keyword) //将博客列表数据listData传入SuccessModel，此时我们只传入了data参数，没有传入message参数 return new SuccessModel(listData)&#125; 测试获取博客列表的接口通过假数据显示已经跑通了： 捋清思路（系统架构设计的四层）系统架构设计的四层抽象：第一层： www.js [开启 Server]第二层：app.js [通信设置层]第三层：router文件夹 [业务逻辑层]第四层：controller.js [数据层] 一开始进入项目执行的是bin文件夹下的www.js,这里面只是createServer的逻辑，端口联通什么的和我们的业务逻辑没有关系。第二层：app.js ，用来设置系统比较基础的功能（处理blog、user路由）或者参数（获取path、解析query）还有返回类型（JSON），还是不涉及业务逻辑的处理。第三层：router文件夹下的两个路由文件blog.js、user.js，稍微涉及逻辑层，但只管路由。匹配到路由（接口）以后会去处理一些数据，然后（通过SuccessModel）会给你返回一个正确的格式。至于这些数据是怎么去匹配的，怎么去筛选的，是正确的还是错误的他不管，他只管和路由（接口）有关的。第四层：controller.js 是最关心数据的层次，他没有res、req、path、query这些东西，只是对传入的数据进行计算处理再返回。（我们目前还没有计算，接下来会有）。至于数据返回后是怎么处理的controller.js是不管的。 一层层拆分是一个由最基础的http服务向逻辑层转变的过程。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"JS笔试遇到的知识点（2）","slug":"JS笔试遇到的知识点（2）","date":"2020-01-18T04:08:59.000Z","updated":"2020-02-06T14:38:36.626Z","comments":true,"path":"2020/01/18/JS笔试遇到的知识点（2）/","link":"","permalink":"http://yoursite.com/2020/01/18/JS笔试遇到的知识点（2）/","excerpt":"js中同名函数后面会覆盖前面的js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。","text":"js中同名函数后面会覆盖前面的js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。 在js中，定义了两个同名函数后，后面的函数会覆盖前面定义的函数。也就是说，前面定义的函数内容会被后面的函数内容覆盖，当你以为自己执行的是前面的函数内容时，其实执行的是后面的函数内容。 例子： 1234567891011&lt;script&gt; var m= 1, j = k = 0; function add(n) &#123; return n = n+1; &#125; y = add(m); function add(n) &#123; return n = n + 3; &#125; z = add(m); &lt;/script&gt; 例子结果：y和z的最终结果为:4,4例子分析：由于函数声明提升，所以函数声明会提前，由于存在同名函数，后面的add函数将覆盖第一个add函数，所以两次调用add()返回的值是相同的。 void关键词 void是一元运算符，它出现在操作数之前，操作数可以是任意类型，操作数会照常计算，但会忽略计算结果并返回undefined。由于void会忽略操作数的值，因此在操作数具有副作用的时候使用void来让程序更具语义。 void 作为运算符后面接的是表达式，void expression。而void(0)也是被当做void 0。如果直接void()，那么我觉得应该是把void当做函数使用了，但是void() 是关键词，并不能作为函数使用,所以void ();会报SyntaxError，即“语法错误”。。1234567void 0; //undefinedvoid (0);//undefinedvoid (); //SyntaxError 语法错误typeof 1; //'number'typeof (1);//'number'typeof (); //SyntaxError 语法错误 按位与运算&amp;&amp;:位运算符 比较两个数字的二进制的数位，按位与运算中 相等为1，否则为0。例子：1&amp;2返回的是0计算过程：（注意是针对二进制的数位进行对比是否相等！！）1＝0001 ，2＝0010，运算以后＝0000， 转换为数字结果为0，故返回0。 返回值和输出值不一样注意：返回值和输出值不是一种东西！任何函数执行完一次，如果没有 return 返回值和声明变量接受返回值，都会立即消失，永远找不到值！（undefined）也就是说，没有写return语句的函数都会默认返回undefined。 先立即执行匿名函数，输出Hello World！ 匿名函数没有写return语句默认返回undefined，则输出未定义 定义函数的三种方法在Javascript定义一个函数一般有如下三种方式： 函数关键字(function)语句： function fnMethodName(x){alert(x);} (最常用的方法) 函数字面量(Function Literals)： var fnMethodName = function(x){alert(x);} Function()构造函数： var fnMethodName = new Function(‘x’,’alert(x);’)后两种都是把一个函数赋值给变量fnMethodName，而这个函数是没有名字的，即匿名函数（拉达姆函数）。类似于 var foo = function bar(){...} 这样的统一按第2种方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。 注意，Function()构造函数没有{} 几个常见的事件的方法preventDefault() 取消事件默认行为（不是阻止事件冒泡），如阻止点击提交按钮时对表单的提交（click没有默认行为）stopImmediatePropagation() 取消事件冒泡同时阻止当前节点上的事件处理程序被调用，影响当前的事件stopPropagation() 取消事件冒泡，不影响事件cancelBubbe() 取消事件冒泡returnValue() 取消事件默认行为 thisIIFE(立即执行函数表达式)中的this指向window null与undefinednull和undefined是不同的，但它们都表示“值的空缺”，判断相等运算符“==”认为两者是相等的（使用严格相等运算符“===”来区分它们则不等） 运算符instanceof、===、== instanceof运算符希望左操作数是一个对象，右操作数表示对象的类（初始化对象的构造函数）。如果左侧的对象是右侧对象的实例，返回true，否则返回false。例如：计算o instanceof f首先计算f.prototype，然后在原型链中查找o，找到返回true ===严格相等运算符：首先计算其操作数的值，然后比较这两个值，比较过程中没有任何类型转换 ==相等运算符：如果两个操作数不是同一类型，那么会尝试进行一些类型转换，然后进行比较（1）尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换，因此==运算符认为两者是相等的（2）NaN表示非数字值，特殊之处：它和任何值都不相等，包括自身。判断NaN的方法：x!=x返回true JS继承方式JavaScript实现继承共6种方式：原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。 转换为布尔值0、“ ”、null、undefined转换为布尔型是false，其余都是true。 运算符优先级+加号运算符优先级大于?:三目运算符。（具体可看20200109第六题） ES6中promise的三种状态 一个 promise 可能有三种状态：等待（pending）、已完成（Resolved，又称fulfilled）、已拒绝（rejected） 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换。 promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 数组js中，数组会自动根据最大下标延长一位，既下标为n，则数组的长度为n+1。没有填值默认为undefinded。 分母为0isNaN(1/0) 任何 数值除以0 都会导致错误而终止程序执行。但是在 JavaScript 中，会返回出特殊的值，因此不会影响程序的执行。 比0大的数除以0，则会得到无穷大，所以 js 用 Infinity （无穷）来显示。 也就是1/0得到的是Infinity。isNaN(1/0)返回的是false。但是isNaN(0/0)返回的就是true。 in操作符（可参考MDN的in运算符） 如果指定的 属性 在指定的对象或其原型链中，则in 运算符返回true。 如果指定的 数组索引 在数组中，则in 运算符返回true。 1 in [1]并不是表示数字1在不在数组里。而是表示数组中含不含有1这个索引index值。 数组长度为1，所以只含有的index值为0，1 in [1]返回fasle。 运算符优先级参考MDN的运算符优先级中的“汇总表” 逻辑运算符&amp;&amp;和||的规律可参考MDN的逻辑运算符 明确：&amp;&amp;和||返回的是表达式，!返回的是布尔值！ 会被转换为 false 的表达式有：null； NaN； 0； 空字符串（&quot;&quot; or &#39;&#39; or ``）； undefined。 帮助理解返回表达式的原则：从前往后判断，只要到了能判断出 整个表达式的真假 的位置我们就停下来返回这个位置的部分表达式。 &amp;&amp;：前后都为真才是真，只要有一个是假的就是假。所以只要有第一个表达式是假的我们就不用继续判断了，返回第一个表达式。如果第一个表达式是真的我们就继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。 ||：只要有一个是真就是真。所以只要有第一个表达式是真的就可以判断整个表达式都是真的，故返回第一个表达式。如果第一个表达式是假的那我们就要继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。 例子12345//10可被强转为true，0则是false，有一个错的就返回错的表达式console.log(10 &amp;&amp; 0);//0//\"\"可被强转为false，\"abc\"可被强转为true，有一个是真的就返回真的表达式console.log(\"\" || \"abc\");//\"abc\"console.log(!window.abc);//true。`window.abc`是undefined，强转为false 题目问题：1 &amp;&amp; 2&gt;1返回的布尔值？答案：true解析：&gt;的优先级排在前，所以先判断右边的表达式，2&gt;1 结果为true。得到1&amp;&amp;true，1可被强转为true，所以返回的结果是 运算符后面的表达式 ，也就是true。 改一下问题：console.log(2 &gt; 1 &amp;&amp; 1);答案：1解析：2&gt;1 结果为true，所以返回 运算符后面的表达式，也就是1. cookie的生命期cookie的有效时间默认为-1，如果不进行设置的话，就会默认在浏览器会话关闭时结束。可以通过setMaxAge()方法设置cookie的生命期。当setMaxAge(0)表示立刻删除该浏览器上指定的cookie。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"牛客网题目","slug":"牛客网题目","permalink":"http://yoursite.com/categories/牛客网题目/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS笔试遇到的知识点（2）","slug":"JS笔试题遇到的知识点（2）","date":"2020-01-18T04:08:59.000Z","updated":"2020-01-18T04:09:34.568Z","comments":true,"path":"2020/01/18/JS笔试题遇到的知识点（2）/","link":"","permalink":"http://yoursite.com/2020/01/18/JS笔试题遇到的知识点（2）/","excerpt":"js中同名函数后面会覆盖前面的js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。","text":"js中同名函数后面会覆盖前面的js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。 在js中，定义了两个同名函数后，后面的函数会覆盖前面定义的函数。也就是说，前面定义的函数内容会被后面的函数内容覆盖，当你以为自己执行的是前面的函数内容时，其实执行的是后面的函数内容。 例子： 1234567891011&lt;script&gt; var m= 1, j = k = 0; function add(n) &#123; return n = n+1; &#125; y = add(m); function add(n) &#123; return n = n + 3; &#125; z = add(m); &lt;/script&gt; 例子结果：y和z的最终结果为:4,4例子分析：由于函数声明提升，所以函数声明会提前，由于存在同名函数，后面的add函数将覆盖第一个add函数，所以两次调用add()返回的值是相同的。 void关键词 void是一元运算符，它出现在操作数之前，操作数可以是任意类型，操作数会照常计算，但会忽略计算结果并返回undefined。由于void会忽略操作数的值，因此在操作数具有副作用的时候使用void来让程序更具语义。 void 作为运算符后面接的是表达式，void expression。而void(0)也是被当做void 0。如果直接void()，那么我觉得应该是把void当做函数使用了，但是void() 是关键词，并不能作为函数使用,所以void ();会报SyntaxError，即“语法错误”。。1234567void 0; //undefinedvoid (0);//undefinedvoid (); //SyntaxError 语法错误typeof 1; //'number'typeof (1);//'number'typeof (); //SyntaxError 语法错误 按位与运算&amp;&amp;:位运算符 比较两个数字的二进制的数位，按位与运算中 相等为1，否则为0。例子：1&amp;2返回的是0计算过程：（注意是针对二进制的数位进行对比是否相等！！）1＝0001 ，2＝0010，运算以后＝0000， 转换为数字结果为0，故返回0。 返回值和输出值不一样注意：返回值和输出值不是一种东西！任何函数执行完一次，如果没有 return 返回值和声明变量接受返回值，都会立即消失，永远找不到值！（undefined）也就是说，没有写return语句的函数都会默认返回undefined。 先立即执行匿名函数，输出Hello World！ 匿名函数没有写return语句默认返回undefined，则输出未定义 定义函数的三种方法在Javascript定义一个函数一般有如下三种方式： 函数关键字(function)语句： function fnMethodName(x){alert(x);} (最常用的方法) 函数字面量(Function Literals)： var fnMethodName = function(x){alert(x);} Function()构造函数： var fnMethodName = new Function(‘x’,’alert(x);’)后两种都是把一个函数赋值给变量fnMethodName，而这个函数是没有名字的，即匿名函数（拉达姆函数）。类似于 var foo = function bar(){...} 这样的统一按第2种方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。 注意，Function()构造函数没有{} 几个常见的事件的方法preventDefault() 取消事件默认行为（不是阻止事件冒泡），如阻止点击提交按钮时对表单的提交（click没有默认行为）stopImmediatePropagation() 取消事件冒泡同时阻止当前节点上的事件处理程序被调用，影响当前的事件stopPropagation() 取消事件冒泡，不影响事件cancelBubbe() 取消事件冒泡returnValue() 取消事件默认行为 thisIIFE(立即执行函数表达式)中的this指向window null与undefinednull和undefined是不同的，但它们都表示“值的空缺”，判断相等运算符“==”认为两者是相等的（使用严格相等运算符“===”来区分它们则不等） 运算符instanceof、===、== instanceof运算符希望左操作数是一个对象，右操作数表示对象的类（初始化对象的构造函数）。如果左侧的对象是右侧对象的实例，返回true，否则返回false。例如：计算o instanceof f首先计算f.prototype，然后在原型链中查找o，找到返回true ===严格相等运算符：首先计算其操作数的值，然后比较这两个值，比较过程中没有任何类型转换 ==相等运算符：如果两个操作数不是同一类型，那么会尝试进行一些类型转换，然后进行比较（1）尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换，因此==运算符认为两者是相等的（2）NaN表示非数字值，特殊之处：它和任何值都不相等，包括自身。判断NaN的方法：x!=x返回true JS继承方式JavaScript实现继承共6种方式：原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。 转换为布尔值0、“ ”、null、undefined转换为布尔型是false，其余都是true。 运算符优先级+加号运算符优先级大于?:三目运算符。（具体可看20200109第六题） ES6中promise的三种状态 一个 promise 可能有三种状态：等待（pending）、已完成（Resolved，又称fulfilled）、已拒绝（rejected） 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换。 promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 数组js中，数组会自动根据最大下标延长一位，既下标为n，则数组的长度为n+1。没有填值默认为undefinded。 #","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"牛客网题目","slug":"牛客网题目","permalink":"http://yoursite.com/categories/牛客网题目/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"hexo deploy中报错：Nunjucks Error","slug":"hexo deploy中报错_Nunjucks Error","date":"2020-01-16T07:34:12.000Z","updated":"2020-01-16T13:35:58.812Z","comments":true,"path":"2020/01/16/hexo deploy中报错_Nunjucks Error/","link":"","permalink":"http://yoursite.com/2020/01/16/hexo deploy中报错_Nunjucks Error/","excerpt":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。","text":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。 回到 git bush 中发现报错。 报错分析 deploy 过程中 git bush 中提到了： Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error: [Line 51, Column 169] unexpected token: }} 根据提示进入网址https://hexo.io/docs/troubleshooting.html去寻找问题，善用`Ctrl+F`+Nunjucks （Error关键词）找到问题所在。 找到问题我的markdown中的出现了会被hexo解析的符号： 解决问题也就是说，Hexo使用Nunjucks来渲染文章(在旧版本中使用了Swig，它们共享相似的语法)。使用{{}}或{% %} 包装的内容将被解析，并可能导致问题。您可以使用raw标签插件包装敏感内容。（如下所示） 123&#123;% raw %&#125;你好呀这里是你原来想要书写的内容 &#123;&#123; 敏感的内容需要使用这种方式被包装起来哦 &#125;&#125;&#123;% endraw %&#125;","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"JS笔试遇到的知识点（1）","slug":"JS笔试遇到的知识点（1）","date":"2020-01-16T03:29:40.000Z","updated":"2020-02-05T13:56:28.236Z","comments":true,"path":"2020/01/16/JS笔试遇到的知识点（1）/","link":"","permalink":"http://yoursite.com/2020/01/16/JS笔试遇到的知识点（1）/","excerpt":"四种touch事件1234touchstart: //手指放到屏幕上时触发touchmove: //手指在屏幕上滑动式触发touchend: //手指离开屏幕时触发touchcancel: //系统取消touch事件的时候触发，这个好像比较少用","text":"四种touch事件1234touchstart: //手指放到屏幕上时触发touchmove: //手指在屏幕上滑动式触发touchend: //手指离开屏幕时触发touchcancel: //系统取消touch事件的时候触发，这个好像比较少用 跨域关于跨域 javascript中实现跨域的方式总结第一种方式：jsonp请求jsonp的原理是利用&lt;script&gt;标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有&lt;img&gt;.第二种方式：document.domain这种方式用在主域名相同子域名不同的跨域访问中第三种方式：window.namewindow的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。第四种方式：window.postMessagewindow.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。第五种方式：CORSCORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。第六种方式：Web Socketsweb sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 Math 对象Math 对象用于执行数学任务。注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。 Math.round(）方法 返回最接近的整数Math.round(）函数返回一个数字四舍五入后最接近的整数如果参数的小数部分大于0.5，四舍五入到相邻的绝对值更大的整数如果参数的小数部分小于0.5，四舍五入到相邻的绝对值更小的整数如果参数的小数部分等于0.5，四舍五入到相邻的在正无穷（+∞）方向上的整数。 例： 1234x=Math.round(2019.49) ; //2019x=Math.round(2019.5); //2020x=Math.round(-2019.5); //-2019x=Math.round(-2019.51); //-2020 Math.abs() 方法 返回数的绝对值 定义：abs() 方法可返回数的绝对值。 语法：Math.abs(x) 参数：必需。必须是一个数值。 基本（原始）、复杂与全局数据类型 基本数据类型（原始值）（记忆：NNUSB=&gt;纳尼USB）Number，Null，Undefined，String，Boolean。es6添加了一种新的原始数据类型：Symbol。所以现在 js的原始数据类型有6种。 复杂数据类型（对象值）：Object，Array，Function，RegExp，Date，Error 全局数据类型：Math 原始值和引用值ECMAScript中，变量可以存放两种类型的值，即原始值和引用值。原始值是存储在栈中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。(基本（原始）数据类型的值)引用值是存储在堆中的对象，也就是说，存储在变量处的值是一个指针，指向存储对象的内存处。（比如对象、数组） RegExp正则表达式JavaScript RegExp 对象有3个方法：test()、exec()、compile()test()：检测一个字符串是否匹配某个正则表达式，如果匹配成功，则返回true，否则返回false；exec()：检索字符串中与正则表达式匹配的值，返回一个数组，存放匹配的结果；如果未找到，返回null；compile():可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。注：match是支持正则表达式的String对象的方法. Array 对象方法concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串,元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素 .push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素unshift() 向数组的开头添加一个或更多元素，并返回新的长度。slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行 升序/降序排序(请注意，数组在原数组上进行排序，不生成副本。)，参数决定排序的顺序（参数为空则按照字符编码的顺序进行排序，参数也可为比较函数）。splice() 删除元素，并向数组添加新元素。(删除，插入，替换；得到的数组都是被删去的）toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。valueOf() 返回数组对象的原始值 不会更改原有数组的方法concat()连接两个或更多的数组，得到新数组。map()循环数组 会更改原有数组的方法splice()【删除，插入，替换；得到的数组都是被删去的】sort()【数组在原数组上进行排序，不生成副本。】 ++前后之区别前置自增：++在前，先+1，再取值，表达式的值即为自增后的值后置自增：++在后，先取值，再+1，表达式的值即为自增前的值 对象={属性：值}1var car = &#123;type=\"porsche\",color=\"white\"&#125; Number类的toFixed（）与toPrecision（） 两个方法返回的数字都是字符串形式。 toFixed（）把数字四舍五入转换为由参数指定小数位数的数字。（不采用科学记数法） toPrecision（） 规定Number对象的值超出参数指定的有效数字的位数时将其有效长度格式化为参数指定的长度。 当参数规定的有效数字的位数能包住Number对象时 注意：参数规定的有效数字的位数是从数字第一个不为0的数(包括整数部分和小数部分)开始计算的位数。 Number对象的值 &gt; 参数指定的有效数字的位数 时，采用定点记数法（使用小数点）【比如参数为5时，312=312.00;参数为2时，要求有效位数2位，0.8=0.80】 Number对象的值 &lt;= 参数指定的有效数字的位数 时，采用科学记数法。【比如参数为2时，1234.1234 = 12.341234*10^2 = 12.341234e10+2】 AngularJS1数据绑定的占位符AngularJS1中页面中用于数据绑定的占位符是{{ }} jquery获取当前窗口的宽度值在jquery中，如果想要获取当前窗口的宽度值,使用width() 在jquery中: width()方法设置或返回元素的宽度（不包括内边距padding、边框border或外边距margin）。 height()方法设置或返回元素的高度（不包括内边距padding、边框border或外边距margin）。 innerWidth()方法返回元素的宽度（包括内边距padding）。 innerHeight() 方法返回元素的高度（包括内边距padding）。 outerWidth()方法返回元素的宽度（包括内边距padding和边框border）。 outerHeight() 方法返回元素的高度（包括内边距padding和边框border）。 outerWidth(true) 方法返回元素的宽度（包括内边距padding、边框border和外边距margin）。 outerHeight(true) 方法返回元素的高度（包括内边距padding、边框border和外边距margin）。 12345678alert($(window).height()); //浏览器当前窗口可视区域高度 alert($(document).height()); //浏览器当前窗口文档的高度 alert($(document.body).height());//浏览器当前窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器当前窗口可视区域宽度 alert($(document).width());//浏览器当前窗口文档对象宽度 alert($(document.body).width());//浏览器当前窗口文档body的宽度 alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin 注意：区分jquery的innerheight（）与window的innerheight属性。window.innerheight 返回浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。window.outerHeight属性设置或返回一个窗口的外部高度，包括所有界面元素（如工具栏/滚动条）。 变量与函数提升 变量声明会被提升，赋值语句不提升。使用 函数声明 时函数也会被提升，但使用 函数表达式 时不存在提升。（注意：函数表达式就是带等号的。函数在ES5中是整个函数被提升，在ES6中是只提升函数的声明（也就是只提升函数名），函数内容（变量初始化的值）是不会被提升的，他们将被留在原来的位置。） 变量声明、函数声明都会被提升到作用域顶处，且 函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖。 补充：当出现多个同名变量与同名函数时，调用该变量名时的优先级为：变量声明&lt; 函数声明 &lt; 变量赋值（具体参考20191215第7题、20200205第4题） 闭包 闭包内变量执行后不会被清除，要到整个闭包被清除的时候才会清除，比如局部变量要等到函数执行完之后。 自调用函数（立即执行函数）理论上是一个闭包。闭包可以访问其他函数内部变量的函数，而立即执行函数传参，相当于父级变量；闭包需要手动执行，不能自主释放内存；而立即执行函数相当于做了一次函数执行，最后释放内存。逻辑上立即执行函数可以理解为：声明闭包函数-执行-释放内存 &lt;link&gt;与&lt;script&gt; &lt;link&gt; 和href配合 加载css，hypertext reference超文本引用，页面加载到href时不会停下来。 &lt;script&gt;和src配合 加载script文件，source资源，页面会停下来等待资源加载完毕（并执行完），所以一般js放在body的最下面。 数组长度不包括数组的方法（函数） 首先要明确：数组也是对象 对象不能用length返回其拥有的属性数量 12345var arr = 0; arr[0] = 0; arr[1] = 1; arr.foo = 'C'; console.loa(arr.lenath);//2 这里要理解所谓‘数组’其实是array类型对象的一个特殊作用，就是：我们可以对它进行一种模式的数据存储，但除此之外，它依然是一个对象 var arr = [‘1’，‘2’] //这本质上是一系列操作：得到一个数组对象；调用了它的数组方法存入了一些数据，arr.length根据存入数据的数目被修改 arr.length，对arr对象的length属性进行一个访问 arr.foo = &#39;hello&#39; 对arr对象创建一个属性，所以.foo 跟.length地位是并列的：就是arr的一个属性**，同时arr的数组方法跟这些属性是毫不相关的。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"牛客网题目","slug":"牛客网题目","permalink":"http://yoursite.com/categories/牛客网题目/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"开发博客项目之接口(1)","slug":"Node.js开发博客项目之接口(1)","date":"2020-01-15T03:41:14.000Z","updated":"2020-01-18T14:04:52.645Z","comments":true,"path":"2020/01/15/Node.js开发博客项目之接口(1)/","link":"","permalink":"http://yoursite.com/2020/01/15/Node.js开发博客项目之接口(1)/","excerpt":"http-概述开发接口（不用任何框架）nodejs处理http请求搭建开发环境开发接口（暂不连接数据库，暂不考虑登录）","text":"http-概述开发接口（不用任何框架）nodejs处理http请求搭建开发环境开发接口（暂不连接数据库，暂不考虑登录） HTTP请求概述（面试常问：从输入url到页面显示都经历了什么）客户端（浏览器）：DNS解析：通过输入的域名解析到一个IP地址；建立TCP连接（三次握手）；发送http请求。服务端：server接收到http请求，处理，并返回。（处理过程在下面“nodejs处理HTTP请求”中）（res返回的都是字符串，只是形式不同，通过content-type来决定，比如html或者json）客户端（浏览器）接收到服务端返回的数据，处理数据（如渲染页面，执行js）。 实例演示客户端（浏览器）进行DNS解析：浏览器或者操作系统本身是有缓存的，如果是缓存过期或者没有缓存又或者是第一次访问，浏览器或者操作系统就会去域名工程商去通过域名去DNS服务器换取IP地址。（更多详情需要复习 计算机网络 ）server端就是这个IP地址的服务器！！（百度比较大，全国各地使用人数多，看到的IP地址不一样是正常的，就算是自己今天看到的和昨天看到的不一样也是很正常的）客户端找到IP地址之后就会进行TCP连接（三次握手） 握手 作用 第1次 客户端（浏览器）询问服务器：你是否可以使用？ 第2次 服务器回答客户端（浏览器）：我可以用。 第3次 客户端（浏览器）告诉服务器：我知道啦，接下来我会访问你哦。 发送http请求：客户端（浏览器）通过url使用get方法向服务端发送http请求，头部包含了请求信息，他们告诉了服务端这个客户端（浏览器）是什么样子的以及有什么要求。（注意：请求req都是客户端发起的，而回复res都是服务端做的。） 我们已经清楚：server端就是这个IP地址的服务器，server端会通过Request Headers 告诉客户端我反回的是html代码而不是纯文本： 客户端（浏览器）接收到server端返回的数据后就会解析这些html代码，解析完之后就会去渲染，渲染完后就会显示页面，页面显示之后就会加载图片、加载js、加载jquery、加载css等，这些又是另外的HTTP请求。（可能会通过一个网页产生很多的HTTP请求，当然请求越少性能越好） nodejs处理HTTP请求nodejs作为server端处理HTTP请求，这也是“从输入url到页面显示都经历了什么”中的第二个步骤。总结：无论是GET还是POST，nodejs处理HTTP请求的最基本思路就是我们（客户端）向服务端传递一些信息（我想向你获取/传递数据），然后服务端进行处理以后再返回给我们。 get请求和querystring（客户端要向server端获取（索取）数据） post请求和postdata（客户端要向服务端传递数据） 路由（接口地址） 处理get请求 get请求，即客户端要向server端获取（索取）数据，如查询博客列表 客户端通过querystring来向服务端传递数据(也就是url参数)，如a.html？a=100&amp;b=200也就是把a=100&amp;b=200传给了服务端，服务端收到后进行处理再返回相应的数据给到客户端。 浏览器直接访问，发送的就是get请求（像上面的“实例演示”中访问百度就是get请求） 例子新建文件夹“http-test”，在vscode中打开，因为不知道接下来会不会需要加载其他包，所以可以在终端先npm init -y初始化npm环境，初始化后会得到package.json，将首页改为app.js后新建主页： 1234567891011121314151617const http = require(\"http\")const querystring = require (\"querystring\")const server = http.createServer((req,res)=&gt;&#123; console.log(\"method:\",req.method)//GET const url = req.url console.log(\"url:\",url) // req.query = querystring.parse(url.split(\"?\")[1]) req.query = querystring.parse(url.split(\"?\")[1]) console.log(\"query:\",req.query) res.end( JSON.stringify(req.query) )&#125;)server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 在终端测试,输入node app.js后得到OK说明监听成功：打开http://localhost:8000/得到的是一个空对象，这是因为query就是一个对象，而我们没有往里面放东西:输入http://localhost:8000/api/blog/list?author=hlz&amp;keyword=hahaha,也就是通过url参数(?后即url参数)往query里面放东西以后：可以看到终端返回的内容也有所变化：补充：终端中的url: /favicon.ico是浏览器默认的请求，主要是向服务端请求一个页面标志： 处理post请求post请求，即客户端要向服务端传递数据，如新建博客也就是客户端通过post data向服务端传递数据，服务端接收以后会进行处理。浏览器无法直接模拟，需要手写js，或者使用postman（不能像上面get请求一样直接通过浏览器访问某个页面来模拟） 安装postmanpostman可用于调试、发送HTTP请求。以前可以进入Google搜索postman chrome，或者可以点击这个链接进行postman插件的添加。现在只能直接去官网下载postman app。 post请求的例子注意：每次修改nodejs代码内容后都需要在终端输入node app.js来重启node。 1234567891011121314151617181920const http = require(\"http\")const server = http.createServer((req, res) =&gt; &#123; if (req.method === \"POST\") &#123; //req 数据格式 console.log(\"req content-type\", req.headers[\"content-type\"]) //接收数据 let postData = \"\" req.on(\"data\", chunk =&gt; &#123; postData += chunk.toString() &#125;) req.on(\"end\", () =&gt; &#123; console.log(\"postData:\", postData) res.end(\"hello world!\") &#125;) &#125;&#125;)server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 在postman上的操作流程：postman接收到了hello world！说明服务端接收到了返回（res）。回到vscode终端可以看到（记得修改nodejs代码内容后需要在终端输入node app.js）：说明我们通过postman发送的数据真正到了node文件中，并且他是一个post请求，且它被我们通过data、on、end的方式被接收到了。 nodejs处理路由路由：代表了url资源唯一的标识。以github为例讲解一下路由： 例子123456789const http = require(\"http\")const server = http.createServer((req, res) =&gt; &#123; const url = req.url const path = url.split(\"?\")[0] res.end(path);//返回路由&#125;);server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 访问http://localhost:8000/api/blog/list?author=hlz&amp;keyword=hahaha 处理http请求的综合示例总结：无论是GET还是POST，nodejs处理HTTP请求的最基本思路就是我们向服务端传递了什么，然后服务端进行处理以后再返回给我们。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const http = require(\"http\")const querystring = require(\"querystring\")const server = http.createServer((req, res) =&gt; &#123; const method = req.method const url = req.url const path = url.split(\"?\")[0] const query = querystring.parse(url.split(\"?\")[1]) //设置返回的字符串格式为JSON res.setHeader(\"Content-type\", \"application/json\") //返回的数据 const resData = &#123; method, url, path, query &#125; //返回 if (method === \"GET\") &#123; res.end( //返回的一定是字符串，而上面设置的Content-type返回类型为json JSON.stringify(resData) ) &#125; if (method === \"POST\") &#123; let postData = \"\" req.on(\"data\", chunk =&gt; &#123; //把post过来的数据都放进postData中 postData += chunk.toString() &#125;) req.on(\"end\", () =&gt; &#123; //postData中的数据必须返回才能显示，所以放入resData中 resData.postData = postData //返回 res.end( JSON.stringify(resData) ) &#125;) &#125;&#125;)server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 测试GET直接在网页测试GET请求，客户端通过querystring向服务端传递？后的query数据（也就是url参数），然后服务端将它们通过res返回到客户端，也就显示在页面上了： 测试POST在postman中进行POST请求的测试，客户端通过 postData 向服务端传递了两条数据（博客标题、博客内容），我们写的nodejs给予的处理是将 postData 放入 resData 中通过 res 返回到页面上，如图所示：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"DOM 元素的 children 与 childNodes 属性","slug":"children","date":"2020-01-13T11:21:07.000Z","updated":"2020-01-13T11:27:44.778Z","comments":true,"path":"2020/01/13/children/","link":"","permalink":"http://yoursite.com/2020/01/13/children/","excerpt":"children 与 childNodes 的区别childNodes 属性返回所有的节点，包括文本节点、注释节点，children 属性只返回元素节点。","text":"children 与 childNodes 的区别childNodes 属性返回所有的节点，包括文本节点、注释节点，children 属性只返回元素节点。 HTML DOM children 属性(子元素)children 属性返回元素的子元素的集合，是一个 HTMLCollection 对象。 HTML DOM childNodes 属性（所有节点） childNodes 属性返回包含被选节点的子节点的 NodeList。 空格和换行都会被看做一个文本节点。 例子 相关题目题目分析下面代码，对于该段代码分析说法正确的是（ ） 123456789101112131415161718192021222324&lt;html&gt;&lt;body&gt; &lt;div id=\"ele\" class=\"div\"&gt; &lt;span id=\"s1\" class=\"sp\" lang=\"zh-cn\"&gt; &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; function exct() &#123; var oEle = document.getElementById(\"ele\"); var child = oEle.children; console.log(\"ele.children的执行结果是:\"); for(i = 0; i &lt; child.length; i++)&#123; console.log(child[i].tagName); &#125; child = oEle.childNodes; console.log(\"ele.childNodes的执行结果是:\"); for(i = 0; i &lt; child.length; i++)&#123; console.log(child[i].tagName); &#125; &#125; exct (); &lt;/script&gt;&lt;/html&gt; 答案其运行结果是： 123456div1.children的执行结果是:SPANdiv1.childNodes的执行结果是:undefinedSPANundefined 对于DOM元素，children是指DOM Object类型的子对象，不包括tag之间隐形存在的TextNode，而childNodes包括tag之间隐形存在的TextNode对象。 解释div元素下虽然只有一个span元素，但有3个子节点。因为childNodes获取子节点没有类型限制，span是一个元素节点，还有两个文本节点：空格和换行都被看做一个文本节点。所以，3个子节点 = 两个文本节点 + 一个元素节点。tagName用来获取元素的标签名，文本节点没有标签名，所以也就为undefined了。 参考链接 HTML DOM children 属性 HTML DOM childNodes 属性","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"DOM事件","slug":"JS_DOM事件","date":"2020-01-09T06:38:27.000Z","updated":"2020-01-10T05:37:51.869Z","comments":true,"path":"2020/01/09/JS_DOM事件/","link":"","permalink":"http://yoursite.com/2020/01/09/JS_DOM事件/","excerpt":"事件类型注意 代码从上往下执行，在DOM事件中，如果先在&lt;script&gt;里获取对象再通过&lt;div&gt;定义对象会报错，因为这个对象的定义是出现在了获取的后面，你想要获取的时候还没定义。此时可以在&lt;script&gt;里使用鼠标事件中的onload（例子在下方）","text":"事件类型注意 代码从上往下执行，在DOM事件中，如果先在&lt;script&gt;里获取对象再通过&lt;div&gt;定义对象会报错，因为这个对象的定义是出现在了获取的后面，你想要获取的时候还没定义。此时可以在&lt;script&gt;里使用鼠标事件中的onload（例子在下方） 关于this指向 在事件触发的（function）函数中，this是对该DOM对象的引用。 可以通过console.log(this)来看this在这个函数中指的是什么。 鼠标事件 onload：页面加载时触发 （页面加载完成后才执行） onclick：鼠标点击时触发 onmousedown：鼠标按钮在元素上按下时触发 onmousemove：每次鼠标指针移动时都会触发 onmouseover：鼠标滑过指定对象上时触发 onmouseout：鼠标离开时触发 onmouseup：在元素上松开鼠标按钮时触发 onfoucs：获得焦点时触发 （只能用于：input标签type为text、passwordtextarea标签） onblur：失去焦点时触发（blur v.使……模糊不清） onchange：域的内容改变时发生 （一般作用于（下拉框）select或checkbox或radio） onsubmit：表单中的确认按钮被点击时发生 （onsubmit事件不是加在按钮上，而是表单上） onresize：当调整浏览器窗口的大小时触发 onscroll：拖动滚动条滚动时触发 需要知道的 onmousedown（按下鼠标）与onmouseup（松开鼠标）组成了onclick（鼠标点击）事件。 onmouseover或onmousemove都必须和onmouseout结合才能实现移入移出不同效果的功能。（onmouseover的例子、onmousemove的例子） onmousemove与onmouseover的区别 时间上 onmousemove 事件触发后，再触发 onmouseover 事件。 动作上 onmouseover 只在刚进入区域时触发。onmousemove 除了刚进入区域触发外，在区域内移动鼠标，也会触发该事件。（当鼠标移动很快时，可能不会触发这两个事件。） onmouseover 与 onmousemove 的区别是： onmousemove在每次鼠标移动时，都会触发，以此获得当前坐标值，用来判断这个点是否落在指定元素内。onmouseover，则会在进入对象时就触发，且仅会触发这一次。当鼠标移过当前对象时就产生了onmouseover事件（onmouseover有个移入移出的过程）,当鼠标在当前对象上移动时就产生了onmousemove事件，只要是在对象上移动而且没有移出对象的，就是onmousemove事件。 例子用canvas标签，创建了一个画布，并画了一个小矩形，我想让鼠标悬停到矩形区域时改变矩形填充色，这里只能监听整个画布，看起来应该用over，实际上用的却是move。因为，move在每次鼠标移动时，都会触发，会获得当前坐标值，用来判断这个点是否落在矩形内。若是用over，则会在进入画布时就触发，且仅会触发这一次，之后鼠标在画布内移动，一直都处于over状态，就不会触发，直到鼠标离开这个画布区域，失效。 HTML事件中调用JS函数时不加括号 加括号就是直接执行函数了，不加括号则是指向函数地址，当发生事件时才去调用函数。 事件=function(){}或者事件=函数名都是可以的，不能使用事件=(function(){})(参数)或事件=函数名()。 如果事件绑定函数想要传参可以使用xx.onclick=function(){函数名(参数);}，也就是绑定一个函数，函数在触发onclick时执行，函数内容是执行你想传参的那个函数。 对window使用onload的例子12345678910111213141516&lt;head&gt; &lt;script&gt; // 页面加载完成后才执行 window.onload=function()&#123; // 获取box var box =document.getElementById(\"box\"); var clicked=function()&#123; alert(\"我被点击了！\"); &#125; box.onclick=clicked; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt;这是一个box&lt;/div&gt;&lt;/body&gt; onfocus事件 只能用于：input标签type为text、password textarea标签 onfocus和onblur事件的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; padding:50px; &#125; .left,.tip&#123; float:left; &#125; .left&#123;margin-right:10px;&#125; .tip&#123;display:none;font-size:14px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; // 获取文本框和提示框 var phone=document.getElementById(\"phone\"), tip=document.getElementById(\"tip\"); // 给文本框绑定激活的事件 phone.onfocus=function()&#123; // 让tip显示出来 tip.style.display='block'; &#125; // 给文本框绑定失去焦点的事件 phone.onblur=function()&#123; // 获取文本框的值,value用于获取表单元素的值 var phoneVal=this.value; // 判断手机号码是否是11位的数字 // 如果输入正确，则显示对号图标，否则显示错号图标 if(phoneVal.length**11 &amp;&amp; isNaN(phoneVal)**false)&#123; tip.innerHTML='&lt;img src=\"E:/慕课网 前端小白入门系列课程完整版/JavaScript/6.javascriptDoM事件/img/right.png\"&gt;'; &#125;else&#123; tip.innerHTML='&lt;img src=\"E:/慕课网 前端小白入门系列课程完整版/JavaScript/6.javascriptDoM事件/img/error.png\"&gt;'; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt; &lt;input type=\"text\" id=\"phone\" placeholder=\"请输入手机号码\"&gt; &lt;/div&gt; &lt;div class=\"tip\" id=\"tip\"&gt; 请输入有效的手机号码 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 实现效果可以看E:\\慕课网 前端小白入门系列课程完整版\\JavaScript\\6.javascriptDoM事件\\index4.html “onchange：域的内容改变时发生”的例子change事件,一般作用域（下拉框）select或checkbox或radio。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 页面加载（注意这是对DOM0级事件的命名函数调用，不要括号） window.onload=init; // 初始化 function init()&#123; // 获取下拉菜单 var menu=document.getElementById(\"menu\"); // 给菜单绑定change事件,一般作用域select或checkbox或radio menu.onchange=function()&#123; // 获取当前选中的值 var bgcolor=this.value; // var bgcolor=menu.options[menu.selectedIndex].value; // 可以先打印出来看看选中选项以后得到的value是什么 // console.log(bgcolor); // 设置body的背景色 //如果bgcolor为空，则下面的脚本将不执行，否则是选择的颜色 if(bgcolor**\"\")&#123; return; &#125;else&#123; document.body.style.background=bgcolor; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; 请选择您喜欢的背景色： &lt;select name=\"\" id=\"menu\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"#f00\"&gt;红色&lt;/option&gt; &lt;option value=\"#0f0\"&gt;绿色&lt;/option&gt; &lt;option value=\"#00f\"&gt;蓝色&lt;/option&gt; &lt;option value=\"#ff0\"&gt;黄色&lt;/option&gt; &lt;option value=\"#ccc\"&gt;灰色&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/body&gt; 在html中使用js中的onchange注意：事件函数中调用函数都不用括号。不建议使用html事件，建议使用DOM事件。 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function upperCase(x)&#123;var y=document.getElementById(x).valuedocument.getElementById(x).value=y.toUpperCase()&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Enter your name: &lt;input type=\"text\" id=\"fname\" onchange=\"upperCase(this.id)\"&gt;&lt;/body&gt;&lt;/html&gt; 效果 onchange事件编程练习总结 if的条件判断一定要注意是两个等号！！ 要求小伙伴们，今天我们学习了onchange鼠标事件，实现下列功能： （1）选择下拉列表中不同的选项，页面中的d iv就设置成不同的背景颜色，div中的内容也发生变化。 比如：选择黄色选项，div的背景颜色就变为黄色，文本内容就变为“我的背景颜色变成了yellow色” （2）当选择下拉列表中的“请选择”时，div的背累颜色变成白色，文本变为“我没有发生任何变化” 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;head&gt; &lt;style type=\"text/css\"&gt; #div &#123; width: 300px; height: 300px; border: 2px solid gray; margin: 100px 0 0 200px; display: none; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; // 页面加载完成后才执行 window.onload = function () &#123; // 获取下拉框与文字 var colorSelect = document.getElementById(\"color\"); var bgText=document.getElementById(\"div\"); // console.log(bgText.innerHTML) // 绑定事件 colorSelect.onchange = choose; function choose() &#123; // console.log(this.value); var bgColor=this.value; // 选择颜色时让下方文字框可见 bgText.style.display=\"block\"; // 一定要注意是两个等号！ if(bgColor**\"0\")&#123; bgText.innerHTML=\"我没有变化呀\"; &#125;else&#123; bgText.innerHTML=\"我变成\"+bgColor+\"色了诶\"; document.body.style.background=bgColor; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;请选择您喜欢的颜色：&lt;/span&gt; &lt;select name=\"\" id=\"color\"&gt; &lt;option value=\"0\"&gt;请选择&lt;/option&gt; &lt;option value=\"yellow\"&gt;黄色&lt;/option&gt; &lt;option value=\"orange\"&gt;橘色&lt;/option&gt; &lt;option value=\"pink\"&gt;粉色&lt;/option&gt; &lt;option value=\"purple\"&gt;紫色&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div id=\"div\"&gt;我是下方文字&lt;/div&gt;&lt;/body&gt; 地址：E:\\慕课网 前端小白入门系列课程完整版\\JavaScript\\6.javascriptDoM事件\\test.html onsubmit事件不是加在按钮上，而是form表单上。 例子1234567891011121314151617&lt;body&gt; &lt;!-- 表单中的确认按钮被点击时发生 --&gt; &lt;p&gt;当提交表单是，触发函数并弹出提示信息。&lt;/p&gt; &lt;form action=\"demo-form.php\" id=\"form_ok\"&gt; 输入名字: &lt;input type=\"text\" name=\"fname\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;script&gt; // 获取表单（不是确认按钮！） var ok=document.getElementById(\"form_ok\"); // 绑定事件 ok.onsubmit=myFunction; function myFunction() &#123; alert(\"表单已提交\"); &#125; &lt;/script&gt;&lt;/body&gt; E:\\慕课网 前端小白入门系列课程完整版\\JavaScript\\6.javascriptDoM事件\\onsubmit.html 三个比较简单的鼠标事件想了解可以看index6.html onmousedown：鼠标按钮在元素上按下时触发 onmousemove：在鼠标指针移动时发生 onmouseup：在元素上松开鼠标按钮时触发 经常作用于window对象的两个事件 onresize：当调整浏览器窗口的大小时触发 onscroll：拖动滚动条滚动时触发","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"正则表达式（身份证）及其方法","slug":"JS正则表达式（身份证）及其方法","date":"2020-01-02T08:01:23.000Z","updated":"2020-01-13T06:59:14.462Z","comments":true,"path":"2020/01/02/JS正则表达式（身份证）及其方法/","link":"","permalink":"http://yoursite.com/2020/01/02/JS正则表达式（身份证）及其方法/","excerpt":"JS中生成RegExp对象的两种方法 RegExp 对象表示正则表达式。 修饰符包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。","text":"JS中生成RegExp对象的两种方法 RegExp 对象表示正则表达式。 修饰符包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。 方法1：使用直接量的方式规则用//包裹起来，修饰符跟在后面： 1const regexp1=/规则/修饰符; 例子： 12//^表示开头，g表示全局匹配。即：开头为a的字符串就满足这个正则表达式const regexp1=/^a/g; 方法2：使用构造函数RegExp的方式规则和修饰符都用引号包裹起来： 1const regexp2=new RegExp('规则','修饰符'); 例子： 1const regexp2=new RegExp('^a','g'); 或者 1const regexp2=new RegExp(/规则/修饰符); 例子： 1const regexp3=new RegExp(/^a/g); 正则方法 字符串的正则方法有：match()、replace()、search()、split() 正则对象的方法有：exec()、test() 注意区分match()和exec()，他们都是返回匹配结果的数组，但区别如下表： match() exec() 字符串的正则方法，使用字符串对象进行调用 正则对象的方法，使用RegExp对象进行调用 返回的是匹配完成后完整的数组 每调用一次返回单次对应的匹配结果并用数组的方式显示 区分match()和exec()的例子：12345678910const r1 = /imooc/g;const str = \"imoocimooc_imooc\";console.log(r1.exec(str));//[\"imooc\", index: 0, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 5, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 11, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//nullconsole.log(str.match(r1));//[\"imooc\", \"imooc\", \"imooc\"] match() 方法 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值(数组)，而不是字符串的位置。 返回值:存放匹配结果的数组。 语法：12stringObject.match(searchvalue)stringObject.match(regexp) 参数 描述 searchvalue 必需。规定要检索的字符串值。 regexp 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 例子：在下面正则表达式完整例子中使用。 exec()方法 exec() 方法用于使用正则表达式，检索字符串中的正则表达式的匹配。 语法：RegExpObject.exec(要检索的字符串) 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 与match()类似，他们都是返回匹配结果的数组，但match()是字符串的正则方法（是使用字符串对象进行调用），exec()是正则对象的方法（使用RegExp对象进行调用）。 例子：在下面y粘连修饰符的例子*中使用。 test()方法 test()方法用于检测一个字符串是否匹配某个模式. 返回值：布尔型。如果字符串中有匹配的值返回 true ，否则返回 false。 注意：和match()类似，不过他返回的是布尔值而不是匹配值构成的数组。 语法：RegExp对象.test(要检测的字符串) 例子：在下面u修饰符的例子中使用。 正则表达式完整例子123456789101112131415//^表示开头，g表示全局匹配。即：开头为\"你\"的字符串就满足这个正则表达式const regexp1 = /^你/g;console.log(\"你好呀你好呀你好呀\".match(regexp1));//[\"你\"]const regexp2 = new RegExp(\"^你好\", \"g\");//不要漏掉g的引号console.log(\"你好呀你好呀你好呀\".match(regexp2));//[\"你好\"]const regexp3 = new RegExp(/^我/g);console.log(\"你好呀你好呀你好呀\".match(regexp3));//null，不符合规则const regexp4 = /你/g;//去掉^console.log(\"你好呀你好呀你好呀\".match(regexp4));//[\"你\", \"你\", \"你\"]const regexp5 = /你/;//去掉g,不再全局搜索console.log(\"你好呀你好呀你好呀\".match(regexp5));//[\"你\"] 正则表达式构造函数RegExp的变化不管有多少个“原来的修饰符”，都会被“新增的修饰符”覆盖，注意：新增的修饰符需要引号 1const regexp = new RegExp(/规则/原来的修饰符,\"新增的修饰符\"); 例子： 1const regexp = new RegExp(/^你/igm,\"i\");//最后生效的是i 定位符 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 元字符 [a-z]字符范围。匹配指定范围内的任意一个字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 \\d匹配一个数字字符。等价于 [0-9]。 x|y匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz]字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 \\w匹配字母、数字或者下划线,等价于[A-Za-z0-9_] /g全局匹配 特殊字符 \\将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n匹配字符 n。\\n匹配换行符。序列 \\\\匹配 \\，而 \\(则匹配 (。 限定符 +匹配前面一个表达式 1 次或者多次,要匹配 + 字符，请使用 \\+。 *匹配前一个表达式 0 次或多次，要匹配 * 字符，请使用 \\*。 ？问号代表前面的字符最多只可以出现一次（0次或1次）【例子：colou?r 可以匹配 color 或者 colour】或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 {n}n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,}n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+。’o{0,}’ 则等价于 o*。 {n,m}m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 o?。请注意在逗号和两个数之间不能有空格。 关于+和*可以看下面“match相关题目1”理解其用法。 运算符优先级相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 身份证相关题目15位身份证（第一代）15位号码各位的含义 1-2位省、自治区、直辖市代码； 3-4位地级市、盟、自治州代码； 5-6位县、县级市、区代码； 7-12位出生年月日,比如670401代表1967年4月1日（这是与18位的第一个区别）； 13-15位为顺序号，其中15位男为单数，女为双数； 举例介绍130503 670401 001的含义: 13为河北，05为邢台，03为桥西区，出生日期为1967年4月1日，顺序号为001。 正则表达式 18位身份证（第二代）要注意最后一位！ match相关题目1正则方法match()可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，返回指定的值(数组)。(更多相关知识可查阅“ES6扩展 正则扩展”中的“match() 方法”)因为+和*都是贪婪匹配，它们会尽可能多地匹配字符，所以\\d+匹配”75”，\\w*匹配”team2017”，而/g就没有表演的机会了。最后选C。关于&amp;quot:属于html中的特殊字符的转义，选项中为双引号。 match相关题目2需要明确： 关于//的含义请到笔记顶部看“JS中生成RegExp对象的两种方法”的“方法1” 正则表达式里： 出现0次或多次. [0,+∞] 出现1次或多次 [1,+∞] g是全局匹配 /b+/ 也就是b出现1次或多次，/b*/ 是b出现0次或多次，/b{1,4}/ 是b至少出现1次，至多出现4次，/b{1,5}/ 是b至少出现1次，至多出现5次。 匹配整数的题目A正负整数，B正整数，C负整数，D正整数或者0 需要知道的？问号代表前面的字符最多只可以出现一次 匹配前面的子表达式零次或多次[a-z]字符范围。匹配指定范围内的任意一个字符.\\d 匹配一个数字字符。等价于 [0-9]。 各选项解析A.(-?[1-9]\\d*)|0 -号出现0次或1次，然后匹配一个1-9之间的数字字符0次或多次。或者匹配0。即 整数或者0。B.[1-9]\\d* 匹配一个1-9之间的数字字符0次或多次，即 正整数。C.-[1-9]\\d* 匹配一个-（1-9）之间的数字字符0次或多次，即 负整数。D.[1-9]\\d*|0 匹配一个1-9之间的数字字符0次或多次，或者匹配0，即 正整数或者0。 更多可参考廖雪峰的相关解释 正则表达式 - 元字符 参考 正则表达式 - 语法参考","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"nodejs介绍","slug":"nodejs介绍","date":"2019-12-31T13:10:44.000Z","updated":"2020-01-22T05:07:27.160Z","comments":true,"path":"2019/12/31/nodejs介绍/","link":"","permalink":"http://yoursite.com/2019/12/31/nodejs介绍/","excerpt":"ES，js和nodejs区别 ES是语法规范，没有api只靠它自己什么也做不了（ES文档看阮一峰的书） js是ES+web API,可以完成浏览器端操作 nodejs是ES+node API，可以完成server端操作nodejs的API文档 在nodejs中尽量使用ES6的语法。","text":"ES，js和nodejs区别 ES是语法规范，没有api只靠它自己什么也做不了（ES文档看阮一峰的书） js是ES+web API,可以完成浏览器端操作 nodejs是ES+node API，可以完成server端操作nodejs的API文档 在nodejs中尽量使用ES6的语法。 commonjs模块化规范使用模块化的好处：可以对代码进行拆分，将功能相似的代码放在一起，在不同的地方都可以进行直接调用。（类似react.js中的组件） 步骤： 在vscode中打开工作文件夹，在vscode终端输入npm init -y用于初始化npm环境 再输入npm i lodash --save用于安装lodash库（其中，lodash是node中常用的数据库） 在根目录中会出现package.json文件，文件内有：（其中，lodash就是依赖的名字） 123\"dependencies\": &#123; \"lodash\": \"^4.17.15\" &#125; 在js文件中引用const _=require(&#39;lodash&#39;)(其中，lodash为package.json里面的依赖名字) 一般使用_代替lodash，所以在需要这个库的js文件顶部调用const _ = require(&#39;lodash&#39;)即可 想要使用该工具库的方法时只需调用_.方法名即可，比如： 12const arr = _.concat([1,2],3)console.log('arr1',arr)//arr1[1,2,3] 注意：可以直接使用require调用node自带的库，不需要另外安装或编写代码、输出，比如const http = require(&#39;http&#39;) debugge推荐使用vscode这个IDE作为debug的工具。 新建一个目录，然后在该目录下在vscode终端输入npm init -y用于初始化npm环境 在该目录下会出现一个package.json文件，该文件内有&quot;main&quot;:&quot;index.js&quot;,也就说明主页面是index.js，那么你需要保证你的目录下有这个文件，或者可以修改页面名称。 在vscode中目录左侧有个虫子图标就是用来debug的，注意点击图标以后出现在目录上方位置的绿色箭头代表“开始debug” 注意打断点，可以通过点击来删除断点，删除后可以点击红色方框停止debug。 server端和前端的区别服务稳定性server端可能会遭受各种恶意攻击和误操作，单个客户端（前端）可以意外挂掉，但是服务端不能。 CPU和内存的优化、扩展前端（客户端）独占一个浏览器，内存和CPU都不是问题，但server端要承载很多请求，CPU和内存都是稀缺资源。 优化：使用stream写日志扩展：使用redis存session（后面会详细讲解） 日志记录前端也会参与写日志，但只是日志的发起方，不关心后续。而server端要记录日志、存储日志、分析日志，前端不关心 安全server端要随时准备接收各种恶意攻击，前端则少很多。如：越权操作（比如用户想删除别的用户的博客），数据库攻击等。后面会讲解登录验证，预防XSS攻击和sql注入（XSS攻击前端也有一部分责任） 集群和服务拆分产品发展速度快，流量可能会迅速增加。server端需要考虑如何通过扩展机器和服务拆分来承载大流量。 module.exports 与 exports强烈建议使用module.exports = xxx的方式来输出模块变量，它可以应对任何情况。具体原因可以参考廖雪峰的博客","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Number类及其方法","slug":"JS_Number","date":"2019-12-15T12:37:00.000Z","updated":"2019-12-16T07:24:11.961Z","comments":true,"path":"2019/12/15/JS_Number/","link":"","permalink":"http://yoursite.com/2019/12/15/JS_Number/","excerpt":"Number Number ：表示整数和浮点数 NaN ：即非数值（ Not a Number ）是一个特殊的数值","text":"Number Number ：表示整数和浮点数 NaN ：即非数值（ Not a Number ）是一个特殊的数值 面试常考！说明： 任何涉及NaN的操作（例如NaN/10 ）都会返回NaN。 NaN与任何值都==不相等==，包括NaN本身。 如果typeof一个NaN，你会在F12中看到number，因为==NaN是特殊的number== toFixed() 方法指定小数位数 toFixed()方法可把 Number类对象的值 四舍五入为指定小数位数的数字（注意是字符串形式的数字）。(通过参数规定小数的位数) 语法：NumberObject.toFixed(num) 参数num:必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。 返回值：返回 NumberObject 的字符串表示，不采用指数计数法，小数点后有固定的 num 位数字。如果必要，该数字会被舍入，也可以用 0 补足，以便它达到指定的长度。如果 num 大于 le+21，则该方法只调用 NumberObject.toString()，返回采用指数计数法表示的字符串。 抛出异常：当 num 太小或太大时抛出异常 RangeError。0 ~ 20 之间的值不会引发该异常。有些实现支持更大范围或更小范围内的值。当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toPrecision() 方法指定数字总长度 toPrecision() 方法可在Number对象的值超出参数指定的位数时将其有效长度转换为指数计数法（科学记数法）。（把Number对象的值格式化为参数指定的长度，注意是总位数不是小数位数） 语法：NumberObject.toPrecision(num) 参数num：必需。规定必须被转换为指数计数法的最小位数。该参数是 1 ~ 21 之间（且包括 1 和 21）的值。有效实现允许有选择地支持更大或更小的 num。如果省略了该参数，则调用方法 toString()，而不是把数字转换成十进制的值。 返回值： 返回 NumberObject 的字符串表示，包含 num 个有效数字。 参数 num &gt;= NumberObject 整数部分的所有数字时返回的字符串将采用定点计数法。 否则，采用指数计数法（科学记数法），即小数点前有一位数字，小数点后有 num-1 位数字。必要时，该数字会被舍入或用 0 补足。 抛出异常：当 num 太小或太大时抛出异常 RangeError。1 ~ 21 之间的值不会引发该异常。有些实现支持更大范围或更小范围内的值。当调用该方法的对象不是 Number 时抛出 TypeError 异常。 参数规定的有效数字的位数是从数字第一个不为0的数(包括整数部分和小数部分)开始计算的位数。 在指数记数法（科学记数法）中，E是指数的意思，在java中e代表10的幂次,5.62e+5 = 5.62*10^5; 同样的,5.62e-5 = 5.62*10^(-5) 例子： 12345678910111213141516171819202122232425//toPrecision()会进行四舍五入var num = 423.536;// 调用的是toString()方法document.writeln( num.toPrecision() ); // 423.536num = 562345.12456;// 由于整数部分有6位，要求只有3位有效数字，必须采用指数计数法才能表示。document.writeln( num.toPrecision( 3 ) ); // 5.62e+5num = -2651.10;// 整数部分有4位，要求的有效数字为4位，采用定点表示法document.writeln( num.toPrecision( 4 ) ); // -2651num = 4564561.12457;// 整数部分有7位，要求有效数字为1位，采用指数计数法document.writeln( num.toPrecision( 1 ) ); // 5e+6num = 231;// 整数部分有3位，要求有效数字为5位，采用定点表示法，并在小数部分填充两个0document.writeln( num.toPrecision( 5 ) ); // 231.00num = 0.8;// 整数部分有1位，要求有效数字为1位，采用定点表示法document.writeln( num.toPrecision( 1 ) ); // 0.8 区别toFixed() 方法和toPrecision() 方法 两者都是返回字符串形式的数字。 toFixed() 方法没有触发要求，参数直接规定小数位数，不采用科学记数法。（0 &lt;= 参数 &lt;= 20） toPrecision() 方法由参数规定整个数字的总位数。（1 &lt;= 参数 &lt;= 21）当 参数 &gt;= Number对象的值的整数位数 时采用定点记数法（也就是小数点）（比如：参数为1时，0.8 = 0.8）。否则采用科学记数法（比如：参数为3时，562345.12456 = 5.62*10^5 = 5.62e+5）","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"React.js基础精讲(1)","slug":"React.js基础精讲（1）","date":"2019-11-26T13:25:34.000Z","updated":"2020-01-29T07:48:19.334Z","comments":true,"path":"2019/11/26/React.js基础精讲（1）/","link":"","permalink":"http://yoursite.com/2019/11/26/React.js基础精讲（1）/","excerpt":"使用React编写TodoList功能 在index.js文件中引入TodoList.js文件TodoList组件时使用的import App from &#39;./TodoList&#39;;其实省略了.js，这是因为你不写.js的话脚手架工具会自动到目录下去找js后缀的文件（但是你在根目录下创建TodoList.js时不要忘记后缀！）","text":"使用React编写TodoList功能 在index.js文件中引入TodoList.js文件TodoList组件时使用的import App from &#39;./TodoList&#39;;其实省略了.js，这是因为你不写.js的话脚手架工具会自动到目录下去找js后缀的文件（但是你在根目录下创建TodoList.js时不要忘记后缀！） 在TodoList.js中 1.先引入React才能使用JSX语法，引入{ Component }才能使我们自定义的组件继承Component： 1import React, &#123; Component &#125; from 'react';/* 快捷键imrc */ 2.自定义的组件一定要继承Component，通过render函数返回组件显示的内容，将组件返回的内容写在return（）内（注意是小括号！）： 1234567class TodoList extends Component&#123; render()&#123; return( ) &#125;&#125; 3.在最后必须使用export default TodoList;导出组件（不导出的话组件在外部是无法引用的） 1export default TodoList; 4.对于render函数来说，4个空格一个缩进太大了，我们可以将它修改为2个空格一个缩进。（修改方法如下） 修改缩进长度 5.不要忘记在render函数的return（）括号中写类似html代码时，只允许存在1个最外层标签，否则报错。（也就是说所有标签都必须包含在1个父元素下）但很多时候我们并不希望他们有父元素，此时可以使用React16提供的占位符Fragment代替父元素标签。记得先引入Fragment: 1import React, &#123; Component,Fragment &#125; from 'react'; 然后可以使用&lt;Fragment&gt;代替&lt;div&gt;作为父元素使用，当你在页面F12时可以发现子元素全部都直接挂靠在了我们指定的index.html的root节点上： 1234567891011121314151617181920import React, &#123; Component,Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &lt;input/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;学习&lt;/li&gt; &lt;li&gt;做题&lt;/li&gt; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125;&#125;export default TodoList; 想要实现输入框中输入的内容被提交以后显示在下方列表中则需要下面讲到的“React中的响应式设计思想和事件绑定”。 React中的响应式设计思想和事件绑定 react在英语中就是“响应、做出反应”的意思，也就是说代码中的数据发生变化时会直接反应在页面上。（也就是说当数据被修改时会被直接反应在页面上）所以在写react时我们不是去改变DOM，而是去修改数据，数据被修改以后会自己反应在DOM上。也就是说我们不需要去关注DOM方面的操作，只需要考虑数据层的操作即可。 实现功能在输入框中键入时页面输入框可同步变化数据内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; constructor(props) &#123;/* 构造函数constructor带有参数props */ super(props);/* 继承父类Component的props */ this.state = &#123;/* 所有的数据都需要保存在状态里（即this.state） */ /* inputValue用于存放输入框内容 */ inputValue: \"\", /* list列表用于存放输入框下方数据 */ list: [] &#125; &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* 注意如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的 */&#125; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;学习&lt;/li&gt; &lt;li&gt;做题&lt;/li&gt; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(e) &#123;/* 传入一个事件对象e */ /* target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue */ // console.log(e.target.value); /* 尝试将e.target.value赋给inputValue，但发现this指向有问题 */ // this.state.inputValue = e.target.value;//报错，显示state未定义，那么就是this指向有问题 // console.log(this);//打印出的是undefined，说明handleInputChange函数内的this并未指向TodoList组件，我们需要使用bind(this)将函数内的this指向TodoList组件以便调用存放在它的状态中的inputValue // this.state.inputValue = e.target.value;//转换this指向以后还是报错，是因为react中改变状态中的数据需要调用组件的setState方法 this.setState(&#123; inputValue:e.target.value &#125;) &#125;&#125;export default TodoList; 代码分析 constructor(props){}函数是构造函数，在js里每个类都会有一个自带的构造函数（注意带一个参数props），当我们使用这个组件时，它会在render函数之前执行。构造函数内必须有super(props); 去继承父类component的props，构造函数内所有定义的数据都需要挂靠在当前对象的状态下，也就是写在this. state={}里面。当状态中的数据发生变化时他的变化会直接反应在页面上。（所以你希望页面数据变化时可以直接修改存在状态内的数据） 为了能在输入框中输入数据后显示在输入框下方，我们需要在构造函数中定义两个数据：inputValue用于存储输入框的值，list设为数组，用于存储显示在下方的列表。（注意：数据是存储在this. state={}里的） 注意：render函数中写的是JSX语法，constructor(props){}中写的是js代码，如果想在JSX中插入js的变量或者表达式则需要使用{}将其框起。（如render函数中&lt;input value={this.state.inputValue} /&gt;） 通过&lt;input value={this.state.inputValue} /&gt;我们将状态中的inputValue赋给了输入框，此时输入框具有默认值，但如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的。 此时我们需要给输入框绑定事件onChange，使输入框内容发生变化时触动函数handleInputChange，通过函数handleInputChange将我们输入的值存储到状态中的inputValue上从而使页面发生变化。(注意：绑定事件处理函数的调用没有括号（onChange={this.handleInputChange}），有括号就直接调用该处理函数了，没有括号则是指向处理函数地址，只有触动该事件时才调用函数) 在绑定事件处理函数handleInputChange中，传入一个参数也就是事件对象e(语法上，事件处理函数默认只传递一个参数，也就是事件对象) ，target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，我们需要将状态中的inputValue修改为input节点的value值，从而使得输入以后页面输入框内容有所变化。 尝试将e.target.value赋给inputValue:this.state.inputValue = e.target.value;报错，显示state未定义，说明this指向有问题，打印出this发现是undefined，说明handleInputChange函数内的this并未指向TodoList组件，我们需要使用bind(this)将函数内的this指向TodoList组件以便调用存放在它的状态中的inputValue。（注意：在这里建议在构造函数中绑定bind（），比较节省性能，可以参考“bind（）”笔记） 转换this指向以后还是报错，是因为react中改变状态中的数据需要调用组件的setState方法：123this.setState(&#123; inputValue:e.target.value&#125;) 思路也就是说，每次点击输入框就会触发绑定的事件函数handleInputChange，在该函数内我们通过setState（）将该事件函数对应的事件对象e的target对象（也就是input节点）的value值赋给state内的inputValue，而我们的input的value正是state内的inputValue，所以一旦触发事件函数handleInputChange我们输入的值就会传入state中从而在页面上出现改变。 总结 在js里每个类（组件）都会有一个自带的构造函数constructor(props){}，（注意带一个参数props），当我们使用这个组件时，它会在render函数之前执行。构造函数内必须有super(props); 去继承父类component的props，构造函数内所有定义的数据都需要挂靠在当前对象的状态下，也就是写在this. state={}里面。 render函数中写的是JSX语法，constructor(props){}中写的是js代码，如果想在JSX中插入js的变量或者表达式则需要使用{}将其框起。（如render函数中&lt;input value={this.state.inputValue} /&gt;） 原生js中内容变化时的事件绑定是onchange，而react中是onChange。在react中事件绑定时驼峰形式的！（如onClick,onChange等） 事件绑定时要使用bind(this)进行函数作用域变更使函数中的this指向使其指向事件对象（即组件）才能调用组件的构造函数中的数据，否则函数中的this指向undefined。（注意：在这里建议在构造函数中绑定bind（），比较节省性能，可以参考“bind（）”笔记） 修改this. state中的数据需要通过setState方法：想要改变this. state里面的数据直接引用this. state进行赋值是不行的，要使用this. setState({state中需要修改的属性:修改以后的属性值;})（其实就是将需要修改的属性通过对象的方式传入setState函数） 实现 TodoList 新增及删除功能新增功能在这之前我们实现的功能是：在输入框中输入文字时我们输入的内容可以同步显示在页面上（是的，虽然这个功能看起来完全不需要我们去实现）现在要完成的功能是：点击“提交”按钮之后，输入的内容会显示在下方的列表之中并清空输入框内容。 思路注意，我们不关心DOM层面上的操作，我们只要让state中的数据发生变化页面就会发生变化，也就是只要点击按钮后将inputValue的值放到list数组中并清空inputValue即可。 点击“提交”按钮之后触发onClick事件绑定函数handleBtnClick，在函数中通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list，然后清空输入框中的值。（到这我们虽然把输入框的值放入数组中，但数组并未设置在页面中显示） 我们需要通过数组的map方法将原本页面写死的ul列表改成数组list中遍历读出的内容，注意给数组中的每一项一个唯一的key属性值作为标识符。 注意：JSX语法中写js表达式和js变量都需要{}括起来，表达式中的变量也需要再用{}括起来！！ 补充：JavaScript Array map()遍历数组并进行操作ES5中提供的JavaScript Array map() 方法可以遍历数组列表并按顺序对数组中的每一项执行回调函数。 react中遍历数组时需要加key值在react中循环渲染（遍历数组）时需要给每一项增加一个唯一的key值作为标识符，否则虽不会报错但是会在控制台显示“Warning”：在这里我们暂时使用数组下标index作为key值，实际编程中这样的习惯是很不好的，但具体原因留到后面再写： 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; constructor(props) &#123;/* 构造函数constructor带有参数props */ super(props);/* 继承父类Component的props */ this.state = &#123;/* 所有的数据都需要保存在状态里（即this.state） */ /* inputValue用于存放输入框内容 */ inputValue: \"\", /* list列表用于存放输入框下方数据 */ list: [] &#125; &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* 注意如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的 */&#125; &#123;/* 事件绑定函数handleInputChange被调用后，handleInputChange函数内的this指向会丢失（即undefined），需要使用bind()绑定handleInputChange的this指向使其指向TodoList组件的this以便在handleInputChange函数中可以获取TodoList组件的inputValue */&#125; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; /* 传入一个参数事件对象e(语法上，事件处理函数默认只传递一个参数，也就是事件对象) */ handleInputChange(e) &#123; /* target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue，react中改变状态中的数据需要调用组件的setState方法 */ this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState(&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...this.state.list, this.state.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;) &#125;&#125;export default TodoList; 删除功能实现功能：点击列表中的某一项时该项被删除。 复习：splice()删除数组部分的元素splice()可用于删除、插入、替换数组中部分元素，无论如何返回值都是从原数组中删除的元素组成的数组。 复习删除用法注意：删除时，返回的是含有删除部分的元素的数组，原数组会变成被删除以后的数组。 语法:arrayObject.splice(index,count) 功能:删除从index处开始的零个或多个元素. 返回值:含有被删除的元素的数组. 说明:count是要删除的项目数量,如果设置为0,则不会删除项目.如果不设置,则删除从index开始的所有值. 例子：12345678var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];//删除var delArr = arr.splice(5);//从数组下标为5的元素开始，包括5【注意是数组下标】console.log(arr);// [\"a\", \"b\", \"c\", \"d\", \"e\"]console.log(delArr);//[\"f\"]var delArr = arr.splice(2, 2);console.log(arr);// [\"a\", \"b\", \"e\"]console.log(delArr);//[\"c\", \"d\"] 思路 给每个li标签绑定一个 onClick 事件函数 handleItemDelete ，通过 bind 绑定 this 指向组件 TodoList 的同时将数组下标 index 通过第二个参数传到 handleItemDelete 中，以便我们在 handleItemDelete函数 中获取到数组下标。 （注意：在这里建议在构造函数中绑定bind（），比较节省性能，可以参考“bind（）”笔记） 123456&lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt; &#123;item&#125;&lt;/li&gt; 使用扩展运算符拷贝 state 中的 list 到 变量list1 中，对 变量list 使用 splice方法 删除选中数组下标为 index 的数组元素，再使用 setState方法 将删除被点击元素后的 变量list1 赋给 state 中的list。12345678handleItemDelete(index) &#123; const list1 = [...this.state.list] list1.splice(index, 1); this.setState(&#123; list: list1 &#125;)&#125; 注意：必须将state中的值拷贝出来再对拷贝出来的变量进行修改，不能直接修改state中的值，否则后期性能优化会很麻烦。（immutable：state 不允许我们做任何的改变） 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; constructor(props) &#123;/* 构造函数constructor带有参数props */ super(props);/* 继承父类Component的props */ this.state = &#123;/* 所有的数据都需要保存在状态里（即this.state） */ /* inputValue用于存放输入框内容 */ inputValue: \"\", /* list列表用于存放输入框下方数据 */ list: [] &#125; &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* 注意如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的 */&#125; &#123;/* 事件绑定函数handleInputChange被调用后，handleInputChange函数内的this指向会丢失（即undefined），需要使用bind()绑定handleInputChange的this指向使其指向TodoList组件的this以便在handleInputChange函数中可以获取TodoList组件的inputValue */&#125; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125; &gt; &#123;item&#125; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; /* 传入一个参数事件对象e(语法上，事件处理函数默认只传递一个参数，也就是事件对象) */ handleInputChange(e) &#123; /* target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue，react中改变状态中的数据需要调用组件的setState方法 */ this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState(&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...this.state.list, this.state.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;) &#125; handleItemDelete(index) &#123; const list1 = [...this.state.list] list1.splice(index, 1); this.setState(&#123; list: list1 &#125;) &#125;&#125;export default TodoList; 总结注意事项 在JSX语法中插入js的变量或者js表达式则需要使用{}将其框起。表达式中的变量也需要再用{}括起来！ 必须将state中的值拷贝出来再对拷贝出来的变量进行修改，不能直接修改state中的值，否则后期性能优化会很麻烦。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React.js初探(2)","slug":"React.js初探（2）","date":"2019-11-25T14:00:00.000Z","updated":"2020-01-31T07:04:35.521Z","comments":true,"path":"2019/11/25/React.js初探（2）/","link":"","permalink":"http://yoursite.com/2019/11/25/React.js初探（2）/","excerpt":"react中的组件 页面是由很多个组件构成的。 只要让自定义的类继承React的Component，那么自定义的类就会成为组件（记得要在最后export default自定义的类）。","text":"react中的组件 页面是由很多个组件构成的。 只要让自定义的类继承React的Component，那么自定义的类就会成为组件（记得要在最后export default自定义的类）。 在需要的js文件中使用import 组建名 from 定义组件的js文件名即可引入组件来使用。 （具体请参考ES6“解构赋值”） import React,{Component} from &quot;react&quot;;等价于： 1234567891011import React,&#123;Component&#125; from \"react\";//等价于import React from \"react\";const Component = React.Component;import &#123;Component&#125; from \"react\";//从ES6看相当于import Component from \"react\".Component;//又因为import React from \"react\";//所以 组件的使用步骤 在src下的App.js文件中定义组件App并在最后使用export default App;导出组件（不导出的话在index.js中是无法引用的） 在src下的index.js文件中通过import 组件名 from 定义组件的js文件名来引入组件并使用ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));将组件App挂载到public文件夹下的index.html内的id为root的DOM节点上。（注意：index.html内并未使用script标签引入index.js） 注意： 在index.js文件中需要引入import React from &#39;react&#39;;，是因为挂载组件时使用的&lt;App /&gt;是JSX语法，如果不import React from &#39;react&#39;;就会编译失败而报错。 在index.js文件中要先import ReactDOM from &#39;react-dom&#39;;才能使用ReactDOM这个第三方的render方法来帮我们将组件挂载到DOM节点上。 在App.js文件中也需要引入React，这是因为render函数中的所有看起来像是html标签的代码其实都是JSX语法。 react里的index.js是怎么跟index.html结合起来的可以注意到，index.html里没有用script标签引入index.js。 也许是create-react-app实现的？ create-react-app 把webpack、babel等配置都封装到了依赖项目react-script中，所以你无法直观的看到这些配置。而index.html与index.js的结合是用html-webpack-plugin这个plugin实现的。 总结：关于不同的引用引入React（涉及JSX语法）使用JSX语法时需要import React from &#39;react&#39;;，否则就会编译失败而报错。比如： App.js文件中render函数中的所有看起来像是html标签的代码实际上是JSX代码。 index.js文件中挂载组件时使用的&lt;App /&gt;是JSX语法。 引入ReactDOM在index.js文件中要先import ReactDOM from &#39;react-dom&#39;;才能使用ReactDOM这个第三方的render方法来帮我们将组件挂载到index.html文件的DOM节点上。 引入{ Component }定义组件时需要继承 React 的 Component ，需要先引入才能继承。此时可以使用ES6的解构赋值简单的引入Component： 1import React, &#123; Component &#125; from 'react'; 相当于： 1import Component from 'react'.Component; 也相当于： 12import React from 'react';const Component = React.Component; React中最基础的JSX语法 我们把html代码直接写在js文件里这就算是JSX语法，之前提到的index.js文件中使用的&lt;App /&gt;也是JSX语法。 JSX语法中，如果我们要使用自己创建的组件（例如App.js中自定义的组件App），必须大写字母开头，通过类似html标签的形式进行调用（比如index.js中将组件挂载在index.html页面的DOM节点上使用的&lt;App /&gt;）。 注意：在render函数的return()括号中写类似html代码时，只允许存在1个最外层标签，否则报错。（也就是说所有标签都必须包含在1个父元素下）","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"hexo deploy到github后404问题","slug":"hexo 404","date":"2019-11-25T11:52:31.000Z","updated":"2019-11-26T09:01:49.051Z","comments":true,"path":"2019/11/25/hexo 404/","link":"","permalink":"http://yoursite.com/2019/11/25/hexo 404/","excerpt":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后成功部署到github上。其他页面正常显示，只有新上传的文章出现404，如下图所示：","text":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后成功部署到github上。其他页面正常显示，只有新上传的文章出现404，如下图所示： 页面中有提示 If this is your site. make sure that the filename case matches the URL For root URLS (like htp:/esample. com ) you must provide an index. html file. 翻译成中文也就是对于根网址（如http://example.com/），您必须提供一个`index.html`文件。 在github我们这个博客项目内可以看到每次deploy都会给我们每篇博客新建一个对应的index.html文件，但是出现404的页面不知道为何并未看到对应的index.html文件。 解决方法将本地中存储的显示404的博客文章对应的markdown文件删除并重新放入再进行deploy，如果还是不行可以适当对文章内容进行修改再deploy（比如加点无关紧要的分隔线之类的）。 我出现了2个页面404，两种方法都能解决，具体是为什么不得而知，如果有知道的小伙伴欢迎留言告诉我一下~","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"React官方脚手架工具的使用","slug":"React官方脚手架工具","date":"2019-11-24T13:28:12.000Z","updated":"2020-01-27T06:36:54.206Z","comments":true,"path":"2019/11/24/React官方脚手架工具/","link":"","permalink":"http://yoursite.com/2019/11/24/React官方脚手架工具/","excerpt":"Create React App 中文文档 创建一个项目在cmd中执行命令行： npx create-react-app 项目名 cd 项目名 npm start或者yarn start 接下来你就可以在http://localhost:3000/中访问到新建项目的index页面","text":"Create React App 中文文档 创建一个项目在cmd中执行命令行： npx create-react-app 项目名 cd 项目名 npm start或者yarn start 接下来你就可以在http://localhost:3000/中访问到新建项目的index页面 例子： 项目存储位置是打开cmd是的路径C:\\Users\\HLZ\\todolist关闭cmd以后还想再运行该项目index页面（在http://localhost:3000/中）时，可以在该项目路径目录下打开cmd窗口输入npm start或者yarn start（“在当前目录下启动cmd窗口的方法”见下文） 在当前目录下启动cmd窗口的两种方法方法1：在当前目录地址栏上清空目录，然后输入cmd回车即可： 方法2：按住键盘shift键，然后鼠标右键，点击 “在此处打开Powershell窗口”（在windows上cmd和powershell都是命令行执行窗口，cmd能做的powershell都能做，甚至能做更多）","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"bind()","slug":"bind()","date":"2019-11-24T13:26:40.000Z","updated":"2020-01-29T06:10:54.002Z","comments":true,"path":"2019/11/24/bind()/","link":"","permalink":"http://yoursite.com/2019/11/24/bind()/","excerpt":"bind()ES5 引入了 Function.prototype.bind。bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。","text":"bind()ES5 引入了 Function.prototype.bind。bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。也就是说，调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数上，无论这个函数是如何被调用的。bind绑定的参数只生效一次。 javascript中apply、call和bind的共同点在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。他们的共同之处： 都是用来改变函数的this对象的指向的。 第一个参数都是this要指向的对象。 都可以利用后续参数传参。 bind（）与apply（）、call（）使用上的区别无参数情况1234567891011121314var xw = &#123; name: \"小王\", gender: \"男\", age: 24, say: function () &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age); &#125;&#125;var xh = &#123; name: \"小红\", gender: \"女\", age: 18&#125;xw.say(); 上面代码显示的是小王 ， 男 ， 今年24。用xw的say方法来显示xh的数据的几种方法: xw.say.call(xh); xw.say.apply(xh); xw.say.bind(xh)();如果直接写xw.say.bind(xh)不会有任何结果,call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。 传参情况12345678910111213var xw = &#123; name : \"小王\", gender : \"男\", age : 24, say : function(school,grade) &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age + \" ,在\" + school + \"上\" + grade); &#125;&#125;var xh = &#123; name : \"小红\", gender : \"女\", age : 18&#125; 可以看到say方法多了两个参数，我们通过4种方法进行传参： xw.say.call(xh,&quot;实验小学&quot;,&quot;六年级&quot;); xw.say.apply(xh,[&quot;实验小学&quot;,&quot;六年级&quot;]); xw.say.bind(xh,&quot;实验小学&quot;,&quot;六年级&quot;)(); xw.say.bind(xh)(&quot;实验小学&quot;,&quot;六年级&quot;);由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。 事件绑定函数与bind(this)在react中，常看到： 123456789101112131415161718export default class App extends Component &#123; constructor(props) &#123;/*构造函数，用于实例化对象*/ super(props); this.foo = this.foo.bind(this); &#125; foo() &#123; // todo something &#125; render() &#123; return ( &lt;View&gt; &lt;Button onPress=&#123;this.foo&#125;/&gt; &lt;/View&gt; ) &#125;&#125; 事件绑定处理函数（onPress={this.foo}）时，foo方法内部的this的指向就会丢失(此时在foo函数内部打印this得到的是undefined)。这就会出现外部的foo方法内部的this会丢失指向。为了解决这个问题，我们需要在实例化对象的时候就需要在构造函数中绑定this（this.foo = this.foo.bind(this);），使得无论事件处理函数如何传递，它的this的指向都是固定的，固定指向我们所实例化的对象（App组件）。（虽然在render函数中&lt;Button onPress={this.foo.bind(this)}/&gt;效果一样，但比较消耗性能，不推荐。） （具体应用可参考笔记“React.js基础精讲(1)”中的“React中的响应式设计思想和事件绑定”）","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"React.js初探","slug":"React.js初探（1）","date":"2019-11-24T13:00:00.000Z","updated":"2020-01-27T08:02:00.019Z","comments":true,"path":"2019/11/24/React.js初探（1）/","link":"","permalink":"http://yoursite.com/2019/11/24/React.js初探（1）/","excerpt":"React简介react.js文档中文文档较为滞后，建议阅读英文文档。","text":"React简介react.js文档中文文档较为滞后，建议阅读英文文档。 与vue.js对比 vue.js使用的api更多所以更简单，但正是因为react.js使用的api少，所以他的灵活度更大，更适合用于一些复杂度高的项目。 一些面向用户端，复杂度不高的项目使用vue.js会更加简单。 React开发环境准备脚手架工具 常见的脚手架工具有：webpack、grunt，还有我们接下来使用的react.js官方提供的Create-react-app。 我们可以使用脚手架工具去更加简单的编写代码，但是编写的代码不能直接运行，需要通过脚手架工具进行编译以后才能运行。 工程目录文件简介总结：重要的就是：public下的index.html文件，负责页面上显示的html内容。src下的index.js文件,整个react项目的入口，他会引入一个APP.js文件的APP组件，该组件负责显示出页面上的组件内容。 重启项目具体可参考笔记“React官方脚手架工具的使用”。 根目录下yarn.lock文件放置一些依赖配置，一般不要动。 README.md文件关于项目的说明，可以删掉再使用markdown语法进行书写。 package.json文件是一个node的包文件，他可以让项目变成一个node的包。** 一般不会去动，是脚手架自动生成的文件。**主要是node里面的内容，包含了：项目名字，版本，依赖的包、可供调用的指令。 我们之所以可以在cmd中通过npm start来启动项目，实际上就是通过npm start启动了下图中红框框出的指令，它会帮我们通过react-scripts去启动服务器： .gitignore文件使用git管理代码时，如果有文件不想上传就可以放在这。 todolist文件夹下node_ modules文件夹放一些这个项目依赖的第三方包，不要动他。 public文件夹下favicon.ico index.html文件项目首页的HTML模板，将注释删掉后会简洁很多，&lt;title&gt;标签决定：&lt;noscript&gt;标签是在网页禁掉script的情况下，用来提示用户应该在浏览器上开启script的适配项或者说允许网页去解析JavaScript。这是一段容错的代码。 manifest.json文件在下面的index.js文件中我们提到使用registerServiceWorker可以在没有网络时网页也可以当做app来使用。我们可以将这个网页在桌面上建一个快捷方式，manifest.json文件正是定义这个app的名字、图标、网址跳转到哪儿、主题颜色等的地方。（不使用manifest.json时该文件可删除，同时index.html中的manifest引用代码也可删除。） src文件夹下放置项目所有的源代码，所有代码的入口在index.js文件里。 index.js文件可以注意到import ./index.css,这是因为react讲究 all in js ，所以css和js也就不分离了。 文件中有一个registerServiceWorker，它主要用于帮助我们借助网页去写手机APP应用，使用了它即使断网了，二次访问时也能加载出页面。那么没有网络时该网页也可以当做app使用。因为registerServiceWorker会帮助你将页面存储在我们的浏览器内。（后来新建的项目是如下代码，可查一下是否同一个意思： 12import * as serviceWorker from './serviceWorker';serviceWorker.unregister(); 如不需使用可删除代码后同样可以删去src下的serviceWorker.js） import App from &#39;./App&#39;;以及ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));则是在index页面上引入并渲染以显示App组件。 App.js文件App.js就是定义App组件的地方。 12345678910111213import React, &#123; Component &#125; from 'react';class App extends Component &#123; render()&#123; return ( &lt;div&gt; hello world &lt;/div&gt; ); &#125;&#125;export default App; App.test.js文件自动化测试文件，还不涉及自动化测试时为使项目简洁可删去该文件。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS 居中）","slug":"百度前端技术学院 第七天学习笔记（CSS居中）","date":"2019-11-22T13:28:12.000Z","updated":"2019-11-25T08:48:08.445Z","comments":true,"path":"2019/11/22/百度前端技术学院 第七天学习笔记（CSS居中）/","link":"","permalink":"http://yoursite.com/2019/11/22/百度前端技术学院 第七天学习笔记（CSS居中）/","excerpt":"水平居中补充：img是行内元素，为什么可以设置框高？（面试题）（题目来自魅族一面）问题：既然img是行内元素，那为什么可以通过CSS设置框高呢？答案：尽管img是行内元素，但同时它也是置换元素，置换元素一般内置框高属性，因此可以设置其框高。","text":"水平居中补充：img是行内元素，为什么可以设置框高？（面试题）（题目来自魅族一面）问题：既然img是行内元素，那为什么可以通过CSS设置框高呢？答案：尽管img是行内元素，但同时它也是置换元素，置换元素一般内置框高属性，因此可以设置其框高。 引申问题：那么什么又是“置换元素”呢？答案：置换元素就是会根据标签属性来显示的元素。反之就是非置换元素了。比如img根据src属性来显示，input根据value属性来显示，因此可知道img和input是置换元素，当然同理select也是置换元素。 行内元素（图片）的水平居中 注意：text-align属性虽然规定元素中的文本的水平对齐方式，但他是作用于没有给定宽度的块级元素的（p/h1等等）。 如果被设置元素为文本、图片等行内元素时，则需要在父元素中设置text-align:center实现行内元素水平居中（必要时可以将子元素的display设置为inline-block，使子元素变成行内元素的同时可设置样式）。 补充：图片等比缩小可借助max-width和max-height 123456789101112.dad &#123; text-align: center;&#125;img &#123; width: auto; height: auto; max-width: 200px; max-height: 200px;&#125;p&#123; text-align: center;&#125; 1234567&lt;div class=\"dad\"&gt; &lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt;&lt;div class=\"dad\"&gt; &lt;span&gt;上校&lt;/span&gt;&lt;/div&gt;&lt;p&gt;喵呜&lt;/p&gt; （定宽）块级元素的水平居中 当被设置元素为定宽块级元素时用 text-align：center 就不起作用了，可以通过设置“左右margin”值为“auto”来实现居中。123456.dad &#123; text-align: center;&#125;.hi &#123; width: 200px;&#125; 123456&lt;div class=\"dad\"&gt;&lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt;&lt;div class=\"dad\"&gt;&lt;div class=\"hi\"&gt;你好呀&lt;/div&gt;&lt;/div&gt; 给.hi添加margin: 0 auto;后： （不定宽）块级元素的水平居中 在实际工作中我们会遇到需要为“不定宽度的块级元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。 可以直接给不定宽的块级元素设置text-align：center来实现水平居中，*也可以给父元素加text-align:center *来实现居中效果。 当不想不定宽块级元素的宽度占一行时，可以设置display 为 inline 类型(行内元素 )或inline-block（行内块元素）。12345678910111213.container &#123;text-align: center;background: beige&#125;.container ul &#123;list-style: none;margin: 0;padding: 0;&#125;.container li &#123;margin-right: 8px;display: inline-block;&#125; 1234567&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 垂直居中首先需要设定两个条件：父元素是盒子容器且高度已经设定。 行内元素垂直居中行内元素高度是由其内容撑开的。这种情况下，需要给他一个固定高度的父元素盒子，通过设定父元素的line-height为行内元素设定高度，通过将父元素的line-height属性值设置与父容器高度相同即可使得子元素实现垂直居中。 12345678.dad &#123; height: 200px; line-height: 200px; border: 1px solid red;&#125;span&#123; background: gray;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校&lt;/span&gt;&lt;/div&gt; 或者子元素是没有给定高度的块级元素时也可以通过相同方法设置块级元素文字垂直居中，相同样式表下：123&lt;div class=\"dad\"&gt;&lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 补充：vertical-align 属性设置（单行）元素的垂直对齐方式 vertical-align 属性设置元素的垂直对齐方式。middle ：把此元素放置在父元素的中部。属性参考（注意：vertical-align不作用于span元素，原因如下） 实际上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。一个 span定义了一个60px的高度，但是这个span的Box中存在很多行，那段文本并不能对齐到span的中央。因此希望那段文本对齐span的中行需要给它定义一个line-height的属性，让line-height为60px，作用于一行的vertical-align就按你的想法工作了。table的单元格，因为是一行内的元素，因此vertical-align按照我们的想法来工作，但是在span中并不是这样的。 补充:display:table-cell;表格单元格设置display:table-cell;会使此元素会作为一个表格单元格显示（类似 &lt;td&gt;和 &lt;th&gt;）。 没有定高的块级元素垂直居中 子元素是块级元素但是子元素高度没有设定，在这种情况下实际上是不知道子元素的高度的，无法通过计算得到padding或margin来调整，但是还是存在一些解法。 方法1（单元格vertical-align）：通过给父元素设定display:table-cell;vertical-align:middle;来实现没有定高的块级子元素垂直居中。 12345678910.dad &#123; height: 200px; display: table-cell; vertical-align: middle; border: 1px solid red;&#125;p &#123; background: gray; margin: 0;&#125; 123&lt;div class=\"dad\"&gt; &lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 方法2（flexbox）：给父元素使用display: flex;将其设置为弹性盒子父容器，然后设置align-items: center;定义子项在交叉轴上的对齐方式： 12345678910.dad &#123; height: 200px; border: 1px solid red; display: flex; align-items: center;&#125;p &#123; background: gray; margin: 0;&#125; 123&lt;div class=\"dad\"&gt; &lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 定高的块级元素垂直居中此时可以计算子元素的margin-top或margin-bottom，将其设置为(父元素高度-子元素高度)/2 12345678910.dad &#123; height: 200px; border: 1px solid red;&#125;p &#123; background: gray; margin: 0; height: 40px; margin-top: 80px;&#125; 123&lt;div class=\"dad\"&gt; &lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 水平+垂直居中单行文本水平垂直居中text-align+ line-height实现块内单行文本水平垂直居中: 123456div &#123; text-align: center; line-height: 100px; background: gray; width: 200px;&#125; 1&lt;div&gt;上校,喵&lt;/div&gt; 注意：行内元素要实现居中就要去给他的父元素设置，垂直居中就通过父元素line-height给子元素一个高度，再通过父元素设置text-align:center实现行内元素水平居中： 123456789span &#123; background: gray; width: 200px;&#125;.dad &#123; text-align: center; line-height: 100px; border: 1px solid red;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校,喵&lt;/span&gt;&lt;/div&gt; text-align + vertical-align实现双向垂直上面有说到vertical-align是只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。而table的单元格是一行内的元素，因此vertical-align生效。注意:子元素需要设置为inline-block，父元素需要设置高度。 123456789101112span &#123; background: gray; width: 200px; display: inline-block;&#125;.dad &#123; display: table-cell; text-align: center;/* 行内元素给父元素设置text-align可水平居中 */ height: 200px; vertical-align: middle; border: 1px solid red;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校,喵&lt;/span&gt;&lt;/div&gt; 若子元素是图像，可不使用table-cell，而是其父元素用行高替代高度，且字体大小设为0。子元素本身设置vertical-align:middle： 12345678910111213.dad &#123; text-align: center;/* 行内元素给父元素设置text-align可水平居中 */ line-height: 200px; font-size: 0; border: 1px solid red;&#125;img &#123; vertical-align: middle; width: auto; height: auto; max-width: 200px; max-height: 200px;;&#125; 123&lt;div class=\"dad\"&gt; &lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt; 相对+绝对定位使用absolute，利用绝对定位元素的盒模型特性，在偏移属性为确定值的基础上，设置margin:auto 1234567891011121314151617span &#123; background: gray; position: absolute; top: 0; left: 0; right: 0; bottom: 0; height: 100px; width: 100px; margin: auto;&#125;.dad &#123; position: relative; border: 1px solid red; width: 200px; height: 200px;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校,喵&lt;/span&gt;&lt;/div&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS 布局）","slug":"百度前端技术学院 第七天学习笔记（CSS布局）","date":"2019-11-20T13:28:13.000Z","updated":"2019-11-25T08:54:01.858Z","comments":true,"path":"2019/11/20/百度前端技术学院 第七天学习笔记（CSS布局）/","link":"","permalink":"http://yoursite.com/2019/11/20/百度前端技术学院 第七天学习笔记（CSS布局）/","excerpt":"display属性 display 是CSS中最重要的用于控制布局的属性。 每个元素都有一个默认的 display 值，这与元素的类型有关。 列举一些已经学过的属性值：","text":"display属性 display 是CSS中最重要的用于控制布局的属性。 每个元素都有一个默认的 display 值，这与元素的类型有关。 列举一些已经学过的属性值： 属性值 描述 block 一个 block 元素通常被叫做块级元素。div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p、 form和HTML5中的新元素： header 、footer 、 section等等。 inline 一个 inline 元素通常被叫做行内元素。span 是一个标准的行内元素, a元素是最常用的行内元素。 inline-block 它可以让内联的盒子像一个块元素，使元素在一行显示，仍然保持样式可设置 flex 用于设置元素为弹性盒子的父容器 none 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden;还会占据空间。 每个元素都有一个默认的display 类型。不过你可以随时随地的重写它！常见的例子是：把 li 元素修改成 inline，制作成水平菜单。 max-width属性更好地处理小窗口情况使用 max-width替代width 可以使浏览器更好地处理小窗口的情况。 123456789101112131415&lt;head&gt; &lt;style&gt; #main &#123; max-width: 600px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\"&gt; 设置块级元素的 width 可以防止它从左到右撑满整个容器。然后你就可以设置左右外边距为 auto 来使其水平居中。元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。 唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。让我们再来改进下这个方案... &lt;/div&gt;&lt;/body&gt; 可以看到缩小窗口以后下方的水平滚动条：使用 max-width替代width 使用 max-width后可以注意到缩小窗口后也不会出现水平滚动条: 替代盒模型注意事项box-sizing是个很新的属性，目前应该像下面例子中那样使用 -webkit-和 -moz-前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+的。 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; position属性与CSS&lt;footer&gt;标签（页脚） 如果你使用了一个固定定位的页眉或页脚，确保有足够的空间来显示它们！比如：在 body 上面加上足够的 margin-bottom 。 例子 float属性Float 可用于实现文字环绕图片，如下： 1234img &#123; float: right; margin: 0 0 1em 1em;&#125; nav元素与float属性这个例子在容器比nav元素高的时候可以正常工作。如果容器比nav元素低，那么nav会溢出到容器的外面。nav改用浮动以后可以解决易出问题。 响应式设计——媒体查询 MDN 媒体查询 一个例子：当屏幕宽度大于600px时执行的CSS样式表与小于599px时执行的CSS样式表有所不同，当窗口缩小到宽度小于599px时，nav中的li元素就会转变为行内元素并出现在section元素上方。 vertical-align属性设置行内元素垂直方向对齐方式 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 注意： vertical-align 只对行内元素、表格单元格元素生效，不能用它垂直对齐块级元素。 作用于行内元素的属性值（分为“相对父元素的值”和”相对行的值”）：相对父元素的属性值 | 描述（这些值使元素相对其父元素垂直对齐） –|—baseline（默认值） | 使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如&lt;textarea&gt; ，这意味着这些元素使用此值的表现因浏览器而异。sub | 使元素的基线与父元素的下标基线对齐。super | 使元素的基线与父元素的上标基线对齐。text-top | 使元素的顶部与父元素的字体顶部对齐。text-bottom | 使元素的底部与父元素的字体底部对齐。middle | 使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐。&lt;length&gt; | 使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。&lt;percentage&gt; | 使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。 相对行的属性值 描述(下列值使元素相对整行垂直对齐) top 使元素及其后代元素的顶部与整行的顶部对齐。 bottom 使元素及其后代元素的底部与整行的底部对齐。 没有基线的元素，使用外边距的下边缘替代。 vertical-align属性可被用于两种环境： 使行内元素盒模型与其行内元素容器垂直对齐。例如，用于垂直对齐一行文本的内的图片&lt;img&gt;： 垂直对齐表格单元内容: MDN vertical-align属性 inline-block属性值可方便创建网格 想要创建很多网格来铺满浏览器。在过去很长的一段时间内使用 float ，但是使用 display:inline-block; 会更简单。 让我们看下使用这两种方法的例子对比 注意： vertical-align 属性（默认值为baseline）会影响到 inline-block 元素，你可以把它的值设置为 top（使元素及其后代元素的顶部与整行的顶部对齐） 。（例子） 你需要设置每一列的宽度 如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙 你得做些额外工作来让IE6和IE7支持 inline-block 。有些时候人们谈到 inline-block 会触发叫做 hasLayout 的东西，你只需要知道那是用来支持旧浏览器的就可以了。如果你对此很感兴趣，可以在这个链接中找到更详细的信息。 columns属性轻松实现文字的多列布局 CSS columns是很新的标准，所以你需要使用前缀（如下方例子中），并且它不被IE9及以下和Opera Mini支持。还有许多和 column 相关的属性，点击这里了解更多。 一个例子 MDN 关于columns属性 使用flexbox居中布局 同时在父容器设置align-items: center;（沿交叉轴居中）与justify-content: center;（沿主轴居中）可以使子项元素在父容器中居中。 例子 布局模型1. 流动模型（Flow） [默认的]流动（Flow）模型是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征： 块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 在流动模型下，行内元素都会在所处的包含元素内从左到右水平分布显示。 2. 浮动模型 (Float)使用CSS的float属性。 3. 层模型（Layer）层模型有三种形式： 相对定位(position: relative) 绝对定位(position: absolute) 固定定位(position: fixed) 注意：固定定位是相对视图定位，不会随着滚动条的操作而移动位置。而绝对定位相对于其最接近的一个非默认position属性值的父元素进行定位，在父元素全部是默认position属性值时则是相对body元素（即相对于浏览器窗口）进行定位，会随着滚动条的操作而移动位置。【注意区分“视图”与“浏览器窗口”】 注意：更改堆叠顺序的z-index属性只适用于定位元素（position属性值为static的对象不是定位元素）父子元素都设置z-index属性时只要父元素z-index属性生效则子元素z-index属性不生效，默认与父元素属性值相等并按照文档流排列，子元素出现在父元素上方。（父元素未设置position属性值或设为默认值static时z-index属性失效，则子元素z-index属性生效） 什么时候用定位，什么时候用浮动 float被设计出来的初衷是用于——文字环绕图片 float是部分脱离文档流，而absolute是完全脱离文档流。也就是说，使用float属性时，其他元素会无视这个float元素，但是其他元素内的文本依然会为这个元素让出位置，环绕在周围，所以称为部分无视。而使用absolute脱离文档流的元素，其它盒子无论是本身还是盒子内的文本都会无视这个元素，也就是完全脱离文档流。 float多个特性具体例子请参考这个链接 破坏性：被设置了float的元素会脱离文档流 包裹性：块级元素设置了float之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。 清空格：根本原因是由于float会导致节点脱离文档流结构,float元素都不属于文档流结构了，那么它身边的什么换行、空格就都和它没关系，它就尽量的往一边去靠拢，能靠多近就靠多近，这就是清空格的本质。 float具有“破坏性”，它会导致父元素“坍塌”（即父元素无法包裹float子元素），此时可以为父元素添加overflow:hidden,这样父元素就有高度了 ，父元素的高度便不会被破坏。 网页布局方式网页实质是块与块之间的位置，块挨着块，块嵌套块，块叠着块。三种关系：相邻，嵌套，重叠。参考 一列布局（固定宽高，水平居中）一般都是固定的宽高，设置margin : 0 auto来水平居中，用于界面显著标题的展示等: 1234567 .main&#123; width: 200px; height: 100px; background-color: grey; margin: 0 auto; &#125;&lt;div class=\"main\"&gt;&lt;/div&gt; 两列布局（常用float）最常见的就是使用float来实现。float浮动布局的缺点是浮动后会造成文本环绕等效果，需要及时清除浮动。设置左左浮动，或设置左右浮动（需要设置父元素的宽度）如果父级元素没有设置高度，则需要设置overflow:hidden避免父元素“高度坍塌”。（如果你没有给父元素定义高度，此时给父元素加个overflow:hidden；（超过浮动就隐藏）就相当于清除浮动，没有浮动又没定义高度，父元素就会根据文档流自适应高度，也就不会“坍塌”了） overflow:hidden;属性可以保证div的高度或宽度不变。div里添加的东西再多，高度或宽度也不变。超出的部分隐藏。解决float子元素图片溢出和float父元素“高度坍塌”都可以使用overflow:hidden;。 1234&lt;div class=\"main\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt; 12345678910111213.main&#123; width: 400px; background: red; overflow: hidden;&#125;.left&#123; background: yellow; float: left;&#125;.right&#123; background: green; float: left;&#125; 三列布局（浮动或子绝父相）浮动：首先设置父级元素的宽度（width: 100%;overflow: hidden;） 可以左左右设置浮动。然后中间设置margin调整间距。 也可以都设置成左浮动，设置margin，调整间距。同样注意清除浮动！ 子绝父相：为父元素设置relative属性，再为子元素设置absolute属性，再分别定位，调间距。 混合布局在一列布局的基础上，保留top和foot部分，将中间的main部分改造成两列或三列布局，小的模块可以再逐级同理划分。 对齐方式水平居中补充：img是行内元素，为什么可以设置框高？（面试题）（题目来自魅族一面）问题：既然img是行内元素，那为什么可以通过CSS设置框高呢？答案：尽管img是行内元素，但同时它也是置换元素，置换元素一般内置框高属性，因此可以设置其框高。 引申问题：那么什么又是“置换元素”呢？答案：置换元素就是会根据标签属性来显示的元素。反之就是非置换元素了。比如img根据src属性来显示，input根据value属性来显示，因此可知道img和input是置换元素，当然同理select也是置换元素。 行内元素的水平居中 注意：text-align属性虽然规定元素中的文本的水平对齐方式，但他是作用于块级元素的（p/h1等等）。 如果被设置元素为文本、图片等行内元素时，则需要在父元素中设置text-align:center实现行内元素水平居中（必要时可以将子元素的display设置为inline-block，使子元素变成行内元素的同时可设置样式）。 补充：图片等比缩小可借助max-width和max-height 123456789101112.dad &#123; text-align: center;&#125;img &#123; width: auto; height: auto; max-width: 200px; max-height: 200px;&#125;p&#123; text-align: center;&#125; 1234567&lt;div class=\"dad\"&gt; &lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt;&lt;div class=\"dad\"&gt; &lt;span&gt;上校&lt;/span&gt;&lt;/div&gt;&lt;p&gt;喵呜&lt;/p&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS flexbox）","slug":"百度前端技术学院 第七天学习笔记 （CSS flexbox）","date":"2019-11-20T08:24:30.000Z","updated":"2019-11-20T13:21:49.248Z","comments":true,"path":"2019/11/20/百度前端技术学院 第七天学习笔记 （CSS flexbox）/","link":"","permalink":"http://yoursite.com/2019/11/20/百度前端技术学院 第七天学习笔记 （CSS flexbox）/","excerpt":"flexbox弹性盒子 MDN flexbox例子 想要flex生效必须定义其父元素的display属性为flex或inline-flex flex容器flex container（父级容器） flex子项flex item","text":"flexbox弹性盒子 MDN flexbox例子 想要flex生效必须定义其父元素的display属性为flex或inline-flex flex容器flex container（父级容器） flex子项flex item 主轴main axis（主轴方向是可变的，主要取决于flex-direction属性），它是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴（垂直于主轴）。该轴的开始和结束被称为 cross start 和 cross end。 父级container的属性display定义flex父容器display属性定义一个flex容器，内联或者根据指定的值，来作用于下面的子类容器。 请注意，CSS列对flex容器无效。 float, clear, vertical-align 在flex项目中不起作用 属性值 含义 flex 块，将对象作为弹性伸缩盒显示 inline-flex 内联，将对象作为内联块级弹性伸缩盒显示 flex-flow简写flex-direction和flex-wrap属性 这是flex-direction和flex-wrap属性的简写，它们一起定义了flexbox的主轴和交叉轴。 默认值为row nowrap。(即：将所有子项排列在一行上)1flex-flow: row wrap; flex-direction规定子项排列方式及方向Flexbox是单向布局概念。可以将弹性项目想像为主要以水平行或垂直列布置。 属性值 含义 row（默认值） 把子项排在同一行，从左到右 row-reverse 行，从右到左 column 把子项排在同一列，从上到下 column-reverse 与row-reverse相似，只是变成了从下到上 flex-wraps使溢出子项换行 默认情况下，所有弹性项目都将尝试放入一行。可以通过修改flex-wrap属性值使溢出父元素宽度的子项换行。 注意：flex-direction属性值为row时将flex-wrap属性值设置为wrap会使得子项换行，但一个子项占据一行，此时可通过设置子项的flex属性值来设置默认宽度来达到一行多个子项的效果。 属性值 含义 nowrap （默认） 所有弹性项目都在一行上 wrap 弹性项目将从上到下分布在多行上。 wrap-reverse 弹性项目将从下到上分布在多行上。 justify-content定义子项沿主轴的对齐方式定义了沿主轴的对齐方式。(主轴是可变的，主要取决于flex-direction属性值) 属性值 含义 flex-start （默认） 从flex-direction的开始处开始放置子项 flex-end 从flex-direction的末端开始放置子项 start 子项从书写模式方向的起点开始放置 end 子项从书写模式方向的末端开始放置 left 子项从容器的左边缘开始放置，除非这与flex-direction不一致，否则它的行为类似于start right 子项从容器的右边缘开始放置，除非这与flex-direction不一致，否则它的行为类似于start center 子项沿线居中 space-between 子项在行中均匀分布，第一项位于开始处，最后一项位于结束处 space-around 项目在行中均匀分布，并且周围有相等的空间。请注意，从视觉上看，空间是不相等的，因为所有项目的两侧都具有相等的空间。第一项相对于容器边缘有一个单位的空间，但是它与下一项之间有两个单位的空间。 space-evenly （evenly：均匀地）分配项目，任意两个项目之间的间距（以及到边缘的间距）相等。 请注意，浏览器对这些值的支持是有细微差别的。例如，space-between从来没有获得Edge支持，并且Chrome没有start/end/left/right。MDN 有详细的图表。最安全的值是flex-start，flex-end和center。 还可以这些值与将两个其他关键字（safe和unsafe）配对。使用safe确保无论执行哪种类型的定位，都不能以无法滚动内容的方式推送元素以使其呈现屏幕外（例如，从顶部移出）（称为“数据丢失”） 。 align-items定义子项在交叉轴上的对齐方式用来设置每个flex元素在侧轴上的默认对齐方式 123.container &#123; align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;&#125; 属性值 含义 stretch （默认） 使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。（仍然遵守最小宽度/最大宽度） flex-start/ start/ self-start 项目放置在cross-axis的起点,它们之间的区别是微妙的，并且是遵守flex-direction规则或writing-mode规则的 flex-end/ end/ self-end 项目放置在cross-axis的末端。差异再次是微妙的，尊重flex-direction规则与writing-mode规则 center 使子项保持其原有的高度，在交叉轴上居中 baseline 项目对齐，例如基线对齐 可以结合safe和unsafe关键字与上面的属性值一起使用（但是注意浏览器支持），他可以防止内容变得不可访问。 align-content定义不同行之间的对齐方式 与在主轴justify-content内对齐单个项目的方式类似，但align-content是定义不同行之间的对齐方式（位置）。 align-content属性设置了浏览器如何沿着父容器（flexbox container）的交叉轴在内容项之间和周围分配空间。 注意：只有一行flexbox时，此属性无效。 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;&#125; 属性值 含义 stretch （默认） 拉伸所有行来填满剩余空间。剩余空间平均的分配给每一行 start 所有行从父容器的起始边缘开始填充 flex-start 所有行从垂直轴起点开始填充。第一行的垂直轴起点边和容器的垂直轴起点边对齐。接下来的每一行紧跟前一行。 end 所有行从父容器的结束边缘开始填充 flex-end 所有行从垂直轴末尾开始填充。最后一行的垂直轴终点和容器的垂直轴终点对齐。同时所有后续行与前一个对齐。 center 所有行朝向父容器的中心填充。每行互相紧挨，相对于容器居中对齐。容器的垂直轴起点边和第一行的距离相等于容器的垂直轴终点边和最后一行的距离。 space-between 所有行在容器中平均分布，相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的边对齐。（第一行在容器的开头，而最后一行在容器的结尾） space-around 所有行在容器中平均分布，相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的距离是相邻两行间距的一半。（每一行周围具有相等的空间（注意：两行之间有两个单位的空间，参考justify-content属性的space-around属性值）） space-evenly 项目均匀分布，（从视觉上看，每一个行周围具有相等的空间。）所有行沿垂直轴均匀分布在对齐容器内。每对相邻的项之间的间距，主开始边和第一项，以及主结束边和最后一项，都完全相同 区别justify-content与align-content还有align-items justify-content属性定义子项在主轴上的对齐方式（位置）。 align-content属性定义不同行的对齐方式（位置）。 align-items属性定义子项在交叉轴上的对齐方式（位置）。 子项item的属性order顺序 默认情况下，flexbox按源顺序排列。但是，该order属性可以控制子项在flex容器中出现的顺序而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。 order 值小的 flex 项在显示顺序中更靠前。相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是2，1，1和0，那么它们的显示顺序就分别是第四，第二，第三，和第一。 属性值：无单位整数，默认为0，可以为负值。 例子：在众多按钮中将第一个按钮移动到主轴的末尾123button:first-child &#123; order: 1;&#125; flex简写flex-grow、flex-shrink和flex-basis 建议使用该简写属性！ 这是flex-grow、flex-shrink和flex-basis组合的简写。 第二和第三个参数(flex-shrink和flex-basis)是可选的（省略部分属性值时注意有顺序要求）。 默认值是0 1 auto。 例子：表示“每个flex 子项将首先给出200px的可用空间，然后将剩余的可用空间将根据flex-grow属性值（2）分配的比例共享” 123.item &#123; flex: 2 200px；&#125; 大多数情况下，开发者需要将 flex 设置为 auto，initial，none，或一个无单位正数。 属性值 描述 initial 元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为”flex: 0 1 auto”。 auto 元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 “flex: 1 1 auto”. none 元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为”flex: 0 0 auto”。 &lt;’flex-grow’&gt; 定义 flex 元素的 flex-grow 属性，详见 &lt;number&gt;。默认值为 0，负值无效。 &lt;’flex-shrink’&gt; 定义 flex 元素的 flex-shrink 属性，详见 &lt;number&gt;。默认值为1，负值无效。 &lt;’flex-basis’&gt; 定义 flex 元素的 flex-basis 属性。若值为0，则必须加上单位，以免被视作伸缩性。 默认值为 auto。 flex 属性可以指定1个，2个或3个值。但他是有顺序要求的！ 单值语法: 值必须为以下其中之一: 一个无单位数(&lt;number&gt;): 它会被当作&lt;flex-grow&gt;的值。 一个有效的宽度(width)值: 它会被当作 &lt;flex-basis&gt;的值。 关键字none，auto或initial. 双值语法: 第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。第二个值必须为以下之一： 一个无单位数：它会被当作&lt;flex-shrink&gt;的值。 一个有效的宽度值: 它会被当作 &lt;flex-basis&gt; 的值。 三值语法: 第一个值必须为一个无单位数，并且它会被当作&lt;flex-grow&gt;的值。 第二个值必须为一个无单位数，并且它会被当作 &lt;flex-shrink&gt; 的值。 第三个值必须为一个有效的宽度值， 并且它会被当作 &lt;flex-basis&gt;的值。 flex-grow定义子项元素空间占比 flex-grow属性值是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小，它决定了子项在父级容器（flex container）内部占用多少可用空间，占用的空间是在设置 padding 和 margin 之后剩余的空间。 属性值：默认为0，不能为负数。 如果所有项目flex-grow都设置为1，则容器中的剩余空间将平均分配给所有子项。如果其中一个孩子的值为2，则剩余空间将占其他孩子的两倍（或者至少会尝试）。123.item &#123; flex-grow: 3; /* default 0 */&#125; flex-shrink弹性收缩 flex-shrink 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 一般用于溢出容器的 flex 子项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 这是一个相当高级的弹性盒子功能. 属性值:默认为1，不能为负数。 123.item &#123; flex-shrink: 2; /* default 1 */&#125; MDN flex-shrink flex-basis定义子项元素初始大小（最小值） flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。 属性值 含义 长度 例如20％，5rem等 关键字 auto：参照我的width和height属性content(此关键字不能很好地支持,不建议使用):根据子项的内容调整大小 123.item &#123; flex-basis: 200px; /* default auto */&#125; MDN flex-basis 属性值如果设置为0，则不考虑内容周围的额外空间。 属性值如果设置为auto，则根据其flex-grow值分配额外的空间。 align-self调整单个子项在交叉轴上的对齐方式 align-self 会对齐当前 flex 行中的 flex 元素，并覆盖已有的align-items 的值，按照cross axis方向进行排列. 注意：float（浮动）, clear（清除浮动） 和 vertical-align对flex子项没有影响。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 属性值 含义 auto (默认值) 设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch flex-start flex 元素会对齐到 cross-axis 的首端 flex-end flex 元素会对齐到 cross-axis 的尾端 center flex元素会对齐到 cross-axis 的中间，如果该元素的 cross-size 的尺寸大于 flex 容器，将在两个方向均等溢出 baseline 所有的 flex 元素会沿着基线对齐。如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。 stretch 子项在交叉轴方向被拉伸以适应容器。如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。 各种属性值效果参考 flex 嵌套弹性盒子也能创建一些颇为复杂的布局。一个元素即可以是父容器也可以是子项，也就是说你可以为父容器中的一个子项也设置display属性使其成为一个父容器。如上图，我们用一个 &lt;section&gt; 元素作为父容器包含了三个 &lt;article&gt;元素。第三个 &lt;article&gt;元素（作为&lt;section&gt;子项的它同时被设置为父容器）包含了三个&lt;div&gt;,像这样： 1234567section - article article article - div - button div button div button button button 特别注意这里我们设置第三个 元素的子节点的布局同样为 flex ，但是属性值为列布局（flex-flow: column;）。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS position）","slug":"百度前端技术学院 第七天学习笔记 （CSS position)","date":"2019-11-19T13:12:24.000Z","updated":"2019-11-21T02:46:02.529Z","comments":true,"path":"2019/11/19/百度前端技术学院 第七天学习笔记 （CSS position)/","link":"","permalink":"http://yoursite.com/2019/11/19/百度前端技术学院 第七天学习笔记 （CSS position)/","excerpt":"position属性position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。","text":"position属性position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。 属性值 含义 absolute 生成绝对定位的元素，不为元素预留空间。通过指定元素相对于最近的非 static定位祖先元素的偏移，来确定元素位置。（如果所有父元素都没是默认position值则绝对定位元素相对文档的 body 元素(即相对于浏览器窗口)进行定位，并且它会随着页面滚动而移动）绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成固定定位的元素，不为元素预留空间。相对于视图（屏幕内的网页窗口）进行定位。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）【即会为元素预留空间】 static 默认值。没有定位，元素出现在正常的流中（此时 top, right, bottom, left 和 z-index 属性无效）。 sticky 基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从浏览器窗口顶部10像素）之后它变得固定。必须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。常用于定位字母列表的头部元素 默认值static 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 相对定位relative 生成相对定位的元素，文档流中将为元素预留空间。 相对定位会相对元素的原始位置对该元素进行移动。 top, bottom, left, right属性除默认值static外，其他属性值都要配合使用top, bottom, left, 和 right属性值来精确指定要将定位元素移动到的位置。 1234567891011121314&lt;body&gt; &lt;h1&gt;Basic document flow&lt;/h1&gt; &lt;p&gt;I am a basic block level element. My adjacent block level elements sit on new lines below me.&lt;/p&gt; &lt;p class=\"positioned\"&gt;By default we span 100% of the width of our parent element, and we are as tall as our child content. Our total width and height is our content + padding + border width/height.&lt;/p&gt; &lt;p&gt;We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both.&lt;/p&gt; &lt;p&gt;inline elements &lt;span&gt;like this one&lt;/span&gt; and &lt;span&gt;this one&lt;/span&gt; sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements will &lt;span&gt;wrap onto a new line if possible (like this one containing text)&lt;/span&gt;, or just go on to a new line if not, much like this image will do: &lt;img src=\"https://mdn.mozillademos.org/files/13360/long.jpg\"&gt; &lt;/p&gt;&lt;/body&gt; 1234567891011121314151617181920212223body &#123; width: 500px; margin: 0 auto; &#125; p &#123; background: aqua; border: 3px solid blue; padding: 10px; margin: 10px; &#125; span &#123; background: red; border: 1px solid black; &#125; .positioned &#123; position: relative; background: yellow; top: 30px; left: 30px; &#125; 绝对定位absolute 使用position:absolute;生成绝对定位的元素，它会相对于第一个非 static 的父元素进行定位。 生成绝对定位的元素，不为元素预留空间。 如果所有的父元素都没有显式地定义position属性(即全部是默认值)，那么所有的父元素默认情况下position属性都是static。结果，绝对定位元素会相对于文档的 body 元素(即相对于浏览器窗口)进行定位，并且它会随着页面滚动而移动。（通过子绝父相可使绝对定位元素相对“相对定位”的父元素进行定位） 将上面例子中的position值改为absolute:1position: absolute; 定位上下文（子绝父相） 上面的例子绝对定位元素会相对于文档的 body 元素进行定位，并且它会随着页面滚动而移动。 可以通过设置绝对定位元素的其中一个父元素的定位属性为相对定位relative来使得绝对定位元素不相对初始块容器进行定位，比如下面例子中将body的css样式设为position: relative;就可以使得body中绝对定位的p元素相对body进行定位。 【子绝父相】：我们可以改变定位上下文(绝对定位的元素的相对位置元素)来使绝对元素相对于body进行定位，而不是相对于浏览器窗口进行定位。也就是设置绝对定位元素的其中一个父元素的定位属性为相对定位relative，给body添加css样式：1position: relative; z-index属性更改堆叠顺序 z-index属性只适用于定位元素（position属性值为static的对象不是定位元素） 可以通过修改z-index属性值更改元素堆叠顺序。 我们使用水平（x轴）和垂直（y轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。（0,0）位于页面（或元素）的左上角，x和y轴跨页面向右和向下（适合从左到右的语言）。 网页也有一个z轴：一条从屏幕表面到你的脸的虚线。z-index 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有z-index为auto，实际上为0。 注意，z-index只接受无单位索引值；你不能指定你想要一个元素是Z轴上23像素。较高的值将高于较低的值，但使用2和3将产生与300和40000相同的效果。 例子1 当出现多个绝对定位元素时，源顺序中排在后面的元素将出现在排在前面的元素的顶部,比如给上面的例子加上下面代码，使得第一段文字也变成绝对定位（之前是只有第二段文字绝对定位）：123456p:nth-of-type(1) &#123; position: absolute; background: lime; top: 10px; right: 30px; &#125; 可以看到第一段文字绿色绝对定位出现在了第一段文字黄色绝对定位的下方。 修改z-index值，使得第一段文字绿色绝对定位出现在了第一段文字黄色绝对定位的上方，将以下声明添加到 p:nth-of-type(1) 规则中：1z-index: 1; 例子2（相同z-index谁上谁下） 如果两个元素都没有设置z-index，使用默认值，一个定位一个没有定位，那么定位元素覆盖未定位元素：12&lt;div style=\"position:relative;top:50px;width:200px;height:200px;\"&gt;&lt;/div&gt;&lt;div style=\" width:100px;height:100px;\"&gt;&lt;div&gt; 如果两个元素都没有定位发生位置重合现象或者两个都已定位元素且z-index相同发生位置重合现象，那么按文档流顺序，后面的覆盖前面的:12&lt;div style=\"position:relative;width:200px;height:200px;\"&gt;&lt;/div&gt;&lt;div style=\"position:relative; top:-50px; width:100px;height:100px;\"&gt;&lt;div&gt; 例子3（父子关系谁上谁下）如果父元素z-index有效，那么子元素无论是否设置z-index都和父元素一致，都会出现在父元素上方（按文档流顺序，后面的覆盖前面的）： 123&lt;div style=\"position:relative;width:200px;height:200px;z-index:10;\"&gt; &lt;div style=\"position:relative;width:100px;height:100px;z-index:-5;\"&gt;&lt;div&gt;&lt;/div&gt; 虽然子元素设置z-index比父元素小，但是子元素仍然出现在父元素上方(子元素z-index=-5未生效):如果父元素z-index失效（未定位或者使用默认值），那么定位子元素的z-index设置生效: 123&lt;div style=\"position:relative;width:200px;height:200px;\"&gt; &lt;div style=\"position:relative;width:100px;height:100px;z-index:-5;\"&gt;&lt;div&gt;&lt;/div&gt; 子元素z-index=-5生效，被父元素覆盖: 固定定位fixed fixed与与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响。 而当父元素都是默认position属性值时，absolute固定元素是相对于body元素（即浏览器窗口）的，它会随着页面滚动而移动。 生成固定定位的元素，也不为元素预留空间。 这意味着您可以创建固定的有用的UI项目，如持久导航菜单。 但移动浏览器对 fixed 的支持很差，可以通过参考这个解决 粘性定位sticky sticky是一个比其他属性要新一些的属性。这基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从浏览器窗口顶部10像素）之后它变得固定。 粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。 必须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;dl&gt; &lt;dt&gt;A&lt;/dt&gt; &lt;dd&gt;Andrew W.K.&lt;/dd&gt; &lt;dd&gt;Apparat&lt;/dd&gt; &lt;dd&gt;Arcade Fire&lt;/dd&gt; &lt;dd&gt;At The Drive-In&lt;/dd&gt; &lt;dd&gt;Aziz Ansari&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;C&lt;/dt&gt; &lt;dd&gt;Chromeo&lt;/dd&gt; &lt;dd&gt;Common&lt;/dd&gt; &lt;dd&gt;Converge&lt;/dd&gt; &lt;dd&gt;Crystal Castles&lt;/dd&gt; &lt;dd&gt;Cursive&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;E&lt;/dt&gt; &lt;dd&gt;Explosions In The Sky&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;T&lt;/dt&gt; &lt;dd&gt;Ted Leo &amp; The Pharmacists&lt;/dd&gt; &lt;dd&gt;T-Pain&lt;/dd&gt; &lt;dd&gt;Thrice&lt;/dd&gt; &lt;dd&gt;TV On The Radio&lt;/dd&gt; &lt;dd&gt;Two Gallants&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031* &#123; box-sizing: border-box;&#125;dl &#123; margin: 0; padding: 24px 0 0 0;&#125;dt &#123; background: #B8C1C8; border-bottom: 1px solid #989EA4; border-top: 1px solid #717D85; color: #FFF; font: bold 18px/21px Helvetica, Arial, sans-serif; margin: 0; padding: 2px 0 0 12px; position: sticky; top: -1px;&#125;dd &#123; font: bold 20px/45px Helvetica, Arial, sans-serif; margin: 0; padding: 0 0 0 12px; white-space: nowrap;&#125;dd + dd &#123; border-top: 1px solid #CCC&#125; （完整例子） 另一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div class=\"con\"&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题一&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题二&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题三&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题四&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题五&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题五六&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 1234567.samecon h2&#123; /* position: -webkit-sticky; */ position: sticky; top: 0; background:#ccc; padding:10px 0;&#125; 如果没有div将h2与p元素框起来则被滚动过去的标题并不会消失。 position实例MDN position实例练习 补充：HTML &lt;section&gt;元素 &lt;section&gt;元素表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。 例如，导航菜单应该包含在&lt;nav&gt;元素中，但搜索结果列表和地图显示及其控件没有特定元素，可以放在&lt;section&gt;里。 MDN 关于&lt;section&gt;元素 注意： 如果元素的内容作为一个独立的有意义的集合，即元素内容可以分为几个部分的话，应该使用&lt;article&gt;而不是&lt;section&gt;。 不要把 &lt;section&gt; 元素作为一个普通的容器来使用，这本应该是&lt;div&gt;的用法（特别是当片段（the sectioning ）仅仅是为了美化样式的时候）。 一般来说，在文档大纲中应该出现不少于一个 &lt;section&gt;。 补充：HTML &lt;article&gt;元素 &lt;article&gt;元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构。如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 例如: 阅读器在博客上滚动时一个接一个地显示每篇文章的文本，每个帖子将包含在&lt;article&gt;元素中，可能包含一个或多个&lt;section&gt;。 每个&lt;article&gt;通常包括标题（&lt;h1&gt; - &lt;h6&gt;元素）作为&lt;article&gt;元素的子元素。 当&lt;article&gt;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&lt;article&gt;元素可嵌套在代表博客文章的&lt;article&gt;元素中。 &lt;article&gt;元素的作者信息可通过&lt;address&gt;元素提供，但是不适用于嵌套的&lt;article&gt;元素。 &lt;article&gt;元素的发布日期和时间可通过&lt;time&gt;元素的pubdate属性表示,但请注意&lt;time&gt;的pubdate 属性不再是W3C HTML5标准。 MDN 关于&lt;article&gt;元素 例子1与例子2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; html &#123; font-family: sans-serif; /* Sans-serif是专指西文中没有衬线的字体，与汉字字体中的黑体相对应 */ &#125; * &#123; box-sizing: border-box; /* 使用 box-sizing 模型 */ &#125; body &#123; margin: 0; /* 去掉 &lt;body&gt; 默认外边距 */ &#125; .info-box &#123; width: 452px;/* 要给ul列表的框border留出2px的宽度，否则位置不够会换行 */ height: 400px; position: fixed; top: 0; &#125; .info-box ul &#123; /* 从无序列表中移除默认的padding-left和margin-top值 */ border: 1px solid #b60000; height: 50px; margin: 0; padding: 0; &#125; .info-box li &#123; float: left; /* 列表项都要左浮动确保三个li元素能在一行合起来 */ list-style-type: none; /* 去除项目符号 */ width: 150px; /* info-box宽度为450px，三个li元素平铺info-box */ &#125; .info-box li a &#123; display: inline-block; /* 使链接在一行显示并保持样式可设置 */ text-decoration: none; /* 去除链接下划线 */ width: 100%; /* 可点击宽度 */ line-height: 3; background-color: white; color: #a60000; font-weight: 800; text-align: center; &#125; .info-box li a:focus, .info-box li a:hover &#123; /* 获得焦点/鼠标悬浮使红底白字 */ background-color: #a60000; color: white; &#125; .info-box li a.active &#123; /* 使用JavaScript来设置，当一个标签被点击时（当某个选项卡的类（ class ）出现 active 时） */ background-color: #a60000; color: white; &#125; .info-box .panels &#123; height: 352px; position: relative; clear: both; &#125; .info-box article &#123; position: absolute; /* 子绝父相：子元素根据父元素进行定位 */ top: 0; left: 0; height: 352px; padding: 10px; color: white; background-color: #a60000; &#125; .info-box .active-panel &#123; /* 使段落位于最上方 */ z-index: 1; &#125; .fake-content &#123; background-color: #a60000; color: white; padding: 10px; height: 2000px; margin-left: 470px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"info-box\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\" class=\"active\"&gt;Tab 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Tab 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Tab 3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"panels\"&gt; &lt;article class=\"active-panel\"&gt; &lt;h2&gt;The first tab&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque turpis nibh, porttitor nec venenatis eu, pulvinar in augue. Vestibulum et orci scelerisque, vulputate tellus quis, lobortis dui. Vivamus varius libero at ipsum mattis efficitur ut nec nisl. Nullam eget tincidunt metus. Donec ultrices, urna maximus consequat aliquet, dui neque eleifend lorem, a auctor libero turpis at sem. Aliquam ut porttitor urna. Nulla facilisi.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;The second tab&lt;/h2&gt; &lt;p&gt;This tab hasn't got any Lorem Ipsum in it. But the content isn't very exciting all the same.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;The third tab&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque turpis nibh, porttitor nec venenatis eu, pulvinar in augue. And now an ordered list: how exciting!&lt;/p&gt; &lt;ol&gt; &lt;li&gt;dui neque eleifend lorem, a auctor libero turpis at sem.&lt;/li&gt; &lt;li&gt;Aliquam ut porttitor urna.&lt;/li&gt; &lt;li&gt;Nulla facilisi&lt;/li&gt; &lt;/ol&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=\"fake-content\"&gt; &lt;h1&gt;Fake content&lt;/h1&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;/section&gt; &lt;script type=\"text/javascript\"&gt; /* 首先我们保存所有的选项卡和所有的面板引用到两个变量中，名为 tabs 和 panels，这样此后我们可以容易地为它们做事。 */ var tabs = document.querySelectorAll('.info-box li a'); var panels = document.querySelectorAll('.info-box article'); /* 遍历所有的选项卡(a标签)，并且在每一个上运行叫做setTabHandler() 的函数，此函数建立当每个选项卡被点击时应该发生的功能。 */ for (i = 0; i &lt; tabs.length; i++) &#123; /* 函数被传递选项卡(a标签)tab和一个索引数i，指明选项卡在tabs 数组中的位置 */ var tab = tabs[i]; setTabHandler(tab, i); &#125; function setTabHandler(tab, tabPos) &#123; /* 创建了一个 onclick 事件来处理点击 */ tab.onclick = function () &#123; /* 用一个 for 循环清除所有标签当前存在的类 */ for (i = 0; i &lt; tabs.length; i++) &#123; /* 实际上清除的是a标签的active类（红底白字） */ if (tabs[i].getAttribute('class')) &#123; tabs[i].removeAttribute('class'); &#125; &#125; /* 在当前a标签上创建一个 active 类以便从相关联的元素中继承CSS的一些属性（红底白字） */ tab.setAttribute('class', 'active'); /* 用一个 for 循环清除所有面板当前存在的类。 */ for (i = 0; i &lt; panels.length; i++) &#123; if (panels[i].getAttribute('class')) &#123; panels[i].removeAttribute('class'); &#125; &#125; /* 当标签被点击的时候在和标签相对应的面板上创建了一个 active-panel 类以便从相关联的元素中继承了CSS的一些属性（使其 z-index 属性被设置为1，让它能位于所有的面板的上面）。 */ panels[tabPos].setAttribute('class', 'active-panel'); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子1、例子2效果 例子3 复习&lt;label&gt;、&lt;aside&gt;标签的使用方法。 复习： margin与padding属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=\"en-us\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Hidden info panel&lt;/title&gt; &lt;style&gt; /* || Checkbox hack to control information box display */ label[for=\"toggle\"] &#123; font-size: 3rem;/* 设置更大的 font-size 使图标更大更美观。 */ position: absolute;/* 设置 position 为 absolute，使用 top 和 right 属性让他能合适的位于右上角。 */ top: 4px; right: 5px; z-index: 1;/* 设置其 z-index 为1——因此当信息面板被赋予样式和显示的时候，不会覆盖我们的图标；相反图标依然会位于最上层能够再次被按下来隐藏信息平板。 */ cursor: pointer;/* 使用 cursor 属性来改变鼠标的指针，当鼠标悬浮在图标上面的时候变成一个手形指针（就像你看到的当悬浮在链接上一样），作为一个额外的可视化线索告诉用户这个图标可以做一些有趣的事情。 */ &#125; input[type=\"checkbox\"] &#123;/* 在实际的 &lt;input&gt; 元素的checkbox 上设置position 属性为 absolute，并从屏幕上方隐藏掉它，我们并不希望在我们的用户界面里看到它。 */ position: absolute; top: -100px; &#125; /* information box styling */ aside &#123; background-color: #a60000; color: white; /* 填充整个浏览器窗口的视口 */ width: 340px; height: 98%; padding: 10px 1%;/*padding2个属性值：上下 左右 */ /* 设置fixed，即使页面的内容在滚动，他也总是显示在同一个位置。设置 top 属性，使其粘在视口顶部，设置 right 属性使其默认情况下位于屏幕的右边隐藏大部分。 */ position: fixed; top: 0; right: -370px; /* Transitions是一个有意思的特性，允许你在状态改变的时候平滑的过渡，而不是粗暴的“开”或“关”。在这个例子中我们尝试在checkbox被选中时让面板平滑的滚动。 */ transition: 0.6s all; &#125; /* Second part of the checkbox hack — the checked state */ /* 选择与 &lt;input&gt; 元素邻接的 &lt;aside&gt; 元素，但是仅仅在它被选择时（请注意使用 :checked 伪类来实现此目的）*/ input[type=checkbox]:checked+aside &#123; right: 0px;/* 将 &lt;aside&gt; 的 right 属性设置为0px，会造成面板再次出现在屏幕上（由于过渡属性会平滑的出现） */ &#125; /* 再一次点击这个标签会取消选中checkbox，面板将会跟着再一次消失。 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- label通过for属性绑定id到了&lt;input&gt;标签的checkbox元素上，这样点击问号相当于点击checkbox --&gt; &lt;label for=\"toggle\"&gt;❔&lt;/label&gt; &lt;input type=\"checkbox\" id=\"toggle\"&gt; &lt;aside&gt; &lt;h2&gt;Information&lt;/h2&gt; &lt;p&gt;Some very important information about your app:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;It has a really cool slide-out information box.&lt;/li&gt; &lt;li&gt;This information box uses a combination of fixed positioning and a CSS transition for the smooth sliding.&lt;/li&gt; &lt;li&gt;It also uses a cool technique called the &lt;a href=\"https://css-tricks.com/the-checkbox-hack/\"&gt;checkbox hack&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;This allows you to create a nice \"toggle on/toggle off\" UI effect without using any JavaScript, which will work in IE9 and above (the smooth transition will work in IE10 and above.)&lt;/li&gt; &lt;/ol&gt; &lt;/aside&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML知识补充（section和article以及aside标签）","slug":"HTML知识补充（section和article以及aside标签）","date":"2019-11-19T08:34:59.000Z","updated":"2019-11-19T08:43:41.362Z","comments":true,"path":"2019/11/19/HTML知识补充（section和article以及aside标签）/","link":"","permalink":"http://yoursite.com/2019/11/19/HTML知识补充（section和article以及aside标签）/","excerpt":"HTML &lt;section&gt;元素 &lt;section&gt;元素表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。","text":"HTML &lt;section&gt;元素 &lt;section&gt;元素表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。 例如，导航菜单应该包含在&lt;nav&gt;元素中，但搜索结果列表和地图显示及其控件没有特定元素，可以放在&lt;section&gt;里。 MDN 关于&lt;section&gt;元素 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的例子1中有所使用。 注意： 如果元素的内容作为一个独立的有意义的集合，即元素内容可以分为几个部分的话，应该使用&lt;article&gt;而不是&lt;section&gt;。 不要把 &lt;section&gt; 元素作为一个普通的容器来使用，这本应该是&lt;div&gt;的用法（特别是当片段（the sectioning ）仅仅是为了美化样式的时候）。 一般来说，在文档大纲中应该出现不少于一个 &lt;section&gt;。 HTML &lt;article&gt;元素 &lt;article&gt;元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构。如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 例如: 阅读器在博客上滚动时一个接一个地显示每篇文章的文本，每个帖子将包含在&lt;article&gt;元素中，可能包含一个或多个&lt;section&gt;。 每个&lt;article&gt;通常包括标题（&lt;h1&gt; - &lt;h6&gt;元素）作为&lt;article&gt;元素的子元素。 当&lt;article&gt;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&lt;article&gt;元素可嵌套在代表博客文章的&lt;article&gt;元素中。 &lt;article&gt;元素的作者信息可通过&lt;address&gt;元素提供，但是不适用于嵌套的&lt;article&gt;元素。 &lt;article&gt;元素的发布日期和时间可通过&lt;time&gt;元素的pubdate属性表示,但请注意&lt;time&gt;的pubdate 属性不再是W3C HTML5标准。 MDN 关于&lt;article&gt;元素 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的例子1中有所使用。 HTML &lt;aside&gt; 元素 HTML &lt;aside&gt; 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框（call-out boxes）。 不要使用&lt;aside&gt; 元素去尾随括号内的文本 ，因为这种文本被认为是主要流内容的一部分。 MDN 关于&lt;aside&gt; 元素 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的例子3中有所使用。","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"JS闭包和面试题","slug":"JS闭包","date":"2019-11-17T03:27:14.000Z","updated":"2019-11-17T03:29:22.065Z","comments":true,"path":"2019/11/17/JS闭包/","link":"","permalink":"http://yoursite.com/2019/11/17/JS闭包/","excerpt":"MDN中关于闭包的描述","text":"MDN中关于闭包的描述 关于闭包 MDN 面试题 这是一个闭包，闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 这里的局部变量i，对f1()来说是全局变量，对f2()来说也是全局变量，但是f1()的i跟f2()的i又是相互独立相互不可见的，f1()每执行一次，f1()的i就加一，f2（）每次执行一次，f2()的i就加油，但是相互之间不影响，因此结果是010。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6扩展 数组扩展","slug":"ES6扩展 数组扩展","date":"2019-11-15T03:36:21.000Z","updated":"2019-11-15T07:25:39.042Z","comments":true,"path":"2019/11/15/ES6扩展 数组扩展/","link":"","permalink":"http://yoursite.com/2019/11/15/ES6扩展 数组扩展/","excerpt":"结合扩展运算符(...)复习：数组合并、复制数组 在解构赋值中讲解了使用扩展运算符将数组合并以及复制数组","text":"结合扩展运算符(...)复习：数组合并、复制数组 在解构赋值中讲解了使用扩展运算符将数组合并以及复制数组 123456789101112131415const arr1 = [1, 2, 3, 4];const arr2 = [4, 3, 2, 1];const arr3 = [\"nihao\", 2.2, false];//数组合并const cArr1 = [1, 2, 3, ...arr1];console.log(cArr1);//[1, 2, 3, 1, 2, 3, 4]const cArr2 = [...arr1, ...arr2, ...arr3];console.log(cArr2);// [1, 2, 3, 4, 4, 3, 2, 1, \"nihao\", 2.2, false]//复制数组arr3const cArr3 = [...arr3];console.log(cArr3);//[\"nihao\", 2.2, false]const [...cArr4] = arr3;console.log(cArr4);//[\"nihao\", 2.2, false] 复习：apply() 语法：func.apply(thisArg, [argsArray]) 可以通过 apply() 方法调用属于另一个对象的方法。 但不仅限于此，当设置第一个参数为null时可以在某些本来需要写成遍历数组变量的任务中使用内建的函数,也就是说此时apply()的作用不是调用属于另一个对象的方法，而是使参数数组中的每一个元素都去执行func函数。【如：下方“读取并展开数组用作多个参数”的“实用例子”中】 参数 描述 thisArg 可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时this会自动替换为指向全局对象，原始值会被包装。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 例子：在“读取并展开数组用作多个参数”的“实用例子”中。 读取并展开数组用作多个参数 另一个作用：在调用函数时把一个数组展开来作为这个函数的参数。 简单例子： 123456function foo(a, b, c) &#123; console.log(a);//1 console.log(b);//3 console.log(c);//2&#125;foo(...[1, 3, 2]); 实用例子：在实际运用中，我们经常将用户信息按照一定的顺序放在数组中而不是对象，这可以节省流量。在这个例子中，我们可以使用扩展运算符简便的读取数组中的每一个元素并作用与对应的参数，避免了重复使用[]去读取各个数组元素）。 补充：需要使用数组的join()将数组hobby转换为字符串。 123456const user = [\"小明\", 15, [\"吃饭\", \"睡觉\", \"打游戏\"], \"我没有女朋友\"];function say(name, age, hobby, desc) &#123; console.log(`我叫$&#123;name&#125;,我今年$&#123;age&#125;岁，我平时喜欢$&#123;hobby.join(\"和\")&#125;，$&#123;desc&#125;。`);&#125;say(user[0],user[1],user[2],user[3]);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say(...user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。 还可以使用apply()(不推荐)：12345678const user = [\"小明\", 15, [\"吃饭\", \"睡觉\", \"打游戏\"], \"我没有女朋友\"];function say(name, age, hobby, desc) &#123; console.log(`我叫$&#123;name&#125;,我今年$&#123;age&#125;岁，我平时喜欢$&#123;hobby.join(\"和\")&#125;，$&#123;desc&#125;。`);&#125;say.apply(null,user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say.apply(\"\",user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say.apply(0,user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say.apply(1,user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。 【他会将数组元素将作为单独的参数传给 say 函数】进行数组变对应参数的调用，但是使用扩展运算符语义更加清晰，而且参数如果传入过多会有超出JavaScript引擎的参数长度限制的风险。故不推荐使用apply()。 补充：生成器函数 语法：function* name([param[, param[, ... param]]]) { statements } 参数： name：函数名param：要传递给函数的一个参数的名称，一个函数最多可以有255个参数。statements：普通JS语句。 描述：生成器函数在执行时能暂停，后面又能从暂停处继续执行。 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （iterator ）对象。当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。【也就是说,首次执行生成器函数需要调用它的next()，当然也可以使用扩展运算符进行迭代调用，例子在下方“扩展运算符与生成器函数”中】 通过yield关键字可暂停函数的执行 通过next关键字可继续函数的执行 与promise类似 扩展运算符与生成器函数1234567891011121314function* g() &#123; console.log(1); yield \"hi~\"; console.log(2); yield \"imooc~\";&#125;//使用扩展运算符相当于迭代（循环）执行生成器函数【在这也就是执行了两次函数g()】// const arr = [...g()];//分别输出1,2//使用扩展运算符一行代码的效果类似于下面的代码const gg = g();gg.next();//1setTimeout(function () &#123; gg.next();//2&#125;, 1000); 结合去重函数Set() Set()参数可放入数组，返回值是字符串类型，想要让他完成去重后返回数组则可使用扩展运算符：123let set = new Set([1, 2, 3, 3]);console.log(set);//&#123;1, 2, 3&#125;console.log([...set]);//[1, 2, 3] 新的方法复习：构造函数法注意事项与数组字面量法创建数组 数组字面量可用于创建数组。（类似的，对象字面量用于创建对象） 创建数组有两种方法：构造函数法、数组字面量法。 第一：构造函数法 1var arr=new Array(); 注意:使用Array()创建数组对象时，如果只有一个数字参数则默认是用于设置数组长度： 12345let arr1 = new Array(\"10\");console.log(arr1);//[\"10\"]let arr2 = new Array(10);console.log(arr2);// [empty × 10] 第二：数组字面量法 1var arr=[\"zhu\",\"zhen\",\"wei\"]; 在调用数组的内建方法时可以使用Array.prototype.内建方法名,也直接使用数组字面量[]，写作[].内建方法名即可少写Array.prototype。（具体例子在下方“Array.from()将类数组转换为数组”例子中） Array.from()将类数组转换为数组 Array.from()将类数组对象或者Iterable对象转换为数组对象。 比如：arguments函数、document.querySelectorAll、 document.getElementByTagName、 document.getElementsByName、 document.getElementsByClassName返回的都是类数组对象。 注意：类数组对象的属性名必须是数值型或者字符串型的数字。类数组对象的length属性值会直接影响数组长度。12345678910111213141516171819const obj = &#123; 0: 1, 1: \"22\", 2: false, length: 2,&#125;;console.log(Array.from(obj));// [1, \"22\"]//Array.from()还可以接收一个回调函数作为第二个参数对类数组对象进行一些处理//在这里箭头函数item将传入的参数item都*2并返回，\"22\"隐式转换为22后也乘以2倍console.log(Array.from(obj, item =&gt; item * 2));// [2, 44]//后面三种方法虽然也可以将类数组转换为数组，但无法使用回调函数对数组对象进行处理。//方法1：使用call()让对象obj调用Array的slice方法以此转换成数组对象console.log(Array.prototype.slice.call(obj));// [1, \"22\"]//方法2：直接使用数组字面量`[]`即可少写`Array.prototype`console.log([].slice.call(obj));// [1, \"22\"]//方法3：添加遍历器接口(`Symbol.iterator`)后使用扩展运算符【具体例子在下面“使用扩展运算符将类数组转换为数组”中】 补充：使用扩展运算符将类数组转换为数组 扩展运算符...背后调用的是遍历器接口(Symbol.iterator)，所以任何有interator接口的对象都可以用...转化为真正的数组。 MDN 关于遍历器接口(Symbol.iterator) 而类数组对象是有interator接口的，所以我们也可以使用扩展运算符将类数组转换为数组。 注意：扩展运算符背后调用的是遍历器接口(Symbol.iterator)，如果一个对象没有部署这个接口，就无法转换。所以如果这个类数组对象是我们自己写的就一定要记得为它部署 Iterator 接口，否则无法使用扩展运算符将它转换为数组。（如下所示） 1234567const obj = &#123; 0: 1, 1: \"22\", 2: false, length: 2&#125;;console.log([...obj]); 在这个例子中，我们没有部署Symbol.iterator接口，就无法转换为数组并报错：TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator)) 正确写法：添加遍历器接口(Symbol.iterator)： 12345678const obj = &#123; 0: 1, 1: \"22\", 2: false, length: 2, [Symbol.iterator]: Array.prototype[Symbol.iterator]//添加遍历器接口&#125;;console.log([...obj]); 注意：不能在对象外面使用obj.obj[Symbol.iterator]= Array.prototype[Symbol.iterator];去添加遍历器接口。只有类数组对象才可以直接使用 Array 的 Iterator，普通对象部署数组的Symbol.iterator方法，并无效果。普通对象需要手动添加 Iterator 方法，添加 Iterator 接口的一种比较常用的方法,是使用Generator函数。普通的对象就算没有实现 Iterator 接口，不能使用 for … of 的情况下，仍然可以使用 for … in 来遍历 key。 Array.of()将参数合成数组 Array.of()将传入的参数合成数组。 语法：Array.of(参数1,参数2,参数3)1console.log(Array.of(1, 2, \"123\", 2.2, false));//[1, 2, \"123\", 2.2, false] Array#fill()固定值替换数组的元素 注意：fill不是静态方法，不能通过Array.fill来调用。 fill()方法用于将一个固定值替换数组的元素。并且可以指定填充的范围（起始值与结束值的数组下标）。 语法：array.fill(value, start, end) 参数 描述 value 必需。填充的值。 start 可选。开始填充位置的数组下标。 end 可选。停止填充位置的数组下标 (默认为 array.length)【注意：不包括end，也就是说array.fill(1, 0, 3)替换的是数组[0]、[1]、[2]】 注意：数组原有参数会被填充的值覆盖。 例子： 12let fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.fill(\"lalala\", 2, 4); 输出结果： 1Banana,Orange,lalala,lalala Array.includes()判断是否含有某元素 与字符串类似，数组也有includes()，用于检测数组中是否包含某元素，是则返回true，否则返回false。 可以代替以前的indexOf()来判断元素是否存在，但indexOf()可以找到数组下标，这个不可替代。123var arr = [1, 2, 3, 4];console.log(arr.includes(1));//trueconsole.log(arr.includes(55));//false keys()和values()还有entries() 与对象类似的，数组也有keys()和values()还有entries()，不过它们是作用在实例上的，即arr.keys()和arr.values()还有arr.entries()。而对象是作用在Object上Object.keys(obj实例) arr.keys()拿到数组下标 补充：拥有迭代（遍历）器接口iterator的对象都可以使用for-of语句。 可以使用keys()拿到数组每一项元素的数组下标。12345const arr = [1, 2, 3, 4.4, \"lalal\", false];console.log(arr.keys());//Array Iterator &#123;&#125;,说明arr.keys()含有迭代器接口Iterator ，故可以使用`for-of`for (let i of arr.keys()) &#123; console.log(i);&#125; arr.values()拿到数组元素使用values()可以按顺序拿到数组中的每一项。 12345const arr = [1, 2, 3, 4.4, \"lalal\", false];for (let v of arr.values()) &#123; console.log(v);&#125; arr.entries()同时拿到数组下标和元素 使用entries()可同时拿到数组下标和元素。 返回值：数组，[数组下标，对应的数组元素] 例子：12345const arr = [1, 2, 3, 4.4, \"lalal\", false];for (let e of arr.entries()) &#123; console.log(e);&#125; 上面例子拿到的e都是数组形式的，所以我们可以对取出来的e进行数组的解构赋值，同时拿到数组下标i和数组元素v：12345const arr = [1, 2, 3, 4.4, \"lalal\", false];for (let [i,v] of arr.entries()) &#123;//对取出来的e进行数组的解构赋值，e = [i,v] console.log(i,v);&#125; find()返回数组中满足回调函数的第一个元素 find()方法会按顺序对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。 语法：arr.find(callback[, thisArg]) 参数 描述 callback 在数组每一项上执行的测试函数(回调函数)，接收 3 个参数：element:当前遍历到的元素。index:可选,当前遍历到的索引。array:可选,数组本身。 thisArg 可选,执行回调时用作this的对象。 返回值：数组中满足提供的测试函数(回调函数)的第一个元素的值。否则返回 undefined。 例子(使用find()找到双数的数组元素)：1234567const res = [1, 7, 6, 3].find(function (value) &#123; console.log(\"value\", value); return value % 2 === 0;//通过取余找到双数&#125;);console.log(res);//6 例子分析：可以从运行结果上看到，1和7循环以后都不符合要求，循环到6时符合要求，输出6。 使用箭头函数简化例子：12const res = [1, 7, 6, 3].find(value =&gt; value % 2 === 0);//通过取余找到双数console.log(res);//6 findIndex()返回数组中找到的元素的下标 根据条件（回调函数）按顺序遍历数组,当回调返回true时就返回当前遍历到的下标,语法、参数都与find()非常相似。 语法：arr.findIndex(callback[, thisArg]) 参数 描述 callback 在数组每一项上执行的测试函数(回调函数)，接收 3 个参数：element:当前遍历到的元素。index:可选,当前遍历到的索引。array:可选,数组本身。 thisArg 可选,执行回调时用作this的对象。 返回值：数组中满足提供的测试函数的第一个元素的索引(下标)。否则返回-1。 例子（找到双数的数组元素的下标）：12const res = [1, 7, 6, 3].findIndex(value =&gt; value % 2 === 0);//通过取余找到双数console.log(res);//2 findIndex()与indexOf()的区别 findIndex()与indexOf()都是返回查找元素的数组下标的，但是findIndex()多了一个回调函数（测试函数），所以可以做一些indexOf()做不到的事情。 indexOf()无法查询数组中是否含有NaN: 但是findIndex()可以通过回调函数里调用Number的isNaN()来判断数组里是否含有NaN：12const res = [1, 7, 6, 3, NaN].findIndex(value =&gt; Number.isNaN(value));console.log(res);//4,也就是说找到了NaN的下标为4","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 对象扩展","slug":"ES6扩展 对象扩展","date":"2019-11-13T09:42:27.000Z","updated":"2019-11-15T07:26:05.144Z","comments":true,"path":"2019/11/13/ES6扩展 对象扩展/","link":"","permalink":"http://yoursite.com/2019/11/13/ES6扩展 对象扩展/","excerpt":"简洁表示法（简写对象属性、方法） 简写对象属性：对象的属性名与变量名同名后可从属性名:变量名简写为属性名。","text":"简洁表示法（简写对象属性、方法） 简写对象属性：对象的属性名与变量名同名后可从属性名:变量名简写为属性名。 简写对象方法：对象的方法可以直接省略冒号和function,从方法名:function(){函数体}简写为方法名(){函数体} 例子：1234567891011121314151617const getUserInfo = (id = 1) =&gt; &#123; //AJAX... const name = \"xiaoming\"; const age = 10; return &#123; name,//相当于`name:name`简写以后属性名name会自动去找到和它同名的变量，把它的值拿过来当值 age,//相当于`age:age` say() &#123;//相当于say:function()&#123;&#125;,简写可以省略冒号与function console.log(this.name + this.age); &#125; &#125;;&#125;;const xiaoming = getUserInfo();console.log(xiaoming);//&#123;name: \"xiaoming\", age: 10, say: ƒ&#125;console.log(xiaoming.say());//xiaoming10 属性名表达式 定义属性时可以用一个简单的表达式。 语法：先定义一个常量，然后[包含常量名的简单表达式]:属性值 123456const key=\"age\";//先定义一个常量keyconst xiaoming =&#123; name:\"xiaoming\", [`now$&#123;key&#125;`]:14//注意：模板字符串是反引号&#125;;console.log(xiaoming);//&#123;name: \"xiaoming\", nowage: 14&#125; 复习：扩展运算符复制对象 使用扩展运算符复制对象是浅拷贝的。 也就是说当你复制的对象obj1中包含一个对象c时，你实际上复制的是c的引用，当你修改复制所得到的对象copyObj1中的对象c的aa属性时，被复制的obj1对象中的对象c的属性aa也会被改变。 而修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的： 123456789101112131415161718const obj1=&#123; a:1, b:2, c:&#123; aa:3, bb:4 &#125;&#125;;const copyObj1=&#123;...obj1&#125;;console.log(copyObj1.c.aa);//3copyObj1.c.aa=999;console.log(copyObj1.c.aa);//999console.log(obj1.c.aa);//999,可以发现obj1的c中的aa也被修改了console.log(copyObj1.b);//2copyObj1.b=222;console.log(copyObj1.b);//222console.log(obj1.b);//2,可以看到修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的 复习：扩展运算符合并对象 如果合并的两个对象中都含有相同属性名的属性，则属性顺序还是按照前面对象的，但后面对象的属性值覆盖前面的。 不管是使用扩展运算符复制对象还是合并对象，他们都是浅拷贝的。 123456789101112131415161718192021const obj1 = &#123; a: 1, b: 2, c: &#123; aa: 3, bb: 4 &#125;, s:8&#125;;const obj2=&#123; a:555, d:33&#125;;const newObj=&#123; ...obj1, ...obj2&#125;;console.log(newObj);//&#123;a: 555, b: 2, c: &#123;…&#125;, s: 8, d: 33&#125;newObj.c.aa=999;console.log(obj1.c.aa);//999，证明合并对象也是浅拷贝的 部分新方法Object.is()判断全等(类似===) 语法：传入两个参数到Object.is() 返回值：全等则返回true，否则返回false。 与===的区别体现在+0与-0、NaN与NaN的判断上： 12345678console.log(Object.is(+0, -0));//falseconsole.log(+0 === -0);//trueconsole.log(Object.is(NaN, NaN));//trueconsole.log(NaN === NaN);//falseconsole.log(Object.is(true, false));//falseconsole.log(true === false);//false Object.assign()合并对象(类似...扩展运算符) assign:分配/赋值. 语法：Object.assign(对象1,对象2,对象3); Object.assign()类似...(扩展运算符),可用于合并对象。 Object.assign()与扩展运算符在合并对象时都是浅拷贝的。当合并的多个对象拥有相同属性时后面的属性值覆盖前面的。 12345678910111213141516//可以看到b的最终属性值是2，后面的覆盖前面的const allObj = Object.assign(&#123; a: 1 &#125;, &#123; b: 3 &#125;, &#123; b: 2 &#125;, &#123; c: 3, d: 4 &#125;);console.log(allObj);//&#123;a: 1, b: 2, c: 3, d: const obj = &#123; h: 1, i: &#123; j: 222, a: 66 &#125;&#125;const newObj = Object.assign(allObj, obj);console.log(newObj);//&#123;a: 1, b: 2, c: 3, d: 4, h: 1, i:&#123;j: 222, a: 66&#125;&#125;//浅拷贝newObj.i.j=999;console.log(obj.i.j);//999 Object.keys()和Object.values()和Object.entries() 注意：这三个方法都是返回对象自身的对应元素的，不包含对象内的对象的元素。 参数：对象。 Object.keys()返回由对象自身的键（属性名）组成的数组。（注意：数组每一项都是放在引号内的【字符串形式】） Object.values()返回由对象自身的值（属性值）组成的数组。 Object.entries()返回由对象自身的键值（属性名和属性值）组成的数组。 1234567891011const obj = &#123; a: 1, b: 2, c: &#123; j: 222, a: 66 &#125;&#125;console.log(Object.keys(obj));//[\"a\", \"b\", \"c\"]console.log(Object.values(obj)); //[1, 2, &#123;j: 222, a: 66&#125;]console.log(Object.entries(obj));//[[\"a\", 1], [\"b\", 2], [\"c\", &#123;j: 222, a: 66&#125;]] 补充：Object的hasOwnProperty()方法 语法：obj.hasOwnProperty(&quot;属性名&quot;) 参数：要检测的属性的 String 字符串形式表示的名称。 返回：布尔值，是对象自身属性则true，不是则false。 例子：下面“for-in遍历对象自身属性”的例子中。 补充：for-in判断对象自身属性(不推荐) 用 for-in 语句遍历对象属性时我们可以使用hasOwnProperty()方法判断属性来源。 关于for-in与hasOwnProperty()遍历对象自身属性的例子：12345678910111213const obj = &#123; a: 1, b: 2, c: &#123; j: 222, a: 66 &#125;&#125;for (let key in obj)&#123; if(obj.hasOwnProperty(key))&#123; console.log(key); &#125;&#125; Object.keys()结合for-of判断自身属性（推荐使用） 可使用Object.keys()代替上面例子中的hasOwnProperty()来判断是否为自身属性。 for-of语句遍历对象属性。 使用for-of语句与Object.keys()打印自身属性的例子： 1234567891011const obj = &#123; a: 1, b: 2, c: &#123; j: 222, a: 66 &#125;&#125;for (let key of Object.keys(obj)) &#123; console.log(key);&#125; 注意：for-of语句与Object.keys()搭配，for-in与hasOwnProperty()搭配。 for-in与Object.keys()与hasOwnProperty()区别 for-in遍历对象所有可枚举属性，包括原型链上的属性。 Object.keys()遍历对象所有可枚举属性，不包括原型链上的属性。(仅自身属性) 1234567const obj1 = &#123; a: 1&#125;;const obj = Object.create(obj1);//以obj1为原型创建对象objconsole.log(Object.keys(obj));//[],可以看到Object.keys()并未枚举原型上的属性obj.b = 22;console.log(Object.keys(obj));//[\"b\"] hasOwnProperty() 检查对象是否包含属性名，无法检查原型链上是否具有此属性名。结合for-in可遍历自身属性（同样不包含原型上的属性），但语句复杂且不是直接放入数组，故不推荐使用。 操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for-in循环，而用for-of与Object.keys()结合来代替。 for-in与for-of 无论是for-in还是for-of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for-in 语句以原始插入顺序迭代对象的可枚举属性。 for-of 语句遍历可迭代对象定义要迭代的数据。 for-in for-in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 使用for-in会遍历数组所有的可枚举属性，包括原型。index索引为字符串型数字，不能直接进行几何运算。故更加适合用于遍历对象。（不是对象属性！） 因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。因此当迭代访问顺序很重要的数组时，最好用整数索引去进行for循环（或者使用 Array.prototype.forEach() 或 for-of 循环）。 for-of【ES6引入】 for-of语句在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 for-of更加适合用于遍历对象属性。 for-in遍历的是数组的索引（即键名），而for-of遍历的是数组元素值，而不包括原型属性method和索引name。 __proto__属性读取对象原型 __proto__属性代表当前对象的原型。 很多浏览器不支持，只出现在ES6附录中没出现在正文。 调试的时候使用就好，不要使用在正式代码中。 例子：（下方“Object.setPrototypeOf()修改对象原型”的例子中） 比起__proto__属性更加推荐使用Object.getPrototypeOf()读取对象原型（下方详述）。 补充：Object.create()创建对象并指定原型 Object.create()用于创建一个对象时指定原型。 语法：const objName = Object.create(原型对象名); 例子：（下方“Object.setPrototypeOf()修改对象原型”的例子中） Object.setPrototypeOf()修改对象原型 语法：Object.setPrototypeOf(需要修改的对象名，新的原型名) Object.setPrototypeOf()性能底下，建议不要使用。 12345678910111213const obj1=&#123; a:1&#125;;const obj2=&#123; b:2&#125;const obj=Object.create(obj1);//以obj1为原型创建对象objconsole.log(obj.__proto__);//&#123;a: 1&#125;Object.setPrototypeOf(obj,obj2);//使用setPrototypeOf()将obj的原型改为obj2console.log(obj.__proto__);//&#123;b: 2&#125; 注意：console.log(obj);打印出的是{}。 Object.getPrototypeOf()读取对象原型 语法：Object.getPrototypeOf(对象名) 比起__proto__属性更加推荐使用Object.getPrototypeOf()读取对象原型。123456789const obj1 = &#123; a: 1&#125;;const obj = Object.create(obj1);//以obj1为原型创建对象objconsole.log(obj.__proto__);//&#123;a: 1&#125;console.log(Object.getPrototypeOf(obj));//&#123;a: 1&#125;console.log(obj.__proto__ === Object.getPrototypeOf(obj));//true super关键字(访问原型对象) 可以通过super关键字访问原型对象上的属性和方法。 注意：只有使用简洁表示法写函数才可以调用super关键字，换成箭头函数或者普通函数写法去调用super关键字会报错呢。123456789const obj=&#123;name:\"小明\"&#125;;const copyObj=&#123; say()&#123; console.log(`我的名字是$&#123;super.name&#125;`); &#125;&#125;//将对象copyObj的原型改为对象obj才可以在copyObj中通过supeobj的属性nameObject.setPrototypeOf(copyObj,obj);copyObj.say();//我的名字是小明","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 函数扩展","slug":"ES6扩展 函数扩展","date":"2019-11-12T13:05:20.000Z","updated":"2019-11-15T07:26:19.384Z","comments":true,"path":"2019/11/12/ES6扩展 函数扩展/","link":"","permalink":"http://yoursite.com/2019/11/12/ES6扩展 函数扩展/","excerpt":"默认参数 和解构赋值一样，ES6中也可以给函数一个默认参数，并且可以用简单的表达式来设定默认值。","text":"默认参数 和解构赋值一样，ES6中也可以给函数一个默认参数，并且可以用简单的表达式来设定默认值。 但要注意：用例子来解释，b的默认值表达式中不能出现b或者c，会报错（b、c未定义）。1234function add(a, b = 999 + a, c = 1) &#123; console.log(a, b, c);&#125;add(1);//1 1000 1 结合对象的解构赋值如果直接调用People（）函数，但什么对象都不传进去，此时则使用age的默认值38，name则undefined。如果调用People（）函数的同时将带有name属性值的对象传入则得到hhh 38： 12345function People(&#123; name, age = 38 &#125; = &#123;&#125;) &#123; console.log(name, age);&#125;People();//undefined 38,什么对象都不传People(&#123; name: \"hhh\" &#125;);//hhh 38，传入带有name属性值的对象 或者直接在对象的解构赋值等号右边设置和调用People（）函数的时候再传入name属性的效果也是一样的： 1234function People1(&#123; name, age = 38 &#125; = &#123;name:\"xiaohuang\"&#125;) &#123; console.log(name, age);&#125;People1();//xiaohuang 38 复习：arguments对象 arguments 是一个对应于传递给函数的参数的类数组对象。arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。 此对象包含传递给函数的每个参数，第一个参数在索引0处。[]语法可访问它的每一个元素: 123arguments[0]arguments[1]arguments[2] 参数也可以被设置： 1arguments[1] = 'new value'; arguments对象不是一个 Array实例 ，它类似于Array。 但除了length属性和索引元素之外没有任何Array属性（length属性确定传递参数的个数）。例如，它没有 pop 方法。 但是它可以被转换为一个真正的Array(下面“结合扩展运算符”中2个例子4种方法都可以将类数组转换为数组) MDN更多参考信息 结合扩展运算符...（剩余参数） 剩余参数...是做聚合的，而扩展运算符...是做展开的，符号都是...,但含义不同。 其实在下面这个例子中...表示剩余参数而不是扩展运算符，sum函数通过将所有的剩余参数1,2,3,4,&quot;ddd&quot;传进args做一个聚合将他们组转换为数组： 1234function sum(...args)&#123;//将传进来的类数组匹配到的剩余参数都放到args中组成数组 console.log(args);//[1, 2, 3, 4, \"ddd\"]&#125;sum(1,2,3,4,\"ddd\");//传入一个类数组,通过剩余参数可以转换为数组 在[1,2,...[1,2,3]];中...就表示扩展运算符，意为将[1,2,3]展开来放入另一个数组中。 除了上面例子，我们还可以回顾一下使用扩展运算符将类数组转换为数组的三种不同方法： 1234567function sum() &#123; let args = Array.prototype.slice.call(arguments); // let args = [...arguments]; // let [...args] = arguments; console.log(args);//[1, 2, 3, 4, \"ddd\"]&#125;sum(1, 2, 3, 4, \"ddd\");//传入一个类数组,通过剩余参数可以转换为数组 注意：无论...表示剩余参数还是扩展运算符，当它作为参数时她都必须在最后一个: 12345function op(type, ...nums) &#123; console.log(type);//sum console.log(nums);//[1, 2, 3, 4, 5]&#125;op(\"sum\", 1, 2, 3, 4, 5); 补充：回调函数 回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 注意：调用回调函数时是不需要()的，直接使用函数名！ 下面reduce()方法的第一个参数就是回调函数。 回调函数与调用普通函数的区别 性能没有区别。 回调函数是作为参数传递的,操作更加灵活。比如，你定义了函数a，b，c,那么使用回调函数时不用修改 a 的代码就可以让 a 调用 c、d、e….当你调用普通函数的时候不修改代码只能在函数a内运行函数b，就失去了变量的灵活性。 补充：数组的reduce()方法 reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。即，对数组每个元素执行回调函数，返回值用于下一次计算参数 reduce()方法的参数由回调函数和一个初始值参数组成。 语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 语法理解：reduce(function(回调返回的值,数组当前元素,当前元素序号值,调用reduce的数组) , 回调函数第一个参数的初始值); 返回值：返回计算结果 例子：12345678910111213141516171819&lt;body&gt;&lt;p&gt;点击按钮计算数组元素相加后的总和。&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;点我&lt;/button&gt;&lt;p&gt;数组元素总和: &lt;span id=\"demo\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt;var numbers = [65, 44, 12, 4];function getSum(total, num) &#123; return total + num;&#125;function myFunction(item) &#123; document.getElementById(\"demo\").innerHTML = numbers.reduce(getSum,0);&#125;&lt;/script&gt;&lt;/body&gt; 实现加法的函数 通过上面的例子我们可以知道传进来的类数组会被转换为数组numbers，而数组拥有累加方法reduce() 先设置参数total的默认值为0，第一次会将1传入num中，相加以后返回1给total；第二次则将2传入num中，相加以后返回3给total，以此类推得到最终total123456function sum(...numbers) &#123; return numbers.reduce(function (a, b) &#123; return a + b; &#125;, 0);&#125;console.log(sum(1,2,3,4));//10 相当于：（注意函数add的调用没有()） 1234567function add(total, num) &#123; return total + num; &#125;function sum(...numbers) &#123; return numbers.reduce(add, 0);&#125;console.log(sum(1, 2, 3, 4));//10 箭头函数=&gt;使用箭头函数可以省略function。 复习：数组的pop()用于删除最后一个元素，返回值为被删除的元素。 多个参数需要用(),多行代码时需要用{}12345const add1 = (a, b) =&gt; &#123; a += 1; return a + b;&#125;console.log(add1(2,4));//7 相当于： 12345const add1 = function (a, b)&#123; a += 1; return a + b;&#125;console.log(add1(2,4));//7 单行代码时可以省略{}和return,代码直接表示为返回值12const add2 = (a, b) =&gt; a + b;console.log(add2(1, 3));//4 单个参数时可省略()这种情况下pop()的返回值会被赋给arr，也就打印出3: 12const popArr1 = arr1 =&gt; arr1.pop();console.log(popArr1([1, 2, 3]));//3 不想要返回值可以添加void使返回值为undefined: 12const popArr2 = arr2 =&gt; void arr2.pop();console.log(popArr2([1, 2, 3]));//undefined 放在大括号里也可以，但没必要，推荐使用void: 12const popArr3 = arr3 =&gt; &#123; arr3.pop() &#125;;console.log(popArr3([1, 2, 3]));//undefined 不需要传参时只写()即可比如： 123log222 = () =&gt; &#123; console.log(222);&#125; 箭头函数和普通函数的区别箭头函数没有arguments对象在箭头函数中调用arguments报错： 1234const arg=()=&gt;&#123; console.log(arguments);&#125;arg(1,2,3);//报错：arguments is not defined at arg 但是我们可以使用扩展运算符代替arguments去拿传入的参数： 1234const arg=(...args)=&gt;&#123; console.log(args);&#125;arg(1,2,3);//[1, 2, 3] 箭头函数没有自己的this this:自动引用正在调用当前方法的.前的对象。 箭头函数获取到的this是调用他的对象当前所处对象的this，也就是调用他的对象的外层的this，不一定是windows。 例子中say1的this指向xiaoming，而say2的this却指向windows，它和xiaoming同级： 1234567891011const xiaoming=&#123; name:\"小明\", say1:function()&#123; console.log(this); &#125;, say2:()=&gt;&#123; console.log(this); &#125;&#125;xiaoming.say1();//&#123;name: \"小明\", say1: ƒ, say2: ƒ&#125;xiaoming.say2();//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125; 更加明显的例子： 123456789101112name=\"小红\";const xiaoming=&#123; name:\"小明\", say1:function()&#123; console.log(this.name); &#125;, say2:()=&gt;&#123; console.log(this.name); &#125;&#125;xiaoming.say1();//小明xiaoming.say2();//小红 回调函数中的this 回调函数中的this默认是指向windows的，因为本质上是在函数内callback,并没有.前的对象调用。 注意：回调函数和箭头函数不同，回调函数时指向windows，而箭头函数只是指向调用他的对象当前所处对象的this，也就是调用他的对象的外层的this，不一定是windows。 也就是说，如果回调函数中想要使用this有两种解决方法(如下)。 要么在使用回调函数之前利用闭包的特性先使用一个变量_this保存this： 12345678910111213const xiaoming = &#123; name:\"xiaoming\", age: null, getAge: function () &#123; let _this = this; //...ajax setTimeout(function () &#123; _this.age = 15; console.log(_this); &#125;, 1000); &#125;&#125;;xiaoming.getAge();//&#123;name: \"xiaoming\", age: 15, getAge: ƒ&#125; 要么将回调函数改为箭头函数，这样this取到外层的this，即我们需要的对象xiaoming： 123456789101112const xiaoming = &#123; name: \"xiaoming\", age: null, getAge: function () &#123; //...ajax setTimeout(() =&gt; &#123; this.age = 15; console.log(this); &#125;, 1000); &#125;&#125;;xiaoming.getAge();//&#123;name: \"xiaoming\", age: 15, getAge: ƒ&#125;","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"回调函数","slug":"JS回调函数","date":"2019-11-12T12:28:12.000Z","updated":"2019-11-25T08:39:07.513Z","comments":true,"path":"2019/11/12/JS回调函数/","link":"","permalink":"http://yoursite.com/2019/11/12/JS回调函数/","excerpt":"回调函数 回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。","text":"回调函数 回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 注意：调用回调函数时是不需要()的，直接使用函数名！ 例子：下面reduce()方法的第一个参数就是回调函数。 回调函数与调用普通函数的区别 性能没有区别。 回调函数是作为参数传递的,操作更加灵活。比如，你定义了函数a，b，c,那么使用回调函数时不用修改 a 的代码就可以让 a 调用 c、d、e….当你调用普通函数的时候不修改代码只能在函数a内运行函数b，就失去了变量的灵活性。 补充：数组的reduce()方法 reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。即，对数组每个元素执行回调函数，返回值用于下一次计算参数 reduce()方法的参数由回调函数和一个初始值参数组成。 语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 语法理解：reduce(function(回调返回的值,数组当前元素,当前元素序号值,调用reduce的数组) , 回调函数第一个参数的初始值); 返回值：返回计算结果 例子：12345678910111213141516171819&lt;body&gt;&lt;p&gt;点击按钮计算数组元素相加后的总和。&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;点我&lt;/button&gt;&lt;p&gt;数组元素总和: &lt;span id=\"demo\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt;var numbers = [65, 44, 12, 4];function getSum(total, num) &#123; return total + num;&#125;function myFunction(item) &#123; document.getElementById(\"demo\").innerHTML = numbers.reduce(getSum,0);&#125;&lt;/script&gt;&lt;/body&gt;","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6扩展 数值扩展","slug":"ES6扩展 数值扩展","date":"2019-11-12T02:29:50.000Z","updated":"2019-11-15T07:26:25.465Z","comments":true,"path":"2019/11/12/ES6扩展 数值扩展/","link":"","permalink":"http://yoursite.com/2019/11/12/ES6扩展 数值扩展/","excerpt":"新的进制表示法 以前八进制可以直接以0开头（octonary），为了将它与十进制区分开，ES6规定八进制必须以0O或者0o开头。 二进制则以0b或者0B开头（binary）。","text":"新的进制表示法 以前八进制可以直接以0开头（octonary），为了将它与十进制区分开，ES6规定八进制必须以0O或者0o开头。 二进制则以0b或者0B开头（binary）。 12console.log(0o16);//14console.log(0b111);//7 新的方法parseInt()与parseFloat()转换为整数与小数 ES6之前，parseInt()与parseFloat()都是挂在window对象上的，window可省略。ES6则将parseInt()与parseFloat()都放在了Number对象上。 但无论对象如何改变，parseInt()与parseFloat()的用途都没改变，依旧是可以将字符串或者数字转换为相应的整数或小数。1234console.log(window.parseInt(\"1.23\"));//1console.log(parseFloat(\"1.23\"));//1.23console.log(Number.parseInt(\"1.23\"));//1console.log(Number.parseFloat(\"1.23\"));//1.23 isNaN()判断是否“非数值” isNaN()判断是否“非数值”，遇到字符串会看能不能将其转换为数值再进行判断. 注意：只有遇到Nan他才会返回true，其他不管是什么类型，包括true与false都被算作是数值，返回false！123456console.log(Number.isNaN(NaN));//trueconsole.log(Number.isNaN(-NaN));//trueconsole.log(Number.isNaN(1)); //falseconsole.log(Number.isNaN('1'));//falseconsole.log(Number.isNaN(true));//falseconsole.log(Number.isNaN(false));//false isFinite()判断是否是无限的1234567console. log(Number. isFinite(Infinity)); //false，Infinity有限的console. log(Number. isFinite(2/0)); //falseconsole. log(Number. isFinite(2/4)); //trueconsole. log(Number. isFinite(1234)); //trueconsole. log(Number. isFinite('12341')); //falseconsole. log(Number. isFinite(true)); //falseconsole. log(Number. isFinite(NaN));//false 安全数 用来判断这个整数是否处于JS内表示的范围之内。 即判断这个整数是否在最大值Number.MAX_SAFE_INTEGER与最小值Number.MIN_SAFE_INTEGER之间。12console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER-1));//true,比最大值小1肯定是安全数console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1));//false 幂运算**(新的运算符) 注意：它是右结合的，也就是说，在没有括号的情况下他是自动从右往左进行运算的。 例子分析：a算出的是2的10次方1024；b如果是左结合则应该得到1，但是得到的是2，和d得到的值一样，也就是说**幂运算是右结合的；想要达到左结合的效果，可以像c一样使用括号。12345678let a = 2 ** 10;console.log(a);//1024let b = 2 ** 10 ** 0;console.log(b);//2let c = (2 ** 10) ** 0;console.log(c);//1let d = 2 ** (10 ** 0);console.log(d);//2","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 正则扩展","slug":"ES6扩展 正则扩展","date":"2019-11-11T10:47:25.000Z","updated":"2019-11-15T07:26:32.741Z","comments":true,"path":"2019/11/11/ES6扩展 正则扩展/","link":"","permalink":"http://yoursite.com/2019/11/11/ES6扩展 正则扩展/","excerpt":"复习：正则表达式简单来说就是用一定的规则去查找、替换符合这个规则的文本。","text":"复习：正则表达式简单来说就是用一定的规则去查找、替换符合这个规则的文本。 JS中生成RegExp对象的两种方法 RegExp 对象表示正则表达式。 修饰符包含属性** “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配**。 方法1：使用直接量的方式规则用//包裹起来，修饰符跟在后面： 1const regexp1=/规则/修饰符; 例子： 12//^表示开头，g表示全局匹配。即：开头为a的字符串就满足这个正则表达式const regexp1=/^a/g; 方法2：使用构造函数RegExp的方式规则和修饰符都用引号包裹起来： 1const regexp2=new RegExp('规则','修饰符'); 例子： 1const regexp2=new RegExp('^a','g'); 或者 1const regexp2=new RegExp(/规则/修饰符); 例子： 1const regexp3=new RegExp(/^a/g); 正则方法 字符串的正则方法有：match()、replace()、search()、split() 正则对象的方法有：exec()、test() 注意区分match()和exec()，他们都是返回匹配结果的数组，但区别如下表： match() exec() 字符串的正则方法，使用字符串对象进行调用 正则对象的方法，使用RegExp对象进行调用 返回的是匹配完成后完整的数组 每调用一次返回单次对应的匹配结果并用数组的方式显示 区分match()和exec()的例子：12345678910const r1 = /imooc/g;const str = \"imoocimooc_imooc\";console.log(r1.exec(str));//[\"imooc\", index: 0, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 5, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 11, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//nullconsole.log(str.match(r1));//[\"imooc\", \"imooc\", \"imooc\"] match() 方法 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值(数组)，而不是字符串的位置。 返回值:存放匹配结果的数组。 语法：12stringObject.match(searchvalue)stringObject.match(regexp) 参数 描述 searchvalue 必需。规定要检索的字符串值。 regexp 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 例子：在下面正则表达式完整例子中使用。 exec()方法 exec() 方法用于使用正则表达式，检索字符串中的正则表达式的匹配。 语法：RegExpObject.exec(要检索的字符串) 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 与match()类似，他们都是返回匹配结果的数组，但match()是字符串的正则方法（是使用字符串对象进行调用），exec()是正则对象的方法（使用RegExp对象进行调用）。 例子：在下面y粘连修饰符的例子*中使用。 test()方法 test()方法用于检测一个字符串是否匹配某个模式. 返回值：布尔型。如果字符串中有匹配的值返回 true ，否则返回 false。 注意：和match()类似，不过他返回的是布尔值而不是匹配值构成的数组。 语法：RegExp对象.test(要检测的字符串) 例子：在下面u修饰符的例子中使用。 正则表达式完整例子123456789101112131415//^表示开头，g表示全局匹配。即：开头为\"你\"的字符串就满足这个正则表达式const regexp1 = /^你/g;console.log(\"你好呀你好呀你好呀\".match(regexp1));//[\"你\"]const regexp2 = new RegExp(\"^你好\", \"g\");//不要漏掉g的引号console.log(\"你好呀你好呀你好呀\".match(regexp2));//[\"你好\"]const regexp3 = new RegExp(/^我/g);console.log(\"你好呀你好呀你好呀\".match(regexp3));//null，不符合规则const regexp4 = /你/g;//去掉^console.log(\"你好呀你好呀你好呀\".match(regexp4));//[\"你\", \"你\", \"你\"]const regexp5 = /你/;//去掉g,不再全局搜索console.log(\"你好呀你好呀你好呀\".match(regexp5));//[\"你\"] 正则表达式构造函数RegExp的变化不管有多少个“原来的修饰符”，都都会被”新增的修饰符”覆盖，注意：新增的修饰符需要引号 1const regexp = new RegExp(/规则/原来的修饰符,\"新增的修饰符\"); 例子： 1const regexp = new RegExp(/^你/igm,\"i\");//最后生效的是i 新增的u、y修饰符u修饰符 ES6 对正则表达式添加了 u 修饰符，含义为 “Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。 u修饰符的作用：使得要检测的字符串会被识别成一个字符而不是拆分成几个字符。使得可以正确处理四个字符的 UTF-16 编码。 例子： 1234//匹配开头为“\\ud83d”的字符串，结果返回true，可是\"\\ud83d\\udc36\"是\"🐶\"console.log(/^\\ud83d/.test(\"\\ud83d\\udc36\"));//true//加上u修饰符：console.log(/^\\ud83d/u.test(\"\\ud83d\\udc36\"));//false 例子分析：上面代码中，\\ud83d\\udc36 是一个四字节的UTF-16 编码，代表一个字符“🐶”。但是，ES5不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第一行代码结果为 true。 加了u修饰符以后，ES6就会识别其为一个字符，所以第二行代码结果为false。 y 粘连修饰符 y即 sticky（adj. 粘的；粘性的） y修饰符和g修饰符很像，他们都是全局匹配的，但y修饰符需要匹配到的第1个和第2个规则直接相粘连才能匹配到第2个，第一个匹配结束以后如果不是马上遇到第2个就停止匹配，返回null。 例子：123456789101112131415const r1 = /imooc/g;const r2 = /imooc/y;const str = \"imoocimooc_imooc\";console.log(r1.exec(str));console.log(r1.exec(str));console.log(r1.exec(str));console.log(r1.exec(str));console.log(\"-----------我是分割线-------------\");console.log(r2.exec(str));console.log(r2.exec(str));console.log(r2.exec(str)); 例子分析：可以看到全局匹配则可以的到3个“imooc”，而使用y（粘连修饰符）只能匹配到2个“imooc”。这是因为y需要匹配到的第一个和第二个规则直接相粘连才能匹配到第2个，在这个例子中第二个“imooc”匹配完以后出现了-于是就停止匹配了。","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子","slug":"ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子","date":"2019-11-07T13:31:20.000Z","updated":"2019-11-15T07:26:11.949Z","comments":true,"path":"2019/11/07/ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子/","link":"","permalink":"http://yoursite.com/2019/11/07/ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子/","excerpt":"ES6之前遍历字符串的方式步骤1：使用for循环","text":"ES6之前遍历字符串的方式步骤1：使用for循环 补充：charAt()查找字符 语法:stringObject.charAt(index) 功能:返回stringObject中index位置的字符. 例子：123456let str=\"我超级棒的！\";for(let i=0,len=str.length;i&lt;len;i++)&#123; // console.log(str[i]); console.log(str.charAt(i));&#125; 直接使用str[index]与str.charAt(index)效果一样。 步骤2：将字符串转换成数组补充：[].slice和Array.prototype.slice的区别 slice()截取，语法：arrayObject.clice(start,end);，start可省、end可省，返回值：数组。如果省略 start，则 slice 从索引 0 开始。 Array是一个构造函数。浏览器内置的特殊对象。 Array没有slice方法,但是”Array的实例[]“有slice方法。 Array.prototype原型上有方法slice()我们可以用Array.prototype.slice或者Array的实例[].slice都行，但不能Array.slice。 Array.prototype.slice.call(arguments)可以将类数组对象（如：字符串）转成数组。（下面的“将字符串转换成数组的各种方法”的“方法一”中有使用） 方法1 Array是一个构造函数。浏览器内置的特殊对象。Array没有slice方法。Array.prototype原型上有方法slice()我们可以用Array.prototype.slice或者Array的实例[].slice都行，但不能Array.slice。 Array.prototype.xx方法.call(str)可以使str调用Array的xx方法从而将字符串转换为数组。 slice()截取，语法：arrayObject.clice(start,end);，start可省、end可省，返回值：数组。如果省略 start，则 slice 从索引 0 开始。 call()传参使用方法：Array.prototype.slice.call(str);1234let str=\"我超级棒的！\";var oStr=Array.prototype.slice.call(str);console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 或者使用var oStr=Array.prototype.slice.call(str,0);也可以。 方法2使用字符串的split()进行切割可以将字符串转换成数组： 1234let str=\"我超级棒的！\";var oStr=str.split(\"\");console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 方法3使用字符串的解构赋结合扩展运算符值可以将字符串转换成数组： 使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。 使用扩展运算符时会把每个oStr中剩余未匹配的字符作为一项组成一个数组来匹配给oStr： 1234let str=\"我超级棒的！\";const [...oStr]=str;console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 方法4使用扩展运算符也可以将字符串转换成数组(即：创建数组oStr的时候，通过扩展运算符将字符串展开，字符串的每一个字符构成一个数组元素。)： 1234let str=\"我超级棒的！\";const oStr=[...str];console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 或者 12let str = \"antzone\";console.log([...str]);// [\"a\", \"n\", \"t\", \"z\", \"o\", \"n\", \"e\"] 补充：forEach()遍历数组的每个元素 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。 注意: forEach() 对于空数组是不会执行回调函数的。 语法：array.forEach(function(currentValue, index, arr), thisValue)12345678910111213141516&lt;body&gt;&lt;p&gt;点击按钮列出数组的每个元素。&lt;/p&gt;&lt;button onclick=\"numbers.forEach(myFunction)\"&gt;点我&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;demoP = document.getElementById(\"demo\");var numbers = [4, 9, 16, 25];function myFunction(item, index) &#123; demoP.innerHTML = demoP.innerHTML + \"index[\" + index + \"]: \" + item + \"&lt;br&gt;\"; &#125;&lt;/script&gt;&lt;/body&gt; 使用3个参数的例子 步骤3：对数组进行遍历使用数组的forEach()对数组进行遍历，整合上面的将字符串转换为数组则可以得到： 12345678let str=\"我超级棒的！\";//将字符串转换为数组var oStr=str.split(\"\");//使用数组的forEach()对数组进行遍历oStr.forEach(function(word)&#123; console.log(word);&#125;);console.log(oStr); ES6之前遍历字符串并进行加密的例子 注意： 可以使用对象名[&quot;property&quot;]来访问对象属性。 但是在该例子中可以发现并没有引号，有引号则取不到，这是因为切割字符串时我们使用的分隔符是引号，所以数组oStr中的每一个元素已经自带引号，即map的属性名word已经是有引号的了。（如下所示）123456789101112let str = \"我超级棒的！\";var oStr=str.split(\"\");//使用字符串的split()进行切割得到数组console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"]const map = &#123; 我: \"www\", 超: \"ccc\", 棒: \"bbb\",级:\"jjj\",的:\"ddd\",'！':\"lll\" &#125;;console.log(map[\"棒\"]);//bbb,注意这里的属性名需要放到引号内oStr.forEach(function(word,index)&#123; if(str.includes(word))&#123; oStr[index]=map[word]; &#125;&#125;);console.log(oStr);//[\"www\", \"ccc\", \"jjj\", \"bbb\", \"ddd\", \"lll\"]","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 字符串扩展","slug":"ES6扩展 字符串扩展","date":"2019-11-07T13:29:42.000Z","updated":"2019-11-15T07:25:52.204Z","comments":true,"path":"2019/11/07/ES6扩展 字符串扩展/","link":"","permalink":"http://yoursite.com/2019/11/07/ES6扩展 字符串扩展/","excerpt":"补充：敲代码中需要注意的地方永远记住对象的属性键值对中间是冒号不是等号！！（具体参考下方“模版字符串”的例子1）","text":"补充：敲代码中需要注意的地方永远记住对象的属性键值对中间是冒号不是等号！！（具体参考下方“模版字符串”的例子1） 补充：在js文件里插入html代码的规则 方法一：html代码放在一行内显示（去掉所有空格/tab/换行） 方法二：想要保留格式可以在每行代码尾部加反斜线\\ 普通字符串拼接中，与变量的拼接可使用+，行尾有+则不需要\\即可折行（如下图例子）但是+前后需要使用引号将html标签单独括起来。（复杂，推荐使用模板字符串） 模板字符串中插入html代码时可以换行，行尾不需要插入转义符\\，但要注意模板字符串是使用反引号`代替引号的。 复习：数组的join()将数组转换为字符串1数组.join(分隔符) 分隔符默认为, 参数类型为string，需要修改分隔符时注意用引号 复习：访问对象属性的两种方法 可以使用 对象名.property (例子1 ) 或对象名[&quot;property&quot;]( 例子2) 模版字符串模版字符串(注意:使用的是反引号！)： 1`一些值$&#123;想要拼接的值，变量等&#125;另一些值` 以前常用的字符串拼接： 1\"一些值\"+变量+\"另一些值\" 模板字符串中插入html代码时可以换行，行尾不需要插入转义符\\。 普通的字符串拼接插入html代码时不能换行，换行时行尾需要插入转义符\\。 例子1 从say1和say4可以看出，使用反引号`来代替最外层引号,使用${}将需要引入的变量括起来代替前后的连接符+。 从say2可以看出${}内还可以包裹${}。也就是模板字符串内还可以拼接模板字符串。 12345678910111213141516171819202122&lt;script&gt; const xiaoming = &#123; name: \"xiaoming\", age: 14, //永远记住属性键值对中间是冒号不是等号！！ say1: function() &#123; console.log(\"我叫\" + this.name.toUpperCase() + \",我今年\" + this.age + \"岁！\"); &#125;, say2: function() &#123; console.log(`我叫$&#123;`Mr.$&#123;this.name.toUpperCase() &#125;`&#125;,我今年$&#123;this.age &#125;岁！`); &#125;, say3: function() &#123; console.log(`我叫$&#123;this.name.toUpperCase() &#125;$&#123;this.age &#125;岁是我的年龄！`); &#125;, say4: function() &#123; console.log(`我叫$&#123;this.name.toUpperCase() &#125;,我今年$&#123;this.age &#125;岁！`); &#125; &#125; xiaoming.say1();//我叫XIAOMING,我今年14岁！ xiaoming.say2();//我叫Mr.XIAOMING,我今年14岁！ xiaoming.say3();//我叫XIAOMING14岁是我的年龄！ xiaoming.say4();//我叫XIAOMING,我今年14岁！&lt;/script&gt; 例子2在该例子中使用数组的join()将数组转换为字符串时类似于: 1[`&lt;li&gt;123&lt;/li&gt;`,`&lt;li&gt;456&lt;/li&gt;`].join(\"\") 会得到&lt;li&gt;123&lt;/li&gt;&lt;li&gt;456&lt;/li&gt;此时只要把准换好的字符串放入ul标签即可得到无序列表在代码1中，我们可以发现：字符串中插入html代码很麻烦，行尾需要插入转义符\\。 推荐将代码1插入html部分改为模板字符串：模板字符串中插入html代码时可以换行，行尾不需要插入转义符\\。在代码2中，我们可以发现： 模板字符串可以对模板字符串进行嵌套。 模板字符串内可以插入简单表达式（比如调用函数） 字符串的部分新方法padStart()与padEnd()补全字符串 第一个参数：补全后的字符串总长度 第二个参数：用来补全的字符串 返回值：字符串 语法：返回的字符串=调用该方法的字符串.padStart(补全后的字符串总长度,用来补全的字符串); 当参数1&gt;调用该方法的字符串长度+用来补全的字符串长度时，用来补全的字符串会被循环使用。（如下面例子str3） padStart()从调用该方法的字符串前面开始插入参数2给出的字符串 padEnd()从调用该方法的字符串后面开始插入参数2给出的字符串 123456789101112&#123; let str=\"L\" let str1=str.padStart(4,\"OVE\"); console.log(str1);//OVEL let str2=str.padEnd(4,\"OVE\"); console.log(str2);//LOVE let str3=str.padEnd(8,'OVE'); console.log(str3);//LOVEOVEO&#125; repeat()重复字符串 语法：返回的字符串=调用该方法的字符串.repeat(重复的次数); 注意：参数可以是大于-1的小数，如果是小数则取整（如：2.33取2，-0.88取0）123&#123; console.log(\"hlb\".repeat(5));//hlbhlbhlbhlbhlb&#125; 也可以自己实现一个简易的repeat方法： 123456//可以自己实现一个repeat方法，将需要重复的字符串str和重复次数num传进去function repeatMe(str,num)&#123; //（返回的数组+1）转换为字符串，间隔符为传入的字符串str return new Array(num+1).join(str);&#125;console.log(repeatMe(\"hlb\",3));//hlbhlbhlb startsWith()与endsWith()判断字符串开头、结尾 语法：需要被判断的字符串.startsWith(&quot;想要验证的字符或者字符串&quot;) 返回值：是则返回true，不是则返回false 字符串中中文/英文/标点符号都支持1234567891011121314151617&#123; const str=\"I am a extremely happy girl\"; console.log(str.startsWith(\"b\"));//false console.log(str.startsWith(\"I am\"));//true console.log(str.endsWith(\"py girl\"));//true console.log(str.endsWith(\"b\"));//false const str1=\"我超级棒的！\"; console.log(str1.startsWith(\"我\"));//true console.log(str1.startsWith(\"I\"));//false console.log(str1.endsWith(\"的！\"));//true console.log(str1.endsWith(\"b\"));//false&#125; include()查找是否含有某字符(串)语法：需要被查询的字符串.includes(&quot;需要查询的字符或字符串&quot;); 123456const str = \"I am a extremely happy girl\";if (str.includes(\"哈哈\")) &#123;//不存在 console.log(\"存在\");&#125;else&#123; console.log(\"不存在\"); &#125; 补充：没有include()前实现该功能的方法 在没有include()之前字符串使用查询字符串下标indexOf()的方式来判断字符串是否拥有另一个字符或者字符串。 原理：如果该字符串不包含参数中的字符或者字符串则返回值为-1，如果包含则返回值为数组下标。123456const str = \"I am a extremely happy girl\";if (str.indexOf(\"哈哈\") != -1) &#123;//不存在 console.log(\"存在\");&#125;else&#123; console.log(\"不存在\"); &#125; 补充：使用“按位取反~”简化上面例子 按位取反~可以简单的理解为~x=-(x+1) 使用按位取反替换上面的例子：123456const str = \"I am a extremely happy girl\";if(~str.indexOf(\"哈哈\"))&#123;//不存在 console.log(\"存在\");&#125;else&#123; console.log(\"不存在\"); &#125; 原理：当str.indexOf(&quot;哈哈&quot;)值为-1时就是没取到，此时使用按位取反结果为0，在if中0为false。 for-of()遍历（迭代）对象 for-of()语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环（遍历），调用自定义迭代钩子，并为每个不同属性的值执行语句。 语法： 123for (variable of iterable) &#123; //statements&#125; 参数：variable：在每次迭代中，将不同属性的值分配给变量。iterable：被迭代枚举其属性的对象。 补充：拥有迭代（遍历）器接口iterator的对象都可以使用for-of语句,比如： 12345const arr = [1, 2, 3, 4.4, \"lalal\", false];console.log(arr.keys());//Array Iterator &#123;&#125;,说明arr.keys()含有迭代器接口Iterator ，故可以使用`for-of`for (let i of arr.keys()) &#123; console.log(i);&#125; 例子： 迭代数组： 123456789let iterable = [10, 20, 30];for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 迭代字符串： 12345678let iterable = \"boo\";for (let value of iterable) &#123; console.log(value);&#125;// \"b\"// \"o\"// \"o\" 迭代去重函数Set()： 12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代arguments对象： 123456789(function() &#123; for (let argument of arguments) &#123; console.log(argument); &#125;&#125;)(1, 2, 3);// 1// 2// 3 迭代 DOM 元素集合，比如一个NodeList对象：MDN中关于NodeList的描述下面的例子演示给每一个 article 标签内的 p 标签添加一个 “read” 类： 123456//注意：这只能在实现了NodeList.prototype[Symbol.iterator]的平台上运行let articleParagraphs = document.querySelectorAll(\"article &gt; p\");for (let paragraph of articleParagraphs) &#123; paragraph.classList.add(\"read\");&#125; MDN中更多关于for-of的知识 for-of()遍历字符串 语法：for(let word of str){执行操作语句} 参数含义：word：当前循环到的元素str：需要遍历的字符串名 注意：word的数据类型是string，所以在下面的加密小例子中用它来当属性名调用对象属性时不需要再加引号！ for-of()还可以遍历对象属性，具体例子在笔记“ES6扩展 对象扩展”中。12345let str=\"我超级棒的！\";for (let word of str)&#123; console.log(word); console.log(typeof(word));//string&#125; 使用for-of()完成加密小例子 注意： 可以使用对象名[&quot;property&quot;]来访问对象属性。 但是在该例子中可以发现并没有引号，这是因为：word的数据类型是string，所以在下面的例子中用它来当属性名调用对象属性时不需要再加引号！ ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子在下一篇笔记。 新的Unicode表示法和遍历方式 概念：Unicode是一项标准包括字符集、编码方案等。 他是为了解决传统的字符编码方案的局限而产生的，为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 js中遇到\\u机器就知道后面跟的是码点，以前的Unicode只能识别0000-ffff之间的码点，现在可以使用{}将码点包起来识别超过0000-ffff这个范围的二进制编码。例如&quot;\\u{1f436}&quot;识别出小狗🐶（注意引号） 使用codePointAt()获取字符串中对应字符的一个码点 语法：&quot;对应字符&quot;.codePointAt(0).toString(16); 例子：123\"🐶\".codePointAt(0);//得到128054//128054是码点，但它是10进制的，要转换为16进制才是我们要的\"🐶\".codePointAt(0).toString(16);//得到\"1f436\" 补充：at()根据下标取字符虽然chrome不支持at()，但是后期可以使用软件将ES6代码转换成ES5，这里了解一下。 1\"🐶\".at(0);","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"百度前端技术学院 第五天学习总结","slug":"百度前端技术学院 第五天学习总结","date":"2019-11-06T12:02:35.000Z","updated":"2019-11-20T11:02:12.173Z","comments":true,"path":"2019/11/06/百度前端技术学院 第五天学习总结/","link":"","permalink":"http://yoursite.com/2019/11/06/百度前端技术学院 第五天学习总结/","excerpt":"补充：CSS块内文字居中参考方法 块内单方文字垂直居中 设置line-height与height相同。","text":"补充：CSS块内文字居中参考方法 块内单方文字垂直居中 设置line-height与height相同。 块内文水平居中 text-align: center; 补充：在github的readme中展示网页效果参考方法 盒模型的概念以及内外边距，宽度，高度，box-sizing等属性首先我们要明确盒模型分两种:标准盒模型和替代盒模型，他们的区别在于宽度和高度的计算方法不同。默认情况下，浏览器使用标准盒模型。如果要为元素打开替代盒模型，可以通过对其进行设置如下代码来实现： 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; box-sizing是个很新的属性，目前应该像上面例子中那样使用 -webkit-和 -moz-前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+的。 通过对比图可以很明显的发现：在标准盒模型中，盒子占用的总大小由框的宽度（width）和高度（height）以及任何填充（padding）和边框（border）相加得到。在替代盒模型中，宽度（width）是页面上可见框的宽度（不用加上padding与border），因此内容区域的宽度是该宽度减去填充和边框的宽度。注意：padding与margin属性值可以为1——4个，含义有所不同，如下表： 属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 inline、block和inline-block的概念首先，inline、block和inline-block都是display的属性值。 inlinedisplay属性inline可以让块元素像行内元素。 block display属性block可以使span元素像块元素。 内联元素高宽与他们的内容高宽一样，所以不能对内联元素设置宽度或高度，它们只是位于块级元素的内容中。 如果要控制内联元素的大小，则需要将其设置为类似块级元素display: block;。 inline-block 这个属性可以让内联盒子不与包含他的盒子内容重叠，也就是说他会让内联盒子的width与height属性生效。 直接从属性名也可以看出他可以让内联的盒子像一个块元素。 他会使元素在一行显示，仍然保持样式可设置。 浮动，清除浮动浮动(float属性)属性值有left、right。 清除浮动(clear属性)要注意及时清理浮动。如果不清楚浮动，所有在浮动下面的自身不浮动的内容都将围绕浮动元素，在最长的列旁边环绕着。 clear 属性值 含义 left 停止任何活动的左浮动 right 停止任何活动的右浮动 both 停止任何活动的左右浮动 建议使用::after 伪元素来清除浮动：只需要给想要浮动的元素一个div框起来并给这个div添加.clearfix并在css里设置如下代码就可以使这个div以后的元素都停止浮动： 12.clearfix::after &#123;content:\".\"; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; ::after的意思是在.clearfix内部的最后加入伪元素::after 首先要显示伪元素，所以display:block 然后为伪元素加入空内容，以便伪元素中不会有内容显示在页面中，所以， content:&quot;&quot;；(.也可以，只要加上visibility:hidden;) 其次，为使伪元素不影响页面布局，将伪元素高度设置为0，所以， height:0 最后，要清除浮动，所以，clear:both。 after伪元素其实是通过 content 在元素的后面生成了内容为一个点的块级元素。这样一来只要设置这两个非浮动元素之间的距离就行了。 使用::after清除浮动的例子未清除浮动时“联系方式”与“姓名”等信息在同一行。因为姓名、性别和应聘职位是浮动三列，所以如果我们希望“联系方式”出现在“姓名”正下方就需要清除浮动。 1234567891011121314151617181920&lt;body&gt; &lt;h1&gt;简历&lt;/h1&gt; &lt;h2&gt;基本信息&lt;/h2&gt; &lt;div class=\".clear\"&gt; &lt;div&gt; &lt;strong&gt;姓名&lt;/strong&gt; &lt;span&gt;张三&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;strong&gt;性别&lt;/strong&gt; &lt;span&gt;男&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;strong&gt;应聘职位&lt;/strong&gt; &lt;span&gt;Web前端工程师&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;h2&gt;联系方式&lt;/h2&gt;&lt;/body&gt; 1234567891011121314151617181920212223div div:nth-of-type(1) &#123; width: 10%; float: left;&#125;div div:nth-of-type(2) &#123; width: 10%; float: left;&#125;div div:nth-of-type(3) &#123; width: 20%; float: left;&#125;.clear::after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden;&#125; 如何使用浮动进行布局设置float属性参考MDN浮动","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"jQuery入门","slug":"JQuery入门","date":"2019-11-05T13:27:50.000Z","updated":"2019-11-05T13:28:09.688Z","comments":true,"path":"2019/11/05/JQuery入门/","link":"","permalink":"http://yoursite.com/2019/11/05/JQuery入门/","excerpt":"补充：结构层、表示层、行为层 结构层：HTML文件 表示层：CSS文件 行为层：JS文件","text":"补充：结构层、表示层、行为层 结构层：HTML文件 表示层：CSS文件 行为层：JS文件 jQueryjQuery是一个JavaScript函数库jQuery是一个轻量级的“写得少，做的多”的JavaScript库 jQuery引用 先去下载jQuery文件 使用jQuery只需要在页面的中引入jQuery 文件即可（注意需要在引入自己的js文件的上面先引入jQuery 文件） $的使用 $是一个变量。 jQuery 把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名。(变量$冲突时可以使用变量jQuery代替它) 绝大多数时候，我们都直接用$。 若$变量已被占用，且不能改，就只能使用jQuery 这个变量。（$===jQuery） jQuery的书写格式jQuery 不变的宗旨是你用什么就选什么。 1jQuery（selector，context） 建议使用下面的方式写jquery： 123$(document).ready(function()&#123;$('div').addClass('div');//这中间写的是jquery代码&#125;); 将jquery代码包含在$(document).ready(function(){}中而不是直接在js文件中书写jquery代码的原因是：我们在html文件中加载js文件是从上至下的，此时jquery代码的js文件放在head中，这就导致运行该js文件时body中的元素还未加载，也就是例子中的div都还不存在，$(document).ready(function(){}的意思就是等到document都准备好了才运行其中的代码。 补充：HTML&lt;nav&gt;标签 &lt;nav&gt;标签定义导航链接的部分,是 HTML 5 中的新标签。 例子 补充：vscode同时选中多行输入按shift+alt，再使用鼠标拖动，可以出现竖直的列光标，同时可以选中多列进行输入。 jquery中CSS方法补充：.eq方法用于选择/遍历变量名.eq(i) .css方法用于修改css样式变量名.css({操作}) 例子获取导航条nav标签中的多个a标签为变量alinks（他会成为一个数组，所以修改a标签的样式需要遍历）已经屏蔽的是原生js的写法。 .text方法用于改变文字内容变量名.text({操作}) 例子 .html方法用于改变文本的同时读取html标签在获取html元素以后使用.html方法可以在改变文本的同时读取插入的html标签。（比如例子中就读取了&lt;strong&gt;实现了加粗效果）变量名.html({操作}) 例子","categories":[{"name":"jQuery学习","slug":"jQuery学习","permalink":"http://yoursite.com/categories/jQuery学习/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"CSS:position属性 相对定位与绝对定位","slug":"CSS position属性 相对定位与绝对定位","date":"2019-11-05T12:30:15.000Z","updated":"2019-11-21T02:45:54.034Z","comments":true,"path":"2019/11/05/CSS position属性 相对定位与绝对定位/","link":"","permalink":"http://yoursite.com/2019/11/05/CSS position属性 相对定位与绝对定位/","excerpt":"补充：设置行内元素的宽高想要设置行内元素的宽高需要先把display设置为block。","text":"补充：设置行内元素的宽高想要设置行内元素的宽高需要先把display设置为block。 补充：两个相对单位vw：相对单位，1vw=可视窗口宽度的1%vh：相对单位，1vh=可视窗口高度的1% 补充：防止溢出防止溢出或者产生滚动条可以使用overflow:hidden; position 属性position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。 属性值 含义 absolute 生成绝对定位的元素，不为元素预留空间。通过指定元素相对于最近的非 static定位祖先元素的偏移，来确定元素位置。（如果所有父元素都没是默认position值则绝对定位元素相对文档的 body 元素(即相对于浏览器窗口)进行定位，并且它会随着页面滚动而移动）绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成固定定位的元素，不为元素预留空间。相对于视图（屏幕内的网页窗口）进行定位。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）【即预留空间】 static 默认值。没有定位，元素出现在正常的流中（此时 top, right, bottom, left 和 z-index 属性无效）。 sticky 基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从浏览器窗口顶部10像素）之后它变得固定。必须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。常用于定位字母列表的头部元素 默认值static 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 相对定位relative 生成相对定位的元素，文档流中将为元素预留空间。 相对定位会相对元素的原始位置对该元素进行移动。 top, bottom, left, right属性光是指定position属性值为relative会发现元素并无变化，此时应配合使用top, bottom, left, 和 right属性值来精确指定要将定位元素移动到的位置。 1234567891011121314&lt;body&gt; &lt;h1&gt;Basic document flow&lt;/h1&gt; &lt;p&gt;I am a basic block level element. My adjacent block level elements sit on new lines below me.&lt;/p&gt; &lt;p class=\"positioned\"&gt;By default we span 100% of the width of our parent element, and we are as tall as our child content. Our total width and height is our content + padding + border width/height.&lt;/p&gt; &lt;p&gt;We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both.&lt;/p&gt; &lt;p&gt;inline elements &lt;span&gt;like this one&lt;/span&gt; and &lt;span&gt;this one&lt;/span&gt; sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements will &lt;span&gt;wrap onto a new line if possible (like this one containing text)&lt;/span&gt;, or just go on to a new line if not, much like this image will do: &lt;img src=\"https://mdn.mozillademos.org/files/13360/long.jpg\"&gt; &lt;/p&gt;&lt;/body&gt; 1234567891011121314151617181920212223body &#123; width: 500px; margin: 0 auto; &#125; p &#123; background: aqua; border: 3px solid blue; padding: 10px; margin: 10px; &#125; span &#123; background: red; border: 1px solid black; &#125; .positioned &#123; position: relative; background: yellow; top: 30px; left: 30px; &#125; 绝对定位absolute 使用position:absolute;生成绝对定位的元素，它会相对于第一个非 static 的父元素进行定位。 生成绝对定位的元素，不为元素预留空间。 如果所有的父元素都没有显式地定义position属性(即全部是默认值)，那么所有的父元素默认情况下position属性都是static。结果，绝对定位元素会相对于文档的 body 元素(即相对于浏览器窗口)进行定位，并且它会随着页面滚动而移动。（通过子绝父相可使绝对定位元素相对“相对定位”的父元素进行定位） 将上面例子中的position值改为absolute:1position: absolute; 定位上下文（子绝父相） 上面的例子绝对定位元素会相对于文档的 body 元素进行定位，并且它会随着页面滚动而移动。（可以通过子绝父相来解决这一问题） 可以通过设置绝对定位元素的其中一个父元素的定位属性为相对定位relative来使得绝对定位元素不相对初始块容器进行定位，比如下面例子中将body的css样式设为position: relative;就可以使得body中绝对定位的p元素相对body进行定位。 【子绝父相】：我们可以改变定位上下文(绝对定位的元素的相对位置元素)来使绝对元素相对于body进行定位，而不是相对于浏览器窗口进行定位。也就是设置绝对定位元素的其中一个父元素的定位属性为相对定位relative，给body添加css样式：1position: relative; z-index属性更改堆叠顺序 z-index属性只适用于定位元素（position属性值为static的对象不是定位元素） 可以通过修改z-index属性值更改元素堆叠顺序。 我们使用水平（x轴）和垂直（y轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。（0,0）位于页面（或元素）的左上角，x和y轴跨页面向右和向下（适合从左到右的语言）。 网页也有一个z轴：一条从屏幕表面到你的脸的虚线。z-index 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有z-index为auto，实际上为0。 注意，z-index只接受无单位索引值；你不能指定你想要一个元素是Z轴上23像素。较高的值将高于较低的值，但使用2和3将产生与300和40000相同的效果。 例子1 当出现多个绝对定位元素时，源顺序中排在后面的元素将出现在排在前面的元素的顶部,比如给上面的例子加上下面代码，使得第一段文字也变成绝对定位（之前是只有第二段文字绝对定位）：123456p:nth-of-type(1) &#123; position: absolute; background: lime; top: 10px; right: 30px; &#125; 可以看到第一段文字绿色绝对定位出现在了第一段文字黄色绝对定位的下方。 修改z-index值，使得第一段文字绿色绝对定位出现在了第一段文字黄色绝对定位的上方，将以下声明添加到 p:nth-of-type(1) 规则中：1z-index: 1; 例子2（相同z-index谁上谁下） 如果两个元素都没有设置z-index，使用默认值，一个定位一个没有定位，那么定位元素覆盖未定位元素：12&lt;div style=\"position:relative;top:50px;width:200px;height:200px;\"&gt;&lt;/div&gt;&lt;div style=\" width:100px;height:100px;\"&gt;&lt;div&gt; 如果两个元素都没有定位发生位置重合现象或者两个都已定位元素且z-index相同发生位置重合现象，那么按文档流顺序，后面的覆盖前面的:12&lt;div style=\"position:relative;width:200px;height:200px;\"&gt;&lt;/div&gt;&lt;div style=\"position:relative; top:-50px; width:100px;height:100px;\"&gt;&lt;div&gt; 例子3（父子关系谁上谁下）如果父元素z-index有效，那么子元素无论是否设置z-index都和父元素一致，都会出现在父元素上方（按文档流顺序，后面的覆盖前面的）： 123&lt;div style=\"position:relative;width:200px;height:200px;z-index:10;\"&gt; &lt;div style=\"position:relative;width:100px;height:100px;z-index:-5;\"&gt;&lt;div&gt;&lt;/div&gt; 虽然子元素设置z-index比父元素小，但是子元素仍然出现在父元素上方(子元素z-index=-5未生效):如果父元素z-index失效（未定位或者使用默认值），那么定位子元素的z-index设置生效: 123&lt;div style=\"position:relative;width:200px;height:200px;\"&gt; &lt;div style=\"position:relative;width:100px;height:100px;z-index:-5;\"&gt;&lt;div&gt;&lt;/div&gt; 子元素z-index=-5生效，被父元素覆盖: 固定定位fixed fixed与与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响。 而当父元素都是默认position属性值时，absolute固定元素是相对于body元素（即浏览器窗口）的，它会随着页面滚动而移动。 生成固定定位的元素，也不为元素预留空间。 这意味着您可以创建固定的有用的UI项目，如持久导航菜单。 但移动浏览器对 fixed 的支持很差，可以通过参考这个解决 粘性定位sticky sticky是一个比其他属性要新一些的属性。这基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从浏览器窗口顶部10像素）之后它变得固定。 粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。 必须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;dl&gt; &lt;dt&gt;A&lt;/dt&gt; &lt;dd&gt;Andrew W.K.&lt;/dd&gt; &lt;dd&gt;Apparat&lt;/dd&gt; &lt;dd&gt;Arcade Fire&lt;/dd&gt; &lt;dd&gt;At The Drive-In&lt;/dd&gt; &lt;dd&gt;Aziz Ansari&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;C&lt;/dt&gt; &lt;dd&gt;Chromeo&lt;/dd&gt; &lt;dd&gt;Common&lt;/dd&gt; &lt;dd&gt;Converge&lt;/dd&gt; &lt;dd&gt;Crystal Castles&lt;/dd&gt; &lt;dd&gt;Cursive&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;E&lt;/dt&gt; &lt;dd&gt;Explosions In The Sky&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;T&lt;/dt&gt; &lt;dd&gt;Ted Leo &amp; The Pharmacists&lt;/dd&gt; &lt;dd&gt;T-Pain&lt;/dd&gt; &lt;dd&gt;Thrice&lt;/dd&gt; &lt;dd&gt;TV On The Radio&lt;/dd&gt; &lt;dd&gt;Two Gallants&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031* &#123; box-sizing: border-box;&#125;dl &#123; margin: 0; padding: 24px 0 0 0;&#125;dt &#123; background: #B8C1C8; border-bottom: 1px solid #989EA4; border-top: 1px solid #717D85; color: #FFF; font: bold 18px/21px Helvetica, Arial, sans-serif; margin: 0; padding: 2px 0 0 12px; position: sticky; top: -1px;&#125;dd &#123; font: bold 20px/45px Helvetica, Arial, sans-serif; margin: 0; padding: 0 0 0 12px; white-space: nowrap;&#125;dd + dd &#123; border-top: 1px solid #CCC&#125; （完整例子） 子绝父相（涉及重叠就要考虑子绝父相）子元素绝对定位，父元素相对定位。 例子我们有很多张图片img放在同一个div标签内，希望得到一个多张图片重叠居中显示在白色背景板上的效果：代码1：代码1实现效果：可以看到图片并未居中也未重叠：解决方法：使用“子绝父相”后：代码2实现效果：可以看到图片已经居中重叠。 绝对定位absolute与fixed 通过绝对定位，元素可以放置到页面上的任何位置。 绝对的永远在样式层叠表的上层。（想要让他处于下层可以将后面的元素设置成相对定位，如下面的”绝对定位与相对定位结合的例子”最后的解决方法，如果还不行就改变z轴位置） 绝对定位与相对定位结合的例子想要实现的效果：导航栏中的a标签背后有一条细长的白色线。 尝试实现的代码1：代码1效果：出现问题原因：绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于ICB（inital container block, 初始包含块）。而我们在白色横条的周围并没有设置非默认值的position，所以他会相对于初始包含块（也就是body）进行定位，所以就跑到上面去了。解决方法：将nav改成相对定位，这样绝对定位就会相对于nav进行定位。修改以后的效果：绝对定位的白色横条覆盖在了导航栏的上面。出现问题原因：绝对定位永远在上层。解决方法：将nav中的a标签改为相对定位。(这样他就不是默认属性值，a标签又跟在nav:before的后面，自然而然就会覆盖白色细条)","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"vscode同时选中多行输入","slug":"vscode","date":"2019-11-05T07:02:57.000Z","updated":"2019-11-05T07:03:51.375Z","comments":true,"path":"2019/11/05/vscode/","link":"","permalink":"http://yoursite.com/2019/11/05/vscode/","excerpt":"vscode同时选中多行输入按shift+alt，再使用鼠标拖动，可以出现竖直的列光标，同时可以选中多列进行输入。","text":"vscode同时选中多行输入按shift+alt，再使用鼠标拖动，可以出现竖直的列光标，同时可以选中多列进行输入。 例子以&lt;nav&gt;标签为例： 在html文件中输入nav&gt;a*5得到： 按住shift+alt，再使用鼠标左键拖动可同时选中并进行输入。 也可以使用该方法一次性将多行文本引入：","categories":[{"name":"vscode使用过程中的小tips","slug":"vscode使用过程中的小tips","permalink":"http://yoursite.com/categories/vscode使用过程中的小tips/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"hexo部署到github后页面效果无变化","slug":"hexo部署到github后页面效果无变化","date":"2019-11-05T03:06:48.000Z","updated":"2019-11-05T03:06:51.652Z","comments":true,"path":"2019/11/05/hexo部署到github后页面效果无变化/","link":"","permalink":"http://yoursite.com/2019/11/05/hexo部署到github后页面效果无变化/","excerpt":"问题描述修改了hexo的部分内容后成功push到了github上，但页面效果无变化。","text":"问题描述修改了hexo的部分内容后成功push到了github上，但页面效果无变化。 解决方法清除浏览器缓存。以谷歌chrom为例： 点击右上角 点击“更多工具”-“清除浏览器缓存” 点击“清除数据”","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo可以本地预览但deploy到github失败","slug":"hexo可以本地预览但deploy到github失败","date":"2019-11-05T02:57:45.000Z","updated":"2019-11-05T03:05:20.713Z","comments":true,"path":"2019/11/05/hexo可以本地预览但deploy到github失败/","link":"","permalink":"http://yoursite.com/2019/11/05/hexo可以本地预览但deploy到github失败/","excerpt":"背景之前修改了hexo内容后在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后都可以成功部署（push）到github上，这一次修改了_config.yml中的部分配置后发现页面效果未发生更改且无法push到github上。","text":"背景之前修改了hexo内容后在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后都可以成功部署（push）到github上，这一次修改了_config.yml中的部分配置后发现页面效果未发生更改且无法push到github上。 问题描述在git bush中使用hexo s时可以在本地预览到正确的页面效果，但是使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后发现并未部署到github上。并且在git bush中出现类似 FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: ...错误 解决方法_config.yml中配置项的冒号后面要用空格隔开，再跟内容","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"解构赋值（2）","slug":"解构赋值（2）","date":"2019-11-02T13:30:00.000Z","updated":"2020-01-22T09:29:09.937Z","comments":true,"path":"2019/11/02/解构赋值（2）/","link":"","permalink":"http://yoursite.com/2019/11/02/解构赋值（2）/","excerpt":"字符串的解构赋值和数组的解构赋值使用方法是类似的，使用[]，空格也会被匹配到，不使用扩展运算符时返回的是字符，使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。","text":"字符串的解构赋值和数组的解构赋值使用方法是类似的，使用[]，空格也会被匹配到，不使用扩展运算符时返回的是字符，使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。 等号左边是数组结构，右边是字符串let [a,b,c,d]=const &quot;I am hlz&quot; 左边的[]中为需要赋值的变量 右边为需要解构的字符串 结合扩展运算符（...）将字符串转换为数组使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。 例子中spStr1与spStr2、spStr3得到的都是一样的。 spStr1使用的是字符串的解构赋值与扩展运算符结合。 spStr2使用的是字符串的split方法。 spStr3使用的是纯粹的扩展运算符，可以理解为“展开运算符”，较难理解，通过下面2个例子来解释： 在创建数组(例子中的oStr)的时候，通过扩展运算符将字符串展开，字符串的每一个字符构成一个数组元素。 1234let str=\"我超级棒的！\";const oStr=[...str];console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 或者 12let str = \"antzone\";console.log([...str]);// [\"a\", \"n\", \"t\", \"z\", \"o\", \"n\", \"e\"] 提取属性（了解即可） 数值与布尔值的解构赋值（了解即可）数值与布尔值的解构赋值与对象的结构赋值方法类似。他获取到的是数值与布尔值的属性。在这个例子中我们先是获取到数值1的属性valueOf，并将其赋给vo，当然不赋给vo也是可以的，结果可以看到是获取成功了。（关于valueOf 方法）然后我们获取布尔值true的属性toString，并将其赋给ts，当然不赋给ts也是可以的，结果可以看到也是获取成功的。我们可以通过数值的解构赋值得到属性valueOf，但是却无法直接通过1.valueOf来获取属性valueOf，这是因为我们在对数值或者布尔值进行解构赋值时会先将他们转换为包装对象再获取属性。str是一个字符串对象，给他一个属性a以后发现并查询不到，这是因为他先把str转换为包装对象以后才进行属性的获取，相当于先把str包装成sStr 函数参数的解构赋值在上图的例子中，我们将传进的参数（数组）进行解构赋值放入变量x与y中，并将他们在返回时调换位置。 Node.js 函数引用 与解构赋值为什么有时候引用外部js文件中的函数时要使用{}进行解构赋值？ 可以看笔记“Node.js函数引用与解构赋值” React.js与解构赋值可以看笔记“React.js基础精讲（1）”","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"解构赋值（1）","slug":"解构赋值（1）","date":"2019-11-02T13:00:00.000Z","updated":"2020-02-01T06:17:08.020Z","comments":true,"path":"2019/11/02/解构赋值（1）/","link":"","permalink":"http://yoursite.com/2019/11/02/解构赋值（1）/","excerpt":"补充：扩展运算符位置 对象中的扩展运算符（…）用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中(数组也一样，自己替换) 扩展运算符用作合并时他是放在需要被合并的数组/对象前的。 扩展运算符用作表示将还未匹配的数据包起来匹配给某变量时放在该变量前面。","text":"补充：扩展运算符位置 对象中的扩展运算符（…）用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中(数组也一样，自己替换) 扩展运算符用作合并时他是放在需要被合并的数组/对象前的。 扩展运算符用作表示将还未匹配的数据包起来匹配给某变量时放在该变量前面。 解构赋值 解构赋值语法是一个JavaScript表达式，它可以将值从数组或属性从对象中提取到不同的变量中。–MDN 我认为，解构赋值可以将 值从数组 或 属性从对象 中提取到不同的变量或者常量const中。 举例理解：对象中,const {name} = obj;等价于const name = obj.name; 数组与对象的解构赋值相对重要一些，字符串、数值与布尔值、函数的解构赋值建立在数组与对象的解构赋的基础之上。 数组的解构赋值 等号两边都是数组结构let [a,b,c,d]=const[1,2,3,4] 左边的[]中为需要赋值的变量 右边为需要解构的数组 更复杂的匹配规则 默认值 在数组的解构赋值中可以使用=设置默认值，当解构赋值中匹配到undefined时自动使用默认值。 const常量没有匹配到默认值时在这并不会报错，会反回undefined。 注意：一定是undefined才会使用默认值，null不会。 交换变量使用数组的解构赋值可以使交换变量更加方便。 接收多个“函数返回值”使用数组的解构赋值可以使接收多个“函数返回值”更加方便。注意：return返回的是一个数组，第一项返回的是布尔值，第二项是一个对象，第三项返回字符串。通过数组的解构赋值可以将函数的多个返回值分别获取为status、data、msg。 数组的解构赋值与扩展运算符（...)结合用法1：通过扩展运算符可以将多个数组合并为一个数组。 用法2：注意：扩展运算符与数组的解构赋值结合使用时只能放在最后，因为扩展运算符在这的意思是将数组后面剩余的还未匹配的值都包起来赋给使用了扩展运算符的那个变量。变量a和b分别取到1和2，扩展运算符使得arr中剩余的3,4,5,6都包在一个数组内给了变量c。 对象的解构赋值 对象的结构赋值与数组的结构赋值相似。 等号左右两边都为对象结构const{a，b}={a：1，b：2} 左边的{}中为需要赋值的变量（常量） 右边为需要解构的对象 注意：等号左边的变量名必须与等号右边的对象属性完全一致才能匹配到，不一致则会返回undefined。 数组的解构赋值之所以不需要左右一样是因为数组是有序的，他可以通过数组下标进行查找。而对象是无序的，所以必须要变量名与属性名一致才能完成查找。 帮助理解：const { saber } = obj;相当于const saber = obj.saber; 稍微复杂的解构条件总结：可以将数组的解构赋值和对象的解构赋值一起使用，只要保证等号两边模式一致就能匹配上。（如何才是保证等号两边模式一致可以看第三个例子） 只想获取skill中的数组第一项而不想获取skill时，可以在对象的解构赋值中使用数组的解构赋值，此时就可以使用skill1,因为数组解构赋值对命名没有要求。（注意：要保证两边模式一致，不要漏掉对象的解构赋值和数组的解构赋值中间的冒号） 在对象中使用数组的解构赋值，获取skillNarme属性值注意：等号左右两边要模式一致才能匹配成功！所以不要漏掉大括号、冒号、中括号！ const不能重复定义，而{skillName}的意思是“获取skll中验组第二项的skillName属性值并赋给常量skillName”，所以采用{skillName：sklName}以免出现两个常量skillName而报错 结合扩展运算符（...）使用（...）获取剩余属性 如果只知道对象的部分属性名又想获取剩余的属性时可以使用扩展运算符（其实这里应该叫剩余参数，他们符号相同含义不同）。 扩展运算符（...oth）在对象的解构赋值中的作用是获取没有匹配到的剩余属性并把它们作为对象包起来返回。 123456789101112&lt;script&gt; const obj = &#123; a: \"lalalla\", b: \"kkk\", c: \"hahah\" &#125;; const &#123; b, ...other &#125; = obj; //查询other得到&#123;a: \"lalalla\", c: \"hahah\"&#125;&lt;/script&gt; 使用扩展运算符复制对象 使用扩展运算符复制对象是浅拷贝的。 也就是说当你复制的对象obj1中包含一个对象c时，你实际上复制的是c的引用，当你修改复制所得到的对象copyObj1中的对象c的aa属性时，被复制的obj1对象中的对象c的属性aa也会被改变。 而修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的：123456789101112131415161718const obj1=&#123; a:1, b:2, c:&#123; aa:3, bb:4 &#125;&#125;;const copyObj1=&#123;...obj1&#125;;console.log(copyObj1.c.aa);//3copyObj1.c.aa=999;console.log(copyObj1.c.aa);//999console.log(obj1.c.aa);//999,可以发现obj1的c中的aa也被修改了console.log(copyObj1.b);//2copyObj1.b=222;console.log(copyObj1.b);//222console.log(obj1.b);//2,可以看到修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的 扩展运算符合并对象 如果合并的两个对象中都含有相同属性名的属性，则属性顺序还是按照前面对象的，但后面对象的属性值覆盖前面的。（例子如下） 不管是使用扩展运算符复制对象还是合并对象，他们都是浅拷贝的。（例子如下）123456789101112131415161718192021const obj1 = &#123; a: 1, b: 2, c: &#123; aa: 3, bb: 4 &#125;, s:8&#125;;const obj2=&#123; a:555, d:33&#125;;const newObj=&#123; ...obj1, ...obj2&#125;;console.log(newObj);//&#123;a: 555, b: 2, c: &#123;…&#125;, s: 8, d: 33&#125;newObj.c.aa=999;console.log(obj1.c.aa);//999，证明合并对象也是浅拷贝的 如何对已经申明了的变量进行对象的解构赋值首先我们要明确，虽然可以解决这个问题，但还是建议变量的申明与对象解构赋值同时进行。（也就是例子中的第一张图片） 解决方法：使用小括号将这一条解构赋值的语句括起来即可。 例子：下图变量age是已经申明才进行解构赋值的，此时{}会被认为是块级作用域而不是对象的解构赋值，想要将对象obj赋给一个块级作用域就报错了。 默认值和数组的解构赋值的默认值用法一样，使用=,当属性没有匹配到或者匹配到undefined时就会返回默认值。 对象的解构赋值的主要用途提取对象属性在上图中可以看到hobby属性是没有获取到的，我们只获取了name属性以及hobby属性中的数组第一项。想要获取hobby属性需要在对象的解构赋值中另外加上hobby： 使用对象传入乱序的函数参数在这个例子中可以看到调用AJAX函数会传入一个对象作为参数，在这里我们使用AJAX函数时传入的参数具有属性url、data，虽然没有type，但是type有默认值，所以最后打印出来的是默认值get。data和url的顺序可以颠倒，毕竟对象的解构赋值只要属性名一致即可这也就是为什么可以传入乱序的函数参数。 获取多个“函数返回值” 在这个例子中，可以发现利用对象的解构赋值来获取多个“函数返回值”的方法和数组时非常相似。 需要注意的是变量名与属性名一致才能匹配到，如果你希望获取到的值不是原本的属性名，可以直接在解构赋值时采用属性名:希望获得的变量名的写法，比如例子中的msg:message意思就是获取对象中的msg属性值并赋给变量message。","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"let命令与const命令","slug":"let与const","date":"2019-11-01T13:00:00.000Z","updated":"2019-11-04T05:03:15.879Z","comments":true,"path":"2019/11/01/let与const/","link":"","permalink":"http://yoursite.com/2019/11/01/let与const/","excerpt":"注意注意：变量是从里面往外面找，块级作用域嵌套时是没有包含关系的，也就是说这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块。","text":"注意注意：变量是从里面往外面找，块级作用域嵌套时是没有包含关系的，也就是说这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块。 块级作用域 注意：花括号包含块级作用域，但声明一个一个对并不是块级作用域。 var结果：打印出0 1 2和3 letlet用于声明变量，用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。 使用let或者const声明的变量不能再被重新声明 let不存在变量提升 暂存死区 ES6规定，如果块级作用域中存在let或者const声明的变量，那么这个变量一开始就会形成封闭的作用域。 也就是说，即使向上的作用域中存在同名变量也是拿不到的。 var不存在暂存死区，所以第一个console可以向上去上面的作用域找同名变量，拿过来打印。（其实有没有大括号意义不大） let存在暂存死区，也就是说向上的作用域中存在同名变量也拿不到，所以第一个console拿不到上面的“我是美猴王”。let又不存在变量提升，所以第一个console中的monkey也没有被声明，只能报错。 补充：HTML DOM Document 对象 每个载入浏览器的 HTML 文档都会成为 Document 对象。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 补充：HTML DOM appendChild() 方法 appendChild()方法可向节点的子节点列表的末尾添加新的子节点。 例子 补充：createElement()方法通过指定名称创建一个元素。 1document.createElement(nodename) 注意：createElement()要与appendChild()结合起来使用才能使创建的元素显示在页面上。例子：HTML元素经常包含文本。创建指定文本的按钮你需要在按钮元素后添加文本节点 使用let实现面试常见小例子代码解析： 先在HTML文档中创建一个按钮节点btn 再改变节点文字 然后给节点btn设置一个点击事件 最后将节点btn添加到body中 原因：执行事件时，alert（）首先需要i，但是当前作用域找不到，它就会到上一级找，上一级通过自调用时有传进来的i，这个i是随着函数的调用而产生，随着函数调用结束而释放的，不是作用在一开始的var i身上的，所以每一个函数都对应不同的数字。 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所以每一次循环中btn的innerText所指向的i其实都是同一个，循环到最后时前面的i全部被最后的结果覆盖了。而局部变量的话就是每循环一次产生一个新的i，所以不会被覆盖。 原因：执行事件时，alert（）首先需要i，但是当前作用域找不到，它就会到上一级找，上一级直接就是var i了，所有的代码都作用在它身上，所以他会是11。 可以发现，使用let以后就不需要额外放一个自调用函数把他们框起来了。变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。 const与let特性十分相似：不能重复声明、不存在提升、只在当前（块级）作用域内有效。 使用const来声明常量（不可改变的量） 使用var或者let声明的是变量 1const a=1; 常量必须在声明的时候赋值，否则报错：Missing initializer in const declaration 常量声明后不能被修改 常量为引用类型的时候可以修改该引用类型常量为引用类型：对象、数组、函数。 常量声明一个对象 修改xiaoming.age可以，修改xiaoming却会报错，因为const只能保证我们声明指向的地址不变，不能保证声明的值不变。 xiaoming指向的地址和两个属性指向的地址是一样的，常量要求xiaoming指向的地址不变。修改属性值以后属性依旧指向原本的地址，所以不会报错。但是修改xiaoming会使得指向地址变化，因此报错。 也就是说，常量为对象时，不能直接修改这个对象，但是可以修改这个对象的属性，因为此时该常量是引用类型。 12345678&lt;script&gt; const xiaoming = &#123; age: 14, name: '小名' &#125;; xiaoming.sax = '男'; console.log(xiaoming.sax); //男&lt;/script&gt; 说明常量对象如果不处理是可以增加属性的。 常量声明一个数组 可以往常量数组中放入值，此时该常量数组指向的地址不变，不会报错。 30试图让常量数组指向另一个地址，报错。 常量为引用类型时需要冻结来防止被修改使用Object.freeze(常量名)注意：使用Object.freeze()以后也不能再给常量增加属性了（比如xiaoming.dd=11;） es6之前怎么声明常量补充：Object.definePropertyObject.defineProperty除了可以增加一个属性以外还可以对已有的属性进行设置writable:false使该属性不可修改。 补充：Object.seal(变量名);Object.seal(变量名);可以使该变量不能再增加属性。两者结合可以使变量成为常量。 补充：对象名.hasOwnProperty(属性名)对象名.hasOwnProperty(属性名)可以帮助我们判断这个属性是自身的还是继承过来的。其中，obj2是通过obj1创建的，遍历打印obj2可以发现除了obj2自身的属性c、d之外还会打印出继承来的a、b属性。 es6之前声明常量的方法思路：自定义一个Object的带有参数obj（需要成为常量的变量名）的方法freezePolyfill，需要声明常量时就使用Object.freezePolyfill(变量名) 实现步骤： 遍历属性和方法 修改遍历到的属性的描述 Object.seal（） 解决方法：可以用递归来判断一下属性是不是方法，再去套上面的代码。（直接使用迭代的方式也可以）","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS transition属性（过渡效果）","slug":"CSS transition属性","date":"2019-10-28T11:46:42.000Z","updated":"2019-11-19T12:58:19.351Z","comments":true,"path":"2019/10/28/CSS transition属性/","link":"","permalink":"http://yoursite.com/2019/10/28/CSS transition属性/","excerpt":"","text":"transition 属性实现过渡效果 transition 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。 transition 可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。比如在不同的伪元素之间切换，像是:hover，:active 或者通过 JavaScript 实现的状态变化。 注意：一定要设置 transition-duration属性，否则时长为 0，就不会产生过渡效果。 默认值：all 0 ease 0 MDN 关于transition 属性 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的“例子3”中。 transition-property属性规定设置过渡效果的 CSS 属性的名称 transition-property属性规定应用过渡效果的 CSS 属性的名称。（当指定的 CSS 属性改变时，过渡效果将开始）。 提示：过渡效果通常在用户将鼠标指针浮动到元素上时发生。 MDN 关于transition-property属性 属性值 描述 none 没有属性会获得过渡效果 all 所有可被动画的属性都表现出过渡动画 IDENT 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）组成。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。。 transition-duration属性指定过渡效果时长 transition-duration 属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s ，表示不出现过渡动画。不接受负值。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。 如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 注意：这是一个实验中的功能。此功能某些浏览器尚在开发中，请参考MDN中浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 MDN 关于transition-duration属性 transition-timing-function 属性规定速度效果的速度曲线 该属性允许过渡效果随着时间来改变其速度。 可以规定多个timing function,通过使用 transition-property属性，可以根据主列表(transition property的列表)给每个CSS属性应用相应的timing function. 如果timing function的个数比主列表中数量少，缺少的值被设置为初始值（ease） 。如果timing function比主列表要多，timing function函数列表会被截断至合适的大小。这两种情况下声明的CSS属性都是有效的。 属性值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 默认值，规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 注意：这是一个实验中的功能。此功能某些浏览器尚在开发中，请参考MDN中浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 MDN 关于transition-timing-function 属性 transition-delay属性定义过渡效果何时开始 transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 属性值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性（transition-property） 注意：这是一个实验中的功能。此功能某些浏览器尚在开发中，请参考MDN中浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 MDN 关于transition-delay属性","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML知识补充（label标签）","slug":"HTML知识补充 label","date":"2019-10-28T11:46:42.000Z","updated":"2019-11-19T08:43:53.496Z","comments":true,"path":"2019/10/28/HTML知识补充 label/","link":"","permalink":"http://yoursite.com/2019/10/28/HTML知识补充 label/","excerpt":"&lt;label&gt;标签 &lt;label&gt;标签为 input 元素定义标注（标记）。","text":"&lt;label&gt;标签 &lt;label&gt;标签为 input 元素定义标注（标记）。 label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择label 标签时，浏览器就会自动将焦点转到和标签相关的表单控件（input元素）上。 注意：&lt;label&gt; 标签的 for 属性需要与相关元素的 id 属性相同，否则不起作用。 下面例子中的文字“Male”也可以是特殊符号，比如一个问号❔。 例子点击文本“Male”可以发现对应的input元素被选中。 123456789101112131415&lt;html&gt;&lt;body&gt;&lt;p&gt;请点击文本标记之一，就可以触发相关控件：&lt;/p&gt;&lt;form&gt;&lt;label for=\"male\"&gt;Male&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"male\" /&gt;&lt;br /&gt;&lt;label for=\"female\"&gt;Female&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"female\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 具体实现","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第五天学习笔记（CSS浮动）","slug":"百度前端技术学院 第五天学习笔记 （CSS浮动）","date":"2019-10-24T08:20:00.000Z","updated":"2019-11-20T11:44:17.879Z","comments":true,"path":"2019/10/24/百度前端技术学院 第五天学习笔记 （CSS浮动）/","link":"","permalink":"http://yoursite.com/2019/10/24/百度前端技术学院 第五天学习笔记 （CSS浮动）/","excerpt":"补充：margin:auto;与margin: 0 auto; 意思不同。margin:auto=margin:auto auto auto auto，表示上下左右都为auto；margin:0 auto=margin:0 auto 0 auto，表示上下为0，左右为auto； 居中方式不同。margin:auto表示横竖都居中。margin: 0 auto表示横居中，竖不居中。","text":"补充：margin:auto;与margin: 0 auto; 意思不同。margin:auto=margin:auto auto auto auto，表示上下左右都为auto；margin:0 auto=margin:0 auto 0 auto，表示上下为0，左右为auto； 居中方式不同。margin:auto表示横竖都居中。margin: 0 auto表示横居中，竖不居中。 补充：:nth-of-type(n)选择器 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素. n 可以是数字、关键词或公式。 在MDN的浮动的双列表或三列表的例子中我们用到了这个选择器。 1234div:nth-of-type(1) &#123; width: 48%; float: left; &#125; 上面这个例子是选择了父元素的第一个div子元素。（注意：不是div的第一个子元素，是第一个div元素！！） 更多用法 浮动(float属性) 属性值有left、right。 注意：如果是三列浮动，前面两列最好指定left，第三列指定right。如果第二列和第三列都指定right，那么第二列会显示在最右边，而第三列会显示在中间，因为第二列源代码顺序上比第三列等级要高 (DOM上第二列先出现并声明了float: right;) ，所以在浮动顺序上也会比第三列等级要高。又因为两者同时像右浮动，所以第二列就会更加地靠右。 参考MDN浮动 Float 可用于实现文字环绕图片，如下：1234img &#123; float: right; margin: 0 0 1em 1em;&#125; 清除浮动( clear 属性) 如果不清楚浮动，所有在浮动下面的自身不浮动的内容都将围绕浮动元素，在最长的列旁边环绕着。 清除浮动原理：通过在浮动元素的末尾添加一个空元素，设置 clear：both属性。 clear 属性值 含义 left 停止任何活动的左浮动 right 停止任何活动的右浮动 both 停止任何活动的左右浮动 当你把clear 属性应用到一个元素上时，它主要意味着”此处停止浮动”,这个元素和源码中后面的元素将不浮动，除非您稍后将一个新的float声明应用到此后的另一个元素。 注意及时清理浮动，必要时增加clearfix块。（不推荐使用）&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;来设定.clearfix {clear: both;}使得自他以后的元素都清除浮动。 建议使用::after 伪元素来清除浮动： 12.clearfix::after &#123;content:\".\"; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; ::after的意思是在.clearfix内部的最后加入伪元素::after 首先要显示伪元素，所以display:block 然后为伪元素加入空内容，以便伪元素中不会有内容显示在页面中，所以， content:&quot;&quot;；(.也可以，只要加上visibility:hidden;) 其次，为使伪元素不影响页面布局，将伪元素高度设置为0，所以， height:0 最后，要清除浮动，所以，clear:both。 after伪元素其实是通过 content 在元素的后面生成了内容为一个点的块级元素。这样一来只要设置这两个非浮动元素之间的距离就行了。 浮动中可能遇到的问题给浮动框加上样式时原有的布局有可能因为宽度不够被挤乱 在上面的例子中三列浮动没什么问题，但给这些框加上样式时，比如添加背景、外边距、内边距等等，就有可能出现由于内边距和边界引入的额外宽度，一行容纳不下三列了，因此第三列下降到另外两列之下的情况。 解决问题的方法：通过box-sizing更改盒模型为替代盒模型来保证增加内边距或边界的宽度时，不会使盒子更宽，而是会使内容调整得更窄。 123* &#123; box-sizing: border-box;&#125; 这里要注意的另一小点是，box-sizing 出现可以追溯到Internet Explorer 8，如果明确需要支持较老的浏览器，可能需要手动调整列的宽度，以允许内边距和边界宽度。 非浮动元素的外边距不能用于它们和浮动元素之间来创建空间使用::after 伪元素(利用::after在元素内部插入元素块，从而达到清除浮动的效果)： 12.clearfix:after &#123;content:\".\"; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; ::after的意思是在.clearfix内部的最后加入伪元素::after 首先要显示伪元素，所以display:block 然后为伪元素加入空内容，以便伪元素中不会有内容显示在页面中，所以， content:&quot;&quot;；(.也可以，只要加上visibility:hidden;) 其次，为使伪元素不影响页面布局，将伪元素高度设置为0，所以， height:0 最后，要清除浮动，所以，clear:both。 after伪元素其实是通过 content 在元素的后面生成了内容为一个点的块级元素。这样一来只要设置这两个非浮动元素之间的距离就行了。 注意及时清除浮动元素 我们在文章中建立的简单例子很容易理解，但是当布局变得更加复杂时清理（clearing）也会变得更加复杂。你需要确保所有的浮动都能尽快清除，以避免它们给下方的内容制造麻烦。如果没有一个方便的容器来进行清理，那么在必要的时候使用clearfix块。 使用overflow属性防止浮动的图片溢出容器 浮动的元素存在于正常的文档布局流之外，在某些方面的行为相当奇怪，比如，他们在父元素中所占的面积的有效高度为0（高度塌陷）。此时就要使用overflow属性让浮动的图片可以被包含在其他元素里面了。 overflow属性值 例子中图片比包含它的元素还高， 而且它是浮动的，于是它就溢出到了容器外面。 例子：123img &#123; float: right;&#125; 解决方法：给包含图片的元素增加overflow属性123.clearfix &#123; overflow: auto;&#125; 如果你想要支持IE6，你就需要再加入如下样式：1234.clearfix &#123; overflow: auto; zoom: 1;&#125; 浮动项目的背景高度 浮动的元素存在于正常的文档布局流之外，在某些方面的行为相当奇怪，比如，他们在父元素中所占的面积的有效高度为0（高度塌陷）。 不同列的高度不同会不太美观。 可以使用overflow属性使得浮动元素的内容滚动来解决浮动元素的高度问题。 参考解决方法: Flexbox可以自动地延长列，这样他们就会像最长的一列一样。（具体用法可看下一篇笔记） 将这些列的背景颜色设置为父元素的背景颜色，这样您就不会看到高度是不同的。这是目前最好的选择。 将它们设置为固定的高度（height），并使内容滚动（overflow属性）。 问题 关于闭合浮动与清除浮动(所以应该是闭合还是清除呢？) 其实我们想要达到的效果更确切地说是闭合浮动，而不是单纯的清除浮动，在footer上设置clear：both清除浮动并不能解决warp高度塌陷的问题。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第五天学习笔记（CSS盒模型）","slug":"百度前端技术学院 第五天学习笔记 （CSS盒模型）","date":"2019-10-18T08:20:00.000Z","updated":"2019-11-20T11:01:46.700Z","comments":true,"path":"2019/10/18/百度前端技术学院 第五天学习笔记 （CSS盒模型）/","link":"","permalink":"http://yoursite.com/2019/10/18/百度前端技术学院 第五天学习笔记 （CSS盒模型）/","excerpt":"块和内联布局 水平书写模式时块垂直放置，但在垂直书写模式下块将水平放置：","text":"块和内联布局 水平书写模式时块垂直放置，但在垂直书写模式下块将水平放置： display属性值block 从下方例子中可以看到，display属性block使span元素像一个块元素，独占一行被包含在p元素内。 flex display属性定义框及其内部任何框的行为。 flex的行为就像一个块元素（自己占一行），它显示在新行上并占据其在行内方向上可以使用的所有空间。 如果应用在&lt;ul&gt;上则会让&lt;li&gt;都显示在一行上，并占据其在行内方向上可以使用的所有空间。 block与flex的例子 1234567891011121314151617181920p, ul &#123; border: 2px solid rebeccapurple; padding: .5em;&#125;.block,li &#123; border: 2px solid blue; padding: .5em;&#125;ul &#123; display: flex; list-style: none;&#125;.block &#123; display: block;&#125; 1234567&lt;p&gt;I am a paragraph. A short one.&lt;/p&gt;&lt;ul&gt; &lt;li&gt;Item One&lt;/li&gt; &lt;li&gt;Item Two&lt;/li&gt; &lt;li&gt;Item Three&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I am another paragraph. Some of the &lt;span class=\"block\"&gt;words&lt;/span&gt; have been wrapped in a &lt;span&gt;span element&lt;/span&gt;.&lt;/p&gt; inlinedisplay属性inline可以让块元素像行内（内联）元素 inline-flexinline-flex与flex比起来更像一个行内元素，它后面如果有一个段落的话，inline-flex容器和段落都在一行上一起运行，而不是像flex显示为块级元素那样将它们换成新行。 inline-block直接从属性名也可以看出他可以让内联的盒子像一个块元素。这个属性可以让内联盒子不与包含他的盒子内容重叠，也就是说他会让内联盒子的width与height属性生效。 123456789span &#123; margin: 20px; padding: 20px; width: 80px; height: 50px; background-color: lightblue; border: 2px solid blue; display: inline-block;&#125; 123&lt;p&gt; I am a paragraph and this is a &lt;span&gt;span&lt;/span&gt; inside that paragraph. A span is an inline element and so does not respect width and height.&lt;/p&gt; display各属性值直观对比图 12345678910111213141516171819p, ul &#123; border: 2px solid rebeccapurple;&#125;span,li &#123; border: 2px solid blue;&#125;ul &#123; display: inline-flex; list-style: none; padding: 0;&#125; .inline &#123; display: inline;&#125; 123456789101112&lt;p&gt; I am a paragraph. Some of the &lt;span&gt;words&lt;/span&gt; have been wrapped in a &lt;span&gt;span element&lt;/span&gt;.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item One&lt;/li&gt; &lt;li&gt;Item Two&lt;/li&gt; &lt;li&gt;Item Three&lt;/li&gt;&lt;/ul&gt;&lt;p class=\"inline\"&gt;I am a paragraph. A short one.&lt;/p&gt;&lt;p class=\"inline\"&gt;I am another paragraph. Also a short one.&lt;/p&gt; 盒模型盒子的组成 内容框：显示内容的区域，可以使用width和属性来调整大小height。 填充框：填充物围绕内容位于空白处；可以使用padding和相关属性控制其大小。 边框：边框用于包装内容和任何填充。可以使用border及其相关属性来控制其大小和样式。 边距框：边距是最外层，将内容，填充和边框包装为此框与其他元素之间的空白。可以使用margin及其相关属性来控制其大小。 注意：边距（margin）影响框外的空间以及框在页面上所占的总空间，但它不计入框的实际大小。框的区域在边界处（border）停止，不会延伸到边缘。 标准盒模型 在标准盒模型中，盒子占用的总大小由框的宽度（width）和高度（height）以及任何填充（padding）和边框（border）相加得到。 例子中盒子占用的空间宽度实际上将为410px（350 + 25 + 25 + 5 + 5），高度为210px（150 + 25 + 25 + 5 + 5），因为填充和边框为添加到用于内容框的宽度。 替代盒模型 使用此模型，任何宽度都是页面上可见框的宽度（不用加上padding与border），因此内容区域的宽度是该宽度减去填充和边框的宽度。 默认情况下，浏览器使用标准盒模型。如果要为元素打开替代盒模型，可以通过对其进行设置box-sizing: border-box;来实现。box-sizing是个很新的属性，目前应该像下面例子中那样使用 -webkit-和 -moz-前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+的： 12345.box &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 如果希望所有元素都使用替代盒模型，请在元素上设置box-sizing属性，然后将所有其他元素设置为继承该值，如： 12345678html &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;*, *::before, *::after &#123; box-sizing: inherit;&#125; 或者： 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; (块之间的)外边距margin折叠 补充：margin可以是负值。 首先，两个兄弟块之间的垂直距离由margin属性 （外边距）确定。 通过两个例子我们可以发现折叠的是两个块之间较小的边距。 也就是说如果有两个具有边距的元素撞在一起，作用于同一个位置的边距将合并为一个边距，即最大单个边距的大小。两个边距撞在一起会合并（折叠），而不是等于两个边距的总和。 属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 例子1：1234p &#123; border: 2px solid green; margin: 20px 0 40px 0;&#125; 1234&lt;div class=\"box\"&gt; &lt;p&gt;文段1&lt;/p&gt; &lt;p&gt;文段2&lt;/p&gt;&lt;/div&gt; 例子2：1234&lt;div class=\"box\"&gt; &lt;p&gt;文段1&lt;/p&gt; &lt;p&gt;文段2&lt;/p&gt;&lt;/div&gt; 1234&lt;div class=\"box\"&gt; &lt;p&gt;文段1&lt;/p&gt; &lt;p&gt;文段2&lt;/p&gt;&lt;/div&gt; 边框border 简写包括border-width、border-style、border-color 也可以只设置单边的这三个属性 例子： 123456789101112.container &#123; border-top: 5px dotted green; border-right: 1px solid black; border-bottom: 20px double rgb(23,45,145);&#125;.box &#123; border: 1px solid #333333; border-top-style: dotted; border-right-width: 20px; border-bottom-color: hotpink;&#125; 123&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;Change my borders.&lt;/div&gt;&lt;/div&gt; 内边距（填充）padding 属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 12345678910.box &#123; padding-top: 0; padding-right: 30px; padding-bottom: 40px; padding-left: 4em;&#125;.container &#123; padding: 20px;&#125; 123&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;Change my padding.&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"let命令","slug":"let","date":"2019-10-15T13:00:00.000Z","updated":"2019-10-31T11:17:06.218Z","comments":true,"path":"2019/10/15/let/","link":"","permalink":"http://yoursite.com/2019/10/15/let/","excerpt":"了解块级作用域 块级作用域是一个语句，将多个操作封装在一起，通常是放在一个大括号里，没有返回值。（但是对象声明用到的大括号不包括块级作用域，它包括的是对象） 块级作用域之中的每个函数都类似一个代码块。（但是这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块）","text":"了解块级作用域 块级作用域是一个语句，将多个操作封装在一起，通常是放在一个大括号里，没有返回值。（但是对象声明用到的大括号不包括块级作用域，它包括的是对象） 块级作用域之中的每个函数都类似一个代码块。（但是这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块） 块级作用域于函数声明 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let ，在块级作用域之外不可引用。 但应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 但为了减轻因此产生的不兼容问题，在ES6环境的浏览器中： 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 ES6 允许块级作用域的任意嵌套先了解一下，匿名立即执行函数表达式（匿名 IIFE）可以用块级作用域实现： 1234567891011// IIFE 写法(function () &#123; var a = 1; console.log(a);&#125;());// 块级作用域写法&#123; let a = 1; console.log(a);&#125; 下面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。。 1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 注意：内层作用域可以定义外层作用域的同名变量。 let 命令 声明变量，用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 for循环的例子(var与let) 首先要明确，for循环有一个特别之处，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 使用var的例子： 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10,数组a中的10个元素都是打印10 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所以a[0]指向的i以及a[1]到a[8]指向的i都被后来循环的a[9]指向的i（也就是10）覆盖掉了。而局部变量的话就是每循环一次产生一个新的i，所以不会被覆盖。 使用let的例子： 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 暂时性死区 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前使用这些变量(包括声明或者赋值)，就会报错。 存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; let不允许重复声明不能在函数内部重新声明参数不能在函数内部重新声明参数，这相当于在同一个块级作用域里面两次用let声明变量： 1234567891011function func(arg) &#123; let arg;&#125;func() // 报错function func(arg) &#123; &#123; let arg; &#125;&#125;func() // 不报错，注意这里是两个代码块了（不理解的话可以看下面的另一个例子） 下面的函数有两个代码块，都声明了变量n，运行后输出5。（因为代码块2的变量n不作用于代码块2之外）这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 123456789function f1() &#123; let n = 5; //代码块1定义的变量n if (true) &#123; let n = 10; //代码块2定义的变量n //在这console.log(n);会得到10 &#125; console.log(n); // 5&#125;f1();","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"百度前端技术学院 第四天学习总结","slug":"百度前端技术学院 第四天学习总结","date":"2019-10-13T07:15:05.000Z","updated":"2019-11-19T09:25:21.108Z","comments":true,"path":"2019/10/13/百度前端技术学院 第四天学习总结/","link":"","permalink":"http://yoursite.com/2019/10/13/百度前端技术学院 第四天学习总结/","excerpt":"背景，边框，列表，链接相关属性背景相关属性background简写：","text":"背景，边框，列表，链接相关属性背景相关属性background简写： 属性 值 background-color 特别注意：rgba中的a是透明度（0.0到1.0之间，0.5为半透明）如：rgba(255,255,255,0)完全透明的白色 background-image url(xxx.jpg) background-size 长度:百分比:cover:保留宽高比,使背景图像完全覆盖背景区域contain:把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 background-repeat repeat-x:在水平方向上重复 repeat-y :在垂直方向上重复no-repeat :不允许图像平铺 background-position 一对或单个关键字、百分数、长度值/混合使用（使用单个则默认另一个关键字是 center）关键字:top、bottom、left、right 和 center 边框相关属性前三个属性可简写border属性：属性 | 值—|—border-style |默认值：none，所以必须记得设置border-style，否则边框就不会出现border-width | 长度值/关键字border-color|命名颜色/十六进制/ RGB 值border-radius|一个或两个长度或百分比，第一个值定义水平半径，第二个值定义垂直半径 列表相关属性可以在 &lt;ul&gt; 或 &lt;ol&gt; 或&lt;li&gt;元素上简写list-style： 属性 值 list-style-type项目符号的类型 默认disc（实心圆） list-style-position列表标志位置 默认 outside list-style-image图像标志 url(xxx.jpg)默认none 链接相关属性选择器四种状态：(他们不是属性！) a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方 a:active - 链接被点击的时刻 注意： a:hover 必须位于 a:link 和 a:visited 之后 a:active 必须位于 a:hover 之后 举例： 1a:link &#123;color:#FF0000;&#125; 属性 属性 值 文本修饰（下划线）text-decoration（多个属性值) 具体参考 背景色background-color 常用俱可 鼠标光标的样式cursor 属性值 文字的轮廓（框）outline 简写：宽度 （outline-width）、样式（outline-style） 、颜色 outline-width 关键字（取决于用户代理）：thin/medium/thick长度：10px/1rem全局值:inherit outline-style 关键字：none(默认值);auto; dotted;dashed; solid; double;groove; ridge;inset; outset;全局值:inherit;initial; unset; CSS 各种选择器的概念，使用方法及使用场景。简单选择器 ID选择器：#ID名称{属性：值;} 类选择器：.类名称{属性：值;} 标签（元素）选择器：html元素名{属性：值;} 通用选择器：*{属性：值;} 属性选择器 属性选择器：[属性名]{CSS样式} 属性和值选择器：[属性名=值]{CSS样式} 属性和（多个）值选择器(类似模糊查找)： 语法 含义 [属性名~=值]{CSS样式} 适用于HTML中由空格分隔的属性值 `[属性名 =值]{CSS样式}` [属性名^=值]{CSS样式} 匹配属性值以指定值开头的每个元素 [属性名$=值]{CSS样式} 匹配属性值以指定值结尾的每个元素 [属性名*=值]{CSS样式} 匹配属性值中包含指定值的每个元素 伪类选择器 :first-child表示一组同级元素中的第一元素 :last-child表示一组同级元素中的最后一个元素 :only-child表示没有任何兄弟姐妹的元素 :invalid设置值无效时的样式 伪元素选择器 注意：使用双冒号，与伪类选择器区分开。 ::first-line伪元素设置文本首行的特殊样式 ::first-letter 伪元素设置文本首字母的特殊样式 ::before伪元素在元素前面插入新内容 派生选择器 用于选择一个标签中的所有另一个标签。（id选择器与类选择器、属性选择器也可以派生） 用空格分隔开两个元素名称。 后代选择器 空格分隔两个选择器名称 选择的元素是其选择器的后代。他们不需要是直接子元素就可以配对(子孙后代都可以)。 儿童组合器 大于号分隔 仅当选择器选择直接子元素时才匹配。层次结构后面的子孙不匹配。（注意：直接子元素并不是一定只有一个，要与伪类选择器:first-child区别开来） 直接相邻的同级选择器 加号分隔 用于选择与层次结构中相同级别的另一个元素相邻的对象。 注意：这两个选择器不仅要是同级别的，还要直接相邻。 一般同级[所有的同级选择器] 用~分隔开两个选择器。 用于选择与层次结构中相同级别的所有指定选择器的对象（包括直接相邻的同级），也可以使用常规的同级组合器。 注意：空格分隔开的是父元素与子元素组成的后代选择器，~分隔开的是同级别的所有指定选择器的对象。 CSS 选择器的优先级 影响优先级的因素从高到低的顺序是：重要性、特异性、源顺序。 注意：并不是整个规则都会被覆盖，只是相同的属性。 源顺序（靠后的获胜）如果有多个选择器作用于同一个元素，则靠后的将获胜。 特异性(计算各个选择器的特异性值) 选择器具有的特异性程度是使用四个不同的值（或成分）来衡量的，可以将其视为千位，百位，十位和个位这四列中的四个个位数： 值 范围 千 如果声明位于style属性内（也称为内联样式）内，则在此列中得一千分。这样的声明没有选择器，因此它们的特异性始终只是1000 百 在此列中为整体选择器中包含的每个ID选择器打分（有几个ID选择器就几百分） 十 在此列中为整体选择器中包含的每个类选择器，属性选择器或伪类计分（注意属性选择器的书写方法） 一 在此列中为整体选择器中包含的每个元素选择器或伪元素*打一分。 重要性!important 超越了上述两个级联的常规规则，但最好不要用。 语法选择器{属性: 属性值 !important;}","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第四天学习笔记（选择器的优先级、了解级联、!important）（4）","slug":"百度前端技术学院 第四天学习笔记（4）","date":"2019-10-13T04:58:05.000Z","updated":"2019-11-19T09:25:59.091Z","comments":true,"path":"2019/10/13/百度前端技术学院 第四天学习笔记（4）/","link":"","permalink":"http://yoursite.com/2019/10/13/百度前端技术学院 第四天学习笔记（4）/","excerpt":"选择器的优先级级联（cascade） 对于相同的选择器，在CSS中排在最后的那个将被使用。","text":"选择器的优先级级联（cascade） 对于相同的选择器，在CSS中排在最后的那个将被使用。 例子： 123456h1 &#123; color: red; &#125;h1 &#123; color: blue; &#125; 1&lt;h1&gt;This is my heading.&lt;/h1&gt; 特异性 有多个选择器作用于同一元素时，类选择器的优先级高于元素选择器。（但这个是针对同一属性的时候，两个选择器没有重合的属性实际都作用于该元素） 例子中有两个适用于h1的规则。类选择器为其规则赋予了更高的特异性，下面的内容h1最终变为红色。因此即使带有颜色的元素选择器的规则在源顺序中排在更下方，类选择器的颜色也将被应用。但元素选择器的其他属性还是会生效。 12345678.main-heading &#123; color: red; /*生效*/&#125; h1 &#123; color: blue; /*未生效*/ text-decoration:underline;/*生效*/&#125; 1&lt;h1 class=\"main-heading\"&gt;This is my heading.&lt;/h1&gt; 继承（Inheritance） 如果在元素上设置color和font-family，除非它直接应用了不同的颜色和字体值，否则其中的每个元素也将使用该颜色和字体的样式。 某些属性不会继承。width, margin, padding,border 等内容不会继承。例如，如果在width元素上设置50％的值，则其所有后代的宽度都不会达到其父级宽度的50％。 例子： 1234567body &#123; color: blue;&#125;span &#123; color: black;&#125; 12&lt;p&gt;As the body has been set to have a color of blue this is inherited through the descendants.&lt;/p&gt;&lt;p&gt;We can change the color by targetting the element with a selector, such as this &lt;span&gt;span&lt;/span&gt;.&lt;/p&gt; 提示：在MDN CSS属性参考页上，通常可以在规格部分的底部找到一个技术信息框，其中列出了有关该属性的许多数据点，包括是否继承。例如，MDN颜色属性 通过四个属性值控制继承CSS提供了四个特殊的通用属性值来控制继承。每个CSS属性都接受这些值。 属性值 作用 inherit继承 将应用于选定元素的属性值设置为其父元素的属性值 initial 最初的 将应用于所选元素的属性值设置为与浏览器默认样式表中为该元素设置的值相同。如果浏览器的默认样式表未设置任何值，就会继承该属性，相当于将属性值设置为inherit。 unset 重置 将属性重置为其自然值，这意味着，如果该属性是自然继承的，则其行为类似于inherit，否则，其行为类似于initial。 新值 revert 它对浏览器的支持有限。revert 例子： 123456789101112131415body &#123; color: green;&#125; .my-class-1 a &#123; color: inherit/*设置为其父元素的属性值*/&#125; .my-class-2 a &#123; color: initial;/*设置为与浏览器默认样式表中为该元素设置的值相同*/&#125; .my-class-3 a &#123; color: unset;/*重置为其自然值.如果该属性是自然继承的，则其行为类似于inherit，否则，其行为类似于initial*/&#125; 123456&lt;ul&gt; &lt;li&gt;Default &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt; &lt;li class=\"my-class-1\"&gt;Inherit the &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt; &lt;li class=\"my-class-2\"&gt;Reset the &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt; &lt;li class=\"my-class-3\"&gt;Unset the &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt;&lt;/ul&gt; 如果添加a { color: red; }则 通过all属性重置所有属性值 all速记属性一次控制（几乎）所有属性的继承，该属性将其值应用于所有属性。这是撤消对样式所做的更改的便捷方法。 属性值：inherit，initial，unset，和revert inherit关键字允许作者显式指定的继承,它适用于继承和非继承属性。可以使用all速记属性一次控制所有属性的继承，该属性将其值应用于所有属性。例如： 12345font: &#123; all: revert; font-size: 200%; font-weight: bold;&#125; 这会将font属性的样式还原为用户代理的默认样式，除非存在用户样式表，否则将使用该样式表。然后将字体大小加倍，并应用font-weight的”bold”。 默认样式表由浏览器供应商提供。(浏览器默认的CSS)用户样式表由浏览器的用户提供,用户自定义的CSS（用户自己写的）。作者样式表由网页作者提供（前端开发人员写的CSS)。 例子： 12345678blockquote &#123; background-color: red; border: 2px solid green;&#125; .fix-this &#123; all: unset;&#125; 1234567&lt;blockquote&gt; &lt;p&gt;This blockquote is styled&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote class=\"fix-this\"&gt; &lt;p&gt;This blockquote is not styled&lt;/p&gt;&lt;/blockquote&gt; 了解级联 要考虑三个因素，这里按重要性从高到低的顺序列出。较早的优先于较晚的：重要性、特异性、源顺序。 注意：并不是整个规则都会被覆盖，只是相同的属性。 源顺序（Source order）如果有多个选择器作用于同一个元素，则靠后的将获胜，也就是说靠后的选择器更加接近元素，他们将覆盖早期的规则，直到最后一个规则获胜并开始为元素设置样式。 特异性（Specificity） 选择器具有的特异性程度是使用四个不同的值（或成分）来衡量的，可以将其视为千位，百位，十位和个位这四列中的四个个位数： 值 范围 千 如果声明位于style属性内（也称为内联样式）内，则在此列中得一千分。这样的声明没有选择器，因此它们的特异性始终只是1000 百 在此列中为整体选择器中包含的每个ID选择器打分（有几个ID选择器就几百分） 十 在此列中为整体选择器中包含的每个类选择器，属性选择器或伪类计分（注意属性选择器的书写方法） 一 在此列中为整体选择器中包含的每个元素选择器或伪元素打一分。 例子： 12345678&lt;div id=\"outer\" class=\"container\"&gt; &lt;div id=\"inner\" class=\"container\"&gt; &lt;ul&gt; &lt;li class=\"nav\"&gt;&lt;a href=\"#\"&gt;One&lt;/a&gt;&lt;/li&gt; &lt;li class=\"nav\"&gt;&lt;a href=\"#\"&gt;Two&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* specificity: 0101 */#outer a &#123; background-color: red;&#125; /* specificity: 0201 */#outer #inner a &#123; background-color: blue;&#125;/* specificity: 0104 */#outer div ul li a &#123; color: yellow;&#125;/* specificity: 0113 */#outer div ul .nav a &#123; color: white;&#125;/* specificity: 0024 */div div li:nth-child(2) a:hover &#123; border: 10px solid black;&#125;/* specificity: 0023 */div li:nth-child(2) a:hover &#123; border: 10px dashed black;&#125;/* specificity: 0033 */div div .nav:nth-child(2) a:hover &#123; border: 10px double black;&#125;a &#123; display: inline-block; line-height: 40px; font-size: 20px; text-decoration: none; text-align: center; width: 200px; margin-bottom: 10px;&#125;ul &#123; padding: 0;&#125;li &#123; list-style-type: none;&#125; 解释： 前两个选择器在争夺链接背景颜色的样式上竞争,第二个选择器获胜并使背景颜色变成蓝色，因为它在链中有一个额外的ID选择器,其特异性是201对101。 第三和第四个选择器正在争夺链接文本颜色的样式,第二个选择器获胜并使文本变成白色，因为尽管元素选择器（1分）少了一个，但缺少的选择器却换成了一个类选择器(10分)。因此获胜的特异性是113比104。 选择器5–7在争夺链接边框的样式。选择器6显然输给了5，特异性为23 vs. 24，链中元素选择器少了一个。但是，选择器7击败了5和6，它在子链中具有与五个相同的子选择器数量，但是一个元素已换成类选择器。因此获胜的特异性是33 vs. 23和24。 重要性（!important） 他可以用来推翻所有上述计算，但是使用它时应格外小心。!important用于使特定属性和值成为最特定的事物，从而超越了级联的常规规则。 语法：选择器{属性: 属性值 !important;} 注意：覆盖此!important声明的方法是在源顺序中稍后的同样特异性的声明中包含另一个!important声明，或者在更高特异性的声明中包含另一个!important声明。 强烈建议除非绝对必要，否则不要使用它。!important更改了级联的正常工作方式，因此可能很难解决调试CSS问题. 例子： 123456789101112131415#winning &#123; background-color: red; border: 1px solid black;&#125; .better &#123; background-color: gray; border: none !important;&#125; p &#123; background-color: blue; color: white; padding: 5px;&#125; 12&lt;p class=\"better\"&gt;This is a paragraph.&lt;/p&gt;&lt;p class=\"better\" id=\"winning\"&gt;One selector to rule them all!&lt;/p&gt; 解释： 可以看到已应用了第三条规则color和padding值，但尚未应用background-color。为什么？确实应该确实适用所有这三个规则，因为源顺序中的后面的规则通常会覆盖前面的规则。 但是，上面的规则会获胜，因为类选择器比元素选择器具有更高的特异性。 这两种元素都有class的better，但第二个一个有一个id的winning了。由于ID 比类具有更高的特异性（页面上每个ID只能具有一个元素，但是具有相同类的许多元素-ID选择器针对的对象非常具体），红色背景色和1像素黑色边框应同时应用于第二个元素，第一个元素将获得灰色背景色，并且没有边框（如该类所指定）。 第二个元素的确获得红色背景色，但没有边框。为什么？由于!important第二条规则中的声明-后面加上该字符串border: none意味着即使ID具有更高的特异性，此声明也将超过上一条规则中的边界值。 声明覆盖顺序（针对冲突声明）冲突声明将按以下顺序应用，后面的声明将覆盖前面的声明： 用户代理样式表中的声明（例如，浏览器的默认样式，未设置其他样式时使用）。 用户样式表中的常规声明（用户设置的自定义样式）。 作者样式表中的常规声明（这些是我们，Web开发人员设置的样式）。 作者样式表中的重要声明。 用户样式表中的重要声明。 最后，注意到CSS声明的重要性取决于在其中指定的样式表，这也是有用的。用户可以设置自定义样式表中的！important来覆盖开发人员的样式。 说明: Web开发人员的样式表覆盖用户样式表是有意义的，因此可以按预期进行设计。 但是如上所述，用户有充分的理由覆盖Web开发人员样式时可以通过!important在其规则中使用来实现。例如，用户可能在视觉上有缺陷，并且想要将所访问的所有网页上的字体大小设置为正常大小的两倍，以便于阅读","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第四天学习笔记（伪类选择器、组合）（3）","slug":"百度前端技术学院 第四天学习笔记（3）","date":"2019-10-11T12:58:05.000Z","updated":"2019-11-19T13:09:11.158Z","comments":true,"path":"2019/10/11/百度前端技术学院 第四天学习笔记（3）/","link":"","permalink":"http://yoursite.com/2019/10/11/百度前端技术学院 第四天学习笔记（3）/","excerpt":"伪类选择器:first-child表示一组同级元素中的第一元素","text":"伪类选择器:first-child表示一组同级元素中的第一元素 例子： 1234567891011&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3 &lt;ul&gt; &lt;li&gt;Item 3.1&lt;/li&gt; &lt;li&gt;Item 3.2&lt;/li&gt; &lt;li&gt;Item 3.3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 12345678ul li &#123; color: blue;&#125;ul li:first-child &#123; color: red; font-weight: bold;&#125; :last-child表示一组同级元素中的最后一个元素 用法与:first-child相似。 :only-child表示没有任何兄弟姐妹的元素 例子1： 123456789&lt;div&gt; &lt;div&gt;I am an only child.&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;div&gt;I am the 1st sibling.&lt;/div&gt; &lt;div&gt;I am the 2nd sibling.&lt;/div&gt; &lt;div&gt;I am the 3rd sibling, &lt;div&gt;but this is an only child.&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 123456789div:only-child &#123; color: red;&#125;div &#123; display: inline-block; margin: 6px; outline: 1px solid;&#125; 例子2： 1234567891011121314&lt;ol&gt; &lt;li&gt;First &lt;ul&gt; &lt;li&gt;This list has just one element.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Second &lt;ul&gt; &lt;li&gt;This list has three elements.&lt;/li&gt; &lt;li&gt;This list has three elements.&lt;/li&gt; &lt;li&gt;This list has three elements.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ol&gt; 12345678li li &#123; list-style-type: disc;&#125;li:only-child &#123; color: red; list-style-type: square;&#125; :invalid设置值无效时的样式 用于在表单元素中的值是非法时设置指定样式。该伪类对于突出显示用户的字段错误很有用。 例子 参考 设置:checked表示某些特定的元素被选中 :checked表示任何处于选中状态的radio(), checkbox () 或(“select”) 元素中的option HTML元素(“option”)。 用户通过勾选/选中元素或取消勾选/取消选中，来改变该元素的 :checked状态。 MDN 关于:checked 可以通过:checked借用隐藏的checkbox来切换元素的样式（无需使用JavaScript），比如“百度前端技术学院 第七天学习笔记（CSS position）”中的“例子3”。 伪元素 注意：按照规范，应该使用双冒号（::）而不是单个冒号（:），以便区分伪类和伪元素。 伪元素是一个附加至选择器末的关键词，允许你对被选择元素的特定部分修改样式。 语法： 1selector::pseudo-element &#123;property:value;&#125; 从MDN了解更多伪元素 CSS 类也可以与伪元素配合使用： 1selector.class::pseudo-element &#123;property:value;&#125; 伪元素与 CSS 类配合使用的例子： 123456p.article::first-letter &#123; color: #FF0000; &#125;&lt;p class=\"article\"&gt;This is a paragraph in an article。&lt;/p&gt; 上面的例子会使所有 class 为 article 的段落的首字母变为红色。 ::first-line 伪元素设置文本首行的特殊样式 用于向文本的首行设置特殊样式,只能用于块级元素。 在下面的例子中，浏览器会根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化：12345p::first-line &#123; color:#ff0000; font-variant:small-caps; &#125; ::first-letter 伪元素设置文本首字母的特殊样式 用于向文本的首字母设置特殊样式,只能用于块级元素。 ::before 伪元素在元素前面插入新内容 可以在元素的内容前面插入新内容。 下面的例子在每个 &lt;h1&gt; 元素前面插入一幅图片：1234h1::before &#123; content:url(logo.gif); &#125; 组合后代选择器（Descendant selector） 用空格分隔开两个选择器。 这些选择器选择的元素是其选择器的后代。他们不需要是直接子元素就可以配对(子孙后代都可以)。 通过这个概念我们遇到父元素有class时子元素就不需要再添加额外的class了。 例子： 123.box p &#123; color: red;&#125; 12&lt;div class=\"box\"&gt;&lt;p&gt;Text in .box&lt;/p&gt;&lt;/div&gt;&lt;p&gt;Text not in .box&lt;/p&gt; 儿童组合器（Child combinator） 用大于号分隔开两个选择器。 仅当选择器选择直接子元素时才匹配。层次结构后面的子孙不匹配。（注意：直接子元素并不是一定只有一个，要与伪类选择器:first-child区别开来） 例子： 123ul &gt; li &#123; border-top: 5px solid red;&#125; 1234567891011&lt;ul&gt; &lt;!--这个`&lt;li&gt;`是`&lt;ul&gt;`的直接子元素--&gt; &lt;li&gt;Unordered item&lt;/li&gt; &lt;!--这个`&lt;li&gt;`也是`&lt;ul&gt;`的直接子元素--&gt; &lt;li&gt;Unordered item &lt;ol&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt;&lt;/ul&gt; 上面的例子中有一个无序列表，嵌套在其中的是另一个无序列表。我正在使用子组合器来选择仅&lt;li&gt;是&lt;ul&gt;的直接子元素的元素，并为其赋予了顶部边框。 如果删除&gt;,则最终&lt;li&gt;将得到后代选择器，所有元素都将显示红色边框。 直接相邻的同级选择器(Adjacent sibling) 用加号分隔开两个选择器。 用于选择与层次结构中相同级别的另一个元素相邻的对象。 注意：这两个选择器不仅要是同级别的，还要直接相邻。 例子： 123456h1 + p &#123; font-weight: bold; background-color: green; color: #fff; padding: .5em;&#125; 12345678&lt;article&gt; &lt;h1&gt;A heading&lt;/h1&gt; &lt;p&gt;Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo melon azuki bean garlic.&lt;/p&gt; &lt;p&gt;Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.&lt;/p&gt;&lt;/article&gt; 一个常见的用例是对标题后面的段落进行处理，如上面的额例子所示。在这里，我们正在寻找与&lt;h1&gt;相邻的段落，并为其设置样式。 如果在&lt;h1&gt;与&lt;p&gt;之间插入其他元素，例如&lt;h2&gt;，则会发现该段落不再与选择器匹配，因此当该元素相邻时，也不会应用背景色和前景色。 一般同级（General sibling）[所有同级选择器] 用~分隔开两个选择器。 用于选择与层次结构中相同级别的所有指定选择器的对象（包括直接相邻的同级），也可以使用常规的同级组合器。 注意：空格分隔开的是父元素与子元素组成的后代选择器，~分隔开的是同级别的所有指定选择器的对象。 例子： 123456h1~p &#123; font-weight: bold; background-color: #333; color: #fff; padding: .5em;&#125; 123456&lt;article&gt; &lt;h1&gt;A heading&lt;/h1&gt; &lt;p&gt;I am a paragraph.&lt;/p&gt; &lt;div&gt;I am a div&lt;/div&gt; &lt;p&gt;I am another paragraph.&lt;/p&gt;&lt;/article&gt;","categories":[{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第四天学习笔记（CSS边框、列表）（2）","slug":"百度前端技术学院 第四天学习笔记（2）","date":"2019-10-09T13:04:38.000Z","updated":"2019-11-19T09:27:19.636Z","comments":true,"path":"2019/10/09/百度前端技术学院 第四天学习笔记（2）/","link":"","permalink":"http://yoursite.com/2019/10/09/百度前端技术学院 第四天学习笔记（2）/","excerpt":"总结 按照 top-right-bottom-left 的顺序设置（不同的四边样式/宽度）","text":"总结 按照 top-right-bottom-left 的顺序设置（不同的四边样式/宽度） 1border-width: 15px 5px 15px 5px; 1border-style: solid dotted dashed double;/*实线上边框、点线右边框、虚线下边框和一个双线左边框*/ border-style 的默认值是 none，如果没有声明样式，就相当于 border-style: none。必须记得设置边框样式border-style，否则边框就不会出现。（不管宽度设置了多少） border简写三个属性123.box &#123; border: 1px solid black; &#125; 相当于 12345.box &#123; border-width: 1px; border-style: solid; border-color: black; &#125; 综合运用例子1234567891011.box &#123; background-color: #567895; border: 5px solid #0b385f;/*宽度为5px ，solid 实线*/ border-bottom-style: dashed;/*底部：dashed虚线,样式与颜色和其他三边一样*/ color: #fff;&#125;h2 &#123; border-top: 2px dotted rebeccapurple;/*顶部：宽度为2px ，dotted 点线，rebeccapurple紫色*/ border-bottom: 1em double rgb(24, 163, 78);/*底部双实线*/&#125; 1234&lt;div class=\"box\"&gt; &lt;h2&gt;Borders&lt;/h2&gt; &lt;p&gt;Try changing the borders.&lt;/p&gt;&lt;/div&gt; 边框样式border-styleborder-style 的默认值是 none，如果没有声明样式，就相当于 border-style: none注意：必须记得设置边框样式border-style，否则边框就不会出现。 定义不同的四边样式：这里的值采用了top-right-bottom-left 的顺序： 12345.box &#123; background-color: #567895; border-width:8px; border-style: solid dotted dashed double;/*实线上边框、点线右边框、虚线下边框和一个双线左边框*/&#125; 定义单边样式： border-top-style border-right-style border-bottom-style border-left-style 因此这两种方法是等价的： 12p &#123;border-style: solid solid solid none;&#125;p &#123;border-style: solid; border-left-style: none;&#125; 注意：如果要使用第二种方法，必须把单边属性放在简写属性之后，因为如果把单边属性放在 border-style 之前，简写属性的值就会覆盖单边值 none。 边框宽度 border-width属性值： 长度值 关键字 比如 2px 或 0.1em thin 、medium（默认值） 和 thick 注释：CSS 没有定义 3 个关键字的具体宽度，所以一个用户代理可能把 thin 、medium 和 thick 分别设置为等于 5px、3px 和 2px，而另一个用户代理则分别设置为 3px、2px 和 1px。 定义不同边的宽度按照 top-right-bottom-left 的顺序设置元素的各边边框： border-width: 15px 5px 15px 5px; 也可以简写为（这样写法称为值复制）：border-width: 15px 5px; 定义单边样式： border-top-width border-right-width border-bottom-width border-left-width 边框的颜色 border-color属性值：可以是命名颜色，也可以是十六进制和 RGB 值。 1234p &#123; border-style: solid; border-color: blue rgb(25%,35%,45%) #909090 red; &#125; 默认值： 默认的边框颜色是元素本身的前景色。如果没有为边框声明颜色，它将与元素的文本颜色相同。 如果元素没有任何文本，假设它是一个表格，其中只包含图像，那么该表的边框颜色就是其父元素的文本颜色（因为 color 可以继承）。这个父元素很可能是 body、div 或另一个 table。 值复制：如果颜色值小于 4 个，值复制就会起作用。例如下面的规则声明了段落的上下边框是蓝色，左右边框是红色(按照top-right-bottom-left 的顺序)： 1234p &#123; border-style: solid; border-color: blue red; &#125; 定义单边颜色： border-top-color border-right-color border-bottom-color border-left-color 透明边框transparent：边框颜色值 transparent。这个值用于创建有宽度的不可见边框。 123456a:link, a:visited &#123; border-style: solid; border-width: 5px; border-color: transparent; &#125;a:hover &#123;border-color: gray;&#125; 完整例子 从某种意义上说，利用 transparent，使用边框就像是额外的内边距一样；此外还有一个好处，就是能在你需要的时候使其可见。这种透明边框相当于内边距，因为元素的背景会延伸到边框区域（如果有可见背景的话）。 重要事项：在 IE7 之前，IE/WIN 没有提供对 transparent 的支持。在以前的版本，IE 会根据元素的 color 值来设置边框颜色。 圆角border-radius属性值：一个或两个长度或百分比，第一个值定义水平半径，第二个值定义垂直半径。 1border-radius: 10px; /*使一个框的所有四个角的半径为10px*/ 1border-top-right-radius: 1em 10%; /*使右上角的水平半径为1em，垂直半径为10％*/ 例子: 12345.box &#123; border: 10px solid rebeccapurple; border-radius: 1em; border-top-right-radius: 10% 30%;&#125; 1234&lt;div class=\"box\"&gt; &lt;h2&gt;Borders&lt;/h2&gt; &lt;p&gt;Try changing the borders.&lt;/p&gt;&lt;/div&gt; 列表简写list-style 这个属性可以在 &lt;ul&gt; 或 &lt;ol&gt; 或&lt;li&gt;元素上设置。 属性值可以任意顺序排列，你可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside） list-style-type的默认值是disc（实心圆）list-style-position的默认值是outside（标志出现在列表项内容之外）list-style-image的默认值是none 只要提供了一个值，其它的就会填入其默认值。如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。123li &#123;list-style : url(example.gif) square inside&#125; 列表的项目符号的类型list-style-type 设置列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。 取值参考1 把无序列表中的列表项标志设置为方块:1ul &#123;list-style-type : square&#125; 图像标志list-style-image1ul li &#123;list-style-image : url(xxx.gif)&#125; 列表标志位置list-style-position 决定标志出现在列表项内容之外还是内容内部。 默认值为 outside。 设置链接的样式链接的四种状态： a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方 a:active - 链接被点击的时刻 注意： a:hover 必须位于 a:link 和 a:visited 之后 a:active 必须位于 a:hover 之后 举例： 1234a:link &#123;color:#FF0000;&#125; /* 未被访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已被访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标指针移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 正在被点击的链接 */ 常见的链接样式属性文本修饰（下划线）text-decoration 大多用于去掉链接中的下划线 underline、none 背景色background-color 规定链接的背景色 鼠标光标的样式cursor 不应该把这个关掉，除非你有非常好的理由。 属性值 文字的轮廓（框）outline 轮廓有点像边框，唯一的区别是边框占用了盒模型的空间，而轮廓没有； 它只是设置在背景图片的顶部。 语法： 12/* 宽度 | 样式 | 颜色 */outline: 1px solid white; 取值： 任意顺序的1~3个属性值。 属性 值 outline-width 关键字（取决于用户代理）：thin/medium/thick长度：10px/1rem全局值:inherit outline-style 关键字：none(默认值);auto; dotted;dashed; solid; double;groove; ridge;inset; outset;全局值:inherit;initial; unset; 例子：123456789101112&lt;head&gt;&lt;style&gt;a:link &#123;/* 未被访问的链接 */ background-color:yellow; outline: solid #000;/*黑色实线框*/&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;&lt;a href=\"www.huanglizhu.github.io\" target=\"_blank\"&gt;点我点我&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"call（）与apply（）","slug":"call()与apply()","date":"2019-10-08T06:26:40.000Z","updated":"2019-11-15T07:14:02.304Z","comments":true,"path":"2019/10/08/call()与apply()/","link":"","permalink":"http://yoursite.com/2019/10/08/call()与apply()/","excerpt":"方法重用：call() 和 apply() 不带参数的使用方法非常相似。 带参数的使用方法有所区别：","text":"方法重用：call() 和 apply() 不带参数的使用方法非常相似。 带参数的使用方法有所区别： 方法 参数 举例 call() 参数列表 person.fullName.call(person1, “Oslo”, “Norway”); apply() 数组形式 person.fullName.apply(person1, [“Oslo”, “Norway”]); 如果要使用数组而不是参数列表，则 apply() 方法非常方便。 面试题语句var arr=[a,b,c,d];执行后，数组arr中每项都是一个整数，能得到其中最大整数语句有： Math.max(arr[0], arr[1], arr[2], arr[3]) Math.max.call(Math, arr[0], arr[1], arr[2], arr[3]) Math.max.apply(Math,arr) 不能得到其中最大整数语句有： 1Math.max(arr) 解析Math的max（）不支持传入数组,所以错误。 JavaScript 函数 Call可以通过 call()调用属于另一个对象的方法。 例子1:普通方法调用 下面的例子创建了带有三个属性的对象（firstName、lastName、fullName）。 12345678var person = &#123; firstName:\"Bill\", lastName: \"Gates\", fullName: function () &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;person.fullName(); // 将返回 \"Bill Gates\" fullName 属性是一个方法。person 对象是该方法的拥有者。 fullName 属性属于 person 对象的方法。 例子2：使用函数 Call分别让person1与person2去调用person的fullName 方法： 123456789101112131415var person = &#123; fullName: function() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;var person1 = &#123; firstName:\"Bill\", lastName: \"Gates\",&#125;var person2 = &#123; firstName:\"Steve\", lastName: \"Jobs\",&#125;person.fullName.call(person1); // 将返回 \"Bill Gates\"person.fullName.call(person2); // 将返回 \"Steve Jobs\" 完整例子 例子3：带参数的 call() 方法让person1带着参数”Seattle”, “USA”去调用person的fullName属性（方法）： 12345678910var person = &#123; fullName: function(city, country) &#123; return this.firstName + \" \" + this.lastName + \",\" + city + \",\" + country; &#125;&#125;var person1 = &#123; firstName:\"Bill\", lastName: \"Gates\"&#125;person.fullName.call(person1, \"Seattle\", \"USA\"); 完整例子 JavaScript 函数 Apply apply()会改变this的指向， 可以通过 apply() 方法调用属于另一个对象的方法。 但不仅限于此，当设置第一个参数为null时可以在某些本来需要写成遍历数组变量的任务中使用内建的函数,也就是说此时apply()的作用不是调用属于另一个对象的方法，而是使参数数组中的每一个元素都去执行func函数。【如：下方例子“使用Apply（）在数组上模拟 max 方法”】 call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。 apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 语法：func.apply(thisArg, [argsArray]) 参数 描述 thisArg 可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时this会自动替换为指向全局对象，原始值会被包装。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 返回值：调用有指定this值和参数的函数的结果。 描述：在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。你也可以使用 arguments对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 例子：使用函数Apply让person1去调用person的fullName 方法： 12345678910var person = &#123; fullName: function() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;var person1 = &#123; firstName: \"Bill\", lastName: \"Gates\",&#125;person.fullName.apply(person1); // 将返回 \"Bill Gates\" 例子：带参数的 apply() 方法apply() 方法接受数组中的参数: 12345678910var person = &#123; fullName: function(city, country) &#123; return this.firstName + \" \" + this.lastName + \",\" + city + \",\" + country; &#125;&#125;var person1 = &#123; firstName:\"John\", lastName: \"Doe\"&#125;person.fullName.apply(person1, [\"Oslo\", \"Norway\"]); 完整例子 使用Apply（）在数组上模拟 max 方法Math的max()方法首先我们了解可以使用Math.max() 方法找到（数字列表中的）最大数字： 1Math.max(1,2,3); // 会返回 3 完整例子 让数组调用Math的max()方法 但是JavaScript 数组没有 max() 方法，因此我们可以通过apply（）让数组调用 Math的max() 方法： 1Math.max.apply(null, [1,2,3]); // 也会返回 3 完整例子 第一个参数（null）无关紧要。在本例中未使用它。这些例子会给出相同的结果： Math.max.apply(Math, [1,2,3]); // 也会返回 3 Math.max.apply(&quot; &quot;, [1,2,3]); // 也会返回 3 Math.max.apply(0, [1,2,3]); // 也会返回 3 JavaScript 严格模式在 JavaScript 严格模式下，如果 apply()方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"函数相关知识点补充","slug":"函数相关知识点补充","date":"2019-10-07T08:10:44.000Z","updated":"2020-02-01T09:10:13.100Z","comments":true,"path":"2019/10/07/函数相关知识点补充/","link":"","permalink":"http://yoursite.com/2019/10/07/函数相关知识点补充/","excerpt":"函数是对象 JavaScript 函数是通过 function 关键词定义的。JavaScript 中的 typeof 运算符会为函数返回 “function”。但是最好是把 JavaScript 函数描述为对象。 JavaScript 函数都有属性和方法。","text":"函数是对象 JavaScript 函数是通过 function 关键词定义的。JavaScript 中的 typeof 运算符会为函数返回 “function”。但是最好是把 JavaScript 函数描述为对象。 JavaScript 函数都有属性和方法。 函数的对象属性arguments.length返回函数被调用时收到的参数数目： 123function myFunction(a, b) &#123; return arguments.length;//2&#125; 完整例子 函数的对象方法toString()以字符串形式返回函数： 12345function myFunction(a, b) &#123; return a * b;&#125;var txt = myFunction.toString(); 完整例子 函数声明与函数表达式函数声明 被声明的函数不会直接执行。它们被“保存供稍后使用”，当它们被调用时执行。 无法对函数声明进行自调用 一个名为multiply的函数声明：123function multiply(x, y) &#123; return x * y;&#125; // 没有分号 函数表达式 JavaScript 函数也可以用表达式来定义。 函数表达式可以在变量中存储。 在变量中保存函数表达式之后，此变量可用作函数. 存放在变量中的函数不需要函数名。他们总是使用变量名调用。 一个匿名函数的函数表达式，被赋值给变量multiply： 123var multiply = function(x, y) &#123; return x * y; &#125;; 一个命名为func_named的函数的函数表达式，被赋值给变量multiply： 123var multiply = function func_name(x, y) &#123; return x * y;&#125;; 注意：在函数外部无法通过 func_name 访问到函数，因为这已经变成了一个表达式。 自调用函数 函数表达式可以自调用。 自调用表达式是自动被调用（开始）的，在不进行调用的情况下。 函数表达式会自动执行，假如表达式后面跟着 ()。 您无法对函数声明进行自调用。 您需要在函数周围添加括号，以指示它是一个函数表达式。 匿名的自调用函数（没有名称的函数）例子：123(function () &#123; var x = \"Hello!!\"; //我会调用我自己&#125;)(); 完整例子 变量与函数提升 关于提升MDN 首先要明确，变量是申明被提升，函数在ES5中是整个函数被提升，在ES6中是只提升函数的声明（具体见例子），函数内容（变量初始化的值）是不会被提升的，他们将被留在原来的位置。 这导致了JavaScript 函数能够在声明之前被调用，不过会undefined，还是建议规范书写代码。 函数声明式存在函数提升，函数表达式的写法不存在函数提升。 函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。 ES5中说，在全局和函数作用域中定义的函数的声明和定义都将会被提前到当前作用域的顶部。 补充：当出现多个同名变量与同名函数时，调用该变量名时的优先级为：变量声明&lt; 函数声明 &lt; 变量赋值（具体参考牛客网20191215第7题） 变量提升 ES6之前只有全局作用域和函数作用域，这两个作用域都存在变量提升。 var命令声明的变量，不管在什么位置，变量声明都会被提升到当前作用域的头部。 注意：变量声明被提升到了当前作用域的头部， ES6之前只有全局作用域和函数作用域，if不是函数作用域，所以变量tmp提升到了foo函数的头部。123456789101112function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125; // 等同于function foo(x) &#123; var tmp;//注意：提升到了if的外面 if (x &gt; 100) &#123; tmp = x - 100; &#125;; 函数提升例子我们正常书写的代码： 12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 实际在内存中被函数提升以后： 123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); 在ES5中，在if内声明的函数f会被提升到函数头部（作用域顶部）。 1234567891011// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined;//函数f的声明提升 if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 而在ES6中，块级作用域内声明的函数，行为类似于var声明的变量。（只提升声明）函数f是在块级作用域内被声明的，因此函数f的声明被提升到了块级作用域的顶部。 箭头函数 IE11 或更早的版本不支持箭头函数。 箭头函数允许使用简短的语法来编写函数表达式。 不需要 function 关键字、return 关键字和花括号。 1234567// ES5var x = function(x, y) &#123; return x * y;&#125;// ES6const x = (x, y) =&gt; x * y; 箭头函数没有自己的 this。它们不适合定义对象方法。 箭头函数未被提升。它们必须在使用前进行定义。 使用 const 比使用 var 更安全，因为函数表达式始终是常量值。 如果函数是单个语句，则只能省略 return 关键字和大括号。因此，保留它们可能是一个好习惯： 1const x = (x, y) =&gt; &#123; return x * y &#125;; 返回对象需要注意如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 12// SyntaxError:x =&gt; &#123; foo: x &#125; 因为和函数体的{ ... }有语法冲突，所以要改为： 12// ok:x =&gt; (&#123; foo: x &#125;) 可参考廖雪峰的博客","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"js对象 学习笔记（2）","slug":"js对象 学习笔记（2）","date":"2019-10-06T13:55:06.000Z","updated":"2019-10-07T07:03:50.451Z","comments":true,"path":"2019/10/06/js对象 学习笔记（2）/","link":"","permalink":"http://yoursite.com/2019/10/06/js对象 学习笔记（2）/","excerpt":"JavaScript 对象访问器（Getter 和 Setter）Getter 和 Setter与函数相比的优点： 它提供了更简洁的语法（Getter 和 Setter使用属性形式访问对象方法，不用加括号）","text":"JavaScript 对象访问器（Getter 和 Setter）Getter 和 Setter与函数相比的优点： 它提供了更简洁的语法（Getter 和 Setter使用属性形式访问对象方法，不用加括号） 它允许属性和方法的语法相同 它可以确保更好的数据质量 有利于后台工作 Getter（get 关键词）12345678910111213141516171819202122&lt;body&gt;&lt;p&gt;Getter 和 Setter 允许您通过方法获取和设置属性。&lt;/p&gt;&lt;p&gt;此示例使用 lang 属性来获取语言属性的值。&lt;/p&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;// 创建对象：var person = &#123; firstName: \"Bill\", lastName : \"Gates\", language : \"en\", get lang() &#123; return this.language; &#125;&#125;;// 使用 getter 显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.lang;&lt;/script&gt;&lt;/body&gt; 完整例子 Setter（set 关键词）1234567891011121314var person = &#123; firstName: \"Bill\", lastName : \"Gates\", language : \"\", set lang(lang) &#123; this.language = lang; &#125;&#125;;// 使用 setter 来设置对象属性：person.lang = \"en\";// 显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.language; 完整例子 JavaScript 函数与 Getter的访问方法不同例子1使用函数： 12345678910var person = &#123; firstName: \"Bill\", lastName : \"Gates\", fullName : function() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;;// 使用方法来显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.fullName(); 例子2使用Getter： 12345678910var person = &#123; firstName: \"Bill\", lastName : \"Gates\", get fullName() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.fullName; 总结： 例子 1 以函数形式访问 fullName：person.fullName()。 例子 2 以属性形式访问 fullName：person.fullName。 第二个例子提供了更简洁的语法。 JavaScript 对象构造器总结 用大写首字母对构造器函数命名是个好习惯。 123456function Person(first, last, age, eye) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eye;&#125; 给已有对象添加属性： 1对象名.新属性名=\"新属性值\" 给已有对象添加新方法: 1对象名.新方法名=function()&#123;函数内容&#125; 给构造器添加新属性: 方法1：回到构造器函数中进行增加。 方法2：构造器名.prototype.新属性名=&quot;新属性值&quot; 给构造器添加新方法： 方法1：回到构造器函数中进行增加。 方法2：构造器名.prototype.新方法名=function(){函数内容} 对象类型（蓝图）（类） 在上面的例子中，函数 Person() 就是对象构造器函数。 通过 new 关键词调用构造器函数可以创建相同类型的对象：12var myFather = new Person(\"Bill\", \"Gates\", 62, \"blue\");var myMother = new Person(\"Steve\", \"Jobs\", 56, \"green\"); 完整例子 this 关键词 在 JavaScript 中，被称为 this 的事物是代码的“拥有者”。 this 的值，在对象中使用时，就是对象本身。 在构造器函数中，this 是没有值的。它是新对象的替代物。 当一个新对象被创建时，this 的值会成为这个新对象。 请注意 this 并不是变量。它是关键词。您无法改变 this 的值。 为(已有)对象添加属性新属性被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 1myFather.nationality = \"English\"; 为(已有)对象添加方法新方法被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 123myFather.name = function () &#123; return this.firstName + \" \" + this.lastName;&#125;; 为构造器添加属性 为(已有)对象添加新属性与新方法都很简单，但与他们不同，为对象构造器添加新属性必须添加到构造器函数内（错误示范：像Person.nationality = &quot;English&quot;;这样会undefined） 1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.nationality = \"English\";&#125; 这样对象属性就可以拥有默认值。 完整例子 为构造器添加方法 同样无法为对象构造器添加新方法，必须在构造器函数内部向一个对象添加方法：12345678910111213141516171819202122232425&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;// Person 对象的构造器函数function Person(firstName,lastName,age,eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; //在构造器函数内部向一个对象添加方法 this.changeName = function (name) &#123; //changeName() 函数把 name 赋值给 person 的 lastName 属性 this.lastName = name; &#125;&#125;// 创建 Person 对象var myFriend = new Person(\"Bill\",\"Gates\",62,\"green\");// 修改姓氏myFriend.changeName(\"Jobs\");// 显示姓氏document.getElementById(\"demo\").innerHTML =\"My friend's last name is \" + myFriend.lastName;&lt;/script&gt; 完整例子 内建 JavaScript 构造器Math() 对象不算，Math 是全局对象。new 关键词不可用于 Math。 12345678var x1 = &#123;&#125;; // 新对象var x2 = \"\"; // 新的原始字符串var x3 = 0; // 新的原始数值var x4 = false; // 新的原始逻辑值var x5 = []; // 新的数组对象var x6 = /()/ // 新的正则表达式对象var x7 = function()&#123;&#125;; // 新的函数对象var x8 = new Date(); // 一个新的 Date 对象 完整例子 JavaScript 对象原型所有 JavaScript 对象都从原型继承属性和方法。 原型继承 日期对象继承自 Date.prototype。 数组对象继承自 Array.prototype。 Person 对象继承自 Person.prototype。 Object.prototype 位于原型继承链的顶端：日期对象、数组对象和 Person 对象都继承自 Object.prototype。 使用 prototype 属性为对象构造器添加新属性/方法注意：请只修改自己的原型。绝不要修改标准 JavaScript 对象的原型。 为对象构造器添加新属性：1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.nationality = \"English\"; 完整例子 为对象构造器添加新方法：123456789function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.name = function() &#123; return this.firstName + \" \" + this.lastName;&#125;; 完整例子","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"hexo中hipaper主题——解决小火箭被目录覆盖问题","slug":"解决小火箭被目录覆盖问题","date":"2019-10-05T10:29:00.000Z","updated":"2019-10-05T10:51:10.641Z","comments":true,"path":"2019/10/05/解决小火箭被目录覆盖问题/","link":"","permalink":"http://yoursite.com/2019/10/05/解决小火箭被目录覆盖问题/","excerpt":"出问题页面F12 发现目录覆盖小火箭","text":"出问题页面F12 发现目录覆盖小火箭 找出样式表 通过style.css找到样式表位置在css文件夹里 全局搜索找到toc-fixed全局搜索真的很重要！一开始在style.styl里面搜索了好久都找不到 打开E:\\Program Files\\Hexo\\themes\\hipaper\\source\\css 在css文件夹内空白处右键打开vscode 点击左边放大镜图标，全局搜索toc-fixed 发现我们要修改的实际上在E:\\Program Files\\Hexo\\themes\\hipaper\\source\\css\\ partial\\article.styl里面 修改为width: 350px !important; 发现小火箭不会被覆盖了","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"hipaper","slug":"hipaper","permalink":"http://yoursite.com/tags/hipaper/"}]},{"title":"js对象 学习笔记（1）","slug":"js对象 学习笔记（1）","date":"2019-10-03T12:31:00.000Z","updated":"2019-10-07T07:03:24.094Z","comments":true,"path":"2019/10/03/js对象 学习笔记（1）/","link":"","permalink":"http://yoursite.com/2019/10/03/js对象 学习笔记（1）/","excerpt":"对象 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。","text":"对象 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。 布尔是对象（如果用 new 关键词定义） 数字是对象（如果用 new 关键词定义） 字符串是对象（如果用 new 关键词定义） 日期永远都是对象 算术永远都是对象 正则表达式永远都是对象 数组永远都是对象 函数永远都是对象 对象永远都是对象 原始值 原始值指的是没有属性或方法的值。 原始数据类型指的是拥有原始值的数据。 JavaScript 定义了 5 种原始数据类型： string number boolean null undefined 原始值是一成不变的（它们是硬编码的，因此不能改变）。 假设 x = 3.14，您能够改变 x 的值。但是您无法改变 3.14 的值。 对象定义 对象是包含变量的变量 JavaScript 对象是命名值的集合。 对象也是变量。但是对象能够包含很多值。 值按照名称 : 值对的形式编写（名称和值以冒号分隔）。1var person = &#123;firstName:\"Bill\", lastName:\"Gates\", age:62, eyeColor:\"blue\"&#125;; 对象属性 属性指的是与 JavaScript 对象相关的值。 JavaScript 对象是无序属性的集合。 属性通常可以被修改、添加和删除，但是某些属性是只读的。 firstName、lastName、age、eyeColor就是属性。 访问对象属性的两种方法 您可以使用 .property (例子1 )或[&quot;property&quot;]( 例子2) JavaScript for…in 循环JavaScript for…in 语句遍历对象的属性。 123for (variable in object) &#123; 要执行的代码&#125; for…in 循环中的代码块会为每个属性执行一次。 1234567891011121314151617&lt;body&gt;&lt;h1&gt;JavaScript 对象属性&lt;/h1&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;var txt = \"\";var person = &#123;fname:\"Bill\", lname:\"Gates\", age:62&#125;; var x;for (x in person) &#123; txt += person[x] + \" \";&#125;document.getElementById(\"demo\").innerHTML = txt;&lt;/script&gt;&lt;/body&gt; 在这里，x依次是fname、lname、age。 例子运行效果 添加新属性 可以通过简单的赋值，向已存在的对象添加新属性。 不能使用预留词作为属性名（或方法名）。请使用 JavaScript 命名规则。1person.nationality = \"English\"; 完整例子 删除属性 delete 关键词会同时删除属性的值和属性本身。 删除完成后，属性在被添加回来之前是无法使用的。 delete 操作符被设计用于对象属性。它对变量或函数没有影响。 delete 操作符不应被用于预定义的 JavaScript 对象属性。这样做会使应用程序崩溃。12var person = &#123;firstName:\"Bill\", lastName:\"Gates\", age:62, eyeColor:\"blue\"&#125;;delete person.age; // 或 delete person[\"age\"]; 完整例子 JavaScript 对象继承了它们的原型的属性。 delete 关键词不会删除被继承的属性，但是如果您删除了某个原型属性，则将影响到所有从原型继承的对象。 对象方法 方法是可以在对象上执行的动作。 对象属性可以是原始值、其他对象以及函数。 对象方法是包含函数定义的对象属性。 属性 值 firstName Bill fullName function() {return this.firstName + “ “ + this.lastName;} this 关键词 在 JavaScript 中，被称为 this 的事物，指的是拥有该 JavaScript 代码的对象。 this 的值，在函数中使用时，是“拥有”该函数的对象。 请注意 this 并非变量。它是关键词。您无法改变 this 的值。 创建与访问对象方法 创建对象方法： 1methodName : function() &#123; 代码行 &#125; 访问对象方法： 1objectName.methodName() 此例访问 person 对象的 fullName() 方法：例子 如果访问 fullName 属性时没有使用 ()，则将返回函数定义：例子 使用内建方法 此例使用 String 对象的 toUpperCase() 方法，把文本转换为大写：12var message = \"Hello world!\";var x = message.toUpperCase(); x 的值，在以上代码执行后将是： 1HELLO WORLD! 添加新的方法向对象添加方法是在构造器函数内部完成的：(更多相关知识在js对象 学习笔记（2）中的“JavaScript 对象构造器”内) 123456789function person(firstName, lastName, age, eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; this.changeName = function (name) &#123; this.lastName = name; &#125;;&#125; changeName() 函数 name 的值赋给了 person 的 lastName 属性。 1myMother.changeName(\"Jobs\"); 完整例子 通过用 myMother “替代” this。 this 的值，在对象中使用时，就是对象本身。 在构造器函数中，this 是没有值的。它是新对象的替代物。 当一个新对象被创建时，this 的值会成为这个新对象。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"AJAX异步更新","slug":"AJAX异步更新","date":"2019-10-02T12:10:37.000Z","updated":"2019-10-02T12:17:44.771Z","comments":true,"path":"2019/10/02/AJAX异步更新/","link":"","permalink":"http://yoursite.com/2019/10/02/AJAX异步更新/","excerpt":"什么是 AJAX ？ AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。","text":"什么是 AJAX ？ AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。 步骤 创建对象：通过检测window对象是否有XMLHttpRequest属性来判断浏览器是否支持标准的XMLHttpRequest，创建XMLHttpRequest对象（不支持则创建ActiveXObject对象）。 判断对象状态：通过XMLHttpRequest的onreadystatechange属性（以及readyState还有status属性）判断对象状态（请求是否初始化、服务器连接是否建立、请求是否接收、请求是否处理中、请求是否已完成且响应已就绪）。 判断到“请求已完成且响应已就绪”时执行函数：直到判断出服务器响应已做好被处理的准备时就使用XMLHttpRequest 对象（或者ActiveXObject对象）的 responseText 或 responseXML 属性来获得响应数据。 向服务器发送请求：使用XMLHttpRequest 对象（或者ActiveXObject对象）的 open() 和 send() 方法向服务器发送请求。 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function loadXMLDoc()&#123;var xmlhttp;//1.创建XMLHttpRequest对象if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;//2.每当XMLHttpRequest对象状态发生变化时，调用onreadystatechange属性xmlhttp.onreadystatechange=function() &#123;//3.通过readyState和status判断请求是否初始化等（具体看readyState参数值） if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123;//4.判断出“请求已完成，且响应已就绪”时, //通过responseText属性获取来自服务器响应的数据 document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;//5.向服务器发送请求xmlhttp.open(\"GET\",\"/ajax/test1.txt\",true);xmlhttp.send();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"myDiv\"&gt;&lt;h2&gt;Let AJAX change this text&lt;/h2&gt;&lt;/div&gt;&lt;button type=\"button\" onclick=\"loadXMLDoc()\"&gt;通过 AJAX 改变内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 原链接 使用多个AJAX任务的步骤 如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。 该函数调用应该包含 URL (发送请求时open方法的参数url)以及发生 onreadystatechange 事件（发生状态变化）时执行的任务（每次调用可能不尽相同） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;var xmlhttp;//标准函数loadXMLDocfunction loadXMLDoc(url,cfunc)&#123;//1.判断是否含有XMLHttpRequest属性，创建对象if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;//2.每当 XMLHttpRequest对象状态发生改变时，就会调用onreadystatechange（也就是cfunc）xmlhttp.onreadystatechange=cfunc;//4.向服务器发送请求xmlhttp.open(\"GET\",url,true);xmlhttp.send();&#125;function myFunction()&#123;loadXMLDoc(\"/ajax/test1.txt\",function() &#123;//3.调用标准函数，把url传入并编写标准函数中的cfunc（即：每当XMLHttpRequest对象状态发生改变时会调用的函数） if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"myDiv\"&gt;&lt;h2&gt;Let AJAX change this text&lt;/h2&gt;&lt;/div&gt;&lt;button type=\"button\" onclick=\"myFunction()\"&gt;通过 AJAX 改变内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 原链接 AJAX 的基础：XMLHttpRequest XMLHttpRequest 对象用于和服务器交换数据。 创建 XMLHttpRequest 对象 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 但是老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象. 所以为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： 123456789var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();//创建 XMLHttpRequest 对象 &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");//创建ActiveX 对象 &#125; 通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。 向服务器发送请求 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：12xmlhttp.open(\"GET\",\"test1.txt\",true);xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method:请求的类型,GET 或 POSTurl:文件在服务器上的位置async:true（异步）或 false（同步）,默认true，可不写 send(string) 将请求发送到服务器。string:仅用于 POST 请求 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。 GET 还是 POST？ 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 注意区分:表单中的method属性值默认GET，推荐使用 POST（更加安全）。 GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得 XML 形式的响应数据 responseText属性使用方法：1document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; responseXML 属性使用方法 如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： 请求 books.xml 文件，并解析响应： 12345678xmlDoc=xmlhttp.responseXML;txt=\"\";x=xmlDoc.getElementsByTagName(\"ARTIST\");for (i=0;i&lt;x.length;i++) &#123; txt=txt + x[i].childNodes[0].nodeValue + \"&lt;br /&gt;\"; &#125;document.getElementById(\"myDiv\").innerHTML=txt; 完整例子 onreadystatechange 事件 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是** XMLHttpRequest 对象的三个重要的属性**： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK” ；404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪。 使用 Callback 函数 callback 函数是一种以参数形式传递给另一个函数的函数。 如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。 该函数调用应该包含 URL (发送请求时open方法的参数url)以及发生 onreadystatechange 事件（发生状态变化）时执行的任务（每次调用可能不尽相同） 函数调用： 1234567891011function myFunction()&#123;//调用标准函数，把url传入并编写标准函数中的cfunc（即：每当readyState 属性改变时会调用的函数）loadXMLDoc(\"/ajax/test1.txt\",function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125; 被调用的标准的函数： 1234567891011121314151617function loadXMLDoc(url,cfunc)&#123;//判断是否含有XMLHttpRequest属性，创建对象if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;//每当 readyState 属性改变时，就会调用onreadystatechange（也就是cfunc）xmlhttp.onreadystatechange=cfunc;//向服务器发送请求xmlhttp.open(\"GET\",url,true);xmlhttp.send();&#125; 例子 廖雪峰关于AJAX的文章","categories":[{"name":"AJAX学习","slug":"AJAX学习","permalink":"http://yoursite.com/categories/AJAX学习/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"}]},{"title":"外联样式表没有效果，但是内联正常的解决方法","slug":"综合课程问题1","date":"2019-10-02T12:10:37.000Z","updated":"2019-10-20T08:42:51.828Z","comments":true,"path":"2019/10/02/综合课程问题1/","link":"","permalink":"http://yoursite.com/2019/10/02/综合课程问题1/","excerpt":"在做学校综合课程的大作业时遇到的问题外联样式表没有效果，但是内联正常的解决方法外联css不起作用但是内联样式表没问题时，可能是服务器端缓存导致样式不刷新了?反正解决方法是： 右键“刷新”按钮 点击“清空缓存并硬性重新加载”","text":"在做学校综合课程的大作业时遇到的问题外联样式表没有效果，但是内联正常的解决方法外联css不起作用但是内联样式表没问题时，可能是服务器端缓存导致样式不刷新了?反正解决方法是： 右键“刷新”按钮 点击“清空缓存并硬性重新加载” &lt;c:url&gt;标签 标签中的value属性如果以/开头，则标签会在重新生成的URL中加上当前Web应用的根路径。 例子 如果你想在login.jsp（路径是goods/WebRoot/jsps/user/login.jsp）里面外联样式表goods/WebRoot/jsps/css/user/login.css,但当前web应用的根路径是http://localhost:8080/goods,所以要想使用login.css要用&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;c:url value=&#39;/jsps/css/user/login.css&#39;/&gt;&quot;&gt;，他会自动在前面补上当前web应用的路径，也就相当于goods/WebRoot/jsps/css/user/login.css了。 如果不这样写的话，经过UserServlet刷新以后有可能读不到外联的样式表。（因为经过请求转发以后路径变了，依照普通的写法就读不到我们想要的样式表了，这个时候就要借助&lt;c:url&gt;标签） 在通常情况下，我们的JSP和这些资源文件的引入都是正常的，也就是说浏览器在解析页面的时候可以通过路径找到这些资源文件；而当我们在内部Servlet处理页面传回来的数据的时候，如果我们进行了请求转发，并且请求转发给了JSP（嵌入JAVA代码的JSP页面可以看成是一个Servlet），最后由JSP返回页面数据，那么这个过程是纯服务端操作，在客户端浏览器并不知情； 通俗点说，即假设A与B不在一个路径下且其外部资源路径都与自己同目录下存放，浏览器向A发起了一个请求，A不想干，让B去干，然后由B返回给浏览器结果，但是浏览器以为还是A发来的，这个时候浏览器还是把A所需要的外部资源给B，结果发现不是B所需要的！","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JS中的同步与异步","slug":"js同步与异步","date":"2019-10-01T10:00:05.000Z","updated":"2020-02-04T11:29:58.971Z","comments":true,"path":"2019/10/01/js同步与异步/","link":"","permalink":"http://yoursite.com/2019/10/01/js同步与异步/","excerpt":"作用域 作用域就是代码的执行环境，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是栈内存。总的来说，作用域就是代码执行时开辟的栈内存。","text":"作用域 作用域就是代码的执行环境，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是栈内存。总的来说，作用域就是代码执行时开辟的栈内存。 总结 描述 私有作用域 函数执行都会形成一个私有作用域 全局作用域 页面一打开就会形成一个全局的作用域 私有变量 在私有作用域里边形成的变量 (通过 var 声明； 形参) 全局变量 在全局作用域形成的变量（var a = 12 或者函数内没有声明，直接赋值的变量） 某个执行环境中所有的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出时，如关闭浏览器或网页，才会被销毁） 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将被环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 作用域链 当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条） 作用域链的前端，始终都是当前执行的代码所在环境的变量对象 作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境 全局执行环境的变量对象始终都是作用域链上的最后一个对象 内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。 所以执行函数时，作用域链是从内到外来排序的。（有形参找形参，没有才找外部的全局变量） 形参与实参 参数 概念 形参（形式参数） 是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。 实参（实际参数） 是在调用时传递给函数的参数，即传递给被调用函数的值。 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量。（随着函数被调用而新建，随着函数销毁而销毁） 函数调用中发生的数据传送是单向的，即只能把实参的值传给形参，而不能把形参的值传给实参。因此，在函数调用的过程中，形参的值可以改变，而实参的值则不会变化。 参考 执行栈例子注意：执行函数时，作用域链是从内到外来排序的。（有形参找形参，没有才找外部的全局变量） 1234567var count = 0;function foo(count) &#123;//count形参 count += 1;//私有变量count console.log(count);//私有变量count&#125;foo(count); // 1 count实参foo(count); // 1 函数的形参属于函数执行上下文，所以当指定这个形参后，它就随着函数被调用而新建，随着函数销毁而销毁。 指定了这个形参，调用函数时传递进来的实参count（0）会沿着作用域链找到私有变量 count（接下来的操作都在私有变量上进行），而不是全局变量count。 步骤我们用执行栈来理解一下 函数每次被调用都会产生新的执行上下文（私有变量 count），实参count（全局变量count）的数据（0）被传入函数，私有变量 count变为0，并被压入执行栈，执行完毕后输出1，当前上下文接着被弹出执行栈，私有变量 count被销毁。 再次调用时又随着函数被调用而新建私有变量 count，重复第一步。 （函数内的操作都在私有变量身上进行，随着私有变量的销毁上一次的操作就没了）所以第一次调用应该返回 1，第二次调用也应该返回 1，第 n 次调用都应该返回 1。 1234567var count = 0;function foo() &#123; count += 1;//全局变量count console.log(count);//全局变量count&#125;foo(count); // 1foo(count); // 2 函数的形参属于函数执行上下文，所以当指定这个形参后，它就随着函数被调用而新建，随着函数销毁而销毁。如果不指定这个形参，实参count（0）传进函数以后找不到形参就会沿着作用域链找到全局变量 count，它属于全局执行上下文，这个时候再去调用 foo() 函数就会读写这个全局变量（也就是函数里的所有操作都是在全局变量上进行的）。 全局变量不会随着函数的调用而新建，也不会随着函数的销毁而销毁。 每个 foo() 函数调用后，给 count（全局变量） 加一，然后被弹出执行栈，而全局执行上下文的生命周期将伴随着整个程序，所以第一次调用打印 1，第二次调用打印 2，第 n 次调用打印 n。 JS的同步与异步为什么会有同步和异步因为JavaScript是单线程，因此单一时间内只能处理单一任务，所有任务都需要排队，前一个任务执行完，才能继续执行下一个任务。但是，如果前一个任务的执行时间很长，比如文件的读取操作或ajax操作，后一个任务就不得不等着，拿ajax来说，当用户向后台获取大量的数据时，不得不等到所有数据都获取完毕才能进行下一步操作，用户只能在那里干等着，严重影响用户体验。因此，JavaScript在设计的时候，就已经考虑到这个问题，主线程可以完全不用等待文件的读取完毕或ajax的加载成功，可以先挂起处于等待中的加载任务，先运行排在后面的任务，等到文件的读取或ajax有了结果后，再回过头执行挂起的任务（这就是异步），因此，任务就可以分为同步任务和异步任务。 同步任务同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务。 异步任务异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务 js的异步机制 同步任务进入总线程，异步任务不会进入主线程，而是会先进入任务队列，任务队列其实是一个先进先出的数据结构，也是一个事件队列。 比如说文件读取操作，因为这是一个异步任务，因此该任务会被添加到任务队列中，等到IO（输入输出）完成后，就会在任务队列中添加一个事件，表示异步任务准备好啦，可以进入执行栈啦~但是这时候呀，主线程不一定有空，当主线程处理完其它任务有空时，就会读取任务队列，读取里面有哪些事件，排在前面的事件会被优先进行处理，如果该任务指定了回调函数，那么主线程在处理该事件时，就会执行回调函数中的代码，也就是执行异步任务啦 单线程从从任务队列中读取任务是不断循环的，每次栈被清空后，都会在任务队列中读取新的任务，如果没有任务，就会等，直到有新的任务，这就叫做任务循环，因为每个任务都是由一个事件触发的，因此也叫作事件循环。 步骤总结： 所有同步任务都在主线程上执行，行成一个执行栈 主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面还有哪些事件，那些对应的异步任务，于是结束等待状态，（异步任务）进入执行栈，开始执行 主线程不断的重复上面的第三步 js的异步编程回调函数 AJAX Promise js中的同步与异步 理解 JavaScript 执行栈 作用域","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"百度前端技术学院 第四天学习笔记（1）（CSS背景）","slug":"百度前端技术学院 第四天学习笔记（1）","date":"2019-09-26T07:47:25.000Z","updated":"2019-11-19T09:26:55.646Z","comments":true,"path":"2019/09/26/百度前端技术学院 第四天学习笔记（1）/","link":"","permalink":"http://yoursite.com/2019/09/26/百度前端技术学院 第四天学习笔记（1）/","excerpt":"补充：margin和padding的区别 在CSS中margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。 在CSS中padding是指自身边框到自身内部另一个容器边框之间的距离，就是容器内边距。","text":"补充：margin和padding的区别 在CSS中margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。 在CSS中padding是指自身边框到自身内部另一个容器边框之间的距离，就是容器内边距。 特别注意 background内如果想要放background-size的值呢就必须有position的值才行 参考MDN并且，&lt;background-size&gt;值只能紧接在&lt;position&gt;后面，并以/字符分隔，例如：“ left/cover”。 不起作用： 1background: url(上校.jpg) cover no-repeat fixed; 起作用： 1background: url(上校.jpg) left/cover no-repeat fixed; 1background: url(上校.jpg) no-repeat fixed; 背景background总结 为了清晰地显示出段落和链接的背景图像，需要为它们设置了少许内边距（padding），外边距（margin）是没用的。 【推荐使用】background简写所有背景属性编写background值时，需要遵循一些规则例如： background-color只能在最后一个逗号后指定。 background-size只能紧随在background-position后并以/字符分隔，如下所示：center/80%。 所有注意事项 概述1234body &#123; background : #00FF00 url(bgimage.gif) no-repeat fixed top; &#125; 通常建议使用这个属性，而不是分别使用单个属性，因为这个属性在较老的浏览器中能够得到更好的支持。 注意：属性值之间使用空格分隔开。如果使用多个背景，则需要为第一个背景指定所有属性，然后在逗号后添加下一个背景。 如果不设置其中的某个值，也不会出问题，所有省略的子值都将设置为其初始值。 可以设置如下属性： background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image 例子123456.box &#123; background : linear-gradient(105deg, rgba(255,255,255,.2) 39%, rgba(51,56,57,1) 96%) center 400px 200px no-repeat,/*渐变*/ url(big-star.png) center no-repeat, /*background-size（400px 200px）只能紧随在background-position（center）后并以'/'字符分隔*/ purple;/*紫色背景色要放在最后*/&#125; background-color属性设置背景颜色1background-color: gray; 补充： rgba颜色中Alpha为色彩空间，也就是透明度/不透明度。它的范围为0.0到1.0之间，0.5为半透明。 rgba(255,255,255,0)则表示完全透明的白色； rgba(0,0,0,1)则表示完全不透明的黑色； background-image属性设置背景图片12background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);padding: 20px; 如果除了背景图像之外还指定了背景色，则图像会显示在该颜色的顶部: 1234.b &#123; background-image: url(star.png); background-color:red;&#125; background-size属性设置背景图片大小 background-size: length|percentage|cover|contain 属性值为length用法 设置背景图像的高度和宽度。 第一个值设置宽度，第二个值设置高度。 如果只设置一个值，则第二个值会被设置为 “auto”。123background-size:100px； //背景图片显示的宽为100像素background-size:100px 160px；//背景图片显示的宽为100像素，高为600像素 属性值为percentage用法 以父元素的百分比来设置背景图像的宽度和高度。 第一个值设置宽度，第二个值设置高度。 如果只设置一个值，则第二个值会被设置为 “auto”。123background-size：60%； //背景图片的显示宽度和高度是图片大小60%；background-size：60% 80%； // 背景图片的显示宽度是图片大小的60%，高度是80%； 属性值为cover用法 把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。保留其宽高比。在这种情况下，某些图像可能会出现在盒子外面 背景图像的某些部分也许无法显示在背景定位区域中。 把y轴拉满，x轴够长的话会平铺重复显示图片。 1background-size：cover； //把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 注意：加上background-attachment: fixed;将图片固定在可视范围内时，图片把x轴拉满（反过来了） 属性值为contain用法 把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。浏览器将使图像大小合适以适合框内。 在这种情况下，如果图像的长宽比与盒子的长宽比不同，则可能会在图像的两侧或顶部和底部出现间隙。 把x轴拉满，y轴够长的话会平铺重复显示图片。1background-size：contain； //把图像图像扩展至最大尺 注意：加上background-attachment: fixed;将图片固定在可视范围内时，图片把y轴拉满（反过来了），x轴右边可能空缺一部分。 background-repeat属性设置背景重复注意：不设置该属性则默认全屏重复（铺满）。 属性值repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。 1background-repeat: repeat-y; background-position属性设置背景定位注意 使用该属性之前需要先设置background-repeat:no-repeat;确保图片不会被铺满整个页面。 位置关键字如果是一对则可以按任何顺序出现。如果是单个关键字和长度/百分比混合使用最好将lefy/right放在长度/百分比左边，将top/bottom放在长度/百分比右边。另，要保证不超过两个关键字(注意是关键字！background-position: top 20px right 10px;表示将背景从顶部放置20px，从右侧放置10px)，一个对应水平方向，另一个对应垂直方向。 属性值可以通过一对或单个关键字、百分数、长度值来给他提供值，如果使用单个则默认另一个关键字是 center。 使用关键字提供属性值 top、bottom、left、right 和 center 123background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);background-repeat:no-repeat;background-position:top right; 使用百分数值提供属性值 百分数值同时应用于元素和图像 如果只提供一个百分数值，所提供的这个值将用作水平值，垂直值将假设为 50%。这一点与关键字类似。 background-position 的默认值是 0% 0%，在功能上相当于 top left。 123background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);background-repeat:no-repeat;background-position:50% 50%; 其中心与其元素的中心对齐。也就是说，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐。 如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角。 使用长度值提供属性值 还可以使用长度值，如 100px 或 5cm。 长度值解释的是元素内边距区左上角的偏移。偏移点是图像的左上角。 注意，这一点与百分数值不同，因为偏移只是从一个左上角到另一个左上角。也就是说，图像的左上角与 background-position 声明中的指定的点对齐。 123background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);background-repeat:no-repeat;background-position:50px 100px; 比如，如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上。 属性值混合使用 将背景从顶部放置20px，从右侧放置10px(只有两个关键词)：12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: top 20px right 10px; &#125; 长度以及百分比：12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: 20px 10%; &#125; 将关键字值与长度或百分比混合: 注意：只使用一个关键字的情况最好按照表格顺序，颠倒以后没有效果: 第一个属性值 第二个属性值 lefy/right 长度或百分比 长度或百分比 top/bottom 12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: 20px bottom;&#125; background-attachment属性固定背景图片（背景关联） 如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。 通过设置属性值为fixed可以使图像固定。 属性值 fixed：声明图像相对于可视区是固定的，因此不会受到滚动的影响。 scroll：（默认值）也就是说，在默认的情况下，背景会随文档滚动。123456body &#123; background-image url(CUsersHLZDesktop百度前端上校.jpg); background-size 200px; background-repeat no-repeat; background-attachment fixed;&#125; 多个背景图像 在一个属性中可以指定多个值，并用逗号分隔每个值。 注意：可能最终得到彼此重叠的背景图像。背景将分层，最后列出的背景图像位于堆栈底部，而每个先前的图像堆栈均位于代码后的背景图像的顶部。 123background-image url(image1.png), url(image2.png), url(image3.png), url(image1.png);background-repeat no-repeat, repeat-x, repeat;background-position 10px 20px, top right; 不同属性的每个值将与其他属性中相同位置的值匹配。例如，在上面image1的background-repeat值将为no-repeat。 当不同的属性具有不同数量的值时,数量较少的值会循环,在上面的示例中，有四个背景图像，但只有两个background-position值。前两个位置值将应用于前两个图像，然后它们将再次循环返回(image3将获得第一个位置值，并将image4获得第二个位置值。) 例子最后列出的背景图像位于堆栈底部，而每个先前的图像堆栈均位于代码后的背景图像的顶部： 123.box &#123; background-image url(star.png), url(big-star.png);&#125; 123div class=wrapper div class=boxdivdiv 123.box &#123; background-imageurl(big-star.png), url(star.png);&#125; MDN参考","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第三天学习总结（CSS文本、派生选择器）（2）","slug":"百度前端技术学院 第三天学习总结（CSS文本） 2","date":"2019-09-25T05:30:16.000Z","updated":"2019-11-19T09:21:08.016Z","comments":true,"path":"2019/09/25/百度前端技术学院 第三天学习总结（CSS文本） 2/","link":"","permalink":"http://yoursite.com/2019/09/25/百度前端技术学院 第三天学习总结（CSS文本） 2/","excerpt":"派生(上下文)选择器非常重要！ 如果希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器：","text":"派生(上下文)选择器非常重要！ 如果希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： 1234li strong &#123; font-style: italic;/*斜体*/ font-weight: normal; &#125; 对下面strong元素起作用： 1&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt;&lt;/li&gt; 只有 li 元素中的 strong 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。 id 选择器和派生选择器12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 上面的样式只会应用于出现在 id 是 sidebar 的元素内的段落。 这个元素很可能是 div 或者是表格单元，尽管它也可能是一个表格或者其他块级元素。它甚至可以是一个内联元素，比如&lt;em&gt;&lt;/em&gt; 或者 &lt;span&gt;&lt;/span&gt;，不过这样的用法是非法的,因为 不可以在内联元素 &lt;span&gt; 中嵌入&lt;p&gt;(原因) 即使被标注为 sidebar 的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次：1234567891011121314#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125;#sidebar h2 &#123; font-size: 1em; font-weight: normal; font-style: italic; margin: 0; line-height: 1.5; text-align: right; &#125; class 也可被用作派生选择器1234.fancy td &#123; color: #f60; background: #666; &#125; 在上面这个例子中，类名为 fancy 的更大的元素内部的表格单元都会以灰色背景显示橙色文字。（名为 fancy 的更大的元素可能是一个表格或者一个 div）反过来，元素也可以基于它们的类而被选择：（要注意包含关系，前包含后） 1234td .fancy &#123; color: #f60; background: #666; &#125; 在上面的例子中，类名为 fancy 的表格单元将是带有灰色背景的橙色。 1&lt;td class=\"fancy\"&gt; 选择器的分组你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。 用逗号将需要分组的选择器分开。 在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; 文本样式都有哪些相关属性，对应哪些值“color 属性”设置字体颜色 color 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 text-decoration 属性放置在文本下方或上方的线 (underline overline)。 “font-size属性”设置字体大小 千万注意 数字与单位之间不要有空 格！ 使用rem更加便于以后的维护 需要注意的是rem不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用em 或 px。 需要先设置html的字体大小（ 1rem 等于 HTML 中的根元素的字体大小），设置为10px将便于后面的计算。12345678910111213html &#123; font-size: 10px;//1em=10px&#125;h1 &#123; font-size: 2.6rem;//26px&#125;p &#123; font-size: 1.4rem;//14px color: red; font-family: Helvetica, Arial, sans-serif;&#125; “font-family属性”设置字体样式 使用字体栈并且将字体栈的最后一个值设置为网络安全字体（通用字体）。 123p &#123; font-family: \"Trebuchet MS\", Verdana, sans-serif;&#125; 注意: 有一些字体名称不止一个单词，比如Trebuchet MS ，那么就需要用引号包裹。 “text-decoration属性”非常有趣可用于在设置链接时取消设置链接上的默认下划线。 可用值为： none: 取消已经存在的任何文本装饰。 underline: 文本下划线. overline: 文本上划线 line-through: 穿过文本的线 注意到 text-decoration 可以一次接受多个值.同时注意 text-decoration 是一个缩写形式，它由 text-decoration-line, text-decoration-style 和 text-decoration-color 构成。 123.la&#123; text-decoration: wavy line-through red;&#125; text-decoration-style属性值的选择参考 “line-height 属性”设置行高 推荐使用数字作为无单位的属性值，无单位的值乘以 font-size 来获得 line-height。1line-height: 1.5; “text-indent 属性”设置首行文本缩进 规定文本块中首行文本的缩进。 注释：允许使用负值。如果使用负值，那么首行会被缩进到左边。 例子1234p&#123;text-indent:50px;&#125;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第三天学习总结（CSS文本、选择器）（1）","slug":"百度前端技术学院 第三天学习总结（CSS文本）","date":"2019-09-25T03:36:16.000Z","updated":"2019-11-19T09:20:48.440Z","comments":true,"path":"2019/09/25/百度前端技术学院 第三天学习总结（CSS文本）/","link":"","permalink":"http://yoursite.com/2019/09/25/百度前端技术学院 第三天学习总结（CSS文本）/","excerpt":"补充：HTML知识title 属性 规定关于元素的额外信息。 这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text）。 提示：title 属性常与 form 以及 a 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 abbr 和 acronym 元素的必需属性。","text":"补充：HTML知识title 属性 规定关于元素的额外信息。 这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text）。 提示：title 属性常与 form 以及 a 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 abbr 和 acronym 元素的必需属性。 p标签的嵌套 内联元素可以嵌套内联元素，块级元素可以嵌套部分块级元素并也能嵌套内联元素，但内联元素不能嵌套块级元素。块级元素为block，内联元素为inline，拥有“inline”特性的同时又拥有“block”的特性称为replace元素。 在&lt;p&gt;元素中是不能嵌套&lt;div&gt;元素的，在&lt;p&gt;标签还没结束时，遇到下一个块级元素就会自动结束。 什么是CSSCSS 指层叠样式表 (Cascading Style Sheets)，样式表中的样式定义如何显示 HTML 元素，存储在 CSS 文件中的外部样式表可以极大提高工作效率。 CSS是如何工作的解释1(来自MDN)（具体可以参考这个链接有实际的转换例子） 浏览器加载HTML 浏览器将HTML转换为DOM 浏览器获取HTML文档链接的大多数资源以及CSS（在此过程只呢个稍后会处理JS） 浏览器解析提取的CSS，并根据选择器类型分到不同的“存储桶”，例如元素，类，ID等。根据找到的选择器，它确定应将哪些规则应用于DOM中的哪些节点，并根据需要向其附加样式（此中间步骤称为渲染树）。 将渲染树放置在规则应用到其后应出现的结构中。（放在合适的HTML元素中） 页面的视觉显示在屏幕上显示（此阶段称为绘画）。 解释2（比较好理解）参考(里面有详细的图片解释) 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 补充：DOMDOM具有树状结构。标记语言中的每个元素，属性和一段文本都成为树结构中的DOM节点。 CSS的基本语法是怎样的参考图 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器通常是您需要改变样式的** HTML 元素**。 每条声明由一个属性和一个值组成。 多条声明中间用分号隔开。 1234选择器 &#123; 属性:值; 属性:值;&#125; 注意：如果值为若干单词，则要给值加引号： 1p &#123;font-family: \"sans serif\";&#125; CSS选择器是什么概念 选择器通常是您需要改变样式的HTML 元素。 简单选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。id 选择器以 “#” 来定义。（id 属性只能在每个 HTML 文档中出现一次。） 类选择器 以一个点号显示 1.center &#123;text-align: center&#125; 在下面的 HTML 代码中，h1 和 p 元素都有 center 类。这意味着两者都将遵守 “.center” 选择器中的规则。 1234567&lt;h1 class=\"center\"&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class=\"center\"&gt;This paragraph will also be center-aligned.&lt;/p&gt; 注意：类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。 类型（标签名/元素）选择器1234567891011span &#123; background-color: yellow;&#125;strong &#123; color: rebeccapurple;&#125;em &#123; color: rebeccapurple;&#125; 通用选择器用星号（*）表示，并选择文档中的所有内容 123* &#123; margin: 0;&#125; 属性选择器 参考 属性选择器 语法[属性名]{css样式} 可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 注释：只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6 及更低的版本中，不支持属性选择。 下面的例子为带有 title 属性的所有元素设置样式：1234[title]&#123;color:red;&#125; 属性和值选择器 下面的例子为 title=”W3School” 的所有元素设置样式：1234[title=W3School]&#123;border:5px solid blue;&#125; 属性和值选择器 - 多个值 下面的例子为包含指定值的 title 属性的所有元素设置样式。适用于HTML中由空格分隔的属性值：（比如：HTML中属性值为”hello world”或”student hello”） 1[title~=hello] &#123; color:red; &#125; 下面的例子为带有包含指定值的 lang 属性的所有元素设置样式。适用于HTML中由连字符分隔的属性值：(比如：HTML中属性值为”en-us”或者”en”) 1[lang|=en] &#123; color:red; &#125; [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 扩展 设置表单的样式的例子 属性选择器在为不带有 class 或 id 的表单设置样式时特别有用。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第三天学习笔记（CSS文本）","slug":"百度前端技术学院 第三天学习笔记（CSS文本）","date":"2019-09-24T03:36:16.000Z","updated":"2019-11-22T02:19:04.148Z","comments":true,"path":"2019/09/24/百度前端技术学院 第三天学习笔记（CSS文本）/","link":"","permalink":"http://yoursite.com/2019/09/24/百度前端技术学院 第三天学习笔记（CSS文本）/","excerpt":"参考 字体颜色 color 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 text-decoration 属性放置在文本下方或上方的线 (underline overline)。","text":"参考 字体颜色 color 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 text-decoration 属性放置在文本下方或上方的线 (underline overline)。123p &#123; color: red;&#125; 字体大小==重点在rem （千万注意数字与单位之间不要有空格！）== px (像素) 将像素的值赋予给你的文本。这是一个绝对单位， 它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。 em 1em 等于我们设计的当前元素的父元素上设置的字体大小 (更加具体的话，比如包含在父元素中的大写字母 M 的宽度) 如果你有大量设置了不同字体大小的嵌套元素，这可能会变得棘手, 但它是可行的，为什么要使用这个麻烦的单位呢? 当你习惯这样做时，那么就会变得很自然，你可以使用em调整任何东西的大小，不只是文本。你可以有一个单位全部都使用 em 的网站，这样维护起来会很简单。 rem 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小， (i.e. ) ，而不是父元素。 这可以让你更容易计算字体大小，但是遗憾的是， rem 不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用em 或 px, 或者是 polyfill 就像 REM-unit-polyfill. （这个单位在“CSS的值和单位”一节也有讲解）12345678910111213html &#123; font-size: 10px;&#125;h1 &#123; font-size: 2.6rem;//26px&#125;p &#123; font-size: 1.4rem;//14px color: red; font-family: Helvetica, Arial, sans-serif;&#125; 字体样式需要了解“网页安全字体” 字体栈 由于你无法保证你想在你的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 你可以提供一个字体栈 (font stack)，这样的话，浏览器就有多种字体可以选择了。只需包含一个font-family属性，其值由几个用逗号分离的字体名称组成。 123p &#123; font-family: \"Trebuchet MS\", Verdana, sans-serif;&#125; ==注意: 有一些字体名称不止一个单词，比如Trebuchet MS ，那么就需要用引号包裹。== 在这种情况下，浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。 在 字体栈的最后提供一个合适的通用的字体名称(网页安全字体) 是个不错的办法，这样的话，即使列出的字体都无法使用，浏览器至少可以提供一个还算合适的选择。 font-style属性用来打开和关闭文本 italic (斜体)。 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态) 可能的值如下： normal: 将文本设置为普通字体 (将存在的斜体关闭) italic: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。 oblique: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。 font-weight属性设置文字的粗体大小。这里有很多值可选 (比如 -light, -normal, -bold, -extrabold, -black, 等等), 不过事实上你很少会用到 normal 和 bold以外的值： normal, bold: 普通或者加粗的字体粗细 lighter, bolder: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。100–900: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。 text-transform属性允许你设置要转换的字体。 值包括： none: 防止任何转型。 uppercase: 将所有文本转为大写。 lowercase: 将所有文本转为小写。 capitalize: 转换所有单词让其首字母大写。 full-width: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。 text-decoration属性（有趣！）设置/取消字体上的文本装饰(你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为： none: 取消已经存在的任何文本装饰。 underline: 文本下划线. overline: 文本上划线 line-through: 穿过文本的线 ==注意 text-decoration 是一个缩写形式，它由 text-decoration-line, text-decoration-style 和 text-decoration-color 构成==。 text-decoration-style属性值的选择 最好不要分开写，因为分开写只有火狐浏览器支持。==注意到 text-decoration 可以一次接受多个值.== 1&lt;h1 class=\"la\"&gt;lalala&lt;/h1&gt; 123.la&#123; text-decoration: wavy line-through red;&#125; 文字阴影 你可以为你的文本应用阴影，使用 text-shadow 属性。这最多需要 4 个值， (前两个值是必须的) 如下例所示： 1text-shadow: 4px 4px 5px red; 4 个属性如下: 阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 length and size units, 但是 px 是比较合适的。这个值必须指定。 阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。 模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为0，这意味着没有模糊。可以使用大多数的 CSS 单位 length and size units. 阴影的基础颜色，可以使用大多数的 CSS 颜色单位 CSS color unit. 如果没有指定，默认为 black. 多种阴影可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本 1234text-shadow: -1px -1px 1px #aaa, 0px 4px 1px rgba(0,0,0,0.5), 4px 4px 5px rgba(0,0,0,0.7), 0px 0px 7px rgba(0,0,0,0.4); 补充 颜色中Alpha为色彩空间，也就是透明度/不透明度。它的范围为0.0到1.0之间，0.5为半透明。 rgba(255,255,255,0)则表示完全透明的白色； rgba(0,0,0,1)则表示完全不透明的黑色； 文本对齐 text-align 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同： left: 左对齐文本。 right: 右对齐文本。 center: 居中文字 justify: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 hyphens，打破一些更长的词语。 行高 line-height 属性 设置文本每行之间的高，可以接受大多数单位 length and size units，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 font-size 来获得 line-height。 推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的1.5倍，你可以使用这个:1line-height: 1.5; 子元素为行内元素时垂直居中可设置该属性值与父元素（盒子容器）高度相同。 字母和单词间距letter-spacing 和 word-spacing 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。 选择器 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器通常是您需要改变样式的** HTML 元素**。 每条声明由一个属性和一个值组成。 多条声明中间用分号隔开。 1234选择器 &#123; 属性:值; 属性:值;&#125; ==注意：如果值为若干单词，则要给值加引号：== 1p &#123;font-family: \"sans serif\";&#125; 选择器列表 被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; 插入外部样式表123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\" /&gt;&lt;/head&gt; 内部样式表1234567&lt;head&gt;&lt;style type=\"text/css\"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url(\"images/back40.gif\");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式123&lt;p style=\"color: sienna; margin-left: 20px\"&gt;This is a paragraph&lt;/p&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第二天学习总结（HTML）","slug":"百度前端技术学院 第二天学习总结（HTML）","date":"2019-09-23T06:10:16.000Z","updated":"2019-11-19T09:21:58.138Z","comments":true,"path":"2019/09/23/百度前端技术学院 第二天学习总结（HTML）/","link":"","permalink":"http://yoursite.com/2019/09/23/百度前端技术学院 第二天学习总结（HTML）/","excerpt":"要好好利用input的type属性值 &lt;input&gt; 元素是最重要的表单元素。","text":"要好好利用input的type属性值 &lt;input&gt; 元素是最重要的表单元素。 最基础的：type=”text” 定义常规文本输入。 type=”radio” 定义单选按钮输入（选择多个选择之一） type=”submit” 定义提交按钮（提交表单） 像是type=”email”能对邮件地址进行验证。 type=”number”可以让输入框变成上下可选择数字范围。type=”range”可以让输入框变成滑动条可选择数字范围。 type=”date”让输入框有日期选择器。 type=”color”让输入框可以弹出颜色选择器。 属性值记得引号 js中写属性值一定要记得加上引号！！！ 验证今天的学习情况HTML是什么，HTML5是什么HTML HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML5 HTML5 是最新的 HTML 标准。 HTML5 是专门为承载丰富的 web 内容而设计的，并且无需额外插件。 HTML5 拥有新的语义、图形以及多媒体元素。 HTML5 提供的新元素和新的 API 简化了 web 应用程序的搭建。 HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。 新的语义元素，比如 &lt;header&gt;, &lt;footer&gt;, &lt;article&gt;, and &lt;section&gt;。 新的表单控件，比如数字、日期、时间、日历和滑块。 强大的图像支持（借由 &lt;canvas&gt;和 &lt;svg&gt;） 强大的多媒体支持（借由 &lt;video&gt; 和 &lt;audio&gt;） 强大的新 API，比如用本地存储取代 cookie。 HTML元素标签、属性都是什么概念？HTML元素标签 HTML 标签是由尖括号包围的关键词，比如&lt;html&gt; HTML 标签通常是成对出现的，比如&lt;b&gt;和 &lt;/b&gt; 标签对中的第一个标签是开始(开放)标签，第二个标签是结束(闭合)标签 HTML元素属性 HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。 属性总是以名称/值对的形式出现，比如：name=”value”。 属性总是在 HTML 元素的开始标签中规定。 文档类型是什么概念，起什么作用？&lt;!DOCTYPE&gt; 声明帮助浏览器正确地显示网页。 Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。 HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。 &lt;!DOCTYPE&gt;不是 HTML 标签。它为浏览器提供一项信息（声明），告诉浏览器 HTML 是用什么版本编写的。 它的出现位置在head标签的上面。 比如：HTML5的声明方式是：&lt;!DOCTYPE html&gt; meta标签都用来做什么的？ 元数据（metadata）是关于数据的信息。 &lt;meta&gt; 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。 典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。 标签始终位于 head 元素中。 元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 针对搜索引擎的关键词一些搜索引擎会利用 meta 元素的 name 和 content 属性来索引您的页面。 下面的 meta 元素定义页面的描述： 1&lt;meta name=\"description\" content=\"Free Web tutorials on HTML, CSS, XML\" /&gt; name 和 content 属性的作用是描述页面的内容。 Web语义化是什么，是为了解决什么问题? 语义化简单说来就是让机器可以读懂内容。在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度。 我们在提供内容的时候，首先要做的就是将内容本身进行合理的描述，暂时不用考虑它的最终呈现会是什么样子。 HTML5 并非 Web 语义唯一倚仗的规范，除了 W3C 和 WHATWG 外，还有其它的组织在为扩展、标准化 Web 语义做着贡献。只要有浏览器厂商、搜索引擎原意支持，它们的规范一样可以成为通用的基础设施。 为了解决机器难以读懂web上发布的各种内容的问题。 链接是什么概念，对应什么标签？ HTML 使用超级链接与网络上的另一个文档相连。 超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。 当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。 我们通过使用&lt;a&gt; 标签在 HTML 中创建链接。 有两种使用 &lt;a&gt;标签的方式：通过使用 href 属性 - 创建指向另一个文档的链接通过使用 name 属性 - 创建文档内的书签(锚) 常用标签都有哪些，都适合用在什么场景 head标签中的title标签定义文档的标题，显示在浏览器的标题栏或标签页上 h1-h6标签用于标题 a标签用于超链接（其中name属性可以用于创建导航栏） p标签用于文段，span标签用于行内文字 input标签非常多用，像他的type的不同属性值让他可以用于多个场景。 最基础的：type=”text” 定义常规文本输入。 type=”radio” 定义单选按钮输入（选择多个选择之一） type=”submit” 定义提交按钮（提交表单） 像是type=”email”能对邮件地址进行验证。 type=”number”可以让输入框变成上下可选择数字范围。type=”range”可以让输入框变成滑动条可选择数字范围。 type=”date”让输入框有日期选择器。 type=”color”让输入框可以弹出颜色选择器。 表单标签都有哪些，对应着什么功能，都有哪些属性？&lt;input&gt;元素是最重要的表单元素。 type属性：他决定了input这个输入框具体用来做什么，比如text那他就是用来输入文本的，button就是按钮，submit定义提交表单数据至表单处理程序的按钮。，radio是单选按钮，checkbox复选框， name 属性：如果form表单要正确地被提交，每个输入字段必须设置一个 name 属性。 ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子ol（有序 HTML 列表） start属性：规定开始数字，如从“50.咖啡”开始： 12345&lt;ol start=\"50\"&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt;&lt;/ol&gt; type属性：不同的属性值决定了有序列表前面的序号表示。 实例 ul（无序 HTML 列表） type属性：不同的属性值决定了无序列表前面的小图标图形。 实例 li 标签 定义列表项目。 &lt;li&gt; 标签可用在有序列表 &lt;ol&gt; 和无序列表 &lt;ul&gt; 中。 dl 标签 &lt;dl&gt; 标签定义了定义列表（definition list）。 &lt;dl&gt; 标签用于结合&lt;dt&gt; （定义列表中的项目）和&lt;dd&gt; （描述列表中的项目）。 实例 dt标签 &lt;dt&gt; 标签定义了定义列表中的项目（即术语部分）。 会顶格显示。 dd标签 &lt;dd&gt;在定义列表中定义条目的定义部分。 会缩进2个字符显示。 总的来说dl相当于ol与ul，dt、dd相当于li的位置。","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（5）","slug":"百度前端技术学院 第二天学习笔记（HTML） 5","date":"2019-09-22T13:30:30.000Z","updated":"2019-11-19T09:22:42.217Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 5/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 5/","excerpt":"height 和 width 属性 height 和 width 属性仅用于 &lt;input type=&quot;image&quot;&gt;。,规定 &lt;input&gt; 元素的高度和宽度。","text":"height 和 width 属性 height 和 width 属性仅用于 &lt;input type=&quot;image&quot;&gt;。,规定 &lt;input&gt; 元素的高度和宽度。 注释：请始终规定图像的尺寸。如果浏览器不清楚图像尺寸，则页面会在图像加载时闪烁。 list 属性 list 属性引用的 &lt;datalist&gt; 元素中包含了&lt;input&gt; 元素的预定义选项。 具体使用如上datalist的实例。 min 和 max 属性 min 和 max 属性规定 &lt;input&gt; 元素的最小值和最大值。 min 和 max 属性适用于如需输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。12345678Enter a date before 1980-01-01:&lt;input type=\"date\" name=\"bday\" max=\"1979-12-31\"&gt; Enter a date after 2000-01-01:&lt;input type=\"date\" name=\"bday\" min=\"2000-01-02\"&gt; Quantity (between 1 and 5):&lt;input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\"&gt; multiple 属性（同时上传多个文件） multiple 属性是布尔属性。 如果设置multiple=&quot;multiple&quot;，则规定允许用户在&lt;input&gt; 元素中输入一个以上的值。 multiple 属性适用于以下输入类型：email 和 file。 实例1234567891011&lt;html&gt;&lt;body&gt;&lt;form action=\"/example/html5/demo_form.asp\" method=\"get\"&gt;选择图片：&lt;input type=\"file\" name=\"img\" multiple=\"multiple\" /&gt;&lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;p&gt;请尝试在浏览文件时选取一个以上的文件。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; pattern 属性 pattern 属性规定用于检查&lt;input&gt; 元素值的正则表达式。 pattern 属性适用于以下输入类型：text、search、url、tel、email、and password。 提示：请使用全局的 title 属性对模式进行描述以帮助用户。 提示：请在我们的 JavaScript 教程中学习更多有关正则表达式的知识。 实例123456789&lt;body&gt;&lt;form action=\"/example/html5/demo_form.asp\" method=\"get\"&gt;国家代码：&lt;input type=\"text\" name=\"country_code\" pattern=\"[A-z]&#123;3&#125;\"title=\"三个字母的国家代码\" /&gt;&lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;/body&gt; placeholder 属性 placeholder 属性规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）。 该提示会在用户输入值之前显示在输入字段中。 placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password。 required 属性 required 属性是布尔属性。 如果设置，则规定在提交表单之前必须填写输入字段。 required 属性适用于以下输入类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio、and file. required或者required=&quot;required&quot;都行。1Username: &lt;input type=\"text\" name=\"usrname\" required&gt; 或者 1Name: &lt;input type=\"text\" name=\"usr_name\" required=\"required\" /&gt; step 属性 step 属性规定&lt;input&gt; 元素的合法数字间隔。 示例：如果 step=”3”，则合法数字应该是 -3、0、3、6、等等。 提示：step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围。 step 属性适用于以下输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。 实例 HTML5 为 &lt;form&gt;增加如需属性：autocompletenovalidate","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（4）","slug":"百度前端技术学院 第二天学习笔记（HTML） 4","date":"2019-09-22T12:10:30.000Z","updated":"2019-11-19T09:22:57.873Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 4/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 4/","excerpt":"&lt;textarea&gt; 元素 &lt;textarea&gt;元素定义多行输入字段（文本域） 实例","text":"&lt;textarea&gt; 元素 &lt;textarea&gt;元素定义多行输入字段（文本域） 实例123&lt;textarea name=\"message\" rows=\"10\" cols=\"30\"&gt;The cat was playing in the garden.&lt;/textarea&gt; &lt;input&gt; 元素 元素是最重要的表单元素。 text 定义常规文本输入。 radio 定义单选按钮输入（选择多个选择之一） submit 定义提交按钮（提交表单） &lt;input&gt; 元素的type属性值 &lt;input type=&quot;text&quot;&gt; 定义供文本输入的单行输入字段 &lt;input type=&quot;password&quot;&gt; 定义密码字段 &lt;input type=&quot;submit&quot;&gt; 定义提交表单数据至表单处理程序的按钮。(在表单的 action 属性中规定表单处理程序（form-handler) &lt;input type=&quot;radio&quot;&gt; 定义单选按钮。(checked属性为默认选中) &lt;input type=&quot;checkbox&quot;&gt; 定义复选框。(允许用户在有限数量的选项中选择零个或多个选项) &lt;input type=&quot;button&gt;定义按钮。 HTML5增加了多个新的输入类型（type属性值） &lt;input type=&quot;number&quot;&gt; 用于应该包含数字值的输入字段。您能够对数字做出限制。根据浏览器支持，限制可应用到输入字段。例子 输入限制（input）有很多属性：max规定输入字段的最大值。min 规定输入字段的最小值。value 规定输入字段的默认值。等等 &lt;input type=&quot;color&quot;&gt;用于应该包含颜色的输入字段。根据浏览器支持，点击输入字段时颜色选择器会出现输入字段中。例子 &lt;input type=&quot;range&quot;&gt; 用于应该包含一定范围内的值的输入字段。根据浏览器支持，输入字段能够显示为滑块控件。(number的效果是上下按键选择范围)例子 &lt;input type=&quot;date&quot;&gt; 用于应该包含日期(年月日)的输入字段。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;month&quot;&gt; 允许用户选择月份和年份。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;week&quot;&gt; 允许用户选择周和年。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;time&quot;&gt; 允许用户选择时间（无时区）。根据浏览器支持，时间选择器会出现输入字段中。 &lt;input type=&quot;datetime&quot;&gt;允许用户选择日期(年月日)和时间（有时区）。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;datetime-local&quot;&gt;允许用户选择日期(年月日)和时间（无时区）。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;email&quot;&gt;用于应该包含电子邮件地址的输入字段。根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证。某些智能手机会识别 email 类型，并在键盘增加 “.com” 以匹配电子邮件输入. &lt;input type=&quot;search&quot;&gt;用于搜索字段（搜索字段的表现类似常规文本字段）。 &lt;input type=&quot;tel&quot;&gt;用于应该包含电话号码的输入字段。目前只有 Safari 8 支持 tel 类型。 &lt;input type=&quot;url&quot;&gt; 用于应该包含 URL 地址的输入字段。根据浏览器支持，在提交时能够自动验证 url 字段。某些智能手机识别 url 类型，并向键盘添加 “.com” 以匹配 url 输入。 &lt;input&gt; 元素的不同属性 value属性规定输入字段的初始值 readonly属性规定输入字段为只读（不能修改）例子 disabled属性规定输入字段是禁用的。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。==disabled 属性不需要值。它等同于 disabled=”disabled”。== size 属性规定输入字段的尺寸（输入框长度）（以字符计）size=&quot;40&quot; maxlength属性规定输入字段允许的最大长度.==(不会改变输入框长度)== 如设置 maxlength 属性，则输入控件不会接受超过所允许数的字符。该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码。 HTML5 表单元素 HTML5 增加了如下表单元素：&lt;datalist&gt;&lt;keygen&gt;&lt;output&gt; HTML5 &lt;datalist&gt; 元素 &lt;datalist&gt; 元素为 &lt;input&gt; 元素规定预定义选项列表。 用户会在他们输入数据时看到预定义选项的下拉列表。 &lt;input&gt; 元素的 list 属性必须引用&lt;datalist&gt; 元素的 id 属性。 效果：当用户点击输入框时可以看到下拉框里有Internet Explorer、Firefox…12345678910&lt;form action=\"action_page.php\"&gt;&lt;input list=\"browsers\"&gt;&lt;datalist id=\"browsers\"&gt; &lt;option value=\"Internet Explorer\"&gt; &lt;option value=\"Firefox\"&gt; &lt;option value=\"Chrome\"&gt; &lt;option value=\"Opera\"&gt; &lt;option value=\"Safari\"&gt;&lt;/datalist&gt; &lt;/form&gt; HTML5 为 &lt;input&gt;增加了如下属性 autocomplete(&lt;form&gt;也增加该属性) autofocus form formaction formenctype formmethod formnovalidate formtarget height 和 width list min 和 max multiple pattern (regexp) placeholder required step 总结 formxxxx的属性都是用于覆盖xxx属性的，也就是有两个input的情况下，一个input使用默认xxx属性，另一个input通过设置formxxxx达到另一个属性。 formaction用于==拥有两个提交按钮并对于不同动作的 HTML 表单== formmethod第一个提交按钮使用表单中method规定的GET/POST，第二个提交按钮通设置formmethod覆盖表单的 HTTP 方法。 formnovalidate用于拥有==两个提交按钮的表单（验证和不验证）== formtarget用于表单有两个提交按钮，对应==不同的目标窗口==（默认是原窗口，formtarget可设置提交到新窗口） autocomplete 属性 自动填值 autocomplete 属性适用于&lt;form&gt; 以及如下&lt;input&gt; 类型：text、search、url、tel、email、password、datepickers、range 以及 color。 autocomplete 属性规定表单或输入字段是否应该自动完成。 当自动完成开启（autocomplete=”on”），浏览器会基于用户之前的输入值自动填写值。 提示：您可以把表单的 autocomplete 设置为 on，同时把特定的输入字段==(手动填值)== 设置为 off，反之亦然。 例子 novalidate 属性 不验证数据 novalidate 属性属于 &lt;form&gt;属性。 如果设置，则 novalidate 规定在提交表单时不对表单数据进行验证。 例子 autofocus 属性 鼠标自动到达输入框 autofocus 属性是布尔属性。 如果设置，则规定当页面加载时&lt;input&gt; 元素应该自动获得焦点。 例子 form 属性 form 属性规定&lt;input&gt; 元素所属的一个或多个表单。 提示：如需引用一个以上的表单，请使用空格分隔的表单 id 列表。 实例输入字段位于 HTML 表单之外（但仍属表单） formaction 属性 注意：formaction是form action的意思，可以用于拥有两个提交按钮并对于不同动作的 HTML 表单 formaction 属性规定当提交表单时处理该输入控件的文件的 URL。 formaction 属性覆盖 元素的 action 属性 formaction 属性适用于 type=”submit” 以及 type=”image”。 实例拥有两个提交按钮并对于不同动作的 HTML 表单1234567&lt;form action=\"action_page.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Submit\"&gt;&lt;br&gt; &lt;input type=\"submit\" formaction=\"demo_admin.asp\" value=\"Submit as admin\"&gt;&lt;/form&gt; formenctype 属性==没弄明白== formmethod 属性 formmethod 属性定义用以向 action URL 发送表单数据（form-data）的 HTTP 方法。(GET/POST) formmethod 属性覆盖 &lt;form&gt; 元素的 method 属性。 formmethod 属性适用于 type=”submit” 以及 type=”image”。 实例第二个提交按钮覆盖表单的 HTTP 方法1234567&lt;form action=\"action_page.php\" method=\"get\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Submit\"&gt; &lt;input type=\"submit\" formmethod=\"post\" formaction=\"demo_post.asp\" value=\"Submit using POST\"&gt;&lt;/form&gt; formnovalidate 属性 novalidate 属性是布尔属性。 如果设置，则规定在提交表单时不对 &lt;input&gt; 元素进行验证。 formnovalidate 属性覆盖&lt;form&gt; 元素的 novalidate 属性。 formnovalidate 属性可用于 type=”submit”。 实例拥有两个提交按钮的表单（验证和不验证）12345&lt;form action=\"/example/html5/demo_form.asp\" method=\"get\"&gt;E-mail: &lt;input type=\"email\" name=\"userid\" /&gt;&lt;br /&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;br /&gt;&lt;input type=\"submit\" formnovalidate=\"formnovalidate\" value=\"进行没有验证的提交\" /&gt;&lt;/form&gt; formtarget 属性 formtarget 属性规定的名称或关键词指示提交表单后在何处显示接收到的响应。 formtarget 属性会覆盖 &lt;form&gt; 元素的 target 属性。 formtarget 属性可与 type=”submit” 和 type=”image” 使用。 实例这个表单有两个提交按钮，对应不同的目标窗口：1234567&lt;form action=\"action_page.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Submit as normal\"&gt; &lt;input type=\"submit\" formtarget=\"_blank\" value=\"Submit to a new window\"&gt;&lt;/form&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（3）","slug":"百度前端技术学院 第二天学习笔记（HTML） 3","date":"2019-09-22T11:20:22.000Z","updated":"2019-11-19T09:23:10.301Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 3/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 3/","excerpt":"Iframeiframe 用于在网页内显示网页。 语法&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt;","text":"Iframeiframe 用于在网页内显示网页。 语法&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt; Iframe - 设置高度和宽度&lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt; height 和 width 属性用于规定 iframe 的高度和宽度。 属性值的默认单位是像素，但也可以用百分比来设定（比如 “80%”）。 Iframe - 删除边框&lt;iframe src=&quot;demo_iframe.htm&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; frameborder 属性规定是否显示 iframe 周围的边框。 设置属性值为 “0” 就可以移除边框： 使用 iframe 作为链接的目标 iframe 可用作链接的目标（target）。 链接的 target 属性必须引用 iframe 的 name 属性： 初始页面是百度，点击“W3School.com.cn”后百度页面会变成w3school页面。123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;iframe src=\"https://www.baidu.com/\" name=\"iframe_a\"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href=\"https://www.w3school.com.cn/html/html_iframe.asp\" target=\"iframe_a\"&gt;W3School.com.cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;由于链接的目标匹配 iframe 的名称，所以链接会在 iframe 中打开。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 背景需要注意：背景图像是否增加了页面的加载时间。小贴士：图像文件==不应超过 10k==。 文件路径 使用==相对路径==是个==好==习惯（如果可能）。 如果使用了相对路径，那么您的网页就不会与当前的基准 URL 进行绑定。所有链接在您的电脑上 (localhost) 或未来的公共域中均可正常工作。 绝对文件路径绝对文件路径是指向一个因特网文件的完整 URL：&lt;img src=&quot;https://www.w3school.com.cn/images/picture.jpg&quot; alt=&quot;flower&quot;&gt; 相对路径相对路径指向了相对于当前页面的文件。 &lt;img src=&quot;picture.jpg&quot;&gt; picture.jpg 位于与当前网页相同的文件夹 &lt;img src=&quot;images/picture.jpg&quot;&gt; picture.jpg 位于当前文件夹的 images 文件夹中 &lt;img src=&quot;/images/picture.jpg&quot;&gt; picture.jpg 当前站点根目录的 images 文件夹中 &lt;img src=&quot;../picture.jpg&quot;&gt; picture.jpg 位于当前文件夹的上一级文件夹中 标签&lt;base&gt; 标签为页面上的所有链接规定==默认地址==或==默认目标==（target） 1234&lt;head&gt;&lt;base href=\"http://www.w3school.com.cn/images/\" /&gt;&lt;base target=\"_blank\" /&gt;&lt;/head&gt; 所有链接一个目标(target)【使用 base】 在内使用使页面中的所有标签在新窗口中打开。 比如&lt;base target=&quot;_blank&quot; /&gt;使得内的超链接都将在==新窗口==中加载，因为 target 属性被设置为 “_blank”。（个别超链接需要不同的打开方式可以单独在设置target属性） 例子 HTML 字符实体 HTML 中的预留字符必须被替换为字符实体。 比如：如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60; 有用的字符实体 表单（form）Action 属性 action 属性定义在提交表单时执行的动作。 &lt;form action=&quot;action_page.php&quot;&gt;如果省略 action 属性，则 action 会被设置为当前页面。 Method 属性 method 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST） &lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt;使用 GET（默认方法）不安全 当您使用 GET 时，表单数据在页面地址栏中是可见的：action_page.php?firstname=Mickey&amp;lastname=Mouse 如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息，可以使用GET。 注释：GET 最适合少量数据的提交。浏览器会设定容量限制。 推荐使用 POST： 如果表单正在更新数据，或者包含敏感信息（例如密码）。 POST 的安全性更加，因为在页面地址栏中被提交的数据是不可见的。 Name 属性 如果要正确地被提交，每个输入字段必须设置一个 name 属性。 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 用&lt;fieldset&gt;组合表单数据 &lt;fieldset&gt; 元素组合表单中的相关数据 &lt;legend&gt; 元素为 &lt;fieldset&gt; 元素定义标题。 例子 效果：会有一个粗框把表格内容框住。 &lt;select&gt; 元素（下拉列表）123456&lt;select name=\"cars\"&gt;&lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt;&lt;option value=\"saab\"&gt;Saab&lt;/option&gt;&lt;option value=\"fiat\"&gt;Fiat&lt;/option&gt;&lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt; 列表通常会把==首个==选项显示为==被选选项==。 您能够通过添加==selected属性==来==定义预定义选项==。&lt;option value=&quot;fiat&quot; selected&gt;Fiat&lt;/option&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（2）","slug":"百度前端技术学院 第二天学习笔记（HTML） 2","date":"2019-09-22T10:20:22.000Z","updated":"2019-11-19T09:22:27.493Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 2/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 2/","excerpt":"单元格边距(Cell padding)本例演示如何使用 Cell padding 来创建单元格内容与其边框之间的空白。","text":"单元格边距(Cell padding)本例演示如何使用 Cell padding 来创建单元格内容与其边框之间的空白。 单元格间距(Cell spacing)本例演示如何使用 Cell spacing 增加单元格之间的距离。 有序列表（ol）与无序列表（ul） ul: unordered lists 无序列表 ol: ordered lists 有序列表 两种列表中的每个列表项始于&lt;li&gt; 1234&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 1234&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; 无序列表中的不同类型&lt;ul&gt;的属性 type=”disc”实心圆（默认） type=”circle”空心圆 type=”square”实心方块 有序列表中的不同类型&lt;ol&gt;的属性 默认：数字列表 type=”A”：大写字母列表 type=”a”:小写字母列表 type=”I”：罗马字母列表 type=”i”：小写罗马字母列表 定义列表dl dl：definition list 自定义列表以&lt;dl&gt;标签开始。每个自定义列表项以&lt;dt&gt;开始。每个自定义列表项的定义以&lt;dd&gt; 开始。123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;&lt;dd&gt;Black hot drink&lt;/dd&gt;&lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;White cold drink&lt;/dd&gt;&lt;/dl&gt; 实现效果： Coffee Black hot drink Milk White cold drink 分类块级元素:&lt;div&gt;元素 &lt;div&gt;元素是块级元素，它是可用于组合其他 HTML 元素的容器。 &lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 设置&lt;div&gt; 元素的类(style)，使我们能够为相同的 元素设置相同的类1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.cities &#123; background-color:black; color:white; margin:20px; padding:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"cities\"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 分类行内元素:&lt;span&gt; 元素 &lt;span&gt;元素是内联元素，可用作文本的容器。 元素也没有特定的含义。 内联元素在显示时通常不会以新行开始。 设置 &lt;span&gt; 元素的类(style)，能够为相同的 元素设置相同的样式。12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; span.red &#123;color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My &lt;span class=\"red\"&gt;Important&lt;/span&gt; Heading&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; HTML布局 参考 行间距line-height HTML 框架 重要提示： 不能 将 标签与 标签同时使用！不过，假如你添加包含一段文本的 标签，就必须将这段文字嵌套于 标签内。（在下面的第一个实例中，可以查看它是如何实现的。） 1234567891011121314&lt;html&gt;&lt;frameset cols=\"25%,50%,25%\"&gt; &lt;frame src=\"/example/html/frame_a.html\"&gt; &lt;frame src=\"/example/html/frame_b.html\"&gt; &lt;frame src=\"/example/html/frame_c.html\"&gt;&lt;noframes&gt;&lt;body&gt;您的浏览器无法处理框架！&lt;/body&gt;&lt;/noframes&gt;&lt;/frameset&gt;&lt;/html&gt; 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。 框架结构标签（&lt;frameset&gt;） 框架结构标签（&lt;frameset&gt;）定义如何将窗口分割为框架 每个 frameset 定义了一系列行或列（混合框架结构使用两对 将含有三份文档的框架结构混合置于行和列之中） rows/columns(cols)的值规定了每行或每列占据屏幕的面积(rows=”25%,50%,25%”规定了每行占据屏幕的面积【宽度】) frameset 标签也被某些文章和书籍译为框架集。 框架标签（Frame）Frame 标签定义了放置在每个框架中的 HTML 文档。 1234567891011&lt;html&gt;&lt;frameset cols=\"25%,50%,25%\"&gt; &lt;frame src=\"/example/html/frame_a.html\"&gt; &lt;frame src=\"/example/html/frame_b.html\"&gt; &lt;frame src=\"/example/html/frame_c.html\"&gt;&lt;/frameset&gt;&lt;/html&gt; 在上面的这个例子中，我们设置了一个三列的框架集。第一列被设置为占据浏览器窗口的 25%。第二列被设置为占据浏览器窗口的 50%。第三列被设置为占据浏览器窗口的 25%。HTML 文档 “frame_a.htm” 被置于第一个列中，而 HTML 文档 “frame_b.htm” 被置于第二个列中，而 HTML 文档 “frame_c.htm” 被置于第三个列中。 noresize 属性 给加上noresize=”noresize”，则框架是不可调整尺寸的。在框架间的边框上拖动鼠标，你会发现边框是无法移动的。 单独给加上noresize=”noresize”,则该框架不可调整尺寸。123456789&lt;html&gt;&lt;frameset cols=\"50%,25%,25%\"&gt; &lt;frame src=\"/example/html/frame_a.html\" noresize=\"noresize\" /&gt; &lt;frame src=\"/example/html/frame_b.html\" /&gt; &lt;frame src=\"/example/html/frame_c.html\" /&gt;&lt;/frameset&gt;&lt;/html&gt; rows，cols，colspan，rowspan rows排 cols列 colspan合并列 rowspan合并排 导航框架本例演示如何制作导航框架。导航框架包含一个将第二个框架作为目标的链接列表。名为 “contents.htm” 的文件包含三个链接。 123456&lt;html&gt;&lt;frameset cols=\"120,*\"&gt; &lt;frame src=\"/example/html/html_contents.html\"&gt; &lt;frame src=\"/example/html/frame_a.html\" name=\"showframe\"&gt;&lt;/frameset&gt;&lt;/html&gt; https://www.w3school.com.cn/example/html/html_contents.html中代码： 1234567&lt;body&gt;&lt;a href=\"/example/html/frame_a, html\"target=\"showframe\"&gt;Frame a&lt;/a&gt;&lt;br&gt;&lt;a href=\"/example/html/frame_b. html\"target=\"showframe\"&gt;Frame b&lt;/a&gt;&lt;br&gt;&lt;a href=\"/example/html/frame_c. html\"target=\"showframe\"&gt;Frame c&lt;/a&gt;&lt;/body&gt; 回顾一下标签中的target属性 参考 在框架中打开窗口不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档. 举例： 1234&lt;frameset cols=\"100,*\"&gt; &lt;frame src=\"toc.html\"&gt; &lt;frame src=\"pref.html\" name=\"view_frame\"&gt;&lt;/frameset&gt; 当浏览器最初显示这两个框架的时候，左边这个框架包含目录，右边这个框架包含前言(初始化时就显示在页面右侧的pref.html)。这是 “toc.html” （即：左侧目录）的源代码： 1234567&lt;h3&gt;Table of Contents&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"pref.html\" target=\"view_frame\"&gt;Preface&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"chap1.html\" target=\"view_frame\"&gt;Chapter 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"chap2.html\" target=\"view_frame\"&gt;Chapter 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"chap3.html\" target=\"view_frame\"&gt;Chapter 3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 请注意，在文档 “toc.html” 中，每个链接的目标（target属性值） 都是 “view_frame”，也就是右边的框架。当用户从左边框架中的目录中选择一个链接时，浏览器会将这个关联的文档载入并显示在右边这个 “view_frame” 框架中。当其他链接被选中时，右边这个框架中的内容也会发生变化，而左边这个框架始终保持不变。 结合我们上文说过的“锚”跳转至框架内的一个指定的节本例演示两个框架。其中的一个框架设置了指向另一个文件内指定的节的链接。这个”link.htm”文件内指定的节使用 进行标识。 123456&lt;html&gt;&lt;frameset cols=\"20%,80%\"&gt; &lt;frame src=\"/example/html/frame_a.html\"&gt; &lt;frame src=\"/example/html/link.html#C10\"&gt;&lt;/frameset&gt;&lt;/html&gt; 使用框架导航跳转至指定的节本例演示两个框架。左侧的导航框架包含了一个链接列表，这些链接将第二个框架作为目标。第二个框架显示被链接的文档。导航框架其中的链接指向目标文件中指定的节。 123456&lt;html&gt;&lt;frameset cols=\"180,*\"&gt;&lt;frame src=\"/example/html/content.html\"&gt;&lt;frame src=\"/example/html/link.html\" name=\"showframe\"&gt;&lt;/frameset&gt;&lt;/html&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（1）","slug":"百度前端技术学院 第二天学习笔记（HTML）","date":"2019-09-22T08:18:22.000Z","updated":"2019-11-19T09:22:11.256Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML）/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML）/","excerpt":"HTML 水平线&lt;hr /&gt;","text":"HTML 水平线&lt;hr /&gt; &lt;p&gt;&lt;/p&gt;与&lt;br /&gt; &lt;br /&gt;是换行,但不是空行，如果想要中间空行就需要&lt;br /&gt;&lt;br /&gt;才能实现效果 &lt;p&gt;&lt;/p&gt;前后会出现空行 两段文字中&lt;br /&gt;&lt;br /&gt;相当于放置两组&lt;p&gt;&lt;/p&gt; 上标与下标 &lt;sup&gt;&lt;/sup&gt;实现效果：上标 &lt;sub&gt;&lt;/subs&gt;实现效果：下标 W3School的例子 附赠粗体&lt;b&gt;，斜体&lt;i&gt;，大号字体&lt;big&gt;,小号字体&lt;small&gt; &lt;p&gt;&lt;/p&gt;与&lt;pre&gt;&lt;/pre&gt; &lt;p&gt;&lt;/p&gt;中无论出现多少个空格或换行都只识别为一个空格。 它不能保留（我是空格） 空格 （我是换行）和换行。 &lt;pre&gt;&lt;/pre&gt;是预格式文本。 它保留了 空格 和换行。 ==&lt;pre&gt;&lt;/pre&gt;适合用来显示计算机代码== &lt;abbr&gt;&lt;/abbr&gt;与&lt;acronym&gt;&lt;/acronym&gt; 在某些浏览器中，当您把鼠标移至缩略词语上时，会展示表达的完整版本。 该标签的title属性值为想要表达的完整版本。 在chrome中两个都可用。比如:缩略词语 [W3School的例子](https://www.w3school.com.cn/tiy/t.asp?f=html_abbracronym) 长引用与短引用 长(块)引用&lt;blockquote&gt;&lt;/blockquote&gt;浏览器会插入换行和外边距。（浏览器通常会对&lt;blockquote&gt;元素进行缩进处理） 短引用&lt;q&gt;&lt;/q&gt;不会插入换行和外边距，但会有双引号。 删除字效果和插入字效果 &lt;del&gt;&lt;/del&gt;实现效果：二十 &lt;ins&gt;&lt;/ins&gt;实现效果：十二 没有下划线的链接123&lt;a href=\"/example/html/lastpage.html\" style=\"text-decoration:none\"&gt;这是一个没有下划线的链接！&lt;/a&gt; 这是一个没有下划线的链接！ 超链接中的链接可以是图片或其他 HTML 元素-提示：”链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。 1&lt;a href=\"C:\\Users\\HLZ\\Desktop\\证件\\立介摄影 一寸.jpg\"&gt;证件照&lt;/a&gt; 新窗口打开超链接 target=&quot;_blank&quot;如果把链接的 target 属性设置为 “_blank”，该链接会在新窗口中打开。1&lt;a href=\"http://www.w3school.com.cn/\" target=\"_blank\"&gt;Visit W3School!&lt;/a&gt; 命名锚 可以作为目录导航来使用。 提示：命名锚经常用于在大型文档开始位置上创建目录。可以为每个章节赋予一个命名锚，然后把链接到这些锚的链接放到文档的上部。==如果您经常访问百度百科，您会发现其中几乎每个词条都采用这样的导航方式。== 提示：假如浏览器找不到已定义的命名锚，那么就会定位到文档的顶端。不会有错误发生。 1&lt;a name=\"label\"&gt;锚（显示在页面上的文本）&lt;/a&gt; name 属性规定锚（anchor）的名称。 当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 实际运用首先，我们在 HTML 文档中对锚进行命名（创建一个书签）： 1&lt;a name=\"tips\"&gt;基本的注意事项 - 有用的提示&lt;/a&gt; 然后，我们在同一个文档中创建指向该锚的链接： 1&lt;a href=\"#tips\"&gt;有用的提示&lt;/a&gt; 您也可以在其他页面中创建指向该锚的链接： 1&lt;a href=\"http://www.w3school.com.cn/html/html_links.asp#tips\"&gt;有用的提示&lt;/a&gt; 在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。 一个完整的例子 外部样式表当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;/head&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在head 部分通过 &lt;style&gt; 标签定义内部样式表。 123456&lt;head&gt;&lt;style type=\"text/css\"&gt;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt;&lt;/head&gt; 内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。 123&lt;p style=\"color: red; margin-left: 20px\"&gt;This is a paragraph&lt;/p&gt; 图片的替换文本属性（Alt）alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。 1&lt;img src=\"boat.gif\" alt=\"Big Boat\"&gt; 图片的align属性 align vi. 排列；排成一行 他的属性值（bottom，middle，top）设置图片的对齐方式 left,right使图片浮动在文本的左右侧。 标签的usemap属性——创建图像映射 本例显示如何创建带有可供点击区域的图像地图。其中的每个区域都是一个超级链接。 usemap用法 标签中的&lt;area&gt; 标签定义图像映射中的区域（注：图像映射指得是带有可点击区域的图像）。area 元素总是嵌套在 标签中。&lt;area&gt; 标签相关用法规定区域的coords属性","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"history对象","slug":"history对象","date":"2019-09-16T03:36:16.000Z","updated":"2019-09-26T06:23:47.386Z","comments":true,"path":"2019/09/16/history对象/","link":"","permalink":"http://yoursite.com/2019/09/16/history对象/","excerpt":"history历史对象history 对象保存了用户在浏览器中访问页面的历史记录。","text":"history历史对象history 对象保存了用户在浏览器中访问页面的历史记录。 history对象的属性 length返回浏览器历史列表中的 URL数量 history对象的方法回到历史记录的上一步 语法：history.back（） 功能：回到历史记录的上一步 说明：相当于使用了history.go（-1） 补充：使用history.go（-2）则是回到历史记录的上一步的再上一步 举例： index10.html里面给个超链接跳转到index11.html： 1&lt;a href=\"index11.html\"&gt;跳转到index11.html&lt;/a&gt; index11.html里给个后退按钮： 1234567891011&lt;body&gt; &lt;p&gt;这是index11.html&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn\" value=\"后退\"&gt;&lt;/p&gt; &lt;script&gt; var btn=document.getElementById(\"btn\"); btn.onclick=function()&#123; history.back(); //history.go(-1); &#125; &lt;/script&gt;&lt;/body&gt; 回到历史记录的下一步 语法：location.forward（） 注意：千万不要忘记forward后面的括号 功能：回到历史记录的下一步 说明：相当于使用了history.go（1） 举例 index11.html：有新增的2个按钮（前进，前进两个页面）和一个跳转index12.html的链接 1234567891011121314151617181920212223242526&lt;body&gt; &lt;p&gt;这是index11.html&lt;/p&gt; &lt;p&gt; &lt;a href=\"index12.html\"&gt;跳转到index12.html&lt;/a&gt; &lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn\" value=\"后退\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn2\" value=\"前进\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn3\" value=\"前进2\"&gt;&lt;/p&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); var btn2 = document.getElementById(\"btn2\"); var btn3 = document.getElementById(\"btn3\"); btn.onclick = function () &#123; // history.back(); history.go(-1); &#125; btn2.onclick = function () &#123; history.forward(); // history.go(1); &#125; btn3.onclick = function () &#123; history.go(2); &#125; &lt;/script&gt;&lt;/body&gt; 做两个可供跳转的页面index12.html和index13.html，从12跳到13 123456&lt;body&gt; &lt;p&gt;这是index12.html&lt;/p&gt; &lt;p&gt; &lt;a href=\"index13.html\"&gt;跳转到index13.html&lt;/a&gt; &lt;/p&gt;&lt;/body&gt; 123&lt;body&gt; &lt;p&gt;这是index13.html&lt;/p&gt; &lt;/body&gt; 跳到13以后再回到11去测试按钮 前进或者后退多步 语法：history.go（-n） 功能：回到历史记录的前n步 语法：history.go（n） 功能：回到历史记录的后n步","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-09-15T14:22:54.206Z","updated":"2019-09-15T14:22:54.206Z","comments":true,"path":"2019/09/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"DOM基础","slug":"DOM基础","date":"2019-09-05T13:27:50.000Z","updated":"2019-11-06T08:38:30.400Z","comments":true,"path":"2019/09/05/DOM基础/","link":"","permalink":"http://yoursite.com/2019/09/05/DOM基础/","excerpt":"DOM查找（获取）方法DOM元素也就是html文件中的元素，可以通过DOM查找（获取）方法获取在js文件（script）中对html文件中的元素。 查找单个DOM元素getElementByld()根据id得到一个元素/对象","text":"DOM查找（获取）方法DOM元素也就是html文件中的元素，可以通过DOM查找（获取）方法获取在js文件（script）中对html文件中的元素。 查找单个DOM元素getElementByld()根据id得到一个元素/对象 语法:document.getElementByld(&quot;id&quot;) 功能:返回对拥有指定ID的第一个对象的引用 返回值:DOM对象 说明:id为DOM元素上id属性的值12345678910&lt;body&gt; &lt;div class=\"box\" id=\"box\"&gt; 元素1 &lt;/div&gt; &lt;script&gt; //获取id为box的这个元素 var box = document.getElementById(\"box\"); console.log(box); &lt;/script&gt;&lt;/body&gt; querySelector()querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。 注意：参数值的类型是字符串，需要双引号。querySelector() 方法仅仅返回匹配指定选择器的第一个元素。如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代。 参数值 类型 描述 CSS 选择器 String 必须。指定一个或多个匹配元素的 CSS 选择器。 可以使用它们的 id, 类, 类型, 属性, 属性值等来选取元素。对于多个选择器，使用逗号隔开，返回一个匹配的元素。 例子：获取文档中 id=”demo” 的元素： 1document.querySelector(\"#demo\"); 完整例子 查找多个DOM元素 注意：前面是document就会获取整个body中的“tag”，如果想要获取指定id下的“tag”可以和上面的语法叠加使用。 语法:document.getElementsByTagName(&quot;tag&quot;) 功能:返回一个对所有tag标签引用的集合 返回值:数组 说明:tag为要获取的标签名称 通过标签名选取的元素是一个类数组对象，如果你要获取到特定的元素，那么就要像数组一样，下标从0开始算起，找到这个元素，比如：要找第三个li，要找lis[2]。 12345678910111213141516171819202122&lt;body&gt; &lt;ul id=\"list1\"&gt; &lt;li&gt;啦啦啦&lt;/li&gt; &lt;li&gt;黄女士&lt;/li&gt; &lt;li&gt;困困&lt;/li&gt; &lt;/ul&gt; &lt;ol id=\"list2\"&gt; &lt;li&gt;醒醒&lt;/li&gt; &lt;li&gt;臭臭&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; //获取页面中所有的li var lis=document.getElementsByTagName(\"li\"); console.log(lis.length);//5，注意会获取整个body中的“li” //获取id为list1下的所有的1i var lis2 = document.getElementById(\"list1\").getElementsByTagName(\"li\"); console.log(lis2.length);//3 // 找第三个li var li3=lis[2]; console.log(li3);//困困 &lt;/script&gt;&lt;/body&gt; 注意：前面是document就会获取整个body中的“tag”，如果想要获取指定id下的“tag”可以和上面的语法叠加使用。 12document.getElementsByTagName(\"li\");//获取整个body中的“li”document.getElementById(\"list1\").getElementsByTagName(\"li\");//获取id为\"list1\"这个对象中的“li” 补充两个DOM元素查找方法** getElementsByName()**通过name属性选取的元素是一个类数组对象，如果你要获取到特定的元素，那么就要像数组一样，下标从0开始算起，找到这个元素。** getElementsByClassName()**较复杂 动态设置元素样式 语法：ele.style.styleName=styleValue 功能：设置ele元素（DOM对象）的CSS样式 说明： ele为要设置样式的DOM对象 注意：必须是DOM对象 ，而getElementsByTagName取出的是“数组”，数组需要遍历才能动态设置CSS样式 styleName为要设置的样式名称 注意：不能使用”-”连字符形式 font-size，使用驼峰命名形式fontSize styleValue为设置的样式值123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;div class=\"box\" id=\"box\"&gt; 元素1 &lt;/div&gt; &lt;ul id=\"list1\"&gt; &lt;li style=\"color:blueviolet;font-size:18px\"&gt;啦啦啦&lt;/li&gt; &lt;li&gt;黄女士&lt;/li&gt; &lt;li&gt;困困&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //设置id为box的这个元素的文字颜色，属性是减号连接的复合形式时 //必需要转换为驼峰形式 var box = document.getElementById(\"box\"); box.style.color=\"#f00\"; box.style.fontWeight=\"bold\"; //获取id为list1下的所有的1i,得到的是数组，需要遍历才能动态设置CSS样式 var lis = document.getElementById(\"list1\").getElementsByTagName(\"li\"); for (var i = 0, len = lis.length; i &lt; len; i++) &#123; // console.log(lis[i]);//可以发现每个li都被打印 lis[i].style.color = \"#00f\";//li全部变蓝色 // 设置不同背景色 if (i == 0) &#123; lis[i].style.backgroundColor = \"#ccc\"; &#125; else if (i == 1) &#123; lis[i].style.backgroundColor = \"#666\"; &#125; else if (i == 2) &#123; lis[i].style.backgroundColor = \"#999\"; &#125; else &#123; lis[i].style.backgroundColor = \"#333\"; &#125; &#125; &lt;/script&gt;&lt;/body&gt; innerHTML获取和设置（增加）标签之间的文本和html内容注意：有=就是设置（增加），没有就是获取。 语法：ele.innerHTML 功能：返回ele元素（DOM元素）开始和结束标签（tag）之间的文本和HTML内容 （倾斜标签&lt;i&gt;与粗体标签&lt;b&gt;都是HTML内容） 语法：ele.innerHTML=&quot;html&quot; 功能：设置ele元素（DOM元素）开始和结束标签之间的HTML内容为html 扩展：想要增加ele元素（DOM元素）开始和结束标签之间的HTML内容可使用ele.innerHTML+=&quot;增加的HTML内容&quot;即ele.innerHTML=ele.innerHTML+&quot;增加的HTML内容&quot;1234567891011121314151617&lt;body&gt; &lt;ul id=\"list1\"&gt; &lt;li style=\"color:blueviolet;font-size:18px\"&gt;啦啦啦&lt;/li&gt; &lt;li&gt;&lt;i&gt;黄女士&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;困困&lt;/b&gt;&lt;/li&gt; &lt;li&gt;醒醒&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //获取id为list1下的所有的1i,得到的是数组 var lis = document.getElementById(\"list1\").getElementsByTagName(\"li\"); for (var i = 0, len = lis.length; i &lt; len; i++) &#123; console.log(lis[i]);//可以发现每个li都被打印,&lt;li&gt;&lt;i&gt;黄女士&lt;/i&gt;&lt;/li&gt;... console.log(lis[i].innerHTML);//打印每一条li内的文本内容,&lt;i&gt;黄女士&lt;/i&gt;... lis[i].innerHTML+=\"程序\";//页面显示会变成：啦啦啦程序...每一条li都加上了“程序” &#125; &lt;/script&gt;&lt;/body&gt; 补充：使用innerHTML插入带有标签的html内容我们希望在js中插入连同div标签和style样式的html内容： 123&lt;div style=\"background: red;\" &gt; lalal &lt;/div&gt; 在innerHTML中要注意将后面的代码用单引号括起来，且去掉html代码中的tab和空格！ 123456789&lt;body&gt; &lt;!-- &lt;div style=\"background: red;\" &gt; lalal &lt;/div&gt; --&gt; &lt;div id=\"la\"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(\"la\").innerHTML = '&lt;div style=\"background: red;\"&gt;lalal&lt;/div&gt;'; &lt;/script&gt;&lt;/body&gt; 当然我们的代码可读性也是非常重要的，所以我们可以使用\\帮助我们进行换行，注意：我们在需要换行的位置加上\\即可。 123456789101112&lt;body&gt; &lt;!-- &lt;div style=\"background: red;\" &gt; lalal &lt;/div&gt; --&gt; &lt;div id=\"la\"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(\"la\").innerHTML = '\\ &lt;div style=\"background: red;\" &gt;\\ lalal\\ &lt;/div&gt;'; &lt;/script&gt;&lt;/body&gt; className 获取和设置（替换） ele元素的class属性注意：有=就是设置，没有就是获取。 className返回ele元素的class属性 语法：ele.className 功能：返回ele元素（DOM元素）的class属性 如果元素有2个以上的class属性值，那么获取这个元素的className属性时，会将它的class属性值都打印出来（实际操作没发现会） className给元素添加类 语法：ele.className=&quot;cls&quot; 功能：设置ele元素（DOM元素）的class属性为cls 注意：ele.className是重新设置类，替换元素本身的class1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;style&gt; .on&#123; border-bottom: 1px solid #0f0; &#125; .current &#123; background: #ccc; color: #f00; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"list1\"&gt; &lt;li style=\"color:blueviolet;font-size:18px\"&gt;啦啦啦&lt;/li&gt; &lt;!-- 一开始“黄女士”的标签是on的样式，但lis[1].className=\"current\";会替换掉on的样式 --&gt; &lt;li class=\"on\"&gt;&lt;i&gt;黄女士&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;困困&lt;/b&gt;&lt;/li&gt; &lt;li&gt;醒醒&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //获取id为list1下的所有的1i,得到的是数组 var lis = document.getElementById(\"list1\").getElementsByTagName(\"li\"); for (var i = 0, len = lis.length; i &lt; len; i++) &#123; lis[1].className=\"current\"; &#125; console.log(lis[1].className);//current &lt;/script&gt;&lt;/body&gt; getAttribute()获取属性 语法：ele.getAttribute（&quot;attribute&quot;） 功能：获取ele元素（DOM元素）的attribute属性 说明： ele是要操作的dom对象 attribute是要获取的html属性（如：id、tpye） 注意： 对于class以外的标准属性都可以直接通过p.id/p.align这种形式来获得属性名。 而class名字则需要通过p.className而不是p.class data-type这种自定义的属性则需通过p.getAttribute(“自定义属性类型”)来获取属性名1234567891011121314&lt;body&gt; &lt;p id=\"text\" class=\"text\" align=\"center\" data-type=\"title\"&gt;文本&lt;/p&gt; &lt;script&gt; var p=document.getElementById(\"text\"); // 对于class以外的标准属性都可以直接通过p.id/p.align这种形式来获得属性名 console.log(p.id);//text console.log(p.align);//center // 而class名字则需要通过p.className而不是p.class console.log(p.className);//text console.log(p.getAttribute(\"class\"));//text，等价的 // data-type这种自定义的属性则需通过p.getAttribute(\"自定义属性类型\")来获取属性名 console.log(p.getAttribute(\"data-type\"));//title &lt;/script&gt;&lt;/body&gt; setAttribute()设置(增加)属性 语法:ele.setAttribute(&quot;attribute&quot;,value) setAttribute方法必须要有两个参数 如果value是字符串，需加引号 setAttribute（）有兼容性问题 功能:在ele元素（DOM元素）上设置属性 说明: ele是要操作的dom对象 attribute为要设置的属性名称 value为设置的attribute属性的值12345678&lt;body&gt; &lt;p id=\"hello\" class=\"text\" align=\"center\" data-type=\"title\"&gt;文本&lt;/p&gt; &lt;script&gt; var p=document.getElementById(\"hello\"); // 给p增加一个isRead的属性 p.setAttribute(\"isRead\",\"false\"); &lt;/script&gt;&lt;/body&gt; removeAttribute()删除属性 语法:ele.removeAttribute(&quot;attribute&quot;) 功能:删除ele上的attribute属性 说明: ele是要操作的dom对象 attribute是要删除的属性名称12345678&lt;body&gt; &lt;p id=\"hello\" class=\"text\" align=\"center\" data-type=\"title\"&gt;文本&lt;/p&gt; &lt;script&gt; var p=document.getElementById(\"hello\"); // 删除p的align属性 p.removeAttribute(\"align\");//删除后文本靠左对齐 &lt;/script&gt;&lt;/body&gt; addEventListener() 添加事件句柄(click)addEventListener() 方法用于向指定元素添加事件句柄。提示： 使用 removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄。 参数 描述 event 必须。字符串，指定事件名。注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。 提示： 所有 HTML DOM 事件，可以查看完整的 HTML DOM Event 对象参考手册 function 必须。指定要事件触发时执行的函数。 当事件对象会作为第一个参数传入函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象 useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。可能值:true - 事件句柄在捕获阶段执行false- 默认。事件句柄在冒泡阶段执行 123456789&lt;button id=\"myBtn\"&gt;点我&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;script&gt;document.getElementById(\"myBtn\").addEventListener(\"click\", myFunction);function myFunction() &#123; document.getElementById(\"demo\").innerHTML = \"Hello World\";&#125;&lt;/script&gt; 或者 12345678&lt;button id=\"myBtn\"&gt;点我&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;script&gt;document.getElementById(\"myBtn\").addEventListener(\"click\", function () &#123; document.getElementById(\"demo\").innerHTML = \"Hello World\";&#125;);&lt;/script&gt; 完整例子","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS对象之数组(2)","slug":"JS对象之数组（2）","date":"2019-08-11T03:40:52.000Z","updated":"2020-02-05T03:44:27.804Z","comments":true,"path":"2019/08/11/JS对象之数组（2）/","link":"","permalink":"http://yoursite.com/2019/08/11/JS对象之数组（2）/","excerpt":"数组的位置查找方法注意： 需要严格相等（===）才能查找位置。 这两个方法都只能用于IE9以上的浏览器，以下的则需要我们封装一个方法来使用。（将其补充在下面）","text":"数组的位置查找方法注意： 需要严格相等（===）才能查找位置。 这两个方法都只能用于IE9以上的浏览器，以下的则需要我们封装一个方法来使用。（将其补充在下面） indexOf() 语法:arrayObject.indexOf(searchvalue,startindex) 功能:从数组的开头(位置0)开始向后查找. 参数:searchvalue:必需,要查找的项;startlndex:可选,起点位置的索引. 返回值:number,查找的项在数组中的位置(如果有多个就返回第一个的位置),没有找到的情况下返回-1.1234var nums=[1,7,5,7,8,1,6,9];var pos=nums. indexOf(7,2);//3var pos2 = nums.indexOf(7);//1console.log(pos,pos2);//3 1 lastIndexOf() 从数组的末尾开始向前查找。 其余与indexOf()一样。1234var nums=[1,7,5,7,8,1,6,9];var pos3 = nums.lastIndexOf(1);//5var pos4 = nums.lastIndexOf(1,3);//0console.log(pos3,pos4);//5 0 面试题1234567891011121314//完成以下代码段，实现b数组对a数组的拷贝，方法越多越好var a = [1,\"yes\",3], b;// 方法1，数组遍历，push// 首先需要将新建为数组,注意不要重复var，也可以写作b=[];b =new Array();for (i=0;i&lt;a.length;i++)&#123; b.push(a[i]);&#125;// 方法2，concatb=a.concat([]);//或者b=[].concat(a);// 方法3，sliceb=a.slice(0);console.log(b); IE9以下的浏览器使用封装方法进行位置查找12345678910111213var nums = [1, 7, 5, 7, 8, 1, 6, 9];//封装一个方法实现indexof的功能function ArrayIndexOf(arr, value) &#123; //检测value在arr中出现的位置 for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] **= value) &#123; return i; &#125; &#125; return -1;&#125;var pos5=ArrayIndexOf(nums, 8);//调用封装的方法console.log(pos5);//4 map() 方法遍历数组并进行操作ES5中提供的JavaScript Array map() 方法可以遍历数组列表并按顺序对数组中的每一项执行回调函数。 补充：in运算符（可参考MDN的in运算符） 如果指定的 属性 在指定的对象或其原型链中，则in 运算符返回true。 如果指定的 数组索引 在数组中，则in 运算符返回true。 注意：不是数组元素，是数组下标！ 语法：prop in object prop一个字符串类型或者 symbol 类型的属性名或者数组索引（非symbol类型将会强制转为字符串）。 objectName检查它（或其原型链）是否包含具有指定名称的属性的对象。 例子： 12345678// 数组var trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");0 in trees // 返回true3 in trees // 返回true6 in trees // 返回false\"bay\" in trees // 返回false (必须使用索引号,而不是数组元素的值)\"length\" in trees // 返回true (length是一个数组属性)","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS对象之数组（1）","slug":"JS对象之数组（1）","date":"2019-08-10T13:38:57.000Z","updated":"2020-02-05T03:34:54.967Z","comments":true,"path":"2019/08/10/JS对象之数组（1）/","link":"","permalink":"http://yoursite.com/2019/08/10/JS对象之数组（1）/","excerpt":"Array 数组 数组中每一项都可以存放不同类型的数据，比如：第一个数是字符串，第二个数是数字，第三个数是布尔型。 数组大小可随着数据的添加自动增长。","text":"Array 数组 数组中每一项都可以存放不同类型的数据，比如：第一个数是字符串，第二个数是数字，第三个数是布尔型。 数组大小可随着数据的添加自动增长。 创建数组 使用Array构造函数语法：new Array() 小括号()说明： 预先知道数组要保存的项目数量 向Array构造函数中传递数组应包含的项 123456789101112131415//创建一个保存颜色的数组var color = new Array();console.log(color);//[]// 往color数组中写入值color[0]=\"#f00\";color[1]=\"#0f0\";color[2]=\"#00f\";console.log(color);//[\"#f00\", \"#0f0\", \"#00f\"]//索引console.log(color[2]);//#00fvar colors=new Array(3);console.log(colors);//(3) [empty × 3] 使用数组字面量表示法由一对包含数组项的方括号[]表示，多个数组项之间以逗号隔开。 123456var nums=new Array(1,3,6,9);console.log(nums);//[1,3,6,9]var cols=[\"red\",\"yellow\",\"green\"];console.log(cols);//[\"red\",\"yellow\",\"green\"]var infos=[6,\"marry\",true];console.log(infos);//[6,\"marry\",true] 数组元素的读写读取和设置值时，使用方括号并提供相应的索引。说明：索引是从0开始的正整数。 1234567var color = new Array();// 往color数组中写入值color[0]=\"#f00\";color[1]=\"#0f0\";color[2]=\"#00f\";//索引console.log(color[2]);//#00f 数组长度 语法：array.length 功能：获取数组array的长度 返回值：number 说明：1、通过设置length可以从数组的末尾移除项或向数组中添加新项。123456var arr=[\"a\",\"b\",\"c\",\"d\"]console.log(arr.length);//4//通过设置length可以从数组的末尾移除项arr.length=2;console.log(arr);//[\"a\", \"b\"] 2、把一个值放在超出当前数组大小的位置上时，会重新计算数组长度值，长度值等于最后一项索引加1。**【注意：4个数加一个最后数组长度并不是5，要看这一个数加到哪个位置，加到下标为99的位置则这个数组的数组长度改为100。】** 123//接上面代码，原本数组长度为4，但是加了一个数到下标为99的位置则这个数组的数组长度改为100arr[99]=\"z\";console.log(arr.length);//100 数组的方法push()：在尾部添加元素 语法:arrayObject.push(newele1,newele2...…,neweX) 功能:把它的参数顺序添加到arrayObject的尾部. 返回值:把指定的值添加到数组后的新长度.123456//push var colors=new Array(\"red\",\"green\"); var len=colors.push(\"blue\",\"yellow\",\"blank\"); console.log(len);//5,要注意添加以后的返回值是长度，数组名的返回值才是所有的数组元素console.log(colors[4]);//blankconsole.log(colors);// [\"red\", \"green\", \"blue\", \"yellow\", \"blank\"] unshift()：在开头添加元素 语法:arrayObject.unshift(newele1,newele 2...…,neweX) 功能:把它的参数顺序添加到arrayObject的 开头 . 返回值:把指定的值添加到数组后的新长度.12345//unshift var nums=[2,7,8,6]; var size=nums.unshift(99,66); console.log(size);//6console.log(nums);//[99, 66, 2, 7, 8, 6] pop()：删除最后一个元素 语法:arrayObject.pop() 功能: 删除arrayObject的最后一个元素 返回值:被删除的那个元素1234//popvar n =nums.pop();console.log(n);//6,是我们被删除的那个元素console.log(nums);//[99, 66, 2, 7, 8],删完以后的nums数组所有元素 shift()：删除第一个元素 语法:arrayObject.shift() 功能: 删除 arrayObject中的第一个元素 返回值:被删除的那个元素1234//shiftvar m=colors.shift();console.log(m);//redconsole.log(colors);//[\"green\", \"blue\", \"yellow\", \"blank\"] 数组的转换方法join()：数组转换为字符串 语法:arrayObject.join(separator)separator:分隔符，也可以为空。参数为空是默认使用逗号隔开，如果不想要逗号可以使用&quot;&quot;作为参数。 功能:用于把数组中的所有元素放入一个字符串. 返回值：字符串12345678910//join var nums=[2,4,5]; var str=nums. join();//2,4,5var words=[\"border\",\"left\",\"color\"];var wordstr=words. join(\"-\"); console.log(wordstr);//border-left-color var wordstr=words. join(\"\"); console.log(wordstr);//borderleftcolor 数组的重排序方法reverse()颠倒顺序 语法:stringObject.reverse() 功能:用于颠倒数组中元素的顺序. 返回值:数组.1234567//reverse nums.reverse();console.log(nums);//[5,4,2]var strs=[\"a\",\"b\",\"c\",\"d\"];//返回dcba这个字符串var newstr=strs.reverse().join(\"\");console.log(newstr); sort()升序/降序排序 语法:arrayObject.sort(sortby) sortby:在这里如果为空则按照字符串的大小来排序（也就是每个元素都先比较第一位的大小来排，再比较第二位），哪怕是数字也是如此。所以要放置一个匿名函数(排序函数)才能用于数字的升降序排序。 功能:用于对数组的元素进行排序(升序/降序),参数决定排序的顺序。 返回值:数组.(注意，数组在原数组上进行排序，不生成副本。) 说明: 即使数组中的每一项都是数值,sort()方法比较的也是字符串. sort()方法可以接收一个比较函数作为参数.(该比较函数为含有两个参数的匿名函数) 原理：如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 返回一个小于 0 的值，在排序后的数组中 a 应该出现在 b 之前。 返回 0。 返回一个大于 0 的值，在排序后的数组中 a 应该出现在 b 之后。 注意：不管是b-a还是a-b还是别的计算式，我们只关注返回值来确定a在b的前面还是后面。 例子： 1234567var arr=[9,23,15,-99,88,12,-2];//降序arr.sort(function(a,b)&#123;return b-a&#125;);console.log(arr);//[88, 23, 15, 12, 9, -2, -99]//升序arr.sort(function(a,b)&#123;return a-b&#125;);console.log(arr);//[-99, -2, 9, 12, 15, 23, 88] 例子原理：排序思想应该是类似于冒泡排序思想的，通过前后相邻的两个数进行比较。例如9与23，这时将9作为方法函数function(a,b)参数列表中的a，23作为b，通过语句return b - a;返回一个数值，23-9=24, 若返回值&gt;=1，则表示 a在排序后的序列中出现在 b 之后,所以9会在排序后出现在23之后。也就是说数组将被由大到小排序。此时，新的数据序列为23,9,15,-99,88,12，-2，再将9作为a，15作为b进行上述的做法。 数组的操作方法concat()连接两个或多个数组 语法:arrayObject.concat(arrayX,arrayX....…arrayX) 功能:用于连接两个或多个数组. 返回值:数组.123456var arrl=[\"a\",\"b\",\"c\"], arr2=[\"d\",\"e\",1,3], arr3;//concat arr3=arrl.concat(arr2,[\"m\",99,8]); console.log(arr3);// [\"a\", \"b\", \"c\", \"d\", \"e\", 1, 3, \"m\", 99, 8] 注意：要事先定义一个新的数组用于存放合并以后形成的数组。 slice()截取部分元素 “截取”的意思 语法:arrayObject.slice(start,end) 功能:从已有的数组中返回选定的元素. 参数 描述 start (可省去) 规定从何处开始选取。如果是负数,那么它规定从数组尾部开始算起的位置。如果省略则 slice 从索引 0 开始。如果start大于原数组的长度，则会返回空数组。 end (可省去) 规定从何处结束选取.该参数是数组片断结束处的数组下标.（不包含该元素）【也就是说，arr.slice(1,2);中只arr[1]，没有arr[2]】 返回值 含有选定那部分元素的数组 注意: 如果没有指定end,那么切分的数组包含从start到数组结束的所有元素. 如果slice()方法的参数中有一个负数,则用数组长度加上该数来确定开始*的位置. 【两个参数都适用】（即：数组长度+负数=参数数值**） 注意：截取从start到end-1的元素。 12345678//slice(start,end)var colors=[\"red\",\"green\",\"blue\",\"yellow\",\"orange\"];var newColors=colors.slice(1,3);console.log(newColors);// [\"green\", \"blue\"]var newColors2=colors.slice(-2,4);//5-2=3,也就是从3开始到4结束（不包括4）console.log(newColors2);//[\"yellow\"]// 5-4=1,5-2=3,相當於colors.slice(1,3)console.log(colors.slice(-4,-2));//[\"green\", \"blue\"] 面试题1234567891011121314//完成以下代码段，实现b数组对a数组的拷贝，方法越多越好var a = [1,\"yes\",3], b;// 方法1，数组遍历，push// 首先需要将新建为数组,注意不要重复var，也可以写作b=[];b =new Array();for (i=0;i&lt;a.length;i++)&#123; b.push(a[i]);&#125;// 方法2，concatb=a.concat([]);//或者b=[].concat(a);// 方法3，sliceb=a.slice(0);console.log(b); splice()删除、插入、替换注意：不管是删除还是插入还是替换，返回值都是从原数组中删除的元素组成的数组。 删除注意：删除时，返回的是含有删除部分的元素的数组，原数组会变成被删除以后的数组。 语法:arrayObject.splice(index,count) 功能:删除从index处开始的零个或多个元素. 返回值:含有被删除的元素的数组. 说明:count是要删除的项目数量,如果设置为0,则不会删除项目.如果不设置,则删除从index开始的所有值.12345678var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];//删除var delArr = arr.splice(5);//从数组下标为5的元素开始，包括5【注意是数组下标】console.log(arr);// [\"a\", \"b\", \"c\", \"d\", \"e\"]console.log(delArr);//[\"f\"]var delArr = arr.splice(2, 2);console.log(arr);// [\"a\", \"b\", \"e\"]console.log(delArr);//[\"c\", \"d\"] 插入注意： “起始位置” 指想要放进去的位置，比如想要在第3个和第4个元素中插入元素，即在[2]和[3]中间要插入元素，则应该在[3]的位置放置新元素，3就是起始位置。 插入的时候不需要删除，所以返回值是空数组。 语法:arrayObject.splice(index,0,item.1...….itemX) 功能:在指定位置插入值 参数:Index:起始位置0:要删除的项数item1…itemX:要插入的项 返回值:数组12345var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];// 插入var insertArr=arr.splice(3,0,\"m\",\"n\");console.log(arr);// [\"a\", \"b\", \"c\", \"m\", \"n\", \"d\", \"e\", \"f\"]console.log(insertArr);//[]，插入的时候不需要删除，所以返回值是空数组。 替换 语法:arrayObject.splice(index,count,item 1...……itemX) 功能:在指定位置插入值,且同时删除任意数量的项 参数:Index:起始位置count:要删除的项数item1…itemX:要插入的项 返回值:从原始数组中删除的项(如果没有删除任何项,则返回空数组)1234//替换【从下标为1的元素开始删除2个元素并插入3个新元素】var relaceArr=arr.splice(1,2,\"x\",\"y\",\"z\");console.log(arr);//[\"a\", \"x\", \"y\", \"z\", \"d\", \"e\", \"f\"]console.log(relaceArr);//[\"b\", \"c\"]","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS数据类型","slug":"JS数据类型","date":"2019-07-01T10:55:12.000Z","updated":"2020-02-04T05:49:22.356Z","comments":true,"path":"2019/07/01/JS数据类型/","link":"","permalink":"http://yoursite.com/2019/07/01/JS数据类型/","excerpt":"很好的验证方法：在控制台中打印1console.log(变量名); 打印出的内容需要到网页F12中的console部分查看","text":"很好的验证方法：在控制台中打印1console.log(变量名); 打印出的内容需要到网页F12中的console部分查看 举例： 12345&lt;script&gt; var name_01=\"marry\",age=18,email=\"marry@qq.com\",address; // 在控制台中打印 console.log(name_01); &lt;/script&gt; 在网页F12中看到的就是marry typeof检测变量类型 功能 检测变量类型 语法 typeof 变量 或 typeof（变量） 返回值 类型，有可能是：string、number、 boolean、 object、undefined、function 举例: 12345&lt;script&gt; var name_01=\"marry\",age=18,email=\"marry@qq.com\",address; // 在控制台中打印 console.log(typeof name_01); &lt;/script&gt; 结果：在网页F12中看到的就是string 注意：typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。准确判断可以从构造函数（instanceof）、原型链（prototype.isPrototypeOf）上下手，具体可以看下面的“如何判断一个对象是不是数组类型”中的例子。 null空对象指针 null值表示一个空对象指针 如果定义的变量准备在将来用于保存对象，那么最好将改变量初始化为null而不是其他值。（如果将来用于保存字符串，则可以使用“”，意为空字符串。） 举例: 1234//如果setting将来打算存储一个对象，最好初始化设置为nullvar setting=null;//如果setting将来打算存储一个字符串，最好初始化设置为\"\"var setting=\"\"; 说明：undefined值是派生自null值的，所以undefined= = null的返回结果是true。 undefined尚未赋值 undefined，一个特殊值，通常用于指示变量尚未赋值。 在高级程序设计语言设计应用程序时，用于指示变量尚未用单等号进行赋值（常量未定义）。 null(对象)与undefined(变量) null的类型是一个对象，用来表示一个变量没有任何数值，而undefined是指变量没有定义任何值（没有赋值）。 在JavaScript中，关键字null表示空值的意思，它表示对象为空，或者变量没有引用任何对象。如果当一个变量的值为null，则表明它的值不是有效的对象、数组、数值、字符串和布尔型等。如果使用alert(typeof(null))来检测null值的类型，则返回object，说明它是一个对象类型。 而undefined与null不同，它表示无值的意思，并且具有独一无二的类型，它区别任何对象、数组、数值、字符串和布尔型。alert(typeof(undefined))的返回值为undefined。 总的来说，null是不限于类型的空对象指针，而undefined是限于类型的变量还没有赋值。 Number整数和浮点数 Number ：表示整数和浮点数 NaN ：即非数值（ Not a Number ）是一个特殊的数值面试常考！ 说明： 任何涉及NaN的操作（例如NaN/10 ）都会返回NaN。 NaN与任何值都不相等，包括NaN本身。 如果typeof一个NaN，你会在F12中看到number，因为NaN是特殊的number isNaN（）判断是否“非数值” 语法：isNaN（n） 功能：检测n是否是“非数值” 返回值：boolean 参数：参数n可以是任何类型 说明 ：isNaN（）对接收的数值，先尝试转换为数值，再检测是否为非数值。（”16”虽然是字符串,但”16”可以转换为16，所以还是false） 注意：只有遇到Nan他才会返回true，其他不管是什么类型，包括true与false都被算作是数值，返回false！ 举例： 123456789&lt;script&gt; var name_01=\"marry\",age=18,email=\"marry@qq.com\",address; var id=\"16\" // 在控制台中打印 console.log(typeof(age));//得到的是false console.log(typeof(age-\"abc\"));//得到的是true console.log(typeof(email));//得到的是false console.log(typeof(id));//id虽然是字符串，但得到的是false,因为isNaN（）会对接收的数值先尝试转换为数值，再检测是否为非数值。而\"16\"可以转换为16。 &lt;/script&gt; 注意：true与false都被算作是数值！ 1234567//isNaN 判断是否“非数值”，遇到字符串会看能不能将其转换为数值再进行判断console.log(Number.isNaN(NaN));//trueconsole.log(Number.isNaN(-NaN));//trueconsole.log(Number.isNaN(1)); //falseconsole.log(Number.isNaN('1'));//falseconsole.log(Number.isNaN(true));//falseconsole.log(Number.isNaN(false));//false 把非数值转换为数值 有3个函数可以把非数值转换为数值： Number（） parseInt（） parseFloat（） 说明： Number（）可以用于任何数据类型 parseInt（）和parseFloat（）则专门用于把字符串转换成数值。 但是最好少用Number（） 只有数字开头的字符串可以使用parseInt（）和parseFloat（），非数字开头的只能使用Number（）【实际上非数字开头用Number（）也没用】 parseInt（）parseInt（） ：会忽略字符串前面的空格，直至找到第一个非空格字符。==也就是说，要想让parseInt（）提取数字，字符串必须是数字开头，比如”18px”，不能是”abc18”。parseInt(“abc18”)会得到NaN== 举例： 1234567&lt;script&gt; var topval=parseInt(\"28px\"); var c=\"abc28\"; // 在控制台中打印 console.log(topval);//得到的是28 console.log(parseInt(c));//得到的是NaN &lt;/script&gt; 说明： parseInt（） ：转换空字符串返回NaN。 ==面试常见== parseInt（）这个函数提供第二个参数：转换时使用的基数（即多少进制） 针对第2点举例： 123&lt;script&gt; console.log(parseInt(\"0xf\"));//得到的是15，并不是取0，而是把16进制转换过来了.也可以写成console.log(parseInt(\"0xf\",16)); &lt;/script&gt; parseFloat（） parseFloat ：从第一个字符开始解析每个字符，直至遇见一个无效的浮点数字符为止。 说明：除了第一个小数点有效外，parseFloat（）与parseInt（）的第二个区别在于它始终都会忽略前导的零。 举例： 123456789&lt;script&gt; var d=parseFloat(\"12.34px\"); // 在控制台中打印 console.log(d);//得到的是12.34 console.log(parseFloat(\"12.34.56px\"));//得到的还是12.34，第二个小数点不会被截取出来 console.log(parseInt(\"0123\"));//得到的是123 console.log(parseFLoat(\"0123\"));//得到的还是123，他们都会忽略前面的0 &lt;/script&gt; Number（） 返回值：如果参数是 Date 对象，Number() 返回从 1970 年 1 月 1 日至今的毫秒数。如果对象的值无法转换为数字，那么 Number() 函数返回 NaN。 ==null与空字符==, number 默认把其转化为0 面试题1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;script&gt; var x; console.log(x);//undefined var y = null; console.log(y);//null console.log(null == 0);//false,null值表示一个空对象指针 console.log(undefined == 0);//false,undefined表示未赋值 console.log(undefined == null);//true,undefined值是派生自null值的 console.log(Number(\"\"));//0 console.log(Number(null));//0 console.log(Number(undefined));//NaN console.log(Number(\"2\"));//2 console.log(Number(\"a2\"));//NaN console.log(Number(\"222 333\"));//NaN console.log(parseInt(\"\"));//NaN console.log(parseInt(null));//NaN console.log(parseInt(undefined));//NaN console.log(parseInt(\"22\"));//22 console.log(parseInt(\"a22\"));//NaN,要想让parseInt（）提取数字，字符串必须是数字开头 console.log(parseInt(22));//22 console.log(parseInt(\" 22\"));//22 console.log(parseInt(\"22 33\"));//22 &lt;/script&gt;&lt;/body&gt; （面试题）如何判断一个对象是不是数组类型首先我们需要知道：在 JavaScript 中，几乎“所有事物”都是对象。（具体可以看笔记“js对象 学习笔记（1）”）typeof {}和typeof []的结果都是object：使用typeof来判断数据类型其实并不准确，数组、正则、日期、对象的typeof返回值都是object。 obj instanceof Array从构造函数入手，typeof 和 instanceof 都可以用来判断变量，typeof方法返回一个字符串，来表示数据的类型。 但是typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。而 instanceof运算符 用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性，返回一个布尔值，如果左侧的对象是右侧对象的实例，返回true，否则返回false。 Array.prototype.isPrototypeOf(obj);从原型入手，利用isPrototypeOf()方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。 12Array.prototype.isPrototypeOf([]);//trueArray.prototype.isPrototypeOf(&#123;&#125;);//false Array.isArray()方法这是js提供的方法，用于判断对象是不是数组类型，如下： 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray('foobar'); // falseArray.isArray(undefined); // false MDN中比较了isArray和instanceof的区别，当Array.isArray()不可用的使用，MDN做了补丁，说明还是比较推荐使用前面讲的方法 Object.prototype.toString.call(obj)。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]}]}