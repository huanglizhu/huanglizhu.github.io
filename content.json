{"meta":{"title":"珠","subtitle":null,"description":"Record every bit of front-end learning.","author":"黄丽珠","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-03-21T03:54:49.973Z","updated":"2020-03-21T03:54:49.973Z","comments":true,"path":"google5b7cd86cfc94af70.html","permalink":"http://yoursite.com/google5b7cd86cfc94af70.html","excerpt":"","text":"google-site-verification: google5b7cd86cfc94af70.html"},{"title":"分类","date":"2019-09-16T04:23:41.000Z","updated":"2019-09-16T08:55:15.762Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2019-09-16T04:23:50.000Z","updated":"2020-01-18T05:00:18.340Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"作者： HLZ 出处： http://huanglizhu.github.io/ 邮箱： 651526410@qq.com 本文基于 知识共享署名-相同方式共享 4.0 国际许可协议发布，欢迎转载、演绎,但是必须保留本文的署名 HLZ及链接。"},{"title":"tags","date":"2019-09-16T04:23:28.000Z","updated":"2019-09-16T04:25:08.820Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"koa2项目加载静态资源","slug":"koa2项目加载静态资源","date":"2020-11-04T06:27:12.000Z","updated":"2020-11-14T03:55:13.447Z","comments":true,"path":"2020/11/04/koa2项目加载静态资源/","link":"","permalink":"http://yoursite.com/2020/11/04/koa2项目加载静态资源/","excerpt":"我想要让数据库中的数据（emoji表情）在不同的页面都显示同一资源文件夹下对应的表情，img是存储在src\\public下的，一开始的思路是数据库读取数据后的格式化中根据不同页面的请求地址拼接src值，但后来发现我把问题想复杂了，使用koa-static中间件配置静态资源托管文件夹后一切都简单起来了","text":"我想要让数据库中的数据（emoji表情）在不同的页面都显示同一资源文件夹下对应的表情，img是存储在src\\public下的，一开始的思路是数据库读取数据后的格式化中根据不同页面的请求地址拼接src值，但后来发现我把问题想复杂了，使用koa-static中间件配置静态资源托管文件夹后一切都简单起来了 实现功能 实现功能：输入框中可选择输入emoji表情，将关键词存入数据库后，不同的页面读取数据时将关键词替换成img标签从而显示对应emoji。 前提条件:koa-static 前提条件：我在koa2框架中使用中间件配置了静态托管文件夹首先为public文件夹，使得浏览器可以直接访问静态资源： src/app.js中设置了静态资源所放在的目录为public，比如遇到http://localhost:3000/img/f1.png则首先去public目录找f1.png:123// src/app.js的__dirname是srcconst koaStatic = require('koa-static')app.use(koaStatic(__dirname + '/public')) koa-static作用：静态资源如png,jpg,jpeg,gif,css,js，当我们应用koa-static中间件设置静态文件目录时，浏览器可以直接访问静态资源。 实现思路图片资源本地存储位置： E:\\nodejsWorkspaces\\weibo\\src\\public\\img内 选中某个表情后，将这个emoji对应成相应的标识词（即[imgName]，比如f1.png使用[f1]作为标识词）存入数据库 页面读取数据库微博内容时做 格式化 处理，遇到标识词就换成img标签&lt;img src=&#39;/img/${imgName}.png&#39; alt=&#39;${imgName}&#39; &gt; 由于我们应用koa-static中间件在src/app.js中设置了静态资源所放在的目录为__dirname/public，所以浏览器可以直接访问静态资源。 所以遇到&lt;img src=&#39;/img/f1.png&#39;时会去__dirname/public下找/img/f1.png 而__dirname总是指向被执行 js 文件的绝对路径，在本地即E:\\nodejsWorkspaces\\weibo\\src 所以最终就会到E:\\nodejsWorkspaces\\weibo\\src\\public下查找图片，成功找到","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Node.js前后端获取url url与绝对/相对路径","slug":"Node.js前后端获取url url与绝对相对路径","date":"2020-10-23T05:01:35.000Z","updated":"2020-11-13T15:17:12.759Z","comments":true,"path":"2020/10/23/Node.js前后端获取url url与绝对相对路径/","link":"","permalink":"http://yoursite.com/2020/10/23/Node.js前后端获取url url与绝对相对路径/","excerpt":"前端写久了差点忘记后端获取url的方法，在后端用location结果undefined了，这才想起前后端的差异，于是记录一下。","text":"前端写久了差点忘记后端获取url的方法，在后端用location结果undefined了，这才想起前后端的差异，于是记录一下。 获取url的方法前端 使用location的常用属性: location.href：整个网站地址(返回完整的URL) location.protocol：返回一个URL协议（比如https:/http:） location.host：域名(返回一个URL的主机名和端口) location.search：返回一个URL的查询部分，即?后的内容 location.hash：网址的哈希(返回一个URL的锚部分)，即#后的内容 location.pathname：返回的URL路径名 后端Node.js 可参考我的文章“Node.js开发博客项目之接口(1)” 通过request 对象的属性获取url(注意request对象是怎么来的)： request.method：客户端是用什么方法请求的(GET/POST) request.url：获取完整的url request.headers：客户端（浏览器）向服务端发送的请求中的头中的信息 request.headers[“content-type”]：请求的数据类型是什么（比如JSON）。 request.setHeader(name, value)：为请求头对象设置单个请求头的值。 （例子） Koa2 通过ctx.request的属性来获取url，具体属性见下方的图片例子。 补充：ctx.request.body包含post请求中的数据 绝对/相对路径 文件和url的绝对/相对路径的知识涉及url中的Scheme。 文件的绝对/相对路径 以前了解的绝对/相对路径就是局限在文件是哪个，似乎我从未考虑过上线以后会发生什么。 相对路径： /：表示根目录 ./ 或 / 一样：表示当前目录 ../：表示父级目录（即 上一级目录） 绝对路径： 从根目录开始一直到该文件位置的全程的路径 比如：E:\\nodejsWorkspaces\\weibo\\package.json就是weibo文件夹下package.json的绝对路径 url与绝对/相对路径 相对路径 ：从该文件自身所在位置开始寻找路径。 绝对路径 ：永远从网站的根目录开始寻找路径。 网页 根目录 例子： 本地项目：http://localhost:3000/是我的微博项目的 首页，它的根目录是http://weibo.mokeyjay.com:3000 线上项目：http://weibo.mokeyjay.com:3000/comment是我的微博项目的 评论页，它的根目录是http://weibo.mokeyjay.com:3000 参考知乎、编程客栈 补充:__dirname与./ __dirname：表示当前文件所在的目录的绝对路径 __filename ：表示当前文件的绝对路径 __dirname 总是指向被执行 js 文件的绝对路径，所以当你在 /d1/d2/myscript.js 文件中写了 __dirname， 它的值就是 /d1/d2 。 相反，./ 会返回你执行 node 命令的路径，例如你的工作路径。 特殊情况：在 require() 中使用 ./ 时，这时的路径是含有 require() 的脚本文件的相对路径。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Bootstrap响应式页面打印A4时被识别为小屏幕","slug":"Bootstrap响应式页面打印A4时被识别为小屏幕","date":"2020-10-11T11:52:53.000Z","updated":"2020-11-11T12:10:53.506Z","comments":true,"path":"2020/10/11/Bootstrap响应式页面打印A4时被识别为小屏幕/","link":"","permalink":"http://yoursite.com/2020/10/11/Bootstrap响应式页面打印A4时被识别为小屏幕/","excerpt":"我正在做自己的web简历，打算做成移动端看起来也舒服的响应式页面，结果设置好@media print打印预览的时候才发现打印A4时被识别为小屏幕，可我希望的效果是打印电脑屏幕而不是手机上的显示效果。","text":"我正在做自己的web简历，打算做成移动端看起来也舒服的响应式页面，结果设置好@media print打印预览的时候才发现打印A4时被识别为小屏幕，可我希望的效果是打印电脑屏幕而不是手机上的显示效果。 问题描述希望打印的效果（大屏幕） 实际打印预览（小屏幕） 原因在css样式表中设置了打印时的页面尺寸为A4，于是识别成了小屏幕： 12345678@media print &#123; @page &#123; /*A4: 210mm × 297mm，size: 794px × 1123px，0边距*/ /*171.9mm × 258.9mm，size：649px × 978px，19.05mm边距（ie浏览器默认打印边距） */ size: 210mm 297mm; margin:0mm; &#125;&#125; 解决方法原本我是使用了bootstrap的栅格系统实现的响应式，现在在识别到打印时重新给.col-md-4和.col-md-8分配对应的宽度： 123456789101112131415@media print &#123; @page &#123; /*A4: 210mm × 297mm，size: 794px × 1123px，0边距*/ /*171.9mm × 258.9mm，size：649px × 978px，19.05mm边距（ie浏览器默认打印边距） */ size: 210mm 297mm; margin:0mm; &#125; /* 避免被识别成小屏幕进行响应式 */ .col-md-4&#123; width: 33.3%; &#125; .col-md-8&#123; width: 66.7%; &#125;&#125; 参考 @media print @page MDN 打印样式设计（@PAGE 规则形象解释）","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"github page部署react项目遇到的坑","slug":"github page部署react项目遇到的坑","date":"2020-09-10T04:10:23.000Z","updated":"2020-11-10T05:36:29.442Z","comments":true,"path":"2020/09/10/github page部署react项目遇到的坑/","link":"","permalink":"http://yoursite.com/2020/09/10/github page部署react项目遇到的坑/","excerpt":"想把自己写好的react项目放到github page上展示，没想到踩了一路的坑，好不容易解决了，记录一下免得下次又忘了。","text":"想把自己写好的react项目放到github page上展示，没想到踩了一路的坑，好不容易解决了，记录一下免得下次又忘了。 一切都正常的步骤安装 gh-pages 依赖react项目中安装 gh-pages 依赖 修改package.json文件在 package.json文件中配置homepage和scripts命令： 1\"homepage\": \"https://yourUserName.github.io/ReactAppName/\", yourUserName为github账户名称 ReactAppName 为 仓库名 scripts 中配置: 1\"deploy\": \"gh-pages -d build\" 依次执行命令依次执行打包、新建gh-pages分支的命令： 12npm run buildnpm run deploy 访问生成的github pagegithub的仓库中找到setting，里面有github pages，会提示你生成的网页： 1https://yourUserName.github.io/ReactAppName/ yourUserName为github账户名称 ReactAppName 为 仓库名 坑来了二级域名错误（页面跳转出错）index.html正常显示，但是我期望的二级域名应该是yourUserName.github.io/ReactAppName/，这里生成的却是yourUserName.github.io，这导致我点击项目中的“首页”永远不是跳转项目首页而是跳转我的博客首页（我的博客时搭建在github page上的） 原因：react-router的basename问题 react-router中默认的basename是domain，但在githubpage部署时，其地址为”domain/ReactAppName”。 所以我们的路由都在ReactAppName下可实际上漏了一个ReactAppName。 解决方法：设置BrowserRouter的basename属性 在使用react-router的BrowserRouter时，手动加上basename： 1&lt;BrowserRouter basename=\"/ReactAppName\"&gt; &#123;/* ReactAppName 为 仓库名 */&#125; 但是加上以后本地或者build后运行起来路径就不对了，可以手动使用process.env.NODE_ENV来判断当前环境，给生产环境和开发环境设置不同的basename（注意别给basename设置为空了，默认的basename是domain） axios的请求路径错误（假数据获取不到）页面是正常显示了，页面跳转的路径没问题了，可是通过axios获取的假数据获取不到。 原因：axios请求地址错误 页面跳转的路径没问题了，可是axios请求的路径还是从domain出发的，而假数据我是放在domain/ReactAppName下的（在build之前假数据在public文件夹下，build后在gh-pages分支的仓库根目录中） 请求报404错误:GET https://huanglizhu.github.io/api/headerList.json 404，它是去请求了https://yourUserName.github.io/假数据路径，漏了重要的ReactAppName 很明显我希望axios发出的请求路径是https://huanglizhu.github.io/ChuangXiang/api/headerList.json，即https://yourUserName.github.io/ReactAppName/假数据路径 解决方法1：环境变量判断不同的请求路径在axios请求路径中使用process.env.NODE_ENV判断来给予不同的请求路径，开发环境下给正常的请求路径，生产环境下给原本的请求路径前加上 仓库名，比如： 123456789101112// 开发环境下的请求地址let getUrl=\"/api/headerList.json\"; // 生产环境下的请求地址 if(process.env.NODE_ENV === 'production' )&#123; getUrl=\"/ChuangXiang/api/headerList.json\" // ChuangXiang是ReactAppName &#125;axios.get(getUrl).then((res) =&gt; &#123; const data = res.data; dispatch(changeList(data.data));&#125;).catch(() =&gt; &#123; console.log(\"error\");&#125;); 解决方法2：使用baseUrl也可以使用axios的baseURL或axios.defaults.baseURL，可参考axios文档进行配置。 后记设置后的build的请求路径就都不对了，有时间再改吧。本地运行页面正常显示，axios报错：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"vscode 函数描述快捷键","slug":"vscode 函数描述快捷键","date":"2020-09-01T13:51:50.000Z","updated":"2020-11-24T01:36:48.760Z","comments":true,"path":"2020/09/01/vscode 函数描述快捷键/","link":"","permalink":"http://yoursite.com/2020/09/01/vscode 函数描述快捷键/","excerpt":"在js文件中可对函数头部用快捷键进行函数描述","text":"在js文件中可对函数头部用快捷键进行函数描述 效果 快捷键写好函数后在函数顶部 输入`/`+回车**，依次输入函数描述、参数类型和参数描述即可 注意在js文件中可用次快捷键，html中的&lt;script&gt;内没用","categories":[{"name":"vscode使用过程中的小tips","slug":"vscode使用过程中的小tips","permalink":"http://yoursite.com/categories/vscode使用过程中的小tips/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"vscode 前端 热更新 live-server","slug":"vscode 前端 热更新 live-server","date":"2020-08-16T06:56:04.000Z","updated":"2020-11-06T07:06:01.819Z","comments":true,"path":"2020/08/16/vscode 前端 热更新 live-server/","link":"","permalink":"http://yoursite.com/2020/08/16/vscode 前端 热更新 live-server/","excerpt":"在做我的web简历的时候，为了方便的实时查看页面效果，找到了live-server这个小工具进行页面的热更新。","text":"在做我的web简历的时候，为了方便的实时查看页面效果，找到了live-server这个小工具进行页面的热更新。 live-server服务器 live-server是一个具有实时加载功能的小型服务器，可以使用它来破解html/css/javascript，但是不能用于部署最终站点。 也就是说我们可以在项目中实时用live-server作为一个实时服务器实时查看开发的网页或项目效果。 安装 首先你需要安装好nodejs（官网） 打开vscode，在项目终端输入npm install live-server -g 开启服务 在项目终端输入live-server 此时会自动打开一个127.0.0.1:8080的网页，可以看到效果 默认端口号是8080，如果想使用其他端口号可以在运行live-server的时候用--port的方式指定端口号，比如live-server --port 8001 关闭服务使用ctrl+c即可关闭服务","categories":[{"name":"vscode使用过程中的小tips","slug":"vscode使用过程中的小tips","permalink":"http://yoursite.com/categories/vscode使用过程中的小tips/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"react antd 样式覆盖（自定义样式）","slug":"react antd 样式覆盖（自定义样式）","date":"2020-08-04T07:56:04.000Z","updated":"2020-10-24T08:48:42.621Z","comments":true,"path":"2020/08/04/react antd 样式覆盖（自定义样式）/","link":"","permalink":"http://yoursite.com/2020/08/04/react antd 样式覆盖（自定义样式）/","excerpt":"自定义antd组件部分样式有几种方式可以自定义antd组件部分样式，使用Styled Components定义样式的项目可以参考方法1或者方法2，使用css文件定义样式的项目可以参考方法3。","text":"自定义antd组件部分样式有几种方式可以自定义antd组件部分样式，使用Styled Components定义样式的项目可以参考方法1或者方法2，使用css文件定义样式的项目可以参考方法3。 方法1：自定义组件包裹antd组件（Styled Components） 参考方法1：新建一个 styled-components 组件 Test 包裹在想要修改的antd组件外，然后通过从 Test 中操作其子代CSS样式对目标antd组件进行样式修改（给作为子组件的antd组件添加className）。 操作其子代CSS样式的方法可参考博客“styled-components的使用方法”中&amp;的使用方法 方法2：antd组件引用css.js中输出的自定义样式（声明样式）参考方法2：直接在存放css样式的js文件中输出样式,再在js文件中引入样式并使用即可： 123456//css.jsimport styled from 'styled-components';export const btnStyle = &#123; background:'pink'&#125; 12345678910import React from 'react';import &#123; Button &#125; from 'antd'; import &#123; btnStyle &#125; from './style'const TodoListUI = (props) =&gt; &#123; return ( &lt;Button style=&#123;btnStyle&#125;type=\"danger\" onClick=&#123;props.handleBtnClick&#125;&gt;提交&lt;/Button&gt; )&#125;export default TodoListUI; 方法3：antd组件内联css样式（行内样式）如下方例子展示 原因原本的项目中，我是自定义组件Header的，后来想用antd来做响应式，Header的外层组件HeaderWrapper就被改成了antd提供的Row，虽然antd提供的Header组件可以实现固定位置，但它自带默认样式，而我想继续沿用自己的Header组件的样式，所以就打算在header/index.js中单独给Row一个自定义样式实现固定位置并显示在最上层 原本的自定义组件的样式header/style.js： 123456789import styled from \"styled-components\";import LogoPic from \"../../statics/logo.png\";export const HeaderWrapper = styled.div` z-index: 1; position:relative; height:56px; border-bottom:1px solid #f0f0f0;`; 使用antd后给Row单独定义部分样式（行内样式）header/index.js： 1&lt;Row style=&#123;&#123; position:\"relative\",zIndex: 1,height:\"56px\",borderBottom:\"1px solid #f0f0f0\" &#125;&#125;&gt; 补充：react中css的定义方法 注意：行内样式和声明样式中，样式名都是驼峰命名法，值需要引号。而Styled Components的模板字符串内使用的与原生CSS是一样的。 参考 行内样式 如上所示，在antd提供的组件中可使用style={{ ...}}来自定义样式，最外层{}表示是一个js表达式，里面的{}表示是一个js对象 注意： ;与,的转变、react中css样式名采用驼峰命名法 、值 需要引号 声明样式声明样式其实是行内样式的一种改进写法，在render函数外部创建style对象，然后传递给组件： 123456789101112131415161718192021222324class App extends React.Component &#123; //... const style1=&#123; background:'#eee', width:'200px', height:'200px' &#125; const style2=&#123; color:'red', fontSize:'40px' &#125; render() &#123; return ( &lt;div style=&#123;style1&#125;&gt; &lt;p style= &#123;style2&#125;&gt;行内样式&lt;/p&gt; &lt;/div&gt; ) &#125;&#125; CSS Modules可参考阮一峰的CSS Modules Styled ComponentsStyled Component是react的一个第三方库，是CSS in JS 的优秀实践和代表，将CSS写在JS中，可以实现常规CSS所不好处理的逻辑复杂、函数方法、复用、避免干扰。样式书写将直接依附在JSX上面，HTML、CSS、JS三者再次内聚，同时也实现H5的语义化标签表现形式。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"警醒！慎用`+`与字符串和对象","slug":"警醒！慎用`+`与字符串和对象","date":"2020-07-21T10:13:56.000Z","updated":"2020-10-21T10:19:12.099Z","comments":true,"path":"2020/07/21/警醒！慎用`+`与字符串和对象/","link":"","permalink":"http://yoursite.com/2020/07/21/警醒！慎用`+`与字符串和对象/","excerpt":"问题描述我有一个数组对象，每个数组元素都是含有多属性的对象，当我尝试使用其中的数组元素的属性时发现无法获知属性值，但是后来发现是因为我在打印语句中使用+连接了对象与字符串，导致结果永远都是字符串，对象显示[object object]，试图获取属性则报错显示未定义","text":"问题描述我有一个数组对象，每个数组元素都是含有多属性的对象，当我尝试使用其中的数组元素的属性时发现无法获知属性值，但是后来发现是因为我在打印语句中使用+连接了对象与字符串，导致结果永远都是字符串，对象显示[object object]，试图获取属性则报错显示未定义 代码描述writerList即list，为immutable数组，newList和pageList为普通js数组，newList内容与writerList一致： 警醒希望自己以后还是别用+来打印了，太伤了，查了半天想不明白，结果问题出在这里……","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"antd使用gutter导致滚动条的产生","slug":"antd使用gutter导致滚动条的产生","date":"2020-06-18T10:26:00.000Z","updated":"2020-10-18T10:30:11.897Z","comments":true,"path":"2020/06/18/antd使用gutter导致滚动条的产生/","link":"","permalink":"http://yoursite.com/2020/06/18/antd使用gutter导致滚动条的产生/","excerpt":"问题描述在react项目中使用Row的gutter属性设置间隔时导致横向滚动条的产生","text":"问题描述在react项目中使用Row的gutter属性设置间隔时导致横向滚动条的产生 解决方法在css中增加以下代码来覆盖以解决宽度增加的部分： 123456789101112.ant-row &#123; margin-right: 0 !important; margin-left: 0 !important;&#125;.ant-col:first-child &#123; padding-left: 0 !important;&#125;.ant-col:last-child &#123; padding-right: 0 !important;&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"CSS 图片固定大小显示（裁剪 不变形）","slug":"CSS 图片固定大小显示（裁剪 不变形）","date":"2020-06-09T07:30:20.000Z","updated":"2020-10-09T09:02:08.346Z","comments":true,"path":"2020/06/09/CSS 图片固定大小显示（裁剪 不变形）/","link":"","permalink":"http://yoursite.com/2020/06/09/CSS 图片固定大小显示（裁剪 不变形）/","excerpt":"起因假设后端返回的图片是不同尺寸的，那么我希望页面上显示的统一尺寸但不变形的图片，可以使用img标签+css的object-fit属性来实现。","text":"起因假设后端返回的图片是不同尺寸的，那么我希望页面上显示的统一尺寸但不变形的图片，可以使用img标签+css的object-fit属性来实现。 img标签 object-fit属性 object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度，一般用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。 可以通过使用 object-position 属性来切换被替换元素的内容对象在元素框内的对齐方式。 更多属性值可参考菜鸟教程 例子： 同样效果：background-size属性 可参考笔记百度前端技术学院 第四天学习笔记（1）（CSS背景），效果可参考菜鸟教程 属性值cover与contain相同之处 他们都会对图片进行等比缩放 区别 cover属性值： 缩放背景图片以完全 覆盖 背景区，可能背景图片部分看不见。 该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被 裁剪。 contain属性值： 保证图片始终 完整 的显示在背景区域，不裁剪图片 缩放背景图片以完全 装入 背景区，可能背景区部分空白。 该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"ES6 Symbol","slug":"ES6 Symbol","date":"2020-06-04T08:53:14.000Z","updated":"2020-11-04T08:58:57.052Z","comments":true,"path":"2020/06/04/ES6 Symbol/","link":"","permalink":"http://yoursite.com/2020/06/04/ES6 Symbol/","excerpt":"ES6规范引入了原始数据类型：Symbol","text":"ES6规范引入了原始数据类型：Symbol 基本（原始）、复杂与全局数据类型 基本数据类型（原始值）（记忆：NNUSB=&gt;纳尼USB）：Number，Null，Undefined，String，Boolean。 es6添加了一种新的原始数据类型：Symbol。所以现在 js的原始数据类型有6种。 复杂数据类型（对象值）：Object，Array，Function，RegExp，Date，Error 全局数据类型：Math Symbol Symbol 生成一个全局唯一的值。 Symbol 可以创建一个独一无二的值（但并不是字符串） 可参考知乎，上面的例子生动易懂。 详细语法等信息可参考MDN","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"hexo deploy中报错：Nunjucks Error","slug":"hexo deploy中报错_Nunjucks Error","date":"2020-05-21T07:34:12.000Z","updated":"2020-10-06T07:58:51.851Z","comments":true,"path":"2020/05/21/hexo deploy中报错_Nunjucks Error/","link":"","permalink":"http://yoursite.com/2020/05/21/hexo deploy中报错_Nunjucks Error/","excerpt":"第一次遇到的问题问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。","text":"第一次遇到的问题问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。 回到 git bush 中发现报错。 报错分析 deploy 过程中 git bush 中提到了： Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error: [Line 51, Column 169] unexpected token: }} 根据提示进入网址https://hexo.io/docs/troubleshooting.html去寻找问题，善用`Ctrl+F`+Nunjucks （Error关键词）找到问题所在。 找到问题我的markdown中的出现了会被hexo解析的符号： 解决问题也就是说，Hexo使用Nunjucks来渲染文章(在旧版本中使用了Swig，它们共享相似的语法)。使用{{}}或{% %} 包装的内容将被解析，并可能导致问题。您可以使用raw标签插件包装敏感内容（如下所示，raw标签将不会被展示出来）。或者使用单引号/三引号包裹他们来跳过解析。 123&#123;% raw %&#125;你好呀这里是你原来想要书写的内容 &#123;&#123; 敏感的内容需要使用这种方式被包装起来哦 &#125;&#125;&#123;% endraw %&#125; 新问题问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。回到 git bush 中发现报错。 报错分析 deploy 过程中 git bush 中提到了： Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlNunjucks Error: [Line 14, Column 40] expected name as lookup value, got 和之前遇到的问题类似但又有所不同 找到问题还是文章中的出现了会被hexo解析的符号{{ ... }}，但是这次我是使用了单引号的，依旧报错。官网说可以使用。 解决方法还是使用raw标签包裹吧，效果很好","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"antd 定制主题","slug":"antd 定制主题","date":"2020-05-15T10:05:17.000Z","updated":"2020-10-01T03:21:12.680Z","comments":true,"path":"2020/05/15/antd 定制主题/","link":"","permalink":"http://yoursite.com/2020/05/15/antd 定制主题/","excerpt":"定制理由原本的antd默认主题不符合我的项目主题，想一次性改很多默认样式。由于antd的文档中提到很多颜色时通过算法来实现的，所以一个个修改不科学，所以我打算直接修改主题色，让他跟着算法生成其他颜色。","text":"定制理由原本的antd默认主题不符合我的项目主题，想一次性改很多默认样式。由于antd的文档中提到很多颜色时通过算法来实现的，所以一个个修改不科学，所以我打算直接修改主题色，让他跟着算法生成其他颜色。 参考文档 可供修改的样式：Ant Design 的样式变量 修改步骤：在 create-react-app 中定制主题 每次修改后都需重启 yarn start才能看到效果 注意原本Redux入门（1）中提到的“antd使用方法”里的“引入样式”在这要去掉，官方文档在定制主题中App.less中已经进行了相关的引入：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React面试题","slug":"React面试题","date":"2020-05-08T09:36:56.000Z","updated":"2020-11-25T17:56:43.974Z","comments":true,"path":"2020/05/08/React面试题/","link":"","permalink":"http://yoursite.com/2020/05/08/React面试题/","excerpt":"自己搜集的面试题以及 慕课 前端框架及项目面试 聚焦VueReactWebpack 第九章 React 面试题","text":"自己搜集的面试题以及 慕课 前端框架及项目面试 聚焦VueReactWebpack 第九章 React 面试题 什么是react 单页面应用 组件设计模式 声明式编程、函数式编程 虚拟DOM 声明式编程 vs 命令式编程 不同于原生 JS 的 命令式开发 ， React 是声名式开发（函数式编程）。 命令式开发 更关注 DOM 的每一步挂载，而 声名式开发 更在意数据的改变，只操作 数据，不关心 具体要如何 操作 DOM，改变数据以后 React 会自动帮你完成 DOM 挂载等步骤。 函数式编程 函数式编程是声明式编程的一部分，你可以像保存变量一样在应用程序中保存、检索和传递这些函数。 核心概念： 纯函数 不可变值：在函数式编程中，你无法更改数据，也不能更改。 如果要改变或更改数据，则必须复制数据副本来更改。（数组中可以使用concat/slice，他们不修改原数组） 什么是纯函数 给定固定的输入，就一定会有固定的输出，没有副作用（即不会偷偷修改其他值，需要修改谁就拷贝出来修改），纯函数不能涉及 异步 或者是关于 时间 的操作，一旦函数中涉及 AJAX请求、new Date()、setTimeout() ,他就 不是纯函数。 要求reducer是纯函数 重点：不可变值，需要修改谁就拷贝出来修改 如arr1=arr.slice() 虚拟DOM及其工作原理 React原理“虚拟dom和diff算法” 组件之间如何通讯 父子组件props： 父组件向子组件传值/函数：在父组件中调用子组件的同时通过给子组件添加属性的方式向子组件传值/函数，注意如要传递函数，则需在父组件构造函数中使用bind绑定该函数this指向 子组件使用父组件传递的值/函数：通过{this.props.属性名/函数名}来调用 子组件修改父组件中数据的方法：子组件通过调用父组件传递过来的函数间接的操作父组件的数据 非嵌套组件间: 兄弟组件通信:找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信 自定义事件（event模块)：发布者（组件1）发布自定义事件，订阅者（组件2）监听事件并做出反应,我们可以通过引入event模块进行通信(例子) redux:利用redux等全局状态（数据）管理工具进行通信,这种工具会维护一个全局状态（数据）中心Store,并根据不同的事件产生新的状态（数据） context：用props太繁琐，用redux小题大做时可使用，context 相当于一个全局变量，是一个大容器，我们可以把要通信的内容放在这个容器中，这样一来，不管嵌套有多深，都可以随意取用。（复杂的公共信息还是要使用redux） 父组件做context生产方，创建context对象，并使用context对象的Provider包裹子组件给子组件获取context的能力 子组件做context消费方，可以获取到父组件中传递的context。 class子组件 直接使用this.context可获取最近的父组件设置的context 函数子组件 由于没有实例导致没有this，所以可以通过context对象的Consumer标签包裹的函数获取context JSX的本质 JSX是javascript的语法扩展。它就像一个拥有javascript全部功能的模板语言。在SX中结合了javascript和HTML，生成可在DOM中呈现的react元素。 JSX的本质就是React.creatElement()： 参数1：组件/html标签（大小写区分） 参数2：属性 参数3：子元素 React.creatElement()执行生成vnode（虚拟DOM） props，state与render函数的关系 React高级内容(1)”props，state与render函数的关系” 每当组件的state或者props发生改变时，render函数就会重新执行。 当父组件的render函数被运行时，它的子组件的render都将被重新运行一次。(不管子组件是否需要更新) 补充： props是只读属性 在构造函数中定义状态值（state） setState场景题（同步与异步，合并）React的batchUpdate机制导致setState同步异步的情况:在合成事件和钩子函数中是“异步”的在原生DOM事件和setTimeout 中都是同步的 setState异步更新前合并/不合并：setState中传入对象，会被合并，多个setState只执行一次setState中传入函数，不会被合并，多个setState执行多次 组件生命周期 被React16弃用并需要替代的函数们： componentWillMount → UNSAFE_componentWillMount componentWillReceiveProps → UNSAFE_componentWillReceiveProps componentWillUpdate → UNSAFE_componentWillUpdate 单组件生命周期：如上图 父子组件生命周期： 首次挂载：相反，卸载的时候父节点先被移除，再从上至下依次触发子组件的卸载钩子 子组件主动更新state数据： 子组件被动更新：父组件通过props把自己的state传递给子组件。不管父组件有没有把数据传递给子组件，只要父组件setState，都会走一遍子组件的更新周期。而且子组件被动更新会比主动更新所执行的流程多出来一个componentWillReceiveProps 方法。（可以使用react提供的PureComponent来规定只有和本组件有关的数据更新时，本组件的render函数才执行，避免不必要的更新渲染） 注意SCU位置 React高级内容（2）“React 的 生命周期函数” shouldComponentUpdate用途 性能优化 配合“不可变值”一起使用，否则会出错 PureComponent 实现了浅比较的shouldComponentUpdate 需要结合不可变值（immutable）使用 优化性能，规定只有和本组件有关的数据更新时，本组件的render函数才执行，避免不必要的更新渲染 react发起ajax的位置放在componentDidMount上，要在DOM元素渲染结束才发起ajax 渲染列表为何使用key 必须使用key，且不能是index/random，必须是稳定的。（数组下标index是会因为列表的变化而发生改变的，他是不稳定的） 因为diff算法中通过tag和key来判断是否是同一个虚拟DOM 使用key可以帮助减少渲染次数，提升渲染性能 大多数情况下，使用唯一id作为子组件的key是不会有任何问题的 函数组件和class组件 函数组件（无状态函数组件）： 纯函数，输入props，输出JSX 没有实例，没有this，没有生命周期，没有state 不能扩展其他方法 但是，React版本16.8中的新功能hooks出现以后给函数组件提供了钩子来实现类组件可做的事情（比如useState()用于为函数组件引入状态（state）） 类组件（有状态组件）： 具有状态（state），可通过 setState()方法更改组件的状态 具有生命周期和this 受控组件与非受控组件 受控组件： 受控组件是在 React 中处理输入表单的一种技术。 组件的值（value/checked）受到state的控制（即state变化时组件值变化） 需要自行监听onChange时间来更新state（todolist例子） 常见的受控组件：input组件（checkbox、radio）、textarea组件 非受控组件： 组件值（比如：input的defaultValue属性）不受state控制，只是使用state给组件赋予了初始值，由于赋予初始值以后组件值就和state无关了，所以后面想获取 组件值 就只能 通过ref获取DOM元素 的值的方式来操作了 使用场景：由于非受控组件需要搭配ref去操作DOM来获取值，所以按照react设计初衷是不推荐使用的，但是特殊时候只能使用 非受控组件，比如： 必须手动操作DOM元素，setState实现不了的时候 文件上传必须使用非受控组件来获取上传的文件（DOM.files[0]）&lt;input type=file&gt; 某些富文本编辑器，需要传入DOM元素（做加粗、加下划线等操作 ） 受控组件vs非受控组件：优先使用受控组件，这样符合React设计原则。必须操作DOM时，再使用非受控组件。 异步组件（懒加载） React知识点汇总（高级特性）”异步组件（懒加载）” 使用场景：组件比较大 或者需要 懒加载 时，我们可以使用 异步组件来做（性能优化） react中可用React.lazy+React.Suspense或者使用react-loadable模块实现异步组件 容器组件和高阶组件 容器组件：容器组件是处理获取数据、订阅 redux 存储等的组件。它们包含UI组件（无状态组件）和其他容器组件，但是里面从来没有html。 高阶组件: 高阶组件 是一个函数，这个函数接受一个组件A，在函数内创建组件B将组件A包裹并给他逻辑，最后返回组件B。 高阶组件负责公共逻辑，传入的组件 传出后 生成的新组件 就会带上这部分逻辑 react-redux connect就是高阶组件 定义高阶组件时 需要向 传入的组件 传递自己的所有props（包括别人传过来的），这样传入的组件才能获取使用 多个组件的公共逻辑，如何抽离 React知识点汇总（高级特性）”组件公共逻辑的抽离” 高阶组件HOC:模式简单，但会增加组件层级（需要考虑透传props以及是否会被覆盖的问题） render props:代码简洁，学习成本较高 区别： 高阶组件 是高阶组件（负责公共逻辑）包含组件A（负责渲染）（即 逻辑包含渲染） render props 是 组件A包含class组件，class组件（负责公共逻辑）中包含函数组件（负责渲染）（即 3层，组件A包含逻辑包含渲染）。 mixin已被react废弃 PropTypes与DefaultProps React高级内容(1)“PropTypes与DefaultProps的应用” PropTypes 强校验： 子组件在接受父组件传过来的值（即 属性 ）时进行强校验。他可以要求父组件给子组件传的值是什么类型的。如若不是也并不会报错，只会在 开发者工具 中给出警告。 isRequired强制传值:可以强制要求父组件向子组件传递某个值，如果父组件并未传值就会报出 警告 。 DefaultProps 设置默认值: 当父组件没有向子组件传递某个值，而子组件使用了该值时，可以在子组件中设置DefaultProps来规定该值的默认值。 redux单向数据流 redux如何进行异步请求 使用异步action，可通过中间件redux-thunk/redux-sagas使action。。 React事件和DOM事件的区别 React事件（SyntheticEvent）是挂载在document上的，而DOM事件（event）绑定在DOM上面的 react的event不是原生的，是react封装的SyntheticEvent 合成事件对象，模拟出了 DOM 事件对象 所有的能力。event.nativeEvent 才是原生事件对象。 div上绑定的事件被触发后冒泡到顶层document上，react中所有事件都绑定在document上 react会实例化成统一的react合成事件（SyntheticEvent合成事件）再进行事件派发（通过target知道谁触发了事件以后就派发给他进行事件处理）将event对象交给对应的处理器执行 react的合成事件机制作用： 更好的兼容性和跨平台 所有事件都挂载在document上，减少内存消耗，避免频繁解绑 单一标签移除时不需要解绑事件，因为事件都挂载在document上 方便事件的统一管理（如事务机制） react性能优化 渲染列表时加key（diff算法加快比对速度） 自定义事件、DOM事件及时销毁（ComponentwillUnmount） react事件是挂载在document上的，所以不需要我们进行手动销毁 合理使用异步组件(React.lazy+React.Suspense或者react-loadable模块) 使用react提供的PureComponent来规定只有和本组件有关的数据更新时，本组件的render函数才执行，避免不必要的更新渲染 函数组件使用 React.memo 记得搭配immutable.js不可变值 constructor中绑定事件函数this，减少bind次数 前端通用的性能优化，如图片懒加载 webpack层面的优化（webpack在production环境下进行打包时，就会自动压缩代码至1/3的大小，在浏览器上进行反解析再进行渲染。） 使用SSR服务器端渲染，不需要通过ajax发送请求，减少请求次数达到性能优化，这个需要额外设置。 超越继承的组合 在React中，我们总是使用组合而不是继承。 组合 是一种结合简单的可重用函数来生成高阶组件的技术。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React原理","slug":"React原理","date":"2020-05-06T12:17:40.000Z","updated":"2020-11-24T19:04:56.342Z","comments":true,"path":"2020/05/06/React原理/","link":"","permalink":"http://yoursite.com/2020/05/06/React原理/","excerpt":"慕课 前端框架及项目面试 聚焦VueReactWebpack 第八章 React 原理","text":"慕课 前端框架及项目面试 聚焦VueReactWebpack 第八章 React 原理 函数式编程（不可变值） 函数式编程是一种编程范式（面向对象也是一种编程范式），概念比较多 函数式编程 重点： 纯函数：给定固定的输入，就一定会有固定的输出，且不能对传入的参数进行修改。纯函数不能涉及 异步 或者是关于 时间 的操作，一旦函数中涉及 AJAX请求、new Date()、setTimeout() ,他就 不是纯函数。要求reducer是纯函数 不可变值：不管是setState还是redux创建action时，都必须使用不可变值。 好处：给前端自动化测试带来很大便捷性。只需要给函数一个输入值，看看函数输出的时候符合预期即可。 整个Redux都是函数式编程的范式，要求reducer是纯函数也是自然而然的事情，使用纯函数才能保证相同的输入得到相同的输入，保证状态的可预测。 虚拟dom和diff算法 虚拟dom和diff算法是实现React的核心技术 虚拟DOMvue和react实现vdom细节不同，但核心概念和实现思路是一样的。 出现原因 DOM操作非常消耗性能，以前使用原生js可以自己控制DOM操作的时机来进行性能优化（缓存DOM操作，合并DOM操作），react是数据驱动视图，不会直接操作DOM，想有效控制DOM操作提升性能就依靠虚拟DOM。 虚拟DOM 就是一个JS对象，用它来描述 真实的DOM。把DOM计算更多的转为js（虚拟DOM）计算（js执行速度很快），计算出最小的变更后再操作DOM（计算过程就是diff算法）。React对性能的提升在于减少了 真实DOM对象 的生成与比较，取而代之的是使用 虚拟DOM(JS对象) 来完成数据改变后的生成与比较。而用JS形成一个 JS对象 性能损耗非常小，生成一个 DOM元素 性能损耗大能。（React中的虚拟DOM） js对象模拟DOM结构js对象的结构主要包含三部分：标签名、属性、子元素，具体命名可能有所不同，但结构都这样 diff算法 diff算法是虚拟DOM中最核心的部分，虚拟DOM的比对就是通过diff算法 diff算法能在日常使用react中体现出来（如key） diff是一个广泛的概念，和组件化一样，她不是react独创的，如linux diff命令、git diff等 两棵树做diff，两个js对象也可以做diff diff算法 优化时间复杂度： 只比较同一层级，不跨级比较逐层比对，如果第一层就不同，react就不会往下比对，而是直接使用 新的虚拟DOM 去生成真实的DOM。虽然可能会造成DOM节点渲染的浪费，但同层比对的算法简单，效率快，大大减少了两个虚拟DOM之间比对的性能消耗。 tag不相同，则直接删掉重建，不再深度比较 tag和key两者都相同，则认为是相同节点，不再深度比较在React中我们会根据key值给 虚拟DOM 命名，数据修改后 新的 虚拟DOM 就会根据key值和 原始的 虚拟DOM 进行快速比对，多出来的就是修改的DOM。这会大大提升性能。（所以key值需要是稳定的，可变的key值也就失去了它存在的意义） JSX的本质 JSX编译出来是什么本质就是什么 babel官网的“试一试”可以直接看到JSX编译的结果：遇到组件会继续拆分组件的jsx结构： 总结：JSX编译出来 JSX的本质就是React.creatElement()： 参数1：组件/html标签（大小写区分） 参数2：属性 参数3：子元素 React.creatElement()执行生成vnode（虚拟DOM） React的合成事件机制 react中所有事件（SyntheticEvent）挂载在document上，而原生的事件（event）是绑定到DOM上面的 react的event不是原生的，是react封装的SyntheticEvent合成事件对象，模拟出了 DOM 事件对象 所有的能力。event.nativeEvent 才是原生事件对象 react事件 和 DOM 事件不一样，和 Vue 事件也不一样 合成事件机制： div上绑定的事件被触发后冒泡到顶层document上，react中所有事件都绑定在document上 react会实例化成统一的react合成事件（SyntheticEvent合成事件）再进行事件派发（通过target知道谁触发了事件以后就派发给他进行事件处理）将event对象交给对应的处理器执行 为什么需要合成事件机制 更好的兼容性和跨平台 所有事件都挂载在document上，减少内存消耗，避免频繁解绑 单一标签移除时不需要解绑事件，因为事件都挂载在document上 方便事件的统一管理（如事务机制） React的batchUpdate机制 setState 可能是异步/同步更新，在合成事件和钩子函数中是“异步”的，在原生DOM事件和setTimeout 中都是同步的。 setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步” 可以通过setState第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果(同步）。 setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。 setState异步更新前合并/不合并： setState中传入对象，会被合并，多个setState只执行一次 setState中传入函数，不会被合并，多个setState执行多次 setState主流程 batchUpdate机制setState异步或同步 主要看能否命中batchUpdate机制（通过isBatchingUpadates判断）注意：实际上isBatchingUpadates是在入口定义的，不是在函数里，上图只是演示方便 能命中batchUpdate机制的入口react可以“管理”的入口：生命周期（和他调用的函数）react中注册的事件（合成事件）（和他调用的函数） 不能命中batchUpdate机制的入口react“管不到”的入口：setTimeout setInterval等（和他调用的函数）自定义的DOM事件（和他调用的函数） transaction（事务）机制 React组件渲染和更新的过程组件渲染过程 state数据+render()中解析JSX结构(creatElement函数)生成虚拟DOM 用 虚拟DOM 生成 真实的DOM ，显示在页面上 组件更新过程 state 数据 发生改变 数据 + JSX模版 结合，生成 新的 虚拟的DOM 比较 原始虚拟DOM 和 新的虚拟DOM 的区别（diff算法，纯js计算），找到区别 直接操作有区别的DOM（将diff结果渲染DOM） React-fiber如何优化性能 React-fiber是React内部运行机制(是一种基于浏览器的单线程调度算法)，开发者体会不到 了解背景和基本概念即可 组件更新过程中，diff算法计算了虚拟DOM的区别以后才进行页面渲染，而JS是单线程，且和DOM渲染共用一个线程。当组件足够复杂，组件更新时计算和渲染都压力大，同时再有DOM操作需求（动画，鼠标拖拽等），将卡顿。 React-fiber就是解决卡顿的方法。它将递归diff算法比对虚拟DOM这个阶段进行任务拆分（DOM渲染阶段无法拆分），DOM需要渲染时暂停，空闲时恢复（window.requestIdleCallback） 前端路由React-router使用 路由模式（hash、H5 history）、知乎 hash特点： hash变化会触发网页跳转，即浏览器的前进、后退、跳转 hash变化不会刷新页面，单页面应用必需的特点 hash永远不会提交到server端（前端自生自灭） history特点： 页面和浏览器的history保持一致 需要后端支持 react-router-dom是应用程序中路由的库。React库中没有路由功能，需要单独安装react-router-dom。它提供两个路由器 BrowserRouter和HashRouter。 BrowserRouter，这是对Router接口的实现。使得页面和浏览器的history保持一致。等于：window.location。http://127.0.0.1:3000/user/type HashRouter，和上面的一样，只是使用的是url的hash部分，等于：window.location.hash。http://127.0.0.1:3000/#/user/type不一定是这样，但#是少不了的） 如果你使用的是一个非静态的站点、要处理各种不同的url那么你就需要使用BrowserRouter。 相反的如果你的server只处理静态的url，那么就使用HashRouter。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"HTML CSS 面试题","slug":"HTML CSS 面试题","date":"2020-05-03T12:24:15.000Z","updated":"2020-11-21T12:28:58.435Z","comments":true,"path":"2020/05/03/HTML CSS 面试题/","link":"","permalink":"http://yoursite.com/2020/05/03/HTML CSS 面试题/","excerpt":"慕课 快速搞定前端技术一面 第三章 笔记","text":"慕课 快速搞定前端技术一面 第三章 笔记 HTML如何理解HTML语义化 让人更容易读懂（增加代码可读性） 让搜索引擎更容易读懂（SEO） 默认下的块级元素/内联元素 问题：默认情况下，哪些HTML标签是块级元素/内联元素 display：block/table；有div h1 h2 table ul ol p等 display：inline/inline-block；有span img input button等 CSS布局盒模型宽度（offsetWidth）计算 offsetWidth包含元素的边框(border)、水平线上的内边距(padding)、竖直方向滚动条(scrollbar)（如果存在的话）、以及CSS设置的宽度(width)的值，不包括外边距。 问题： 错误答案:100+10+1=111px 注意内边距和border是2份！1+10+100+10+1=122px 补充问题：如果让offsetWidth等于100px，该如何做？ 答案：设置CSS3属性box-sizing为border-box，这样100px的width就包含了padding、border和width了，在这offsetWidth=padding（20）+border（2）+内容的width（会自动缩小为78）=width（100px） （块之间的）margin纵向重叠的问题 相邻块元素的margin-top和margin-bottom会发生重叠（只发生在块之间，所以只涉及纵向，inline-block之间不存在margin重叠） 注意：空白内容的&lt;p&gt;&lt;/p&gt;也会重叠 问题： 错误答案：15*4=60px 答案：15px margin负值的问题 问题：对margin的top left right bottom设置负值，有何效果？ 答案： margin-top和margin-left负值，元素向上、向左移动 margin-right负值，自身不受影响，右侧元素左移 margin-bottom负值，自身不受影响，下方元素上移 BFC理解和应用 问题：什么是BFC 答案： Block format context 块级格式化上下文，是一块独立渲染区域，内部元素的渲染不会影响边界以外的元素 问题：形成BFC的常见条件 答案： float不是none position是absolute或fixed overflow不是visible display是flex、inline-block等 建议使用display:flow-root产生无副作用的BFC 注意：块级元素不算BFC！！ 问题：常见应用 答案：清除浮动，将浮动元素的父元素设置为BFC 更多可参考“BFC与浮动” float布局实现圣杯布局和双飞翼布局 圣杯布局和双飞翼布局的目的： 三栏布局，中间一栏最先加载和渲染（内容最重要） 两侧内容固定，中间内容随着宽度自适应 一般用于PC网页 圣杯布局和双飞翼布局的技术总结（只要是达到这3个要点，细节不同无所谓）： 中间3栏都使用float布局，中间一栏100%宽度放最前面 两侧都是使用margin负值，以便和中间内容横向重叠（同一行） 防止中间内容被两侧覆盖，圣杯用padding，双飞翼用margin 圣杯用3栏的父元素设置padding往中间挤+左右往2边分开 双飞翼用3栏中间盒子main内增加一个内层div（main-inner）设置margin空出左右两栏位置 具体代码实现 手写clearfix12345.clearfix::after&#123; content:\"\"; display:table; clear:both;&#125; 参考“百度前端技术学院 第五天学习笔记 （CSS浮动）”的“清除浮动-clear-属性” flex布局 可参考“百度前端技术学院 第七天学习笔记（CSS flexbox）” 基础语法回顾： 父容器中： flex-flow简写flex-direction和flex-wrap属性 flex-direction规定子项排列方式及方向 flex-wrap规定溢出子项是否换行/如何换行（默认不换行） justify-content定义子项沿主轴的对齐方式 align-items定义子项在交叉轴上的对齐方式 align-content定义行沿交叉轴的对齐方式 子项中： align-self调整单个子项在交叉轴上的对齐方式（对应父容器的align-items） order顺序 flex简写flex-grow、flex-shrink和flex-basis flex-grow子项空间占比（放大比例），默认为0(即如果存在剩余空间，也不放大)，不能为负数。 flex-shrink弹性收缩（缩小比例），默认为1（即如果空间不足，该项目将缩小），不能为负数。如果是0，则空间不足子项也不缩小 flex-basis子项初始大小（最小值），规定在主轴方向上的初始大小 画色子3点面 注意：E:nth-child(n) 选择器（CSS3）匹配E元素的父元素中的第 n 个子元素E（假设该子元素不是E，则选择符无效） 定位absolute和relative分别依据什么定位 relative依据自身定位 absolute依据最近一层的定位元素定位 定为元素：absolute、relative、fixed、body 居中对齐 水平居中： inline元素：text-align：center block元素（子元素宽度未知时）：margin：auto absolute元素：left：50%+ margin-left负值/transform: translateX(-50%);（父元素宽度未知时） 垂直居中： inline元素：line-height的值等于height值 absolute元素：top：50%+ margin-top负值/transform: translateY(-50%);（子元素高度未知时） 水平垂直居中：（前提是父元素高度确定） absolute元素（子元素宽高未知时）：top：50% + left：50% + transform:translate（-50%，-50%） absolute元素（子元素宽高未知时）：top，left，bottom，right= 0 + margin：auto 让绝对定位元素上下左右都等于0，再通过设置元素的margin自动填充达到居中效果 图文样式 line-height的继承问题 知识点：如何继承取决于父元素的line-height的单位 具体数值，如30px，则直接继承该数值（子元素的line-height=父元素的line-height） 比例，如2/1.5，则直接继承该比例（子元素的line-height=子元素的font-size*父元素的line-height比例） 百分比，如200%，则继承计算出来的值（子元素的line-height=父元素的font-size*父元素的line-height百分比） 问题： 答案：20px*200%=40px 响应式rem、em、px rem是一个相对长度单位，相对于根元素（&lt;html&gt;）的font-size，常用于响应式布局 px是绝对长度单位，最常用 em是相对长度单位，相对于父元素的font-size，不常用 响应式布局的常用方案media-query搭配rem：media-query根据不同的屏幕宽度来设置根元素font-sizerem基于根元素的相对单位 vw/vh rem的弊端：“阶梯性”，从上面“响应式布局的常用方案”例子中可以看到布局分为3个“阶梯”，一段一段的布局，vw/vh可以解决这个问题 网页视口尺寸：（高度为例，宽度相似） window.screen.height//屏幕高度（和手机型号有关系） window.innerHeight//网页视口高度 document.body.clientHeight//body高度 vw：网页视口宽度的1/100 vh：网页视口高度的1/100 vmax：取两者（vw/vh）的最大值 vmin：取两者（vw/vh）的最小值 CSS3 动画 可参考“CSS动画”","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"react start报错 Can't resolve '@babel/runtime/helpers/esm/createSuper'","slug":"react start报错 Can't resolve","date":"2020-05-01T07:50:27.000Z","updated":"2020-09-29T07:51:51.890Z","comments":true,"path":"2020/05/01/react start报错 Can't resolve/","link":"","permalink":"http://yoursite.com/2020/05/01/react start报错 Can't resolve/","excerpt":"问题描述react项目进行npm start后报错如下，无法正常显示页面： Module not found: Can’t resolve ‘@babel/runtime/helpers/esm/createSuper’ in ‘E:\\jianshu\\jianshu\\node_modules\\rc-field-form\\es’","text":"问题描述react项目进行npm start后报错如下，无法正常显示页面： Module not found: Can’t resolve ‘@babel/runtime/helpers/esm/createSuper’ in ‘E:\\jianshu\\jianshu\\node_modules\\rc-field-form\\es’ 查找@babel/runtime/helpers/esm下发现没有createSuper 解决方法重新安装babel： 1npm install --save-dev @babel/core @babel/cli 根据提示添加createSuper： 1yarn add @babel/runtime/helpers/esm/createSuper 根据提示依次执行以下命令： 12yarn upgradeyarn install 页面正常显示","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Bootstrap4","slug":"Bootstrap4","date":"2020-04-19T04:54:45.000Z","updated":"2020-08-24T01:42:45.541Z","comments":true,"path":"2020/04/19/Bootstrap4/","link":"","permalink":"http://yoursite.com/2020/04/19/Bootstrap4/","excerpt":"不翻墙可参考菜鸟教程","text":"不翻墙可参考菜鸟教程 安装使用 可使用CDN/官网下载 Bootstrap4 资源库/使用npm安装 网格系统 分成12列，通过.col-*-*类设置，此处涉及响应式布局 第一个星号*可以是 sm、md、lg、xl，表示屏幕设备类型，第二个星号*可以是 1 到 12 的数字。 注意： 每一行的父容器：网格每一行需要放在设置了 .container(固定宽度) 或 .container-fluid (全屏宽度) 类的容器中，这样就可以自动设置一些外边距与内边距。 偏移列：通过 offset-*-* 类来设置。 第一个星号*可以是 sm、md、lg、xl，表示屏幕设备类型，第二个星号*可以是 1 到 11 的数字。 这些类会把一个列的 左外边距（margin） 增加 * 列，其中 * 范围是从 1 到 11。 例子：.offset-md-4 是把.col-md-4 往右移了四列格： 面试题Bootstrap的优缺点 优点：CSS代码结构合理，有现成的样式可以直接用 缺点：定制较为繁琐，体积大 Bootstrap如何实现响应式布局 原理：通过media query设置不同分辨率的class，当分辨率不同时调用不同的class 使用：为不同分辨率选择不同的网格class Bootstrap定制方法 使用CSS同名类覆盖 需要一起修改的东西很多，不推荐 比如像修改按钮的颜色，同时还需要我们修改按钮的hover颜色、边框颜色等，很麻烦，这些其实是bootstrap通过 修改源码重新构建 方便，源码中将很多逻辑缩减为变量，只需改变一个变量就能改变一系列的样式 但要求较高，需要了解源码（bootstrap4是scss文件）和构建方式 比如：想要修改按钮的一系列颜色+输入框的颜色只需要修改主体色即可 引用scss源文件 修改变量 要求更高，需要清除了解bootstrap4的源码各个模块是做什么的 在自己的sass文件中将源码引进做mixin，项目中引入自己的sass文件（可参考“CSS预处理器（less与sass）mixin复用css代码”）","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"前端面试题目（2）","slug":"前端面试题目（2）","date":"2020-04-18T14:27:28.000Z","updated":"2020-11-20T12:15:05.532Z","comments":true,"path":"2020/04/18/前端面试题目（2）/","link":"","permalink":"http://yoursite.com/2020/04/18/前端面试题目（2）/","excerpt":"参考","text":"参考 事件代理 可参考“JS Web API 事件” 事件代理，即需要绑定事件的元素太多时将事件绑定在他们的父元素上，利用冒泡机制触发该事件（在事件函数中再通过target.nodeName来筛选出需要的子元素标签即可） 优点：代码简洁、减少浏览器内存占用 target、currentTarget的区别？ currentTarget当前所绑定事件的元素 target当前被点击的元素 宏任务和微任务 可参考“从输入url到页面显示都经历了什么” 宏任务：当前调用栈中执行的任务称为宏任务。（主代码快（script），定时器等等）。 微任务： 当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务为微任务。（可以理解为回调事件，promise.then，proness.nextTick等等）。 宏任务先于微任务执行。 宏任务中的事件放在callback queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。 继承的几种方式及优缺点 区分 原型继承 和原型链继承： 原型继承： 子原型 继承 父原型 原型链继承：在原型的显式原型上绑定新的方法，原型实例可调用该方法（可参考“JS原型和原型链”中 封装DOM查询的例子） 参考 方法1：原型继承：将子对象原型的 显式原型（prototype） 指向父对象原型的一个实例（可参考“JS原型和原型链”中 写一个原型链继承的例子），这样子对象原型new出的对象不仅有 子原型的属性，还会有 子原型.prototype(即父原型的对象的属性，又父原型的对象的隐式原型全等于父原型的显式原型，故完成继承) 优点：原先存在父类型的实例中的所有属性和方法也能存在于子类型的原型中。 缺点：（因为如下两个问题,实践中很少会单独使用原型继承） 在通过原型链实现继承时，子类的原型实际上会成为父类型的实例。所以父类的实例属性实际上会成为子类的原型属性。结果就是所有的子类的实例都会共享父类的实例属性（引用类型的）。 子类型实例 无法在不影响父类实例的情况下给父类型的构造函数 传递参数。 方法2：子类构造函数中利用apply()和/call()调用父类构造函数（经典继承） ：在子类型构造函数的内部利用apply()和 call()调用父类型构造函数。 优点：解决了“原型继承”的两种问题（可以在不影响父类实例下传参给父类） 缺点：无法复用父类的构造函数中的函数。（因为这个问题,实践中也很少会单独使用构造函数继承） 方法3：组合继承（伪经典继承）: 思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对父类实例属性的继承（注意区分构造函数和显式原型）。 将方法1和方法2组合到一块，使用方法1解决方法2中子类无法复用父类函数的问题（子类可顺着原型链去找父类的方法）。 使用方法2解决方法1中子类无法在不影响父类实例下传参给父类的问题。（使用call/apply的同时可以传参） 优点： 既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。 避免了原型链和借用构造函数的缺陷，融合了它们的优点，成为 JavaScript 中最常用的继承模式。而且，instanceof 和 isPrototypeOf() 也能够用于识别基于组合继承创建的对象。 缺点： 无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。 没错，子类型最终会包含超类型对象的全部实例属性， 例子：123456789101112131415161718192021222324252627282930313233343536373839// 父类SuperType 构造函数定义了两个属性：name 和 colorsfunction SuperType(name)&#123; this.name = name; this.colors = [\"red\", \"blue\", \"green\"]; &#125; // 父类SuperType 的原型定义了一个方法 sayName()SuperType.prototype.sayName = function()&#123; alert(this.name); &#125;; // 子类SubType 构造函数function SubType(name, age)&#123; // 继承实例属性 // （经典继承）继承父类属性并传参数name SuperType.call(this, name); // 定义子类自己的属性 age this.age = age; &#125; // 继承原型属性和方法// （原型继承）将 SuperType 的实例赋值给 SubType 的原型SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; // 在该新原型上定义了方法 sayAge()SubType.prototype.sayAge = function()&#123; alert(this.age); &#125;; var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" instance1.sayName(); //\"Nicholas\"; instance1.sayAge(); //29 var instance2 = new SubType(\"Greg\", 27); alert(instance2.colors); //\"red,blue,green\" instance2.sayName(); //\"Greg\"; instance2.sayAge(); //27 这样一来，就可以让两个不同的 SubType 实例既分别拥有自己属性(包括 colors 属性)，又可以使用相同的方法了。 闭包 可参考“JS作用域和闭包” 闭包的实质是因为函数嵌套而形成的作用域链 闭包的定义即：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包（闭包就是定义在一个函数内部的函数） 闭包作用：让一个函数有权访问另一个函数作用域（闭包）中的变量。 为什么使用闭包：闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。 闭包特性： 函数中定义函数 封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口； 持久性：一般的函数调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在（参数和变量不会在函数被调用完后被垃圾回收机制回收） export和export default的区别 使用上的不同，可参考“export和export default 的区别” export default在同一个模块中只能出现一次,export导出多个对象，export default只能导出一个对象。 export导出对象需要用{ }，export default 不需要{ } 仅允许表达式、函数或类作为export default导出,你想使用{ }导出对象时只能使用default。 性能上export会略微好一些，建议使用export12345export default xxximport xxx from './'export &#123;xxx,yyy,zzz&#125;import &#123;xxx&#125; from './' 常用的es6的功能 此题是一道开放题，可以自由回答。但要注意像let这种简单的用法就别说了，说一些经常用到并有一定高度的新功能像module、class、promise等，尽量讲的详细一点。 会话cookie 持久cookie 指定了expires属性的是持久cookie,没有指定的是会话cookie。 如果expires设置一个过去的时间点，那么这个cookie 会被立即删掉（失效） cookie是一些数据, 存储于你电脑上的文本文件中。（可参考“JS Web API 存储”） 当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。Cookie 的作用就是用于解决 “如何记录客户端的用户信息”: 当用户访问 web 页面时，他的名字可以记录在 cookie 中。 在用户下一次访问该页面会在请求中带上cookie，这样服务器就可以在 cookie 中读取用户访问记录。 数组去重（5种方法）js中3种方法： 1234567891011121314151617181920212223242526272829303132333435363738var arr=['12','32','89','12','12','78','12','32']; // 方法1：最简单数组去重法（遍历结果数组，没有的就加进去） function unique1(array)&#123; var n = []; //一个新的临时数组 for(var i = 0; i &lt; array.length; i++)&#123; //遍历当前数组 if (n.indexOf(array[i]) == -1) //没有找到的情况下返回-1 n.push(array[i]);//数组尾部添加元素 &#125; return n; &#125; arr=unique1(arr); // 方法2：速度最快， 占空间最多（空间换时间） function unique2(array)&#123; var n = &#123;&#125;, r = [], type; for (var i = 0; i &lt; array.length; i++) &#123; type = typeof array[i]; if (!n[array[i]]) &#123; n[array[i]] = [type]; r.push(array[i]); &#125; else if (n[array[i]].indexOf(type) &lt; 0) &#123; n[array[i]].push(type); r.push(array[i]); &#125; &#125; return r; &#125; //方法3：数组下标判断法（遍历原数组，符合的就加进结果数组中） function unique3(array)&#123; var n = [array[0]]; //结果数组 for(var i = 1; i &lt; array.length; i++) &#123; //从第二项开始遍历 //注意：indexOf遇到多个时返回第一个的位置 if (array.indexOf(array[i]) == i) n.push(array[i]); &#125; return n; &#125; ES6的2种方法： 12345678// 方法1：注意Set对象不是数组，需要转换为数组arr=[...new Set(arr)];// 方法2：function dedupe(array) &#123; //Array.from()能把set结构转换为数组 return Array.from(new Set(array)); &#125; get、post的区别 传参方式：get传参方式是通过地址栏URL传递，是可以直接看到get传递的参数，post传参方式参数URL不可见，get把请求的数据在URL后通过？连接，通过&amp;进行参数分割。psot将参数存放在HTTP的包体内 参数长度限制： get传递数据是通过URL进行传递，对传递的数据长度是受到URL大小的限制，URL最大长度是2048个字符。post没有长度限制 get后退不会有影响，post后退会重新进行提交 缓存： get请求可以被缓存，post不可以被缓存（标准如此，但是现在浏览器他们都能被缓存） 编码方式： get请求只支持URL编码，post支持多种编码方式 历史记录： get请求的记录会留在历史记录中，post请求不会留在历史记录 字符类型： get只支持ASCII字符，post没有字符类型限制 http的响应码及含义 1xx(临时响应) 100: 请求者应当继续提出请求。 101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。 2xx(成功) 200：正确的请求返回正确的结果 201：表示资源被正确的创建。比如说，我们 POST 用户名、密码正确创建了一个用户就可以返回 201。 202：请求是正确的，但是结果正在处理中，这时候客户端可以通过轮询等机制继续请求。 3xx(已重定向) 300：请求成功，但结果有多种选择。 301：请求成功，但是资源被永久转移。 303：使用 GET 来访问新的地址来获取资源。 304：请求的资源并没有被修改过 4xx(请求错误) 400：请求出现错误，比如请求头不对等。 401：没有提供认证信息。请求的时候没有带上 Token 等。 402：为以后需要所保留的状态码。 403：请求的资源不允许访问。就是说没有权限。 404：请求的内容不存在。 5xx(服务器错误) 500：服务器错误。 501：请求还没有被实现。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS 响应式布局","slug":"CSS 响应式布局","date":"2020-04-17T04:54:45.000Z","updated":"2020-08-09T04:59:38.606Z","comments":true,"path":"2020/04/17/CSS 响应式布局/","link":"","permalink":"http://yoursite.com/2020/04/17/CSS 响应式布局/","excerpt":"例子： 起源：为了让网页适配移动端，使得网页在不同设备上正常使用，一般主要处理屏幕大小问题。 优点：解决了设备之间的差异化展示（让不同的设备达到最优的视觉体验） 缺点：兼容性代码多，工作量大，加载速度受影响。对原有网站布局会产生影响，用户判断未必精确。","text":"例子： 起源：为了让网页适配移动端，使得网页在不同设备上正常使用，一般主要处理屏幕大小问题。 优点：解决了设备之间的差异化展示（让不同的设备达到最优的视觉体验） 缺点：兼容性代码多，工作量大，加载速度受影响。对原有网站布局会产生影响，用户判断未必精确。 设计原则 移动优先：在设计的初期就要考虑的页面如何在多终端展示 渐进增强：充分发挥硬件设备的最大功能（比如：IE8以下不支持CSS3，但我们也要设计CSS3的，要让支持的用于享受到最完美体验） 如何实现 viewport：使网页适配移动端（例子）&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt;width=device-width: content：将页面宽度width设为 屏幕区域大小device-width（注意区分 页面 和 屏幕 ，device-width只和设备有关系）,使页面和屏幕的宽度进行匹配。（如果不加这个，那么很多手机上网页的默认宽度使980px，然而手机只有这么大却要显示980个像素，看起来页面就被缩小了很多。） initial-scale：表示初始的缩放比例 CSS3 Media Query 是最简单的方式 对于不支持CSS3的，可以借助原生Javascript成本高，不推荐使用 第三方开源框架（比如bootstrap） 可以很好的支持浏览器响应式布局的设计 CSS3 Media Query 根据不同的设备给予不同的展示 常见属性 device-width，device-height 屏幕宽高（注意区分“屏幕”与“窗口”） width，height 渲染窗口宽高(物理上的可视窗口宽高) orientation 设备方向（横/竖） resolution 设备分辨率 media的使用（语法） 具体语法可参考菜鸟教程 CSS3 @media 查询 @media可以针对不同的屏幕尺寸设置不同的样式 语法： 外联样式表：&lt;link rel=&quot;stylesheet&quot; media=&quot;mediatype and|not|only (media feature)&quot; href=&quot;mystylesheet.css&quot;&gt; 内嵌样式表:@media mediatype and|not|only (media feature) {CSS-Code;} 媒体类型： all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕，平板电脑，智能手机等。 speech 应用于屏幕阅读器等发声设备 媒体功能：可参考菜鸟教程 注意：media的规定规则中区分 媒体类型 和 媒体功能 ，比如screen和max-width 是定义输出设备中的 页面 最大可见区域宽度。而 媒体功能中max-device-width 才是 定义输出设备的 屏幕 最大可见宽度。 例子： bootstrap 注意： bootstrap是高度组件化的，尽量使用他提供的，不要自己尝试重新开发 核心：栅格化布局 优点：可快速搭建网站 缺点：需要加载大量额外代码，性能不高 实际工作中使用media是不够的，框架可帮助我们解决低端浏览器不支持CSS3的问题 bootstrap是移动优先的前端框架，写非常少的代码即可实现多终端的页面适配。 使用：可以下载编译后的源码/使用CDN 使IE8支持media： bootstrap基本适配所有的浏览器，唯独IE8 需要 Respond.js 配合才能实现对媒体查询（media query）的支持。 注意：这个Respond.js必须部署在web server（网站）的域名下，不能是在静态资源域名下，会存在跨域的问题（具体可参考bootstrap官网） 官方例子官方例子: CSS样式、组件介绍设置padding（.container） Bootstrap 需要为页面内容和栅格系统包裹一个 .container 容器，以便为其赋予合适的排列（aligment）和内补（padding）（官方参考） 栅格系统（列布局） 栅格系统 栅格系统的简介中有提到：“行（row）”必须包含在 .container（固定宽度）或 .container-fluid（100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）”（官方参考） 可以通过栅格参数理解Bootstrap 的栅格系统是如何在多种屏幕设备上工作的。 类前缀：手机.col-xs-、平板.col-sm-、桌面显示器.col-md-、大桌面显示器.col-lg- 中等屏幕（桌面显示器）应用.col-md-前缀（实例：从堆叠到水平排列）： 如果不希望在换到小屏幕后12列堆叠（像上面的例子那样），可以使用.col-xs-* 和 .col-md-*前缀（实例：移动设备和桌面屏幕）（注意：3比2的比例来设置xs和md） 浮动、清除浮动（辅助类） bootstrap提供了快速浮动的 辅助类，我们可以借助他实现float的效果 通过为父元素添加.clearfix 类可以很容易地清除浮动 例子：下面“实际案例”的“做侧边栏响应式”中，给按钮的父元素增加了.pull-right使得按钮浮动在右边 不同设备展示/隐藏某些内容 通过单独或联合使用bootstrap提供的响应式工具以列出的类，可以针对不同屏幕尺寸隐藏或显示页面部分内容。 例子：下面“实际案例”的“做侧边栏响应式”中，给按钮的父元素增加了.visible-xs-*使得按钮只在极小屏幕下可见 Button bootstrap中的按钮有预定义样式，并且可以在不同屏幕中使用不同尺寸 组件 bootstrap提供了很多现成的组件 注意：我们自己定义的class名需要避免与组件本身的class样式产生冲突。 实际案例 使用bootstrap只需要很少的代码即可呈现很棒的效果 实现效果： 传统2列布局在电脑上的显示效果： 模拟平板宽度: 模拟手机宽度： 栅格系统的简介中有提到：“行（row）”必须包含在 .container（固定宽度）或 .container-fluid（100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）” 所以想让导航栏有padding可使用官方提供的.container 类作为父元素 顶部导航使用bootstrap提供的nav 组件，使用.container 容器包裹nav组件使其有padding： 侧边导航 使用bootstrap提供的列表组 将 列表组 放在 栅格系统 中（注意使用.container 容器包裹 栅格系统 使其有padding）分成9:3,9的部分留着放网站主体，3用来放侧边导航 巨幕在栅格系统的9中，使用bootstrap提供的巨幕 主体部分 实现效果：每篇文章在不同大小的屏幕中都显示同样的宽度 在 栅格系统 的左列中嵌套栅格系统： 目前实现的效果： 做侧边栏的响应式 此时将页面宽度缩小，可发现需要一个侧边栏的响应式（按钮）：","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"前端面试题目（1）","slug":"前端面试题目（1）","date":"2020-04-16T14:27:28.000Z","updated":"2020-08-10T12:18:41.066Z","comments":true,"path":"2020/04/16/前端面试题目（1）/","link":"","permalink":"http://yoursite.com/2020/04/16/前端面试题目（1）/","excerpt":"参考","text":"参考 单页面应用的优缺点 react是 单页应用的跳转，也就是说，不管怎么进行页面跳转，整个网站只会加载一次html文件，这也就决定了不能使用&lt;a&gt;标签进行页面跳转。（可参考“首页开发（3）”） 如果使用&lt;a&gt;标签进行页面跳转，跳转时会发送HTTP请求。 而借助react-router-dom的Link组件实现跳转则不会，因此加载速度会快很多，借此也可提高性能。 优点： 良好的交互体验：单页应用的内容的改变不需要重新加载整个页面，获取数据也是通过Ajax异步获取，没有页面之间的切换，就不会出现“白屏现象”,也不会出现假死并有“闪烁”现象，页面显示流畅。 良好的前后端工作分离模式：后端不再负责模板渲染、输出页面工作，后端API通用化，即同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端。 减轻服务器压力：单页应用相对服务器压力小，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍。 缺点： 首屏加载慢：如果不对路由进行处理，在加载首页的时候，就会将所有组件全部加载，并向服务器请求数据，这必将拖慢加载速度；（可使用react-loadable模块实现异步加载组件） 不利于SEO：seo 本质是一个服务器向另一个服务器发起请求，解析请求内容。但一般来说搜索引擎是不会去执行请求到的js的。也就是说，搜索引擎的基础爬虫的原理就是抓取url，然后获取html源代码并解析。 如果一个单页应用，html在服务器端还没有渲染部分数据数据，在浏览器才渲染出数据，即搜索引擎请求到的html是模型页面而不是最终数据的渲染页面。 这样就很不利于内容被搜索引擎搜索到。 轮播图是怎么实现的，后台数据抓取是怎么写的 可参考慕课、简书 html重点就是包裹关系，注意动态添加小圆点（js中根据图片数量来决定圆点数量） 12345678910111213141516171819202122232425262728293031323334353637&lt;div class=\"slider-box\"&gt;&lt;!-- slider做一个框，和单张图等宽等高，overflow隐藏溢出部分 --&gt;&lt;!-- 子绝父相，slider相对定位，ul绝对定位，调整ul的left使其移动--&gt; &lt;div class=\"slider\" id=\"slider\"&gt; &lt;!-- ul宽是所有图的宽，内部li浮动来一排显示--&gt; &lt;ul class=\"clearfix\"&gt; &lt;li&gt; &lt;img width=\"590\" height=\"470\" src=\"./img/1.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img width=\"590\" height=\"470\" src=\"./img/2.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img width=\"590\" height=\"470\" src=\"./img/3.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img width=\"590\" height=\"470\" src=\"./img/4.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;li&gt; &lt;img width=\"590\" height=\"470\" src=\"./img/5.jpg\" alt=\"\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;!-- 左箭头，绝对定位，left-box设置为flex容器，实现span水平垂直居中--&gt; &lt;div class=\"left-box\"&gt; &lt;span&gt;&amp;lt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 右箭头，同上中--&gt; &lt;div class=\"right-box\"&gt; &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;/div&gt; &lt;!-- 小圆点索引，绝对定位，通过js根据图片数量决定圆点数量--&gt; &lt;div class=\"index-box\"&gt; &lt;ol&gt; &lt;/ol&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css重点就是子绝父相（子为ul元素，父为显示在页面上的div），图片浮动为一排通过left移动，注意父元素使用overflow：hidden隐藏滚动条 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586.slider-box &#123; margin-right: 10px;&#125;.slider-box .slider &#123; position: relative; width: 590px; height: 470px; overflow: hidden;&#125;.slider-box .slider ul &#123; position: absolute; top: 0px; left: -590px; width: 500%;/*所有图片的宽度和*/ height: 100%; /* transition: left 1s linear; */&#125;.slider-box .slider ul li &#123; float: left;/*浮动以显示在一排，且父元素left移动时会全部一起动*/&#125;/*左箭头*/.slider-box .left-box &#123; background: rgba(0, 0, 0, 0.2); position: absolute; top: 45%; left: 0px; width: 50px; height: 50px; color: #fff; display: flex;/*flex容器可使子元素轻松居中*/ justify-content: center;/*水平居中*/ align-items: center;/*垂直居中*/ cursor: pointer;&#125;/*右箭头*/.slider-box .right-box &#123; background: rgba(0, 0, 0, 0.2); position: absolute; top: 45%; right: 0px; width: 50px; height: 50px; color: #fff; display: flex; justify-content: center; align-items: center; cursor: pointer;&#125;.slider-box .left-box, .slider-box .right-box span &#123; font-size: 24px;&#125;/*小圆点索引*/.slider-box .index-box &#123; position: absolute; bottom: 3%; left: 10%;&#125;.slider-box .index-box &gt; ol &#123; height: 14px; display: flex; justify-content: space-evenly; align-items: center; background: rgba(0, 0, 0, 0.6);&#125;.slider-box .index-box &gt; ol &gt; li &#123; width: 10px; height: 10px; border-radius: 50%; background: #fff; list-style: none; cursor: pointer;&#125;.slider-box .index-box &gt; ol &gt; li.active &#123; background: #e1251b;&#125; js中使用class 我们先通过ES6 class创建一个class Slider，这个类的作用就是获取轮播图的父盒子id然后给他内部的轮播图、小圆点、左右按钮添加js逻辑。然后在需要使用轮播图的文件中使用Slider类来new一个对象，同时将Slider需要的DOM元素（轮播图的父盒子）的id传过去，相对应的逻辑就绑上去了。 class的使用：123456&lt;!-- 在html中&lt;/body&gt;上方new一个对象引入即可--&gt;&lt;script type=\"text/javascript\"&gt; &lt;!-- 传入的是Slider类构造函数中需要的轮播图父元素的id--&gt; const slider = new Slider(\"#slider\"); &lt;!-- 那么绑定在Slider类构造函数中的属性、函数都会被引入--&gt;&lt;/script&gt; 动态添加小圆点 DOM children 在slider类中定义的函数initPoint：123456789101112131415161718192021222324252627282930313233343536class Slider &#123; constructor(id) &#123; this.box = document.querySelector(id) // 轮播图盒子 this.picBox = this.box.querySelector(\"ul\") // 图片盒子 this.indexBox = this.box.querySelector(\".index-box\") // 小圆点父盒子 this.init() &#125; init() &#123; this.initPoint() &#125; // 动态添加小圆点 initPoint() &#123; // 图片的数量就是圆点的数量 const num = this.picBox.children.length; // 减少DOM操作（Fragment） let frg = document.createDocumentFragment(); for (let i = 0; i &lt; num; i++) &#123; let li = document.createElement(\"li\") // 提前给圆点设置属性data-index，用于点击跳转 li.setAttribute(\"data-index\", i + 1) // 给当前图的小圆点特殊样式，默认第一张图 if (i == 0) li.className = \"active\" frg.appendChild(li) &#125; // 添加的样式 this.indexBox.children[0].style.width = num * 10 * 2 + \"px\"; // 一次性添加到小圆点父盒子中 this.indexBox.children[0].appendChild(frg) &#125;&#125; 实现图片可无限滚动 实现效果：点击“向右”到最后一张图片时再次点击“向右”可回到第一张图（“向左”也是），非常流畅 思路： 在 绝对定位的ul 的头和尾各增加一个 辅助图，当我们的辅助图进入红框（显示的相对定位父元素）时 将辅助图与对应的真正的图的位置迅速替换 补充： DOM clonenode创建指定的节点的精确拷贝 Element.firstElementChild返回对象的第一个子元素 Element.lastElementChild返回对象的最后一个子元素 Element.clientWidth表示元素的内部宽度，以像素计。该属性包括内边距 padding，但不包括边框 border、外边距 margin 和垂直滚动条（如果有的话） 添加辅助图 Slider类中： 123456789101112131415161718192021222324252627282930// 只放相关的部分，没变的部分见上class Slider &#123; constructor(id) &#123; // 整个轮播图的宽度sliderWidth（轮播图容器宽度clientWidth） this.sliderWidth = this.box.clientWidth this.init() &#125; init() &#123; // copyPic需要在构造函数中被调用，这样才会生效 this.copyPic() &#125; // 增加辅助图，实现无限滚动 copyPic() &#123; // 复制 图1节点 给first（辅助图1） const first = this.picBox.firstElementChild.cloneNode(true) // 复制 最后一张图的节点 给last（辅助图5） const last = this.picBox.lastElementChild.cloneNode(true) // 在 ul尾部 增加 辅助图1 this.picBox.appendChild(first) // 在 ul的第一个元素 前增加 辅助图5 this.picBox.insertBefore(last, this.picBox.firstElementChild) // 增加后首先显示的是 辅助图5 ，需要改成首先显示图1（也可以在css中设置） this.picBox.style.width = this.sliderWidth * this.picBox.children.length + \"px\" this.picBox.style.left = -1 * this.sliderWidth + \"px\" &#125;&#125; （copyPic()后面几行代码可在css中设置）添加成功后修改css中ul这个绝对定位元素的left，使其初始值向左一个图片的宽度，达到首先显示图1而不是辅助图5的效果： 1234567891011.slider-box .slider ul &#123; position: absolute; top: 0px; /* 向左移一张图的宽度，使其首先显示图1而不是辅助图5 */ left: -590px; /* 增加辅助图后ul的总宽度也要修改 */ width: 700%; /* 如果js的copyPic()中已经设置，则可不用在css重新设置left和width */ height: 100%; /* transition: left 1s linear; */&#125; 抵达辅助图时替换为真正的对应图 【可以看完下面的“预防多次连续点击出错”再来看这里会更加完整】 在Slider类的animate()函数中实现替换（具体animate()实现功能见下“左右按钮”中）： 构造函数中定义的：sliders轮播图数量（注意是5不是7，此时还未添加辅助图）、整个轮播图的宽度sliderWidth（轮播图容器宽度clientWidth） 左右按钮 实现效果：点击左右按钮可切换图片 思路: leftRight()函数中获取左右按钮，绑定点击事件，分别调用move(offset)函数，offset是位移 move(offset)函数中改变圆点样式，调用animate(offset)函数 animate(offset)函数中实现移动的动画效果 Slider类中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 只放相关的部分，没变的部分见上class Slider &#123; constructor(id) &#123; // 整个轮播图的宽度sliderWidth（轮播图容器宽度clientWidth） this.sliderWidth = this.box.clientWidth this.init() &#125; init() &#123; // leftRight 需要在构造函数中被调用，这样才会生效 this.leftRight() &#125; // 用于调用轮播图移动效果的函数，改变圆点样式，offset是位移 move(offset) &#123; // 动画效果animate() this.animate(offset); // 圆点数量num，给当前圆点加特殊样式，其他圆点抹掉样式 const num = this.indexBox.children[0].children.length for (let i = 0; i &lt; num; i++) &#123; this.indexBox.children[0].children[i].className = \"\" &#125; this.indexBox.children[0].children[this.index - 1].className = \"active\" &#125; // 移动的动画效果，offset是位移 animate(offset) &#123; const time = 1000 // 运动的总时间time（ms） const rate = 100 // 动一次的时间rate let speed = offset / (time / rate) // 每次移动的距离speed=位移/运动次数 // 移动的目标位置goal=当前位置向左移动offset // 注意left带单位，使用parseFloat去掉单位 let goal = parseFloat(this.picBox.style.left) - offset // this.animated = true // setInterval重复执行，每隔100ms执行一次 let animate = setInterval(() =&gt; &#123; // 到达目标位置goal/非常接近目标位置goal（即，距离目标位置&lt;移动一次的距离）时 if (this.picBox.style.left == goal || Math.abs(Math.abs(parseFloat(this.picBox.style.left)) - Math.abs(goal)) &lt; Math.abs(speed)) &#123; this.picBox.style.left == goal // 直接设置为达到目标位置 clearInterval(animate) // 清除重复执行 // this.animated = false &#125; else &#123; // 没有到达目标位置goal前则每隔100ms移动一次 this.picBox.style.left = parseFloat(this.picBox.style.left) - speed + \"px\"; &#125; &#125;, rate); &#125; // 点击左右按钮可切换图片 leftRight() &#123; // 选中左侧按钮 this.box.querySelector(\".left-box\").addEventListener(\"click\", () =&gt; &#123; console.log(\"left\") // 调用move()移动轮播图,移动位移为 负 轮播图宽度 this.move(-this.sliderWidth) &#125;) // 选中右侧按钮 this.box.querySelector(\".right-box\").addEventListener(\"click\", () =&gt; &#123; console.log(\"right\") /*if (this.animated) &#123; return &#125; if (this.index + 1 &gt; this.sliders) &#123; this.index = 1 &#125; else &#123; this.index++ &#125;*/ this.move(this.sliderWidth) &#125;) &#125;&#125; 点击圆点跳转对应图片 实现效果：点击圆点跳转对应图片 思路: 在动态添加小圆点的initPoint()中调用move(offset)函数中绑定点击事件，复用上面左右按钮中的move()，offset是位移 move(offset)函数中改变圆点样式，调用animate(offset)函数（见上） animate(offset)函数中实现移动的动画效果（见上） Slider类中： 预防多次连续点击出错 实现效果：快速连续点击左右按钮跳转时，限制其跳转一张图结束后才能跳转下一张图片(连续点击出现空白图时为溢出,列表溢出则重置) 思路: 在构造函数中添加属性animated，默认false，用来判断此时是否正在移动。如是则需等待移动结束才能继续移动下一张。 在animate()中设置animated，移动开始则为true，结束则为false 优化leftRight()，通过animated判断是否处于移动中，否才允许继续移动，当处于轮播图最左端（index=1，辅助图5）时，若还想继续向左则 Slider类中优化leftRight()：1234567// 只展示添加的部分class Slider &#123; constructor(id) &#123; this.animated = false &#125;&#125; 自动播放 实现效果：页面自动向右播放轮播图 思路: 构造函数中调用的init()中添加play()，自动调用 play()中，采用setInterval()每隔2秒点击一次“向右”按钮 给 轮播图盒子 绑定 onmouseenter/onmouseover事件，规定鼠标进入 轮播图盒子 时，清除定时器（停止向右） 给 轮播图盒子 绑定 onmouseleave/onmouseout事件，规定鼠标移出 轮播图盒子 时，继续执行定时器（继续向右） 补充： onmouseenter、onmouseleave可参考DOM事件 Slider类中：12345678910111213141516171819202122232425262728293031class Slider &#123; constructor(id) &#123; this.init() &#125; init() &#123; this.play() &#125; // 自动播放 play() &#123; // 每隔2秒点击一次“向右”按钮 this.auto = setInterval(() =&gt; &#123; this.box.querySelector(\".right-box\").click() &#125;, 2000); // 鼠标进入 轮播图盒子 时，清除定时器 this.box.addEventListener(\"mouseenter\", () =&gt; &#123; clearInterval(this.auto) &#125;) // 鼠标移出 轮播图盒子 时，继续执行定时器 this.box.addEventListener(\"mouseleave\", () =&gt; &#123; this.auto = setInterval(() =&gt; &#123; this.box.querySelector(\".right-box\").click() &#125;, 2000); &#125;) &#125;&#125; js完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196class Slider &#123; constructor(id) &#123; this.box = document.querySelector(id) this.picBox = this.box.querySelector(\"ul\") this.indexBox = this.box.querySelector(\".index-box\") // 整个轮播图的宽度sliderWidth（轮播图容器宽度clientWidth） this.sliderWidth = this.box.clientWidth // sliders轮播图数量（注意是5不是7） this.sliders = this.picBox.children.length // 小圆点的索引，初始为1 this.index = 1 // animated当前是否在移动中 this.animated = false this.auto = null this.init() &#125; init() &#123; this.initPoint() this.copyPic() this.leftRight() this.play() &#125; // 动态添加小圆点 initPoint() &#123; // 图片的数量就是圆点的数量 const num = this.picBox.children.length; // 减少DOM操作（Fragment） let frg = document.createDocumentFragment(); for (let i = 0; i &lt; num; i++) &#123; let li = document.createElement(\"li\") // 提前给圆点设置属性data-index，用于点击跳转 li.setAttribute(\"data-index\", i + 1) // 给当前图的小圆点特殊样式，默认第一张图 if (i == 0) li.className = \"active\" frg.appendChild(li) &#125; // 添加的样式 this.indexBox.children[0].style.width = num * 10 * 2 + \"px\"; this.indexBox.children[0].appendChild(frg) // 点击圆点，跳转对应图片 this.indexBox.children[0].addEventListener(\"click\", (e) =&gt; &#123; console.log(\"point\") // 获取当前点击的DOM元素的data-index属性值 let pointIndex = (e.target).getAttribute(\"data-index\") // index是构造函数中定义并初始为1的索引 if (pointIndex == this.index || this.animated) &#123; return &#125; // 跳转相应图片，offset为移动距离 // index为当前小圆点索引（构造函数中定义初始为1） // sliderWidth为轮播图的宽度 let offset = (pointIndex - this.index) * this.sliderWidth this.index = pointIndex this.move(offset) // 调用move()移动图片 &#125;) &#125; // 增加辅助图，实现无限滚动 copyPic() &#123; // 复制 图1节点 给first（辅助图1） const first = this.picBox.firstElementChild.cloneNode(true) // 复制 最后一张图的节点 给last（辅助图5） const last = this.picBox.lastElementChild.cloneNode(true) // 在 ul尾部 增加 辅助图1 this.picBox.appendChild(first) // 在 ul的第一个元素 前增加 辅助图5 this.picBox.insertBefore(last, this.picBox.firstElementChild) // 增加后首先显示的是 辅助图5 ，需要改成首先显示图1（也可以在css中设置） this.picBox.style.width = this.sliderWidth * this.picBox.children.length + \"px\" this.picBox.style.left = -1 * this.sliderWidth + \"px\" &#125; // 用于调用轮播图移动效果的函数，改变圆点样式，offset是位移 move(offset) &#123; // 动画效果animate() this.animate(offset); // 圆点数量num，给当前圆点加特殊样式，其他圆点抹掉样式 const num = this.indexBox.children[0].children.length for (let i = 0; i &lt; num; i++) &#123; this.indexBox.children[0].children[i].className = \"\" &#125; this.indexBox.children[0].children[this.index - 1].className = \"active\" &#125; // 移动的动画效果，offset是位移 animate(offset) &#123; const time = 1000 // 运动的总时间time（ms） const rate = 100 // 动一次的时间rate let speed = offset / (time / rate) // 每次移动的距离speed=位移/运动次数 // 移动的目标位置goal=当前位置向左移动offset // 注意left带单位，使用parseFloat去掉单位 let goal = parseFloat(this.picBox.style.left) - offset this.animated = true // setInterval重复执行，每隔100ms执行一次 let animate = setInterval(() =&gt; &#123; // 到达目标位置goal/非常接近目标位置goal（即，距离目标位置&lt;移动一次的距离）时 if (this.picBox.style.left == goal || Math.abs(Math.abs(parseFloat(this.picBox.style.left)) - Math.abs(goal)) &lt; Math.abs(speed)) &#123; this.picBox.style.left == goal // 直接设置为达到目标位置 clearInterval(animate) // 清除重复执行 this.animated = false // 移动到辅助图5时，替换为真正的图5（sliders轮播图数量为5） if (parseFloat(this.picBox.style.left) == 0) &#123; this.picBox.style.left = -this.sliders * this.sliderWidth + \"px\" &#125; else if (parseFloat(this.picBox.style.left) == -(this.sliders + 1) * this.sliderWidth) &#123; // 移动到辅助图1时，替换为真正的图1 this.picBox.style.left = -this.sliderWidth + \"px\" &#125; &#125; else &#123; // 没有到达目标位置goal前每隔100ms移动一次 this.picBox.style.left = parseFloat(this.picBox.style.left) - speed + \"px\"; &#125; &#125;, rate); &#125; // 点击左右按钮可切换图片 leftRight() &#123; // 选中左侧按钮 this.box.querySelector(\".left-box\").addEventListener(\"click\", () =&gt; &#123; console.log(\"left\") // 如果此时正在移动，直接返回，不允许继续移动 if (this.animated) &#123; // animated构造函数中默认false return &#125; // 如果此时不是正在移动，则继续 // index为当前小圆点索引（初始图1为1），sliders为图片数量5 // 如列表溢出则重置，连续点击出现空白图时为溢出 if (this.index - 1 &lt; 1) &#123; // 当前位置左移1位却小于1时，index重置为5 this.index = this.sliders &#125; else &#123; // 正常则当前图片索引index减1 this.index-- &#125; // 调用move()移动轮播图,移动位移为 负 轮播图宽度 this.move(-this.sliderWidth) &#125;) // 选中右侧按钮 this.box.querySelector(\".right-box\").addEventListener(\"click\", () =&gt; &#123; console.log(\"right\") if (this.animated) &#123; return &#125; // 同理，当前位置+1超出总轮播图数量时，重置index为1 if (this.index + 1 &gt; this.sliders) &#123; this.index = 1 &#125; else &#123; this.index++ &#125; this.move(this.sliderWidth) &#125;) &#125; // 自动播放 play() &#123; // 每隔2秒点击一次“向右”按钮 this.auto = setInterval(() =&gt; &#123; this.box.querySelector(\".right-box\").click() &#125;, 2000); // 鼠标进入 轮播图盒子 时，清除定时器 this.box.addEventListener(\"mouseenter\", () =&gt; &#123; clearInterval(this.auto) &#125;) // 鼠标移出 轮播图盒子 时，继续执行定时器 this.box.addEventListener(\"mouseleave\", () =&gt; &#123; this.auto = setInterval(() =&gt; &#123; this.box.querySelector(\".right-box\").click() &#125;, 2000); &#125;) &#125;&#125; 跨域的方法有哪些，常用的是？ 可参考JS Web API AJAX 可通过jsonp、cors实现跨域 怎么理解前端，怎么学习前端（途径） “前端”是与用户直接交互的部分，包括你在浏览网页时接触的所有视觉内容。 好比你去快餐店吃饭。你在外面看到的店面装饰、点餐员、菜单、保温柜里面摆着的鸡腿汉堡这些给用户看的都是属于前端，相当于门户网站、用户输入、数据列表等。大概可以归类为网页开发的html、css。 你跟点餐员点好餐之后，点餐员会录入你点的菜，向你确认可乐加不加冰、咖啡加不加糖然后让你支付。这些用户与前端的交互就交给了javascript来完成。 然后点餐员向厨房喊一声“一个xx套餐，可乐不加冰”。这就向后端发送了一个ajax请求。这些请求是异步的，你得等一会儿才能收到你点的餐。 而他们厨房里炸鸡的、炸薯条的、做汉堡的，弄好之后递给前台，这些就相当于后端。他们负责把食物（数据）制作好，再返回给前端，前端再将收到的这些东西装盘（将收到的数据转为需要的格式）递给用户。这基本就是一个前后端交互的逻辑了。 对后端语言的了解程度常用的浏览器及内核 可参考这篇文章 目前最为主流浏览器有五大款，分别是IE、Firefox、Google Chrome、Safari、Opera。 浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。（JS 引擎越来越独立，内核倾向于只指渲染引擎） 渲染引擎 负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。 常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 我使用的是chrome浏览器+Blink内核 总结一下各常用浏览器所使用的内核： IE浏览器内核：Trident内核，也是俗称的IE内核； Chrome浏览器内核：统称为Chromium内核或Chrome内核，以前是Webkit内核，现在是Blink内核； Firefox浏览器内核：Gecko内核，俗称Firefox内核； Safari浏览器内核：Webkit内核； Opera浏览器内核：最初是自己的Presto内核，后来是Webkit，现在是Blink内核； 百度浏览器、世界之窗内核：IE内核； 前端性能优化的方法，举例 可参考前端基础-HTTP/HTML/浏览器（2）/JS 运行环境 让加载更快： 减少资源体积：压缩代码 比如使用webpack在production环境下进行打包时，就会自动压缩代码至1/3的大小，在浏览器上进行反解析再进行渲染。 减少请求次数： 合并代码：比如webpack中，在index.js中引入a.js、b.js，打包后只生成一个bundle.js，这就是合并代码。（加载3次3kb的文件不如加载1次9kb快，这和网络请求有关系） SSR服务器端渲染：不需要通过ajax发送请求。 缓存：原本需要发送多个请求的数据直接在缓存中获取即可减少访问次数。 应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。 更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在问题了（webpack打包时会把静态资源的路径加上hash值） 较为合理的缓存方案： HTML：使用协商缓存。 CSS&amp;JS&amp;图片：使用强缓存，文件命名带上hash值。 雪碧图 使用更快的网络：CDN CDN是分区域的，也就是使用CDN的时候上海和北京对同一个网站的IP地址是不同的。CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了 图片、js等静态资源采用CDN是很快的，我们经常使用的bootstrap就是使用的CDN 让渲染更快： CSS放在head中，JS放在body最下面 原因： 页面是边解析边渲染的，如果把CSS写在HTML后，则先解析DOM树渲染在页面上，再生成CSSOM合成渲染树重新渲染在页面上，这样会有一个过程，用户可能会看到一个过程变化。所以在DOM树生成之前就先生成CSSOM会更好，这样当DOM树生成时就可直接和所有CSSOM进行合并，一步渲染完成。 页面是边解析边渲染的，如果把JS写在body中间，虽然JS有异步的处理机制，但极端情况会出现前面已经渲染了一半就卡住的情况，渲染时间会拖长。 尽早开始执行JS，用DOMContentLoaded触发 懒加载（图片懒加载，上滑加载更多） 对DOM查询进行缓存（DOM操作很耗性能） 合并的频繁DOM操作，一起插入DOM结构（利用createDocumentFragment()） 让渲染更流畅： 节流throttle：无论执行动作多快，都固定每隔100ms触发一次（时间自定义）。 防抖debounce：用户输入结束或暂停时，才会触发相关事件。际上是对定时器setTimeout的使用，但我们通常将其封装为debounce函数来使用。 可以通过什么途径查看到网站目前使用的技术 google插件WhatRuns 检测的内容： 网页服务器 内容管理系统 网页字体 JavaScript 框架 Wordpress插件等 react的核心是什么 可参考知乎、segmentfault，总得来说就是组件+虚拟DOM 组件：所有React代码基本上就是一个包含许多小组件在内的大组件。 组件API：render、setState、constructor（一般会在其中初始化state并做一些函数this的绑定）、生命周期函数等 组件类型：class组件、函数式组件、高阶组件 JSX：React的意思就是让我们把HTML和JS代码全都写在一起。React是通过一种叫做JSX的语法扩展（X代表XML）来实现的。 Props &amp; State：React当中，属性就被称作props（properties的缩写），组件之间可以通过Props进行交互。 正因如此，React当中的数据流是单向的：数据只能从父组件传向子组件，反过来则不行。可是组件不可能只接受从父组件传来的数据（例如还有用户在input当中的输入），这时state就派上了用场。 声明式渲染（虚拟DOM）： 初始化渲染：JSX语法=》render函数渲染出虚拟DOM树=》react将虚拟DOM渲染成真实的DOM 页面更新渲染：state改变=》render函数重新渲染出虚拟DOM=》diff算法比对当前虚拟DOM和需要更新的虚拟DOM=》重新渲染部分真实DOM 总结： React的代码是由一个个的组件构成的。 组件采用了JSX语法扩展的写法。 数据流总是从父组件到子组件，除state可以通过调用方法修改之外。 组件包含一些特定方法和生命周期函数。 你也完全可以用函数声明只有render方法的无状态组件。 区分处理UI和数据逻辑的组件是一种很好的开发实践。 高阶组件函数可以传入一个组件并为其赋予更多功能。 写过项目最难的部分说一下 react模拟假数据","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Redux、React-router知识点汇总","slug":"Redux、React-router知识点汇总","date":"2020-04-15T06:29:40.000Z","updated":"2020-07-31T06:30:26.612Z","comments":true,"path":"2020/04/15/Redux、React-router知识点汇总/","link":"","permalink":"http://yoursite.com/2020/04/15/Redux、React-router知识点汇总/","excerpt":"Redux基本概念 redux中文官网 可参考博客“Redux入门（1）”、“Redux入门（2）”、Redux进阶(1)UI组件、容器组件、无状态组件 store state（注意state不可变值，可用immutable.js） action（redux-thunk中间件可使action为函数） reducer是一个纯函数","text":"Redux基本概念 redux中文官网 可参考博客“Redux入门（1）”、“Redux入门（2）”、Redux进阶(1)UI组件、容器组件、无状态组件 store state（注意state不可变值，可用immutable.js） action（redux-thunk中间件可使action为函数） reducer是一个纯函数 单项数据流 dispatch（action） reducer-&gt; newState subscribe触发通知 react-redux 可参考Redux进阶(3)React-Redux的使用 &lt; Provider&gt; 一般放在App.js中包裹组件最外层，使得被包含在该组件下的所有组件都有能力连接store connect()高阶组件，规定组件连接store的规则 mapStateToProps()，获取state的值放到组件的props上。 mapDispatchToProps()，接受store的dispatch()为参数，函数中可自定义函数放到组件的props上,使props中的函数可以调用dispatch()派发action。 异步action 前端想要请求后端的数据时就需要用到ajax请求，而想要修改store中数据就要用到action，想在action中异步请求数据需要 异步action： 当然不能直接这么写，action默认只能是对象，需要Redux-thunk中间件使得action可为函数 可参考博客Redux进阶(2)Redux-thunk与Redux-saga中间件 中间件 可参考博客Redux进阶(2)Redux-thunk与Redux-saga中间件 注意：中间件指的是action和store的中间。只有redux才有action和store，所以只有redux才有中间件！（react没有） 总的来说，redux中间件就是对dispatch()做了个升级 本来原始的dispatch()只能接收对象类型的action，接收以后直接传递给store。但经过redux-thunk中间件升级后，dispatch()可以接收 函数类型的 action，他会执行该函数。（在函数中就可以进行AJAX请求了） 这个升级不能放在reducer中，因为reducer是纯函数，具体可参考Redux的reducer为什么不能有异步操作 React-router使用 面试考点并不多（前提是熟悉React） 路由模式（hash、H5 history），同vue-router 路由配置（动态路由、懒加载），同vue-router 路由模式（hash、H5 history） hash模式（默认），如http://abc.com/#/user/10 H5 history模式，如http://abc.com/user/20 后者需要server端支持，因此无特殊需求可选择前者 对客户端的可用H5 history模式，对后台的可用hash模式 路由配置动态传参 例子： 补充： 【react的url中传递参数值】组件的跳转路径上最好使用/:参数值的方法传值，这样组件中可以直接使用this.props.match.params.参数名获取所传参数值。 【react将参数值传递给node】在react的组件的action中通过ajax请求的路径中使用?key=value来传值，这样在node中通过queryString.parse可直接得到JSON对象 跳转路由 Link组件： 用js跳转路由： 懒加载 使用React.lazy+React.Suspense: 或者使用react-loadable模块","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React知识点汇总（高级特性）","slug":"React知识点汇总（高级特性）","date":"2020-04-14T09:57:59.000Z","updated":"2020-07-30T13:12:07.345Z","comments":true,"path":"2020/04/14/React知识点汇总（高级特性）/","link":"","permalink":"http://yoursite.com/2020/04/14/React知识点汇总（高级特性）/","excerpt":"不是每个都很常用，但用到的时候必须要知道 考察候选人对React的掌握是否全面，且有深度 考察做过的项目是否有深度和复杂度（至少能用到高级特性）","text":"不是每个都很常用，但用到的时候必须要知道 考察候选人对React的掌握是否全面，且有深度 考察做过的项目是否有深度和复杂度（至少能用到高级特性） 函数组件 函数组件是 纯函数，输入props，输出JSX 没有实例（自然也没有this），没有生命周期函数与state，所以性能好 不能扩展其他方法 函数组件，即 无状态组件，更多知识可参考“Redux进阶(1)UI组件、容器组件、无状态组件” 当一个组件中只有render函数时，我们可以使用 无状态组件 替换 它。 使用方法：使用常量const定义一个箭头函数，该函数接收一个参数props（来自父组件的变量、方法），返回原本render函数中的内容（记得输出） ref属性 ref可参考“React高级内容（2）” ref属性值 必须是通过React.create()创建的对象 三个地方名字(refName)一致才能获取DOM节点 创建ref：this.refName = React.createRef()(构造函数中) 使用ref：&lt;input defaultValue={this.state.name} ref={this.refName}/&gt;（render函数中） 通过 ref 获取 DOM 节点(elem):const elem = this.refName.current（事件函数中） 具体例子在下方“非受控组件”中 非受控组件 非受控组件：组件值不受state控制（比如：input的值不受state控制），只是使用state给组件赋予了初始值（比如：input的defaultValue属性），由于赋予初始值以后组件值就和state无关了，所以后面想获取 组件值 就只能 通过ref获取DOM元素 的值的方式来操作了。（可回顾“React知识点汇总（基础使用1）”中的 受控组件（value/checked）） 使用场景：由于非受控组件需要搭配ref去操作DOM来获取值，所以按照react设计初衷是不推荐使用的，但是特殊时候只能使用 非受控组件，比如： 必须手动操作DOM元素，setState实现不了的时候 文件上传&lt;input type=file&gt; 某些富文本编辑器，需要传入DOM元素（做加粗、加下划线等操作 ） 受控组件vs非受控组件：优先使用受控组件，这样符合React设计原则。必须操作DOM时，再使用非受控组件。 input的 defaultValue属性 注意：区别react中input的 defaultValue属性 和 value属性 react中input的defaultValue就相当于原生DOM中的value属性，这样写出来的组件，其value值就是用户输入的内容，和react没有关系，完全不管输入的过程。 而react中input的value属性必须使用onChange来监听这个input，使state和input关联（即 受控组件） 如果在使用input时只需要获取model里的值时，使用 defaultValue就可以了。如果需要获取model的值并且还需要改变它的时候，就需要使用value结合onChange事件与state联系就可以了。（但还是尽量使用value，毕竟defaultValue需要结合ref来获取DOM元素，而react的设计初衷就是尽量不要操作DOM，通过state来带动DOM） 例子： checkbox的defaultChecked属性 上传文件【必须使用非受控组件】MDN input file使用方法 Protals（传送门 让组件渲染到父组件以外） 组件默认会按照既定层次嵌套渲染，但我们可以使用Protals让组件渲染到父组件以外。 在react中的组件排布位置是不变的（不会改变组件解构），只是在渲染的时候做了一个hack使相关组件渲染到我们指定的地方。 Portals使用场景： 父组件是BFC时，会限制子组件的布局，此时可使用Protals将子组件脱离BFC父组件（比如overflow：hidden） 父组件z-index值太小时 fixed元素需要放在body第一层级（DOM树最外层），有更好的浏览器兼容性 总之，Protals一般在CSS布局方面使用 例子（fixed元素放在body第一层级） 正常渲染时：（注意：this.props.children可获取的内容）可以看到固定定位的元素位于DOM树内层 使用 Portals 渲染到 body 上： context（传递公共信息） 公共信息（语言、主题）如何传递给每个组件？用props太繁琐，用redux小题大做，使用context将 公共信息（语言、主题）如何传递给每个组件。 例子：在这里只是假设theme为需要使用的主题，在这个例子中，从外向内是App组件（最外层组件）=》Toolbar组件（中间组件）=》ThemedButton组件（class 组件）、ThemeLink组件（函数组件） 父组件做context生产方，创建context，并使用context包裹子组件给子组件获取context的能力： 中间的组件不需要指明往下传递 theme ： 子组件做context消费方，可以获取到父组件中传递的context。 class子组件 直接使用this.context可获取父组件设置的context： 函数子组件 由于没有实例导致没有this，所以： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import React from 'react'// 创建 Context 填入默认值（任何一个 js 变量，这里用字符串）const ThemeContext = React.createContext('light')// 底层组件 - 函数是组件function ThemeLink (props) &#123; // const theme = this.context // 会报错。函数式组件没有实例，即没有 this // 函数式组件可以使用 Consumer return &lt;ThemeContext.Consumer&gt; &#123; value =&gt; &lt;p&gt;link's theme is &#123;value&#125;&lt;/p&gt; &#125; &lt;/ThemeContext.Consumer&gt;&#125;// 底层组件 - class 组件class ThemedButton extends React.Component &#123; // 指定 contextType 读取当前的 theme context。 // static contextType = ThemeContext // 可用ES6 static，也可用 ThemedButton.contextType = ThemeContext render() &#123; const theme = this.context // React 会往上找到最近的 theme Provider，然后使用它的值。 return &lt;div&gt; &lt;p&gt;button's theme is &#123;theme&#125;&lt;/p&gt; &lt;/div&gt; &#125;&#125;ThemedButton.contextType = ThemeContext // 指定 contextType 读取当前的 theme context。// 中间的组件再也不必指明往下传递 theme 了。function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;ThemeLink /&gt; &lt;/div&gt; )&#125;class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; theme: 'light' &#125; &#125; render() &#123; return &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt; &lt;Toolbar /&gt; &lt;hr/&gt; &lt;button onClick=&#123;this.changeTheme&#125;&gt;change theme&lt;/button&gt; &lt;/ThemeContext.Provider&gt; &#125; changeTheme = () =&gt; &#123; this.setState(&#123; theme: this.state.theme === 'light' ? 'dark' : 'light' &#125;) &#125;&#125;export default App 异步组件（懒加载） 使用场景：组件比较大 或者需要 懒加载 时，我们可以使用 异步组件来做（性能优化） vue中可用import()，react中可用React.lazy+React.Suspense(见下方例子)或者使用react-loadable模块 例子： 使用React.lazy+React.Suspense实现异步组件： 使用react-loadable模块 实现异步组件 的例子 【重点】性能优化 比起vue，性能优化对于React更加重要。因为react本身设计的shouldComponentUpdate默认是返回true的，也就是说父组件一更新就会带着所有子组件重新渲染，不管子组件是否有数据变化（是否需要重新渲染）。 回顾讲setState时重点强调的不可变值 措施： 使用shouldComponentUpdate()避免不必要的子组件渲染（注意搭配state不可变值） state数据设计为浅层（不要出现二维数组之类的），避免深拷贝或者深度比较（他们需要一次性递归，很消耗性能） class组件 使用 PureComponent ，它自带浅比较，不需要我们手写shouldComponentUpdate()【需要将state数据设计为浅层】；函数组件 使用 React.memo，可用函数代替shouldComponentUpdate()，解决函数组件没有生命周期函数的问题 immutable.js可生成不可变的对象，它基于共享数据（不是深拷贝），速度快性能好，但有一定学习和迁移成本，按需使用。（补充：redux-immutable库的combineReducers()可使合成各个组件的reducer得到的就是immutable对象） shouldComponentUpdate（简称SCU） React默认机制：父组件有更新，（不管子组件是否有改变）子组件也无条件也更新！！！所以我们需要优化react，避免不必要重复渲染的子组件被带着渲染来影响性能。 如不设置shouldComponentUpdate 则默认返回true，代表可以渲染： 使用shouldComponentUpdate做 性能优化：shouldComponentUpdate()会接收新的Props和State值作为参数，并且给了我们权利去决定什么时候返回false来拒绝重复渲染 SCU优化一定要每次都用吗？其实不是，需要的时候才优化，如果页面不卡顿就可以不用，一切以开发为主 SCU一定要配合state不可变值 原因：如果state不是不可变值，即它在setState前被改变了，则SCU中拿到的nextState和state是相同的，导致该重新渲染时被判断为不可重新渲染。（lodash库的isEqual可进行深度比较，对于引用类型，===是会比较地址的，而 lodash库的isEqual 则只是比较内容物是否相等） 例子： 总结：所以SCU一定要配合state不可变值才能保证不会出错 注意：深度比较 很耗费性能，需要进行一次性递归到底，设计state时设计的浅一些来避免使用深度比较会好一些（React的PureComponent和 React.memo就实现了自带浅比较来决定是否重新渲染） PureComponent 和 React.memo React的PureComponent（纯组件）实现了自带浅比较，它只对比state和props数据的第一层，比起 深度比较 性能更好。 注意：PureComponent也要搭配state不可变值（即不能改变state本身） 让 class组件 继承PureComponent，不需要手写SCU，它自带SCU并实现了浅比较（PureComponent的例子） memo，即 函数组件 中的PureComponent：可用函数代替shouldComponentUpdate()，解决函数组件没有生命周期函数的问题 浅比较已适用大部分情况（尽量不要做深度比较），这就需要我们在react中设计state时尽量扁平，不要一层套一层 不可变值immutable.js immutable.js彻底拥抱“不可变值”，它基于共享数据（不是深拷贝），速度快性能好，但有一定学习和迁移成本，按需使用。 深拷贝的性能差 具体使用可参考博客“简书Header组件开发（使用immutable.js库、redux-immutable库）” 例子： 按需使用 &amp; state层级 不是任何时候都需要使用性能优化，不卡顿可不用 state层级设计的浅一些可避免深拷贝/深度比较等耗费性能的操作 组件公共逻辑的抽离 mixin已被React弃用 高阶组件HOC Vs Render Props 按需使用即可 高阶组件HOC：模式简单，但会增加组件层级（需要考虑透传props以及是否会被覆盖的问题） Render Props：代码简洁，学习成本较高 高阶组件HOC 高阶组件不是一种功能，是一种模式，他是一个函数，这个函数接受一个组件并返回一个新组件 高阶组件负责公共逻辑，传入的组件 传出后 生成的新组件 就会带上这部分逻辑 定义高阶组件时 需要向 传入的组件 传递自己的所有props（包括别人传过来的），这样传入的组件才能获取使用（详情见下面例子） 高阶组件的定义：创建一个函数，接受一个组件A，在函数内创建组件B将组件A包裹并给他逻辑，最后返回组件B。 例子 实现效果：鼠标划过时显示鼠标位置 思路：假设很多组件都要使用这个逻辑，那么怎么将这个逻辑抽离出来？在 高阶组件 的函数中实现鼠标滑动的逻辑，App组件（函数组件）只需要负责渲染，最终返回的是 App组件通过高阶组件来返回的新组件（已经包含了逻辑的App组件） 代码： react-redux connectreact-redux connect也是高阶组件 connect(函数1，函数2)返回的是高阶组件的函数（回顾：redux-thunk中间件使action可以为函数） 在调用1返回的函数并将组件TodoList传入，得到的就是新的组件 render props 高阶组件 是高阶组件（负责逻辑）包含组件A（负责渲染）（即 逻辑包含渲染）；render props 是 组件A包含class组件，class组件（负责逻辑）中包含函数组件（负责渲染（即 逻辑包含渲染）。 区分 高阶组件 和 render props 的包裹关系： 思路： 左图定义一个class组件Factory，在class组件中将state作为参数传给 函数（组件）render（注意：class组件需要设置propTypes来规定必须接收一个 render 属性，而且是函数（具体见下方例子）） 右图是调用class组件Factory时，在render属性上定义一个函数组件render，该组件通过参数获取到父组件Factory中传过来的数据（state） 例子： 实现效果：鼠标划过时显示鼠标位置 代码：获取App的父组件的值的方法比使用 高阶组件 要简单，毕竟App组件就是最外层，不需要透传所有props。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JS 深度比较 与 `===`","slug":"JS 深度比较 与 ===","date":"2020-04-13T07:20:44.000Z","updated":"2020-07-29T07:48:58.177Z","comments":true,"path":"2020/04/13/JS 深度比较 与 ===/","link":"","permalink":"http://yoursite.com/2020/04/13/JS 深度比较 与 ===/","excerpt":"可以回顾何时使用==何时使用===","text":"可以回顾何时使用==何时使用=== 全等比较（严格相等） 当我们使用===比较引用类型时，是会对地址进行比较的，所以就算属性和属性值完全相等的两个对象也是不等的。 深度比较 深度比较则不会对引用类型的地址进行比较，只要内容相等就判定为相等。 可以使用lodash库的isEqual()来进行深度比较，也可以自己使用js写 回顾：lodash库的cloneDeep()可以用来深拷贝引用类型 注意：lodash库的 isEqual()深度比较 和 cloneDeep()深拷贝 都很耗费性能，他们都要进行一次性递归到底。轻易不推荐使用。 js实现深度比较思路： 先判断2个对象的数据类型是否一致。 如果对象的数据是基础的数据类型则直接比较; 如果是 Number, 对NaN进行特殊处理。 如果对象的数据类型是 Array，对象进行循环, 逐值进行判断。 如果对象的数据类型是 Object，分别对象的key, value 进行判断。（Reflect.ownKeys() 返回一个由目标对象自身的属性键组成的数组） 如果对象的数据类型是 Map 或者 Set， 转化为Array进行判断。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * * 返回对相应的数据类型 */ function getType(data) &#123; return Object.prototype.toString.call(data).substring(8).split(/]/)[0] &#125; // 假设data为123 // Object.prototype.toString.call(data)得到\"[object Number]\" // substring从第八位开始截取，得到\"Number]\" // split从]分隔为数组，取第一位，得到Number // 注意：NaN也会得到Number，但NaN.toString()可得NaN /** * * @param &#123;*&#125; sourceObj * @param &#123;*&#125; compareObj * * 比较对象是否相等 * */ function comparisonObject(sourceObj, compareObj) &#123; if (arguments.length &lt; 2) throw \"Incorrect number of parameters\"; let sourceType = getType(sourceObj); if (sourceType !== getType(compareObj)) return false; // Not objects and arrays if (sourceType !== \"Array\" &amp;&amp; sourceType !== \"Object\" &amp;&amp; sourceType !== \"Set\" &amp;&amp; sourceType !== \"Map\") &#123; if (sourceType === \"Number\" &amp;&amp; sourceObj.toString() === \"NaN\") &#123; return compareObj.toString() === \"NaN\" &#125; if (sourceType === \"Date\" || sourceType === \"RegExp\") &#123; return sourceObj.toString() === compareObj.toString() &#125; return sourceObj === compareObj &#125; else if (sourceType === \"Array\") &#123; if (sourceObj.length !== compareObj.length) return false; if (sourceObj.length === 0) return true;//??? for (let i = 0; i &lt; sourceObj.length; i++) &#123; if (!comparisonObject(sourceObj[i], compareObj[i])) return false; &#125; &#125; else if (sourceType === \"Object\") &#123; // 通过Reflect.ownKeys得到属性名组成的数组 let sourceKeyList = Reflect.ownKeys(sourceObj); let compareKeyList = Reflect.ownKeys(compareObj); let key; if (sourceKeyList.length !== compareKeyList.length) return false; for (let i = 0; i &lt; sourceKeyList.length; i++) &#123; key = sourceKeyList[i]; // 比较属性名 if (key !== compareKeyList[i]) return false; // 比较属性值 if (!comparisonObject(sourceObj[key], compareObj[key])) return false; &#125; &#125; else if (sourceType === \"Set\" || sourceType === \"Map\") &#123; // 把 Set Map 转为 Array if (!comparisonObject(Array.from(sourceObj), Array.from(compareObj))) return false; &#125; return true; &#125;","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"React知识点汇总（基础使用2）","slug":"React知识点汇总（基础使用2）","date":"2020-04-12T08:55:56.000Z","updated":"2020-11-24T15:34:02.375Z","comments":true,"path":"2020/04/12/React知识点汇总（基础使用2）/","link":"","permalink":"http://yoursite.com/2020/04/12/React知识点汇总（基础使用2）/","excerpt":"【重点】setState 不可变值 可能是异步更新 可能会被合并","text":"【重点】setState 不可变值 可能是异步更新 可能会被合并 state 要在构造函数中定义 函数组件（后面会讲），默认没有 state 不能直接修改 state ，使用 不可变值 不能直接修改 state，需要使用setState。也不能提前修改state再使用setState，在setState中什么使用需要state再进行修改。 简单例子：修改state中的值类型（原因：shouldComponentUpdate中具体阐述） 修改state中的引用类型 原则：在setState中使用的方法都不能改变state中的原数组/对象（比如数组的push pop splice都不能使用），或者在setState前先拷贝数组/对象来进行操作。 【数组】state中存放 数组时，需要注意不能直接对 this.state.list 进行 push pop splice 等会直接改变原数组（state中数据）的操作，这样违反不可变值。需要做复杂操作时，可先拷贝出来再进行操作。（ES6 filter-数组过滤方法） 【对象】巧用assign方法将state中对象放在参数2，则可不改变state中原对象。 setState 可能是异步/同步更新 直接在JSX中使用 setState 是异步的（即 合成事件 中setState是异步的）： setTimeout 中 setState 是同步的： 自定义的 DOM 事件中 setState 是同步的（即原生DOM事件中是同步的，只要html中能正常跑起来的绑定方法就是原生DOM事件）：在body上绑定自定义的click事件，在该DOM事件中setState 是同步的 注意：“自定义的 DOM 事件”的概念，onclick是DOM事件，通过addEventListener绑定的click事件是“自定义的 DOM 事件”，JSX中的onClick是 合成事件 setState异步更新前合并/不合并 state 异步更新时，setState中传入对象，会被合并，执行结果只一次，点击一次“累加”按钮的执行结果是 +1：一样用点击按钮累加数字作为例子，点击事件的事件函数increase中设置3次setState，由于这里是异步的setState，所以点击按钮时，系统会发现setState3次都是一样的修改，最后会被合并为1次（即每次点击都只+1不会+3 ） state 异步更新时，setState中传入函数，不会被合并。点击一次“累加”按钮的执行结果是 +3：函数是无法合并的，所以三个函数都会生效 组件生命周期 React 组件生命周期图示 更多可参考博客“React高级内容（2）”","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React知识点汇总（基础使用1）","slug":"React知识点汇总（基础使用1）","date":"2020-04-11T08:02:36.000Z","updated":"2020-09-29T04:01:28.200Z","comments":true,"path":"2020/04/11/React知识点汇总（基础使用1）/","link":"","permalink":"http://yoursite.com/2020/04/11/React知识点汇总（基础使用1）/","excerpt":"JSXJSX中使用原生html（dangerouslySetInnerHTML属性）想要让原生html在JSX中正常显示，需要将其写在dangerouslySetInnerHTML属性内：","text":"JSXJSX中使用原生html（dangerouslySetInnerHTML属性）想要让原生html在JSX中正常显示，需要将其写在dangerouslySetInnerHTML属性内： 条件判断(和js使用方法一样)if else、三元表达式、逻辑运算符&amp;&amp;/||： map()渲染列表map():可参考React.js基础精讲，需要注意map不会改变原数组，且它的返回值（数组）可直接渲染在页面上，不需要另外拆分 事件react事件函数为何需要bind绑定this 关于this可参考博客“JS作用域和闭包”，关于 react事件函数为何需要bind绑定this 可参考博客“bind()” react中的事件函数需要在构造函数中使用bind()绑定this后才能在事件函数中使用this，否则事件函数中的this默认是undefined。我们需要绑定this使得无论事件函数如何传递，它的this的指向都是固定的，固定指向我们所实例化的对象（父组件） 例子： 不需要bind this 事件函数的方法 借助react-redux库使用redux管理数据则不存在需要bind绑定this的事情，毕竟不存在this.setState或者this.state，直接操作state就行。 使用箭头函数定义事件函数，则this固定指向当前组件： 关于event参数（事件对象） 系统在调用事件函数时，把事件会发生的一切信息，都封装成一个对象，然后作为一个参数传递给事件处理程序，而这个对象就是事件对象。在原生的函数中，经常会看见一个event的东西，而这个东西就是我们说的事件对象。 调用事件函数时不传参数，则事件函数的定义中获取到的参数为event（当前元素）。 例子： react中的event 是react封装的 SyntheticEvent（组合事件【合成对象】），模拟出了 DOM 事件对象 所有的能力 event.nativeEvent 才是原生事件对象 react中所有的事件都被挂载到 document 上，而原生的事件是绑定到DOM上面的 react事件 和 DOM 事件不一样，和 Vue 事件也不一样 传递自定义参数 事件函数传递自定义参数时，在事件函数的定义中可在最后追加一个参数，即可接收 event 例子： 表单（受控组件） 受控组件:组件的值（value/checked）可受到state的控制（即state变化时组件值变化） 非受控组件（在后面的“高级特性”博客中详细讲解）：组件中的值无法受state的控制 例子：比如input组件，想要页面上实时显示我们输入的内容是需要让其value与state相关联的（注意区别 defaultValue属性 和 value属性） 注意： 常见的受控组件： input组件（checkbox、radio）、textarea组件、select组件 textarea组件 也是受控组件，但在react中需要使用&lt;textarea/&gt;，而html中是&lt;textarea&gt;&lt;textarea/&gt;。 在react中label标签使用htmlFor代替for属性。 区别 defaultValue属性 和 value属性 注意：区别react中input的 defaultValue属性 和 value属性 react中input的defaultValue就相当于原生DOM中的value属性，这样写出来的组件，其value值就是用户输入的内容，和react没有关系，完全不管输入的过程。 而react中input的value属性必须使用onChange来监听这个input，使state和input关联（即 受控组件） 如果在使用input时只需要获取model里的值时，使用defaultValue就可以了。如果需要获取model的值并且还需要改变它的时候，就需要使用value结合onChange事件与state联系就可以了。（但还是尽量使用value，毕竟defaultValue需要结合ref来获取DOM元素，而react的设计初衷就是尽量不要操作DOM，通过state来带动DOM） input textarea select用value textarea组件： select组件： input组件例子在上方 checkbox radio用checked checkbox： radio： 组件使用props类型检查（propTypes） PropTypes 强校验可参考博客“React高级内容（1）” 子组件在接受父组件传过来的值（即 属性 ）时进行强校验。他可以要求父组件给子组件传的值是什么类型的。如若不是也并不会报错，只会在 开发者工具 中给出警告。 props传递数据/函数(React父子组件通讯) 基础通讯方法 可参考博客 围绕 React 衍生出的思考，还可以使用redux管理数据 父组件向子组件传值/函数：在父组件中调用子组件的同时通过给子组件添加属性的方式向子组件传值/函数，注意如要传递函数，则需在父组件构造函数中使用bind绑定该函数this指向 子组件使用父组件传递的值/函数：通过{this.props.属性名/函数名}来调用 子组件修改父组件中数据的方法：子组件通过调用父组件传递过来的函数间接的操作父组件的数据 数据（状态）提升 数据（状态）提升：将数据提到最高的组件中存放。 设计思路：数据都放在 父组件 中进行管理，父组件将数据下发到各个子组件中进行处理/渲染。 例子：","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React知识点汇总（项目）","slug":"React知识点汇总（项目）","date":"2020-04-10T02:55:36.000Z","updated":"2020-10-24T08:08:25.826Z","comments":true,"path":"2020/04/10/React知识点汇总（项目）/","link":"","permalink":"http://yoursite.com/2020/04/10/React知识点汇总（项目）/","excerpt":"总结遇到过的性能优化 【构造函数内绑定事件函数this指向】：在constructor函数里绑定 事件函数 的 this指向（bind），而不是在事件函数内绑定，这样可以保证整个程序里只绑定一次，且可以避免 子组件 的无谓渲染。","text":"总结遇到过的性能优化 【构造函数内绑定事件函数this指向】：在constructor函数里绑定 事件函数 的 this指向（bind），而不是在事件函数内绑定，这样可以保证整个程序里只绑定一次，且可以避免 子组件 的无谓渲染。 【异步setState】：React的底层内置的setState是异步的，可以把多次的数据改变结合成一次来做，降低了 虚拟DOM 的比对频率。 【虚拟DOM】：React的底层用了虚拟DOM的概念，替代了之前的 真实的DOM（JS对象）。 【diff算法】：React的 diff算法： 同层比对、key值的运用 来提升 虚拟DOM 比对的速度。 【shouldComponentUpdate/PureComponent避免不必要的子组件render函数的渲染更新】： 借助生命周期函数shouldComponentUpdate来提高组件性能，避免不必要的子组件render函数的渲染更新。（例子在“React高级内容（3）”） 更为简单的方法可参考下面的“PureComponent” 让组件继承 react提供的PureComponent（替代手写shouldComponentUpdate）判断只有和本组件有关的数据更新时，本组件的render函数才执行，否则return false不让组件重新渲染。通过避免虚拟DOM的比对来提高性能。 【使用react-router-dom库进行路由跳转】：使用react-router-dom的Link组件进行页面跳转，跳转时不会发送HTTP请求，因此加载速度会快很多，借此也可提高性能。 【异步加载组件】：可使用react-loadable模块实现异步加载组件解决首屏加载慢的问题。 React中的CSS 比较麻烦，因为官方没有集成方案，也没有推荐具体的方案 但社区方案众多，可以根据需求进行选择 css modules （babel）react-css-modules styled components：直接在单独的js文件中将样式写在组件里（也可以修饰现有的组件），然后直接使用带有样式的组件：从Div组件可以明确：styled components不仅可生成带样式组件，还可获取组件属性设置特殊样式，例子中就规定了big属性的Div组件字体大小为72px（涉及ES6的模板字符串和变量的使用方法） styled jsx：简单粗暴，在jsx中允许直接写入css 使用antd时用styled-Components修改部分样式 参考方法1：新建一个 styled-components 组件 Test 包裹在想要修改的antd组件外，然后通过从 Test 中操作其子代CSS样式对目标antd组件进行样式修改（给作为子组件的antd组件添加className）。 操作其子代CSS样式的方法可参考博客“styled-components的使用方法”中&amp;的使用方法 参考方法2：直接在存放css样式的js文件中输出样式,再在js文件中引入样式并使用即可：123456//css.jsimport styled from 'styled-components';export const btnStyle = &#123; background:'pink'&#125; 12345678910import React from 'react';import &#123; Button &#125; from 'antd'; import &#123; btnStyle &#125; from './style'const TodoListUI = (props) =&gt; &#123; return ( &lt;Button style=&#123;btnStyle&#125;type=\"danger\" onClick=&#123;props.handleBtnClick&#125;&gt;提交&lt;/Button&gt; )&#125;export default TodoListUI; 路由跳转（react-router-dom的Link组件） 注意：react是 单页应用的跳转，也就是说，不管怎么进行页面跳转，整个网站只会加载一次html文件，这也就决定了不能使用&lt;a&gt;标签进行页面跳转。 如果使用&lt;a&gt;标签进行页面跳转，跳转时会发送HTTP请求。而借助react-router-dom的Link组件实现跳转则不会，因此加载速度会快很多，借此也可提高性能。 react-router-dom的Link组件 例子 路由传值 可参考react-router-dom的使用 个人觉得，【react的url中传递参数值】组件的跳转路径上最好使用/:参数值的方法传值，这样组件中可以直接使用this.props.match.params.参数名获取所传参数值。【react将参数值传递给node】在react的组件的action中通过ajax请求的路径中使用?key=value来传值，这样在node中通过queryString.parse可直接得到JSON对象 遇到过的问题 模拟接口数据（Charles抓包/mockjs/public下新建api文件夹） 路由跳转时 Link组件 必须在router的内部（例子、react-router-dom、react中路由相关知识点）","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"ES6 Map和Set","slug":"ES6 Map和Set","date":"2020-04-09T04:21:51.000Z","updated":"2020-07-27T04:22:15.088Z","comments":true,"path":"2020/04/09/ES6 Map和Set/","link":"","permalink":"http://yoursite.com/2020/04/09/ES6 Map和Set/","excerpt":"ES6规范引入了新的数据类型Map和Set","text":"ES6规范引入了新的数据类型Map和Set Map 键值对二维数组 具体使用和更多方法可参考廖雪峰的博客 Map是一组键值对的结构，具有极快的查找速度。 【创建方法】用Map实现，只需要一个“名字”-“成绩”的对照表，可直接根据名字查找成绩： 12var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);m.get('Michael'); // 95 初始化Map需要一个二维数组，或者直接初始化一个空Map 该二维数组中一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉 Set 数组去重 具体使用和更多方法可参考廖雪峰的博客 Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。 【创建方法】要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set： 12var s1 = new Set(); // 空Setvar s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在Set中自动被过滤(注意 数字3 和 字符串3 是不同的元素)： 12var s = new Set([1, 2, 3, 3, '3']);s; // Set &#123;1, 2, 3, \"3\"&#125; 数组相关的面试题微信 一个学前端的码农 一道 JS 数组相关的面试题（答案用不到Set）问题：给定一个有序数组，数组里有重复元素，要求原地操作数组，删除重复元素。 设置一个 temp 变量，用来临时存储每一个不重复的数 在原数组上循环，i为循环的index，设置len为不重复数的index（也就是将不重复数替换到 原数组[len] 位置上，这样就不用新开一个数组了） 先将temp设置为arr[0]，len设置为1，然后从i=1开始遍历数组，将arr[i]与temp比较，相同就不管，i++进行下一次循环，不同时将arr[i]赋给arrlen，再将arr[i]拿去替换temp（即换掉下一次循环的比较对象），最后len++（使得下一次替换的原数组index+1） 全部去重后，使用splice(len)将len后面的多余数据删掉","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS动画","slug":"CSS布局面试题","date":"2020-04-08T04:48:37.000Z","updated":"2020-11-04T08:20:28.957Z","comments":true,"path":"2020/04/08/CSS布局面试题/","link":"","permalink":"http://yoursite.com/2020/04/08/CSS布局面试题/","excerpt":"CSS中的动画类型 transition补间动画：有开头结尾两个状态，中间靠脑补（需要状态变化来带动） @keyframe+animation关键帧动画：相当于有很多个补间动画，多个状态之间靠脑补（不需要状态变化来带动） 逐帧动画：不需要靠脑补（属于animation关键帧动画的特殊用法）","text":"CSS中的动画类型 transition补间动画：有开头结尾两个状态，中间靠脑补（需要状态变化来带动） @keyframe+animation关键帧动画：相当于有很多个补间动画，多个状态之间靠脑补（不需要状态变化来带动） 逐帧动画：不需要靠脑补（属于animation关键帧动画的特殊用法） transition补间动画 CSS3 transition属性，需要状态变化来带动 位置-平移（left/right/margin/transform） 方位-旋转（transform） 大小-缩放（transform） 透明度（opacity） 其它-线性变换（transform） 网页上调试动画 可自定义速度曲线其中transition-timing-function属性规定的速度曲线可自定义，比如使用https://matthewlein.com/tools/ceaser @keyframes+animation关键帧动画 CSS3 @keyframes、CSS3 animation（动画） 属性相当于多个transition补间动画，与元素状态的变化无关，定义更加灵活。 animation简写的属性和transition极其相似但比他多，第二开始依次是动画效果时长、速度效果的速度曲线、过渡效果何时开始等等。 逐帧动画 逐帧动画是使用animation关键帧动画实现的，只是去除了补间动画效果 适用于无法补间计算的动画（即两个状态之间无法计算的情况） 资源较大，影响性能，过长或者过大的动画不适合使用逐帧来实现 在动画速度曲线的属性中使用steps()去除补间动画效果 steps()中的数字其实表示希望两个关键帧之间产生几个画面，所以设置steps(1)即表示只产生1个画面，也就是去除补间动画效果。 例子 相关面试题考查的最多的是transition和animation+@keyframes的语法，怎么写 CSS动画的实现方式有几种 CSS3 transition CSS3 animation+CSS3 keyframes 过渡动画和关键帧动画的区别 过渡动画需要有状态变化(即需要事件去触发动画效果) 关键帧动画不需要状态变化 关键帧动画能控制更精细 如何实现逐帧动画 使用关键帧动画（animation）实现 在控制 动画速度曲线的属性animation-timing-function 属性 中进行设置来去掉补间（steps） CSS动画的性能（JS也可实现动画） CSS动画性能不坏 部分情况下优于JS（因为JS实现动画的库有很多，这之间性能相差也很大） 但JS可以做到比CSS更好（因为CSS提供的性能优化方式少） CSS动画要注意部分高危属性（box-shadow等），很消耗CPU性能 react中的动画 react中也可使用transition/animation+@keyframes，更方便的有第三方库，可参考博客文章“使用react-transition-group实现动画”","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS动画","slug":"CSS动画","date":"2020-04-08T04:48:37.000Z","updated":"2020-07-21T04:49:24.468Z","comments":true,"path":"2020/04/08/CSS动画/","link":"","permalink":"http://yoursite.com/2020/04/08/CSS动画/","excerpt":"CSS中的动画类型 transition补间动画：有开头结尾两个状态，中间靠脑补（需要状态变化来带动） @keyframe+animation关键帧动画：相当于有很多个补间动画，多个状态之间靠脑补（不需要状态变化来带动） 逐帧动画：不需要靠脑补（属于animation关键帧动画的特殊用法）","text":"CSS中的动画类型 transition补间动画：有开头结尾两个状态，中间靠脑补（需要状态变化来带动） @keyframe+animation关键帧动画：相当于有很多个补间动画，多个状态之间靠脑补（不需要状态变化来带动） 逐帧动画：不需要靠脑补（属于animation关键帧动画的特殊用法） transition补间动画 CSS3 transition属性，需要状态变化来带动 位置-平移（left/right/margin/transform） 方位-旋转（transform） 大小-缩放（transform） 透明度（opacity） 其它-线性变换（transform） 网页上调试动画 可自定义速度曲线其中transition-timing-function属性规定的速度曲线可自定义，比如使用https://matthewlein.com/tools/ceaser @keyframes+animation关键帧动画 CSS3 @keyframes、CSS3 animation（动画） 属性相当于多个transition补间动画，与元素状态的变化无关，定义更加灵活。 animation简写的属性和transition极其相似但比他多，第二开始依次是动画效果时长、速度效果的速度曲线、过渡效果何时开始等等。 逐帧动画 逐帧动画是使用animation关键帧动画实现的，只是去除了补间动画效果 适用于无法补间计算的动画（即两个状态之间无法计算的情况） 资源较大，影响性能，过长或者过大的动画不适合使用逐帧来实现 在动画速度曲线的属性中使用steps()去除补间动画效果 steps()中的数字其实表示希望两个关键帧之间产生几个画面，所以设置steps(1)即表示只产生1个画面，也就是去除补间动画效果。 例子 相关面试题考查的最多的是transition和animation+@keyframes的语法，怎么写 CSS动画的实现方式有几种 transition keyframes（animation） 过渡动画和关键帧动画的区别 过渡动画需要有状态变化 关键帧动画不需要状态变化 关键帧动画能控制更精细 如何实现逐帧动画 使用关键帧动画（animation）实现 在控制动画速度曲线的属性中去掉补间（steps） CSS动画的性能（JS也可实现动画） CSS动画性能不坏 部分情况下优于JS（因为JS实现动画的库有很多，这之间性能相差也很大） 但JS可以做到比CSS更好（因为CSS提供的性能优化方式少） CSS动画要注意部分高危属性（box-shadow等），很消耗CPU性能","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS预处理器（less与sass）","slug":"CSS预处理器（less与sass）","date":"2020-04-07T05:32:52.000Z","updated":"2020-07-19T05:44:35.775Z","comments":true,"path":"2020/04/07/CSS预处理器（less与sass）/","link":"","permalink":"http://yoursite.com/2020/04/07/CSS预处理器（less与sass）/","excerpt":"CSS预处理器 CSS预处理器是基于CSS的另一种语言 通过工具编译成CSS 添加了很多CSS不具备的特性 能提升CSS文件的组织方式","text":"CSS预处理器 CSS预处理器是基于CSS的另一种语言 通过工具编译成CSS 添加了很多CSS不具备的特性 能提升CSS文件的组织方式 作用： 嵌套：反映层级，约束选择器范围 变量和计算：减少重复代码，方便维护 Extend和Mixin：复用代码片段（公共样式的class/清除浮动，将以前在html中的工作放到预处理器中完成） 循环：适用于复杂有规律的样式（比如表格、动画） import：CSS文件模块化（可以按照模块的方式组织css文件，不再受限于http加载的问题） less与sass 对比安装 less： less是基于node的 非全局安装（安装到项目下）：npm i less则调用时使用./node_module/.bin/lessc 其他参数 其他参数：xxx.less&gt;yyy.css即将less文件编译后放入css文件 全局安装：npm i less -g则调用时使用lessc 其他参数 sass： 非全局安装（安装到项目下）：npm i node-sass则调用时使用./node_module/.bin/node-sass 其他参数 其他参数：xxx.scss&gt;yyy.css即将sass文件（后缀为scss）编译后放入css文件 全局安装：npm i node-sass -g则调用时使用node-sass 其他参数 嵌套 less嵌套： sass嵌套：sass语法和less类似。除了换行，其他和less编译的css没有区别 变量和计算 less中变量语法：@变量名:变量值(带单位); sass中变量语法：$变量名:变量值(带单位); 语法不同的原因： less是尽量接近CSS语法 sass是觉得自己和CSS既然不兼容，就要避免产生混淆，因为@在CSS中是有意义的 less的例子： sass：语法不同，例子和结果除了空行上的区别，其他是没有区别的（background的函数也是相同的） mixin 复用CSS代码 mixin：实现一大段CSS代码的复用（以前只能在HTML中实现），相当于将一段CSS代码复制到调用mixin的地方。 less： 语法： 定义mixin：选择器(可传参){CSS规则}和普通class的语法基本没区别 调用mixin：选择器(可传参)和普通调用class一样 注意： 有括号的mixin 不会被编译到CSS文件中 mixin 可以不加括号，但是不加括号的mixin 会被编译到CSS文件中 例子： sass： 语法： 定义mixin：@mixin 名称(可传参){CSS规则} 调用mixin：@include 名称(可传参) 注意： 定义时不是选择器名称！是自定义的mixin名称 例子： extend 复用CSS代码 当我们频繁使用mixin时，就会导致编译产生的CSS文件中出现大量选择器中有一部分都是相同的代码。此时若是手写的CSS，我们会将同样的代码提出来写在公共class中，以此减小CSS文件体积。extend也可以做到这样的效果 作用： 将mixin代码提取出来作为公共样式（如果直接使用mixin则是疯狂复制），比起直接使用mixin 产生的css代码量会更少，但是十分复杂的情况下直接使用mixin会更好。 使用extend增加了代码的可维护性。 less： 语法： 方法1：当前选择器:extend(mixin的选择器名){当前选择器匹配的CSS规则} 方法2：当前选择器{CSS规则;&amp;:extend(mixin的选择器名);其他CSS规则} 例子： sass： 语法：当前选择器{CSS规则;@extend mixin的选择器名;当前选择器匹配的CSS规则} 例子： loop 循环 less： less中没有循环，但是mixin可以自己调用自己，所以可以通过mixin递归实现循环的效果。 例子：](http://ww1.sinaimg.cn/large/005H7IVsgy1ggswfwbuxwj30q70hmtj2.jpg) sass： sass的循环实现更加简单，因为sass支持for循环。但也可以像less那样实现，只是要注意less是外部使用when，而sass是内部使用if 例子： sass支持的for来实现循环：生成的css文件和less例子生成的一样（只是多了空格） 【不推荐】像less的实现方式： import CSS模块化 在CSS中是可以使用import语句的，但是引入的css样式表并不会进行合并，加载的时候也不会复用，他只会在加载的时候去链接一个个的css样式表，即发出的http请求数并不会因为import而减少。而预处理器的import会在编译时将css样式表编译到一起，最后产生的是一整个css样式表，可减少发出的http请求数，提高加载性能。 预处理器中的变量可以跨文件使用， 有了import以后css文件就可以按照结构划分，而不用为了性能而将所有css写到一个文件中，这样有利于维护。 语法：@import &quot;相对路径的less或者sass文件名&quot;（可忽略文件名后缀） less： 在实际项目中module1和module2不会那么一致，这里只是演示 在实际项目中就可以把不同的区域样式独立在不同less文件中再最后import在一起编译出一个整体： sass：sass的import语法和less是一样的，唯独需要注意sass的变量定义方法和less不同：编译结果和使用less是一样的 预处理器框架 使用预处理器框架可按需使用别人的css代码 目前流行的预处理器框架： SASS中有Compass(例子) Less中有Lesshat/EST 作用： 提供现成的mixin 类似JS类库，封装常用功能 EST EST是由百度工程师写的 基本特性： variables是规定好的全局变量，比如使用@support-html5来添加支持 HTML5 新元素相关的代码（默认不支持，需要额外添加的css代码） normalize用来归一化不同浏览器下的页面样式，相当于之前讲过的CSS Reset重置样式，使用EST时只需.global-normalize();就相当于一大段CSS代码了 reset功能同上，也是相当于之前讲过的CSS Reset重置样式 compatibility提供基础的兼容性封装。 grid帮助生成自定义的栅格布局（网格布局），实际编译后是采用浮动来实现的。 .make-row()让元素变为行（栅格外部容器） .make-column()让元素变为列（栅格单列容器） 例子： less文件： html文件：引用编译后的less文件 效果： shapes绘制基本形状的功能（比如：三角形），例子在上面grid例子最底部 面试题常见的CSS预处理器 Less：原生使用Node.js编写 Sass：原生使Ruby编写，官方有提供Node版本，但该版本是由c++编写，安装可能比较麻烦 预处理器的作用 帮助更好地组织CSS代码 提高代码复用率 提升可维护性 预处理器的能力 嵌套：反映层级，约束选择器范围 变量和计算：减少重复代码，方便维护 Extend和Mixin：复用代码片段（公共样式的class/清除浮动，将以前在html中的工作放到预处理器中完成） 循环：适用于复杂有规律的样式（比如表格、动画） import：CSS文件模块化（可以按照模块的方式组织css文件，不再受限于http加载的问题） 预处理器的优缺点 优点：提高代码复用率和可维护性 缺点： （开发/发布都）需要引入编译过程 有学习成本（虽然看起来像css语法，但是less和sass都有自己独立的语法） 推荐使用预处理器吗不一定，随着前端工程化的发展，对于css方面的提升有了更多的手段，预处理器不再是唯一的手段，所以还可能有别的方式来处理css所面临的问题。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"前端基础-CSS（2）","slug":"前端基础-CSS（2）","date":"2020-04-06T02:40:39.000Z","updated":"2020-11-21T03:26:07.881Z","comments":true,"path":"2020/04/06/前端基础-CSS（2）/","link":"","permalink":"http://yoursite.com/2020/04/06/前端基础-CSS（2）/","excerpt":"CSS3新特性 可参考博客","text":"CSS3新特性 可参考博客 CSS3边框如border-radius，box-shadow,border-image：CSS3边框图片。通过 CSS3 的 border-image 属性，您可以使用图片来创建边框。； CSS3背景如background-size，background-origin规定背景图片的定位区域。背景图片可以放置于 content-box、padding-box 或 border-box 区域。 CSS3文字效果： text-shadow：在 CSS3 中，text-shadow 可向文本应用阴影。text-shadow:5px 5px 5px #FFFFFF; word-wrap :单词太长的话就可能无法超出某个区域，允许对长单词进行拆分，并换行到下一行：p{word-wrap:break-word;} CSS3 2D，3D转换如transform等； CSS3动画如transition、animation等 布局方面新增了flex属性 选择器方面新增了例如:first-of-type,:nth-child等选择器 盒模型方面添加了box-sizing来改变盒模型 颜色方面添加opacity(透明)，rgba等 最后还有@media查询(媒体查)等 transition和animation的区别 animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值(过渡动画效果) 主要区别: transition需要触发一个事件才能改变属性，而animation 不需要触发任何事件的情况下才会随时间改变属性值(transition例子/animation例子) transition为2帧，从from .... to，而animation可以一帧一帧的。 css动画如何实现 创建动画序列，需要使用animation属性或其子属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 @keyframes规则实现，具体情况参见使用keyframes定义动画序列小节部分。 transition也可实现动画。transition强调过渡，是元素的一个或多个属性发生变化时产生的过渡效果，同一个元素通过两个不同的途径获取样式，而第二个途径当某种改变发生（例如hover）时才能获取样式，这样就会产生过渡动画。 用的最多的css属性是？ 目前来说最多的是flex属性，方便排版、居中。 transform属性和transition属性，前者单独用来协助子绝父相的居中。两者搭配实现旋转类的动画效果。 @media查询，响应式。 background-size的以contain、cover及border-radius我也十分常用。 CSS3中对溢出的处理 text-overflow属性，值为clip是修剪文本；ellipsis为显示省略符号来表被修剪的文本；string为使用给定的字符串来代表被修剪的文本。 用 CSS 实现多行文本的省略号显示可参考博客CSS 实现单/多行文本的省略号显示 CSS选择器，优先级 可参考百度前端技术学院 第三天学习总结（CSS文本、选择器）（1）、百度前端技术学院 第四天学习笔记（选择器的优先级、了解级联、!important）（4） id 选择器，class 选择器，标签选择器，属性选择器，伪元素选择器，伪类选择器等 同一元素引用了多个样式时，排在后面的样式属性的优先级高； 样式选择器的类型不同时，优先级顺序为：内联样式 &gt; id 选择器 &gt; class 选择器/属性选择器或伪类 &gt; 标签选择器/伪元素； 标签之间存在层级包含关系时，后代元素会继承祖先元素的样式。如果后代元素定义了与祖先元素相同的样式，则祖先元素的相同的样式属性会被覆盖。继承的样式的优先级比较低，至少比标签选择器的优先级低； 带有!important 标记的样式属性的优先级最高； 样式表的来源不同时，优先级顺序为：内联样式&gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式 属性和伪类选择器的优先级 属性选择器和伪类选择器优先级相同 【看】CSS布局 六种布局方式总结：圣杯布局、双飞翼布局、Flex布局、绝对定位布局、表格布局、网格布局。(圣杯布局和双飞翼布局) 圣杯布局是指布局从上到下分为header、container、footer，然后container部分定为三栏布局。圣杯布局的缺陷在于 center 是在 container 的padding中的，因此宽度小的时候会出现混乱。 双飞翼布局给center 部分内加了一个 center-inner 来通过设置margin主动地把页面撑开，这样宽度小的时候不会出现混乱。 Flex布局是由CSS3提供的一种方便的布局方式。 绝对定位布局/)是给container 设置position: relative和overflow: hidden，因为绝对定位的元素的参照物为第一个postion不为static的祖先元素。 left 向左浮动，right 向右浮动。center 使用绝对定位，通过设置left和right并把两边撑开。 center 设置top: 0和bottom: 0使其高度撑开。 表格布局的好处是能使三栏的高度统一。 网格布局可能是最强大的布局方式了，使用起来极其方便，但目前而言，兼容性并不好。网格布局，可以将页面分割成多个区域，或者用来定义内部元素的大小，位置，图层关系。 两栏布局 参考七种实现左侧固定，右侧自适应两栏布局的方法 需知左盒子宽度+两盒子间距： 双inline-block+calc()：由于使用了inline-block，所以需要注意父元素font-size:0来消除子元素之间的空格，子元素设置顶端对齐 双float+calc()：父元素注意创建BFC清除浮动（display:flow-root） float+margin-left：父元素注意创建BFC清除浮动（display:flow-root） 子绝父相+margin-left：注意绝对定位脱离文档流，所以若左侧盒子高于右侧盒子，就会超出父容器的高度。因此只能通过设置父容器的min-height来放置这种情况。 只需知道间距： float+BFC：这个方案同样是利用了左侧浮动，但是右侧盒子通过overflow: auto;形成了BFC，因此右侧盒子不会与浮动的元素重叠。 flex：左边flex: 0 0 auto;即原始大小不缩放，右边flex: 1 1 auto;即按照比例缩放 注意，flex容器的一个默认属性值:align-items: stretch;导致了列等高的效果，需要设置: align-items: flex-start; grid布局 calc属性 calc函数用于动态计算长度值。 任何长度值都可以使用calc()函数计算，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)； 当其为负数时，会使用最小值而不是消失 三栏布局 其实圣杯布局和双飞翼布局本质就是三栏布局 实现思路：先把最重要的身体部分放好，然后再将翅膀移动到适当的地方 三列布局又分为两种，两列定宽一列自适应，以及两侧定宽中间自适应，可参考CSS布局面试题、圣杯布局和双飞翼布局的例子 两列定宽一列自适应： 使用float+margin： 左左右设置浮动/都设置成左浮动 使用float+overflow： 给div设置float：left，再给right的div设置overflow:hidden。 这样子两个盒子浮动，另一个盒子触发bfc达到自适应&gt; 使用position(子绝父相)： 父级div设置position：relative，三个子级div设置position：absolute 这个要计算好盒子的宽度和间隔去设置位置，兼容性比较好。 使用table实现： 父级div设置display：table，设置border-spacing：10px//设置相邻单元格的边框间的距离，取值随意。 子级div设置display:table-cell 这种方法兼容性好，适用于高度宽度未知的情况，但是margin失效，设计间隔比较麻烦 flex实现： parent的div设置display：flex； left和center的div设置margin-right；然后right 的div设置flex：1； 这样子right自适应，但是flex的兼容性不好 grid实现： parent的div设置display：grid，设置grid-template-columns属性，固定第一列第二列宽度，第三列auto 对于两侧定宽中间自适应的布局，对于这种布局需要把center放在前面，可以采用 双飞翼布局、圣杯布局 来实现，也可以使用上述方法中的grid，table，flex，position实现。 圣杯布局点击查看圣杯布局代码+效果，重点就是 三栏浮动中间100%宽度+负边距同行+三栏父元素padding向中靠+左右两栏相对定位去左右 html代码中 middle部分首先要放在container的最前部分。然后是left,right 将三者都 float:left （因为middle部分满我们给了百分之百的宽度） 利用负边距布局：此时middle占满了，所以要把left拉到最左边，使用margin-left:-100%，让右边的盒子上去，也就是margin-left：-200px;（注意是负的自己的宽度，这里不是百分号！） 解决中间盒子里的内容被左右盒子覆盖的问题：这时left拉回来了，但会覆盖middle内容的左端，要把middle内容拉出来，所以在外围container加上 padding:0 200px 先利用父级元素设置左右padding的值把父级的三个子盒子往中间挤 再给左右两个盒子加 相对定位+left/right 双飞翼布局重点就是 三栏浮动中间100%宽度+负边距同行+三栏中间盒子main内增加一个内层div（main-inner）设置margin空出左右两栏位置 左翅 left 有200px,右翅 right 是200px，身体main自适应未知 html代码中，main要放最前边，再放left、right 将main left right 都float:left 将main占满 width:100% 此时main占满了，所以要把left拉到最左边，使用margin-left:-100% 同理 right使用margin-left:-200px（到这一步和圣杯布局都是一样的） main内容被覆盖了，圣杯布局是给中间三栏的父元素设置padding将两侧位置空出放置left right。双飞翼布局则使用margin，给三栏的中间盒子main增加一个内层div（main-inner）设置margin, 然后margin:0 200px main正确展示 注意：第6步一定是给中间盒子增加一个内盒子，如果直接在中间盒子上更改margin整个布局就乱了（如下，右边盒子在最外围看不见的地方，左边盒子右移）因为中间3个盒子都是浮动的，而float属性对兄弟元素的影响是会贴着旁边float元素，所以中间盒子向右边移动以后左边盒子也会跟着向右边移动，所以需要在中间盒子内部放置块元素来调整margin避免影响其他浮动元素 浮动布局时，三个div的生成顺序有没有影响有，设置第1、3列为浮动，中间使用margin将空间留出来给普通元素。为防止第三列浮动元素受到中间普通元素文本的影响，需要在HTML中将最左和最右两个浮动写在一起，中间的普通元素放在最后。区别可参考CSS布局面试题 Flex布局 Flex是Flexible Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。可参考我以前的博客百度前端技术学院 第七天学习笔记（CSS flexbox） 父元素（flex容器）的属性中重点区分： justify-content属性定义子项在主轴上的对齐方式（位置）。【单个子项为单位】 align-items属性定义子项在交叉轴上的对齐方式（位置）。【单个子项为单位】 而align-content属性只适用多行的flex子项（也就是flex父容器中的子项不止一行时该属性才有效果） 当flex父容器在交叉轴上有多余的空间时，且属性值为：flex-start、flex-end、center、stretch时，将所有子项作为一个整体单位沿交叉轴进行对齐。当flex父容器在交叉轴上有多余的空间时，且属性值为：space-between/space-around时，将单行子项作为一个单位沿交叉轴进行对齐。 Flex 布局教程：语法篇、Flex 布局教程：实例篇做骰子/网格布局/百分比布局/圣杯布局、Flexbox 布局的最简单表单 布局的传统解决方案，基于盒状模型，依赖display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 注意：Flex布局兼容性不好，目前主流还是浮动布局 瀑布流布局（flex布局/CSS3的column属性）可参考博客 使用flex布局实现： 最外层用flex并设置为行布局：flex-direction: row; 内部使用flex并设置为列布局flex-direction: column; 每一个列布局内放置若干flex子项 使用CSS3的column属性实现：可参考博客 改变DOM元素的字体颜色，不在它身上进行操作 可以更改父元素的color line-height和height的区别 line-height一般是指布局里面一段文字上下行之间的高度，是针对字体来设置的 height一般是指容器的整体高度 设置元素的背景颜色，会填充哪些区域 background-color设置的背景颜色会填充元素的content、padding、border区域 重绘和重排，减少重绘和重排 可参考从输入url到页面显示都经历了什么 DOM的变化影响到了预算内宿的几何属性比如宽高，浏览器重新计算元素的几何属性，其他元素的几何属性也会受到影响，浏览器需要重新构造渲染这些几何属性，这个过程称之为重排（回流） 浏览器将受到影响的部分重新绘制在屏幕上 的过程称为重绘 重排一定导致重绘，重绘不一定导致重排 引起重排重绘的原因有： 添加或者删除可见的DOM元素 元素尺寸位置的改变 增加或移出样式表 操作class属性 浏览器页面初始化 浏览器窗口大小发生改变 减少重绘重排，即减少对render tree的操作，并减少对一些style信息的请求，合理利用浏览器优化策略，方法有： 对DOM查询做缓存 使用csstext,className 一次性改变属性，减少设置多项内联样式 使用DocumentFragment将频繁的DOM操作改为一次性操作 对于多次重排的元素，比如说动画。使用绝对定位脱离文档流，使其不影响其他元素，减少render 树的规模 table布局的渲染与普通DOM节点的操作相比，性能消耗更大，如果可以，尽量减少table布局的使用 使用虚拟dom脚本库，例如react等 让文档脱离文档流有哪些方法 float：使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在该元素的周围。 absolute：绝对定位，因为使用absolute脱离文档流后的元素，是相对于该元素的父类（及以上，如果直系父类元素不满足条件则继续向上查询）元素进行定位的，并且这个父类元素的position必须是非static定位的（static是默认定位方式）。 fixed：完全脱离文档流，相对于浏览器窗口进行定位。（相对于浏览器窗口就是相对于html）。 css预处理器有什么less，sass等","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"前端基础-CSS（1）","slug":"前端基础-CSS（1）","date":"2020-04-05T08:17:53.000Z","updated":"2020-11-19T13:17:42.255Z","comments":true,"path":"2020/04/05/前端基础-CSS（1）/","link":"","permalink":"http://yoursite.com/2020/04/05/前端基础-CSS（1）/","excerpt":"说一下css盒模型 可参考百度前端技术学院 第五天学习笔记（CSS盒模型） CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既width已经包含了padding和border值） 在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准盒模型，box-sizing:border-box表示的是替代盒模型（IE盒模型）","text":"说一下css盒模型 可参考百度前端技术学院 第五天学习笔记（CSS盒模型） CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。 标准盒模型：一个块的总宽度=width+margin(左右)+padding(左右)+border(左右) 怪异盒模型：一个块的总宽度=width+margin（左右）（既width已经包含了padding和border值） 在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准盒模型，box-sizing:border-box表示的是替代盒模型（IE盒模型） box-sizing的语法和基本用处 box-sizing规定两个并排的带边框的框，语法为box-sizing：content-box/border-box/inherit content-box：标准盒模型,宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框 border-box：替代盒模型,为元素设定的宽度和高度决定了元素的边框盒 inherit：继承父元素的box-sizing 画一条0.5px的线 参考文章1/参考文章2，注意不能直接设置0.5px，每个浏览器显示效果不同 先决条件： 屏幕的分辨率要足够高，设备像素比要大于1，即css中的1个像素对应物理屏幕中1个以上的像素点。 对于普通电脑，屏幕物理像素和css像素一一对应，显示的最小单位就是1px。而现在的手机，屏幕物理宽度一般都大于页面显示宽度。例如苹果6s的屏幕分辨率为1334x750像素，但是以375px的宽度显示页面，设备像素比就是750/375=2；此时在css中定义0.5px的宽度，实际上对应物理屏幕的1个像素点，这就是border小于1px的的实现基础。 【万能方法】meta viewport： 这样子就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。要记得viewport只针对于移动端，只在移动端上才能看到效果。 在移端开发里面一般会把viewport的scale设置成1，其中width=device-width表示将viewport视窗的宽度调整为设备的宽度，这个宽度通常是指物理上宽度。 默认的缩放比例为1，如iphone 6竖屏的宽度为750px，它的dpr=2，用2px表示1px，这样设置之后viewport的宽度就变成375px。这时候0.5px的边就使用我们上面讨论的方法。 这样的话，viewport的宽度就是原本的750px，所以1个px还是1px，正常画就行，但这样也意味着UI需要按2倍图的出，整体面面的单位都会放大一倍。12&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=0.5\"/&gt; CSS3中box-shadow：box-shadow: 0 0.5px 0 #000;设置box-shadow的第二个参数为0.5px，表示阴影垂直方向的偏移为0.5px。这个方法在Chrome和Firefox都非常完美，但是Safari不支持小于1px的boxshadow，所以完全没显示出来了。不过至少找到了一种方法能够让PC的Chrome显示0.5px。 CSS3中transform: scale():transform: scale(0.5,0.5);会导致Chrome变虚，而粗细几乎没有变化，只有Firefox比较完美看起来是实的而且还很细，效果和直接设置0.5px一样。 CSS3中linear-gradient：linear-gradient(0deg, #fff, #000)的意思是：渐变的角度从下往上，从白色#fff渐变到黑色#000，而且是线性的，在高清屏上，1px的逻辑像素代表的物理（设备）像素有2px，由于是线性渐变，所以第1个px只能是#fff，而剩下的那个像素只能是#000，这样就达到了画一半的目的。逻辑分析很完美，实际的效果在各个流览器上面都不完美，效果都是虚的，和完美的0.5px还是有差距。这个效果和scale 0.5的差不多，都是通过虚化线，让人觉得变细了。 【看】CSS画三角形/正方体 三角形/扇形可利用border+transparent实现 ,transform1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;perspective&lt;/title&gt; &lt;style&gt; .wrapper &#123; width: 50%; float: left; &#125; .cube &#123; font-size: 4em; width: 2em; margin: 1.5em auto; transform-style: preserve-3d; transform: rotateX(-35deg) rotateY(30deg); &#125; .side &#123; position: absolute; width: 2em; height: 2em; background: rgba(255, 99, 71, 0.6); border: 1px solid rgba(0, 0, 0, 0.5); color: white; text-align: center; line-height: 2em; &#125; .front &#123; transform: translateZ(1em); &#125; .bottom &#123; transform: rotateX(-90deg) translateZ(1em); &#125; .top &#123; transform: rotateX(90deg) translateZ(1em); &#125; .left &#123; transform: rotateY(-90deg) translateZ(1em); &#125; .right &#123; transform: rotateY(90deg) translateZ(1em); &#125; .back &#123; transform: translateZ(-1em); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"wrapper w1\"&gt; &lt;div class=\"cube\"&gt; &lt;div class=\"side front\"&gt;1&lt;/div&gt; &lt;div class=\"side back\"&gt;6&lt;/div&gt; &lt;div class=\"side right\"&gt;4&lt;/div&gt; &lt;div class=\"side left\"&gt;3&lt;/div&gt; &lt;div class=\"side top\"&gt;5&lt;/div&gt; &lt;div class=\"side bottom\"&gt;2&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; link标签和import标签的区别 link属于html标签，而@import是css提供的 页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。 link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。 link方式样式的权重高于@import的。 让footer始终位于页面的最底部12345678910// 方法1和2的html&lt;body&gt; &lt;div class=\"page\"&gt; &lt;header&gt; 头部 &lt;/header&gt; &lt;div class=\"content\"&gt; &lt;p class=\"内容区\"&gt;&lt;/p&gt; &lt;/div&gt; &lt;footer&gt; 底部 &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt; 子绝父相：footer使用绝对定位+bottom固定在底部： 使用flexbox方法1： header/footer：flex项不分配容器中的剩余空间，flex项宽度之和大于容器的时候也不发生收缩，在主轴方向上的初始大小参照flex项的width和height属性。 content：flex项分配容器中的所有剩余空间，flex项宽度之和大于容器的时候也不发生收缩，在主轴方向上的初始大小参照flex项的width和height属性。 使用flexbox方法（阮一峰）：父元素设置100vh，子项内容设置为1，header便会自动吸顶，footer变会自动吸底因为flex子元素的flex默认值是0 1 auto，也就是按照自己的宽高进行等比缩小。即，除了content，其他flex项都不会占有父元素剩余空间，他们只会按照自己的宽高进行等比缩小，自然就自动吸顶和吸底了。 CSS3新属性：单位vhvh是相对于视口的高度。视口被均分为100单位的vh 水平、垂直居中的方法 可参考百度前端技术学院 第七天学习笔记（CSS 居中） 水平居中： text-align: center;：行内文本/图片（给父元素设置text-align）/块内文本 定宽块级元素：margin: auto;或margin: 0 auto; text-align: center;：直接给不定宽的块级元素设置/给父元素加 position:absolute +left:50%+ transform:translateX(-50%) display:flex + justify-content: center 垂直居中：（必备条件：父元素是盒子容器且高度已经设定） line-height： 行内/块内文本 vertical-align:middle：行内元素（图片）/单元格，作用于display属性值为inline、inline-block、inline-table另加一个table-cell的元素 块内文本：单元格+vertical-align：给父元素设置display:table;子元素设定display:table-cell;vertical-align:middle; 注意：vertical-align 不作用于span元素 定高块级元素：计算子元素的margin-top或margin-bottom，将其设置为(父元素高度-子元素高度)/2 不定高块级元素： flexbox：父元素使用display: flex;将其设置为弹性盒子父容器，然后设置align-items: center;定义子项在交叉轴上的对齐方式 line-height+inline-block:给块级元素设置display:inline-block,然后使用行内元素的line-height属性实现垂直居中。 补充：绝对定位/固定定位/浮动 都会使元素变为inline-block元素 position：absolute +top:50%+ transform:translateY(-50%) 水平+垂直居中: text-align+ line-height:块/行内元素单行文本双向居中 text-align + vertical-align:实现行内元素（图片）双向垂直 利用flex：将父元素设置为display:flex，并且设置align-items:center;justify-content:center; 子绝父相+top、bottom、left、right设为0+margin:auto：定位为上下左右为0，margin：auto可以实现脱离文档流的居中（子绝父相的情况）原理是当top,bottom为0时，margin-top&amp;bottom设置auto的话会无限延伸沾满空间并平分，当left，right为0时,margin-left&amp;right设置auto会无限延伸占满空间并平分 子绝父相+top、left设为50%+transformposition：absolute +left:50%+top:50%+ transform:translate(-50%,-50%) 如何实现图片在某个容器中居中的？ 父元素不定宽高： 弹性布局 父元素设置display: flex、align-items: center; justify-content: center 【vertical-align单独用行不通，必须联合字体大小为0】父元素设置为单元格 display: table-cell、设置text-align:center实现水平居中、设置vertical-align:middle实现垂直居中。（vertical-align:middle可能会造成基线的问题导致垂直不太居中，可参考这篇文章，如果想解决这个偏差就需要设置字体大小为0） 父元素固定宽高，子元素设置position: absolute，margin：auto平均分配margin 父元素与图片固定宽高，利用定位及设置子元素margin值为自身的一半。 图片不定宽高： css3属性transform。子元素设置position: absolute; left: 50%; top: 50%;transform: translate(-50%,-50%);即可。 不知道自身宽高的情况下，可以利用translate()函数来进行水平垂直居中。 当使用position: absolute;top: 50%;left: 50%;， 是以左上角为原点，故不处于中心位置。 translate(-50%,-50%)作用是往上（x轴）,左（y轴）移动自身长宽的 50%，以使其居于中心位置。 如何实现元素的垂直居中 行内/块内文本：line-height 父元素display:flex,align-items:center; 元素绝对定位，top:50%，margin-top：-（高度/2） top:50%定位点是左上角，所以需要使用margin-top将其调高自身一半达到垂直居中 高度不确定时元素绝对定位+transform：translateY（-50%）向上移动自身高度的一半 行内元素/图片/单元格：子元素设置vertical-align:center;(vertical-align不作用于span元素) width300，height300在屏幕上垂直水平居中对于行内块级元素: 【父单元格+vertical-align，子margin】 父级元素设置display:table-cell，vertical-align:middle达到垂直居中,子元素设置margin:auto实现水平居中 【子绝父相+top+left+transform/margin】采用绝对定位，原理是子绝父相，父元素设置position：relative，子元素设置position：absolute，然后通过transform或margin组合使用达到居中效果，设置top：50%，left：50%，transform：translate（-50%，-50%） 【子绝父相+top、bottom、left、right设为0+margin设为auto】绝对居中，原理是当top,bottom为0时，margin-top&amp;bottom设置auto的话会无限延伸沾满空间并平分，当left，right为0时,margin-left&amp;right设置auto会无限延伸占满空间并平分 【flex+margin/align-items+justify-content】采用flex，父元素设置display:flex，子元素设置 margin:auto。或者设置父元素align-items:center;justify-content:center; 【margin（vh）+transform】 视窗居中，vh为视口单位，50vh即是视口高度的50/100，设置margin：50vh auto 0，transform：translateY(-50%) 关于js动画和css3动画的差异性 渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。 区别： 功能涵盖面，js比css大 实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定 对帧速表现不好的低版本浏览器，css3可以做到自然降级 css动画有天然事件支持 css3有兼容性问题 display主要取值有none,block,inline-block,inline,flex等 inline-block、inline和block的区别 Block是块级元素，其前后都会有换行符，能设置宽度，高度，margin/padding 水平垂直方向都有效。 Inline：行元素，设置width和height无效，margin在竖直方向上无效，padding在水平方向垂直方向都有效，前后无换行符 Inline-block：行内块元素，能设置宽度高度，margin/padding水平垂直方向 都有效，前后无换行符 为什么img是inline还可以设置宽高因为他是置换元素，答案 怎么样让一个元素消失visibility:hidden，opacity:0，display:none CSS3的opacity:0，该元素隐藏起来了，但不会改变页面布局，并且，可触发原绑定事件，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的 visibility:hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 display:none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。（搜索引擎会过滤掉这里面的内容） 双边距重叠问题（外边距折叠） 多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。 两个外边距一正一负时，折叠结果是两者的相加的和。 position属性 比较 默认定位Static：默认值。没有定位，元素出现在正常的流中（忽略top, bottom, left, right 或者 z-index 声明）。 相对定位relative：如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位absolute：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于&lt;html&gt;。 absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。 固定定位fixed：元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed定位使元素的位置与文档流无关，因此不占据空间。 Fixed定位的元素和其他元素重叠。 粘性定位sticky：元素先按照普通文档流定位，然后相对于该元素在流中的flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 inherit:规定应该从父元素继承position 属性的值。 注意：区分绝对定位和浮动，前者完全脱离文档流，后者不脱离文本流 z-index的定位方法 z-index/#z-index更改堆叠顺序)属性设置元素的堆叠顺序 z轴：一条从屏幕表面到你的脸的虚线。 正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。 z-index 可以为负，且z-index只能在定位元素上奏效 它的属性值默认auto(实际上为0)，默认，堆叠顺序与父元素相等，number，inherit，从父元素继承z-index属性的值 BFC（清除浮动，防止margin重叠等） BFC直译成：块级格式化上下文，是页面上的一个独立容器，规定了内部如何布局，并且这个区域的子元素不会影响到外面的元素(可参考知乎) BFC内部box垂直放置 BFC区域不会与float box重叠 计算BFC的高度时，浮动元素也会参与计算 下面的元素会生成BFC： 根元素 float不为none的元素 position为fixed和absolute的元素 display为inline-block、table-cell、table-caption，flex，inline-flex的元素(使用display:flow-root可以创建无副作用的BFC) overflow不为visible的元素 浮动清除 推荐方法：父元素添加display: flow-root可以创建无副作用的BFC 方法一：使用带clear属性的空元素 在浮动元素后使用一个空元素如&lt;div class=&quot;clear&quot;&gt;&lt;/div&gt;，并在CSS中赋予.clear{clear:both;}属性即可清理浮动。亦可使用&lt;br class=&quot;clear&quot; /&gt;或&lt;hr class=&quot;clear&quot; /&gt;来进行清理。 方法二：使用CSS的overflow属性 给浮动元素的容器(父元素)添加overflow:hidden;或overflow:auto;可以清除浮动，另外在 IE6 中还需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。在添加overflow属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动的效果。 方法三：给浮动的元素的容器（父元素）添加浮动（BFC） 给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影响布局，不推荐使用。 方法四：使用邻接元素处理 什么都不做，给浮动元素后面的元素添加clear属性。 方法五：使用CSS的::after伪元素 结合::after伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。给浮动元素的容器添加一个clearfix的class，然后给这个class添加一个::after伪元素实现元素末尾添加一个看不见的块元素（Block element）清理浮动。 overflow清除浮动的原理 滚动（overflow属性） 要讲清楚这个解决方案的原理，首先需要了解块格式化上下文，块格式化上下文是CSS可视化渲染的一部分，它是一块区域，规定了内部块盒 的渲染方式，以及浮动相互之间的影响关系 当元素设置了overflow样式且值不是visible时，该元素就构建了一个BFC，BFC在计算高度时，内部浮动元素的高度也要计算在内，也就是说即使BFC区域内只有一个浮动元素，BFC的高度也不会发生塌缩，所以达到了清除浮动的目的","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS 实现单/多行文本的省略号显示","slug":"CSS 实现单 多行文本的省略号显示","date":"2020-04-05T02:56:19.000Z","updated":"2020-07-06T03:14:03.328Z","comments":true,"path":"2020/04/05/CSS 实现单 多行文本的省略号显示/","link":"","permalink":"http://yoursite.com/2020/04/05/CSS 实现单 多行文本的省略号显示/","excerpt":"单行文本的省略号显示CSS3 text-overflow属性 CSS3text-overflow属性可实现单行文本的省略号显示，可参考例子 text-overflow属性指定当文本溢出包含它的元素，应该发生什么。","text":"单行文本的省略号显示CSS3 text-overflow属性 CSS3text-overflow属性可实现单行文本的省略号显示，可参考例子 text-overflow属性指定当文本溢出包含它的元素，应该发生什么。 多行文本的省略号显示-webkit-line-clamp属性12345678910/*将对象作为弹性伸缩盒子模型*/display: -webkit-box /*设置或检索伸缩盒对象的子元素的排列方式，默认水平*/-webkit-box-orient:vertical/*设置显示多少行*/-webkit-line-clamp:3 /*元素内容溢出的部分隐藏*/overflow:hidden/*当文本溢出包含它的元素，显示省略号“…”*/text-overflow: ellipsis; -webkit-line-clamp是显示的文本的行数。为了实现该效果，需要组合其他的WebKit属性： display: -webkit-box:必须结合的属性 ，将对象作为弹性盒子模型显示 。 -webkit-box-orient:必须结合的属性 ，设置对象的子元素的排列方式 。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"前端基础-HTTP/HTML/浏览器（3）","slug":"前端基础-HTTP HTML 浏览器（3）","date":"2020-04-04T06:30:27.000Z","updated":"2020-11-01T09:39:31.997Z","comments":true,"path":"2020/04/04/前端基础-HTTP HTML 浏览器（3）/","link":"","permalink":"http://yoursite.com/2020/04/04/前端基础-HTTP HTML 浏览器（3）/","excerpt":"浏览器几个很实用的BOM属性对象方法什么是Bom? Bom是浏览器对象。","text":"浏览器几个很实用的BOM属性对象方法什么是Bom? Bom是浏览器对象。 有哪些常用的Bom属性呢？(1)location对象（地址的信息）location.href– 返回或设置当前文档的URLlocation.search – 返回URL中的查询字符串部分。例如 http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu 返回包括(?)后面的内容?id=5&amp;name=dreamdulocation.hash – 返回URL#后面的内容，如果没有#，返回空location.host – 返回URL中的域名部分，例如www.dreamdu.comlocation.hostname – 返回URL中的主域名部分，例如dreamdu.comlocation.pathname – 返回URL的域名后的部分。例如 http://www.dreamdu.com/xhtml/ 返回/xhtml/location.port – 返回URL中的端口部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回8080location.protocol – 返回URL中的协议部分。例如 http://www.dreamdu.com:8080/xhtml/ 返回(//)前面的内容http:location.assign – 设置当前文档的URLlocation.replace() – 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);location.reload() – 重载当前页面 (2)history对象（前移、后退的信息）history.go() – 前进或后退指定的页面数 history.go(num);history.back() – 后退一页history.forward() – 前进一页 (3)Navigator对象（浏览器的信息）navigator.userAgent – 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)navigator.cookieEnabled – 返回浏览器是否支持(启用)cookie 说一下web Quality（无障碍）能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。残障人士指的是那些带有残疾或者身体不健康的用户。 我们可以使用alt属性：&lt;img src=&quot;person.jpg&quot; alt=&quot;this is a person&quot;/&gt;有时候浏览器会无法显示图像。具体的原因有： 用户关闭了图像显示 浏览器是不支持图形显示的迷你浏览器 浏览器是语音浏览器（供盲人和弱视人群使用） 如果使用了alt 属性，那么浏览器至少可以显示或读出有关图像的描述。 ajax/fetch发送2次请求的原因 MDN fetch API、使用fetch 问题： fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？ 原因：很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。 浏览器对复杂跨域请求的处理，在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(preflight request), 用于试探服务端是否能接受真正的请求，如果options获得的回应是拒绝性质的，比如404\\403\\500等http状态，就会停止post、put等请求的发出。 发送2次请求的前提条件 跨域 请求方法不是GET/HEAD/POST ，且POST请求的Content-Type不是application/x-www-form-urlencoded, multipart/form-data, 或text/plain iframe是什么？有什么缺点？ 参考 定义：iframe元素会创建包含另一个文档的内联框架（将另一个HTML页面嵌入到当前页面中） 提示：可以将提示文字放在&lt;iframe&gt;&lt;/iframe&gt;之间，来提示某些不支持iframe的浏览器。 无障碍环境：使用 iframe 的 title 属性来标识框架的主要内容，这样可以极大方便使用辅助技术（例如屏幕阅读器）浏览网页的人。 缺点： 会阻塞主页面的onload事件 搜索引擎无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。 Doctype作用?严格模式与混杂模式如何区分？它们有何意义? 参考 Doctype声明于文档最前面，主要作用是告诉浏览器的解析器使用哪种HTML规范或者XHTML规范（方式）来解析页面。这里有两种模式，严格模式和混杂模式。 严格模式：又称标准模式，是指浏览器按照W3C标准，以该浏览器支持的最高标准来解析代码，呈现页面 混杂模式：又称为怪异模式或者兼容模式，是指浏览器按照自己的方式来解析代码，使用一种比较宽松的向后兼容的方式来显示页面，防止浏览器无法兼容页面。 HTML5 没有严格和混杂之分：对于HTML5文档，HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。 viewport和移动端布局 响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh） 总的来说，viewport即视口。广义的视口，是指浏览器显示内容的屏幕区域，狭义的视口包括了布局视口、视觉视口和理想视口。 理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。 设置理想视口：在移动端布局时，在meta标签中我们会将width设置称为device-width，device-width一般是表示分辨率的宽，通过width=device-width的设置我们就将布局视口设置成了理想的视口:1&lt;meta id=\"viewport\" name=\"viewport\" content=\"width=device-width; initial-scale=1.0; maximum-scale=1; user-scalable=no;\"&gt; 移动端布局响应式布局: 通过rem: rem单位无论嵌套层级如何，都只相对于浏览器的根元素（HTML元素）的font-size，默认1 rem = 16px。 如果通过rem来实现响应式的布局，只需要根据视图容器的大小，动态的改变font-size即可。 缺点：在响应式布局中，必须通过js来动态控制根元素font-size的大小。也就是说css样式和js代码有一定的耦合性。且必须将改变font-size的代码放在css样式之前。 通过vw/vh来实现自适应，这样就不需要使用js来动态控制根元素大小了: css3中引入了新的单位vw/vh，与视图窗口有关，vw表示相对于视图窗口的宽度（视窗宽度是100vw），vh表示相对于视图窗口高度（视窗高度是100vh）。 px换算成vw单位方法： 很简单，只要确定视图的窗口大小（布局视口），比如移动端的分辨率宽度是375px，则375px=100vw，1px=100/375vw。 或者使用postcss的相应插件postcss-px-to-viewport预处理css做一个自动的转换，可以自动将px转化成vw。 click在ios上有300ms延迟，原因及如何解决？ 参考 原因：苹果公司在发布首款 iPhone 时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。当用户一次点击屏幕之后，浏览器并不能立刻判断用户是要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。 解决：(1)粗暴型，禁用缩放&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;&gt;(2)利用FastClick，其原理是：检测到touchend事件后，立刻触发模拟click事件，并且把浏览器300毫秒之后真正触发的事件给阻断掉 addEventListener参数 参考 DOM元素.addEventListener(event, function, useCapture)event指定事件名；function指定要事件触发时执行的函数；useCapture指定事件是否在捕获或冒泡阶段执行。 true - 事件句柄在捕获阶段执行。false- 默认。事件句柄在冒泡阶段执行 捕获与冒泡总得来说，冒泡：当事件发生后，这个事件就要开始冒泡(从里到外)。捕获事件则是从外往里（只有特殊需要再使用事件捕获即可） HTML5新增的元素 首先html5为了更好的实践web语义化，增加了新的语义化元素 header，footer，nav,aside,section等语义化标签（不建议使用一些语义不强的元素：b、i、font等） 在表单方面，为了增强表单验证，为input增加了color，emial,data ,range等类型（表单验证在这之前只能通过js来完成）【更多验证可参考】 在存储方面【JS层面的】，提供了sessionStorage，localStorage和离线存储，通过这些存储方式方便数据在客户端的存储和获取（原本只有cookie，HTML5 web 存储是比cookie更好的本地存储方式） 注意：session保存在服务器端，而cookie、sessionStorage，localStorage搜保存在浏览器端 在多媒体方面规定了音频和视频元素audio和vedio 另外还有地理定位，canvas画布，拖放，多线程编程的web worker和websocket协议 对HTML语义化标签的理解 HTML5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如nav表示导航条，类似的还有article、header、footer等等标签。 语义化简单说来就是让机器可以读懂内容。在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度。我们在提供内容的时候，首先要做的就是将内容本身进行合理的描述，暂时不用考虑它的最终呈现会是什么样子。 作用：为了解决机器难以读懂web上发布的各种内容的问题。 说一下web worker 参考 出现理由： JS是单线程没有多线程，当JS在页面中运行长耗时同步任务的时候就会导致页面假死影响用户体验，从而需要设置把任务放在任务队列中；执行任务队列中的任务也并非多线程进行的，然而现在HTML5提供了Web Workers API，可以让浏览器作为宿主环境提供给JS一个多线程运行的环境。 Web Workers 使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞。 作用：就是给JS创造多线程运行环境，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行，相互不干扰，在worker线程运行结束后把结果返回给主线程。这样做的好处是主线程可以把计算密集型或高延迟的任务交给worker线程执行，这样主线程就会变得轻松，不会被阻塞或拖慢。 注意：这并不意味着JS语言本身支持了多线程能力，而是浏览器作为宿主环境提供了JS一个多线程运行的环境。 缺点：因为worker一旦新建，就会一直运行，不会被主线程的活动打断，这样有利于随时响应主线程的通性，但是也会造成资源的浪费，所以不应过度使用，用完注意关闭。或者说：如果worker无实例引用，该worker空闲后立即会被关闭；如果worker实列引用不为0，该worker空闲也不会被关闭。 说一下HTML5 drag api例子draggable属性：使元素可拖动，把 draggable 属性设置为 truedragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。dragover：事件主体是目标元素，在被拖放元素在某元素内移动时触发。dragleave：事件主体是目标元素，在被拖放元素移出目标元素时触发。drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。dragend：事件主体是被拖放元素，在整个拖放操作结束时触发 dragstart与ondragstart参考这 HTML5和CSS3用的多吗？你了解它们的新属性吗？有在项目中用过吗？HTML5 标签增删 8个语义元素 header section footer aside nav main article figure 内容元素mark高亮 progress进度 新的input类型(增强表单验证) color date datetime datetime-local email time url search，（表单验证在这之前只能通过js来完成）【更多验证可参考】 移除过时标签big font frame frameset canvas绘图，支持内联SVG。支持MathML 多媒体audio video source embed track 本地离线存储，把需要离线存储在本地的文件列在一个manifest配置文件 web存储。localStorage、SessionStorage【JS层面的】 CSS3 CSS3边框如border-radius（可做扇形），box-shadow等； CSS3背景如background-size，background-origin等； CSS3 2D，3D转换如transform等（我多用于搭配子绝父相实现元素居中）； CSS3动画如transition和animation等。 新增单位：vh、vw 新增属性：box-sizing替代盒模型 更多特性可参考“前端基础-CSS（2）”中CSS3新特性","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS 运行环境","slug":"JS 运行环境","date":"2020-04-04T04:41:32.000Z","updated":"2020-11-12T11:32:26.220Z","comments":true,"path":"2020/04/04/JS 运行环境/","link":"","permalink":"http://yoursite.com/2020/04/04/JS 运行环境/","excerpt":"运行环境介绍 运行环境即浏览器（server端有nodejs，移动端在app/微信上） 下载网页代码，渲染出页面，期间会执行若干JS 要保证代码在浏览器中：稳定且高效 网页加载过程 性能优化 安全","text":"运行环境介绍 运行环境即浏览器（server端有nodejs，移动端在app/微信上） 下载网页代码，渲染出页面，期间会执行若干JS 要保证代码在浏览器中：稳定且高效 网页加载过程 性能优化 安全 页面加载和渲染过程 资源的形式 html代码 媒体文件，如图片、视频等 javascript CSS 加载过程： DNS解析（Domain Name Server）：域名-&gt;IP地址（不直接使用IP是因为不同区域IP地址不同，域名更好记） 建立TCP连接，浏览器根据IP地址向服务器发起http请求 服务器处理http请求，并返回html给浏览器 渲染过程： 根据HTML代码生成DOM Tree（Document Object Model） 根据CSS代码生成CSSOM（CSS Object Model，CSS对象模型） 将DOM Tree和CSSOM整合形成Render Tree（渲染树） 根据Render Tree渲染页面 遇到&lt;script&gt;则暂停渲染（因为JS有可能修改DOM结构），优先加载并执行JS代码，完成再继续 直至把Render Tree渲染完成 例子：渲染到img时如果太大还未加载完成也不会阻塞DOM树的渲染，直接往下渲染，等图片加载完成再插入 window.onload和DOMContentLoaded window.onload：页面的全部资源加载完才会执行，包括图片、视频等 DOMContentLoaded：DOM渲染完即可执行，此时图片、视频还可能没有加载完 注意：使用DOMContentLoaded来触发JS比window.onload更好，不需要等图片、视频都加载完成才触发JS的加载，这样页面渲染会更快。 性能优化 原则: 多使用内存、缓存或其他方法 减少CPU计算量，减少网络加载耗时 （适用于所有编程的性能优化一空间换时间） 从何入手: 让加载更快 让渲染更快 让加载更快 减少资源体积：压缩代码 比如使用webpack在production环境下进行打包时，就会自动压缩代码至1/3的大小，在浏览器上进行反解析再进行渲染。 减少访问次数： 合并代码：比如webpack中，在index.js中引入a.js、b.js，打包后只生成一个bundle.js，这就是合并代码。（加载3次3kb的文件不如加载1次9kb快，这和网络请求有关系） SSR服务器端渲染：不需要通过ajax发送请求。 缓存：原本需要发送多个请求的数据直接在缓存中获取即可减少访问次数。 使用更快的网络：CDN CDN是分区域的，也就是使用CDN的时候上海和北京对同一个网站的IP地址是不同的。CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了 图片、js等静态资源采用CDN是很快的，我们经常使用的bootstrap就是使用的CDN 缓存 静态资源加hash后缀，根据文件内容计算hash 文件内容不变，则hash不变，则url不变 url和文件不变，则会自动触发http缓存机制，返回304（提示用户资源未更新，到缓存中获取）【大部分web服务器都默认开启协商缓存】 例子：在使用webpack的例子webpack-demo中，配置webpack的输出文件名时采用的内容哈希值[contenthash]就会根据文件内容来生成哈希值（每一次生成的文件不会覆盖之前的文件，且只要内容变化名字就会发生改变） 可参考强缓存与协商缓存 CDN CDN，Content Delivery Network，即内容分发网络。是根据地域做静态服务的，我们经常使用的bootstrap就是使用的CDN，他会加快加载速度。（CDN缓存） CDN不变且文件不变时，也会自动触发http缓存机制，返回304。 而百度这里用的bdstatic就不是CDN： SSR SSR（服务器端渲染）：server side render，将网页和数据一起加载，一起渲染 非SSR：先加载网页，再加载数据，再渲染数据 早先的JSP ASP PHP 都是SSR，现在的 vue 和 react 默认下不是ssr，但可以在配置下成为ssr 如果右键查看源码看不到input等元素标签，则为非ssr。 SSR与非SSR 让渲染更快 CSS放在head中，JS放在body最下面 尽早开始执行JS，用DOMContentLoaded触发 懒加载（图片懒加载，上滑加载更多） 对DOM查询进行缓存（DOM操作很耗性能） 频繁DOM操作，合并到一起插入DOM结构 让渲染更流畅：节流throttle防抖debounce 懒加载 懒加载：常见图片懒加载，也就是我们希望先加载第一张图片，后面的图片没显示在屏幕上的就先不加载，等到滑动到图片位置时再进行该图片的加载。 例子：一开始加载src地址下的图片，等到滑动到下一图片位置时将data-realsrc的属性值赋给src，此时即为加载图片abc（本例子中不进行图片位置的判断，实际根据DOM元素距离顶部的值来计算） 缓存DOM的查询js的操作和DOM的操作完全不是一个数量级的，尽量避免多次操作DOM： 多个DOM操作合并多个DOM操作一起插入到DOM结构时注意可通过createDocumentFragment()先创建一个文档片段，这个文档片段是保存在JS中的（不是在DOM树中）： 尽早开始执行JS使用DOMContentLoaded来触发JS比window.onload更好，不需要等图片、视频都加载完成才触发JS的加载，这样页面渲染会更快。DOMContentLoaded是当DOM树渲染完即可执行，此时图片、视频还可能没有加载完（注意是DOM渲染完成而不是页面渲染完成） 防抖 debounce 防抖：比如，监听一个输入框的文字变化后触发change事件，直接用keyup事件，则会频发触发change事件。如果使用防抖，则用户输入结束或暂停时，才会触发change事件。（防抖不仅限于change事件） 防抖实际上是对定时器setTimeout的使用，但我们通常将其封装为debounce函数来使用 例子： 原本设定是输入框中每输入一个字符就触发一个打印，将输入框中的值打印出来 采用防抖后，每次输入结束的半秒后才会触发事件进行打印（半秒是自己设置的）：逻辑梳理： timer用于存储定时器id，输入a时，通过setTimeout给timer赋值，准备500毫秒后触发打印 紧接着输入s时,由于此时timer不为空，所以执行clearTimerout将之前的定时器清除，重新创建setTimeout给timer赋值，准备500毫秒后触发打印 依旧紧接着输入d时，一直到s都重复上一步逻辑 直到输入最后一个f时，清除了上一个timer后创建了新的timer，且500毫秒后未被清除，故打印asdfasdfasf，并将timer清空 封装为debounce函数，避免每次使用都要创建setTimeout：27行直接使用fn()也可以，使用apply是为了防止fn有this或者参数（arguments对象）需要传入debounce函数（如果要传入this，则需注意传入的fn，即例子中的箭头函数不能是箭头函数）【可参考下面“节流”中的apply解释】 节流 throttle 比如：拖拽一个元素时，要随时拿到该元素被拖拽的位置。这里直接用drag事件则会频发触发，很容易导致卡顿。而使用节流，则无论拖拽速度多快，都会每隔100ms触发一次（时间自定义） 例子： 设置一个可拖拽元素并直接用drag事件，拖拽时实时打印元素位置： 采取节流后：逻辑梳理： 和节流相似，都设置一个定时器，初始为空 元素开始拖拽时触发事件，根据setTimeout返回的id赋给timer，此时需要等待100毫秒才打印位置 由于快速拖动元素，100毫秒内再次出发drag事件，但此时timer有值，直接退出drag事件，直到100毫秒位置打印后timer清空才会再走第二步。以此实现无论拖拽速度多快，都会每隔100ms触发一次drag事件 封装为throttle函数：这样的封装没问题，但是使用时会报错：解决报错，添加e： apply的作用：参数1绑定this指向，参数2绑定调用该函数时传入的参数（即：将参数传入fn）(arguments对象)。比如这里的e就必须是使用apply传入了参数e，则调用throttle函数时传入的fn函数才能找到e。注意：父级作用域是在 函数定义时 规定的，不需要管执行顺序。所以如果24行使用fn()则31行找e时的父级作用域（这里的父级作用域是全局作用域，不是函数throttle）里没有e，30行的e是提供给throttle函数的返回函数的（19-27）。而24使用apply则将e传入了fn，31也就可以获取到e了。 安全 CSRF又称XSRF，前端Cookie如何防范XSS攻击可参考博客XSS和XSRF网络攻击及防范 XSS跨站请求攻击 XSS：一个博客网站，我发表一篇博客，其中嵌入&lt;script&gt;脚本，脚本内容用以获取cookie，发送到我的服务器（只要我将自己的服务器设置好配合跨域，那么点击我的链接我就可以解决cookie跨域的问题）。那么只要我发布这篇博客，有人查看它，我就能轻松收割访问者的cookie。 例子：攻击者在博客中嵌入&lt;script&gt;脚本来获取访问者的cookie（cookie只要获取到，那么script中还可加入ajax等跨域方式（比如jsonp）将cookie发送出去，此时只要攻击者的服务器设置为支持跨域，那攻击者就能轻松获取数据）：!其他用户访问该博客时，cookie被带出：假设script中还有ajax等跨域方式（比如jsonp）将cookie发送出去，此时只要攻击者的服务器设置为支持跨域，则敏感信息也会被送出。 XSS预防 : 前端在显示时替换，后端在存储时替换，都做总不会有错(可参考XSS网络攻击及防范) 替换特殊字符，如&lt;变为&amp;lt； &gt;变为&amp;gt,&lt;script&gt;变为&amp;lt；script&amp;gt；直接显示，而不会作为脚本执行(实际工作中可使用XSS工具) 例子：特殊字符在html中会被浏览器解析显示为相应的符号，故script以字符串形式显示，不会作为脚本执行 在HTTP头部配上set-cookie:httponly,禁止javascript脚本来访问cookie。严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。（在node中的设置方法可参考博客项目登录（cookie）） 设置cookie的secure属性为secure:true,告诉浏览器仅在请求为https的时候发送cookie XSS工具：替换特殊字符可使用XSS工具 node使用XSS的方法可参考博客：博客项目安全 前端使用XSS的方法可参考官方例子： XSRF跨站请求伪造 XSRF（CSRF）例子： 你正在购物，看中了某个商品，商品id是100，付费接口是xxx.com/pay？id=100，但没有任何验证（此时你已经登录了该网站）。 我是攻击者，我看中了一个商品，id是200（我现在想让你来帮我买单） 此时我向你发送一封电子邮件，邮件标题很吸引人但邮件正文隐藏着&lt;img src=xxx.com/pay？id=200/&gt;你一查看邮件，就帮我购买了id是200的商品。（注意img是支持跨域的，此时你的cookie会被带着） 预防XSRF：（更多防御方式可参考csrf网络攻击及防范） 使用post接口，img这些跨域只能接收get请求，设计post请求的需要server端的允许 增加验证，例如密码、短信验证码、指纹等。验证码会强制用户必须与应用进行交互，才能完成最终请求，但是也不能给网站所有的操作都加上验证码，所以只能作为防御 CSRF 的一种辅助手段，而不能作为最终的解决方案。 使用token验证：在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，若请求无 token 或者 token 不正确，则认为可能是 CSRF 攻击而拒绝该请求。 检查https头部的Referer：在HTTP头中有一个字段叫做Referer,它记录了该HTTP请求的来源地址。通过Referer Check,可以检查是否来自合法的”源”。例如：从www.user.com发起的删帖请求，那么Referer值是http://www.user.com, 删帖请求应该被允许；而如果是从CSRF攻击者构造的页面www.attack.com发起删帖请求， 那么Referer值是http://www.attack.com, 删帖请求应该被阻止。 相关题目为什么建议CSS写在head中因为页面是边解析边渲染的，如果把CSS写在HTML后，则先解析DOM树渲染在页面上，再生成CSSOM合成渲染树重新渲染在页面上，这样会有一个过程，用户可能会看到一个过程变化。所以在DOM树生成之前就先生成CSSOM会更好，这样当DOM树生成时就可直接和所有CSSOM进行合并，一步渲染完成。 为什么建议JS写在body最后因为页面是边解析边渲染的，如果把JS写在body中间，虽然JS有异步的处理机制，但极端情况会出现前面已经渲染了一半就卡住的情况。渲染时间会拖长。 从输入url到页面显示都经历了什么 下载资源：各个资源类型，下载过程 渲染页面：结合html Css javascript图片等 详细过程可参考博客从输入url到页面显示都经历了什么 window.onload和DOMContentLoaded的区别 window.onload：页面的全部资源加载完才会执行，包括图片、视频等 DOMContentLoaded：DOM渲染完即可执行，此时图片、视频还可能没有加载完 注意：使用DOMContentLoaded来触发JS比window.onload更好，不需要等图片、视频都加载完成才触发JS的加载，这样页面渲染会更快。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"前端基础-HTTP/HTML/浏览器（2）","slug":"前端基础-HTTP HTML 浏览器（2）","date":"2020-04-03T04:29:23.000Z","updated":"2020-11-19T12:54:32.569Z","comments":true,"path":"2020/04/03/前端基础-HTTP HTML 浏览器（2）/","link":"","permalink":"http://yoursite.com/2020/04/03/前端基础-HTTP HTML 浏览器（2）/","excerpt":"流程tcp三次握手，一句话概括","text":"流程tcp三次握手，一句话概括 三次握手可以简化为：C发起 请求连接，S确认 发送给确认响应，C确认并发送HTTP请求 看每次握手的作用： 第一次握手：S只可以确认自己可以接受C发送的报文段 第二次握手：C可以确认S收到了自己发送的报文段，并且可以确认自己可以接受S发送的报文段 第三次握手：S可以确认C收到了自己发送的报文段 TCP和UDP的区别 TCP UDP 面向连接的可靠性传输（三次握手） 无连接，即发送数据前不需要先建立链接。 提供可靠的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达(因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。) 尽最大努力交付，即不保证可靠交付 面向字节流 面向报文，且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等） TCP只能是1对1 UDP 支持1对1,1对多 TCP的首部较大，为20字节 UDP只有8字节 一个图片url访问后直接下载怎样实现？设置请求的返回头（HTTP响应报文首部的content-type），用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。 使用HTML5实现 HTML5提供的Canvas以 &lt;a&gt;的download 属性 MouseEvent()构造器、MouseEvent事件 注意：如希望 自动触发事件 应使用dispatchEvent(event)，比xxx.onclick();或xxx.click();好 1234567891011121314151617181920downloadIamge(imgsrc, name) &#123;//下载图片地址和图片名 let image = new Image(); // 解决跨域 Canvas 污染问题（允许跨域） image.setAttribute(\"crossOrigin\", \"anonymous\"); // onload 事件在图片加载完成后立即执行 image.onload = function() &#123; let canvas = document.createElement(\"canvas\"); canvas.width = image.width; canvas.height = image.height; let context = canvas.getContext(\"2d\"); //创建canvas对象 context.drawImage(image, 0, 0, image.width, image.height); let url = canvas.toDataURL(\"image/png\"); //得到图片的base64编码数据 let a = document.createElement(\"a\"); // 生成一个a元素 let event = new MouseEvent(\"click\"); // 创建一个单击事件 a.download = name || \"photo\"; // 设置图片名称 a.href = url; // 将生成的URL设置为a.href属性 a.dispatchEvent(event); // 触发a的单击事件 &#125;; image.src = imgsrc; &#125;, 在地址栏里输入一个URL,到这个页面呈现出来，中间会发生什么？这是一个必考的面试问题，输入url后， 客户端： DNS解析： 首先需要找到这个url域名的服务器ip,为了寻找这个ip，先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。 如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。 如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。 如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。 建立TCP连接（三次握手）： 客户机发送一个TCP连接请求报文-》服务器回送一个TCP确认响应报文-》客户机向服务器发送一个包含“HTTP请求”与“TCP确认”的报文 发送http请求： 浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器。 服务端： 服务器解析这个请求来作出响应，返回相应的html给浏览器。 客户端： 构建DOM树：浏览器根据这个html来构建DOM树，在dom树的构建过程中如果遇到JS脚本和外部JS连接，则会停止构建DOM树和css解析（因为JS有可能修改DOM结构）来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面。 js的解析涉及同步、异步（宏任务与微任务），事件循环 构建CSS对象模型树CSSOM树：解析html过程中遇到引入了css，则会在解析html的同时解析css，根据外部样式，内部样式，内联样式构建一个CSS对象模型树CSSOM树 合并为渲染树： CSSOM树构建完成后CSSOM树和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点。 最后浏览器将渲染树绘制到屏幕上显示。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 回流：浏览器去计算各个元素（盒模型）的位置和大小等 重绘：当盒模型的位置,大小以及其他属性，如颜色,字体等确定下来之后，浏览器便开始绘制内容 另外的HTTP请求： html文件中会含有 图片、视频、音频、js、jquery、css等其他资源，这些又是另外的HTTP请求。在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，可能会通过一个网页产生很多的HTTP请求，请求越少性能越好。 为提高性能要关注缓存（强缓存和协商缓存），缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control。 在请求这些有设置了缓存的数据时，如是强缓存，则不发送请求，直接从缓存中获取数据。 如是协商缓存，则会发送请求到服务器，如果上一次 响应设置了ETag值，则会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验客户端发送的IF-Modified-Since与服务端的 Last-Modified是否一致，没有设置ETag则直接验证Last-Modified，都一致则返回304（Not Changed）告知浏览器可以直接从缓存获取，否则返回最新的资源内容。 连接结束： 主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； cookie相关 补充说明一下cookie的作用： 保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。 跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。 如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。 cookie有哪些编码方式encodeURI（） cookie有哪些字段可以设置 name字段：一个cookie的名称。 value字段：一个cookie的值。 Size字段：此cookie大小。 domain字段：可以访问此cookie的域名。 非顶级域名，如二级域名或者三级域名，设置的cookie的domain 只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie，否则cookie无法生成。 二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie。所以要想cookie在多个二级域名中共享，需要设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值了。 顶级域名：只能设置domain为顶级域名，不能设置为二级域名或者三级域名，否则cookie无法生成。 顶级域名只能获取到domain设置为顶级域名的cookie，其他domain设置为二级域名的无法获取。 path字段：可以访问此cookie的页面路径。比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。 expires/Max-Age 字段：此cookie超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。 注意：其实在浏览器关闭后，session并没有失效，正常来说一个session的存活时间是30分钟，也就是在不操作这个session的情况下，30分钟自动清除。可是实际中浏览器关闭，设置的session也会随之消失，这里的消失是指你找不到这个session，不是他没有了，因为在浏览器重新打开时，浏览器总会自动给你创建一个的新的session。session并不是唯一的，每个session都有自己的一个专属sessionId，这个sessionId在浏览器打开时创建，保存在浏览器的cookie中，浏览器关闭，cookie自动清除，sessionId丢失，之前的session找寻不到！ http字段：cookie的httponly属性。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。（即禁止javascript脚本来访问cookie） secure 字段：设置是否仅在请求为https的时候传递此条cookie Cookie如何防范XSS攻击 XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上set-cookie： httponly,这个属性可以防止XSS,它会 禁止javascript脚本来访问cookie。 在请求为https的时候可以设置secure:true告诉浏览器对cookie进行加密。。 XSS和csrf网络攻击及防范 区别： XSS是利用用户对指定网站的信任，CSRF是利用网站对用户的信任。 XSS：跨站脚本攻击，攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息。 存储性（持久型）：用户输入的带有恶意脚本的数据存储在服务器端。当浏览器请求数据时，服务器返回脚本并执行。主要是通过html标签注入，篡改网页，插入恶意的脚本，前端可能没有经过严格的校验直接就进到数据库，数据库又通过前端程序又回显到浏览器。 比如：攻击者在社区或论坛上写下一篇包含恶意 Js代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。 反射型（非持久型）：把用户输入的数据”反射”给浏览器。通常是，用户点击链接或提交表单时，攻击者向用户访问的网站注入恶意脚本。 比如：在正常页面上添加一个恶意链接。恶意链接的地址指向localhost:8080。然后攻击者有一个node服务来处理对localhost:8080的请求:当用户点击恶意链接时，页面跳转到攻击者预先准备的localhost:8080页面，执行了 恶意的js 脚本，产生攻击。 防御： 在HTTP头部配上set-cookie： httponly，对用户的输入进行检查，进行特殊字符过滤，禁止javascript脚本来访问cookie。（严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击） 在请求为https的时候可以设置secure:true告诉浏览器对cookie进行加密。 CSRF：跨站请求伪造，攻击者借助用户的 Cookie 骗取服务器的信任，以用户名义伪造请求发送给服务器。如：在请求的url后加入一些恶意的参数。换句话说，CSRF就是利用用户的登录态发起恶意请求。 比如：你登录网站，并在本地存下了，如果在没退出该网站的时候不小心访问了恶意网站，而且这个网站需要你发一些请求等，此时，你是携带cookie进行访问的，那么你的存在cookie里的信息就会被恶意网站捕捉到，那么你的信息就被盗用，导致一些不法分子做一些事情。 假设某银行网站A以GET请求来发起转账操作，转账的地址为www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000，参数accountNum表示转账的账户，参数money表示转账金额。而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：&lt;img src=&quot;http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000&quot;&gt;当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块…（上述只是举例，转账怎么可能是get请求，为了保险，肯定是post请求，更何况银行的交易付款会有登录密码和支付密码等一系列屏障，流程复杂得多，安全系数也高得多） 防御： 使用token验证：在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，若请求无 token 或者 token 不正确，则认为可能是 CSRF 攻击而拒绝该请求。 每次请求时 CSRF Token 都是不同的。(例子) 例子： 比如有个网站，点赞是 get 方式请求：http://www.xxxx.com/like?id=12365 如果没有验证 token 的话，我只要随便在某个网页发个图，图片地址设置这个 url，对方只要访问这个页面，加载这个图，对方就会自动给 id 为 12365 的帖子点赞了。 如果验证 token，点赞的 get 的可能就是这种： http://www.xxxx.com/like?id=12365&amp;token=A23F267AE65 ，由于每个人的 token 是变化的，你无法预先知道对方的 token，对方加载了 http://www.xxxx.com/like?id=12365，也不会成功 检查https头部的Referer：在HTTP头中有一个字段叫做Referer,它记录了该HTTP请求的来源地址。通过Referer Check,可以检查是否来自合法的”源”。 例如：从www.user.com发起的删帖请求，那么Referer值是http://www.user.com, 删帖请求应该被允许；而如果是从CSRF攻击者构造的页面www.attack.com发起删帖请求， 那么Referer值是http://www.attack.com, 删帖请求应该被阻止。 验证码：验证码会强制用户必须与应用进行交互，才能完成最终请求，但是也不能给网站所有的操作都加上验证码，所以只能作为防御 CSRF 的一种辅助手段，而不能作为最终的解决方案。 除了cookie，还有什么存储方式还有localStorage，sessionStorage，indexdDB等 cookie、sessionStorage、localStorage的区别 共同点：都保存在浏览器端。 区别： 生命周期： Cookie：设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。未设置则默认为关闭浏览器后失效。(不是浏览器标签页，而是整个浏览器) Localstorage:除非被手动清除，否则永久保存，窗口或浏览器关闭也一直保存，因此用作持久数据。 Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除（刷新页面不会被清除），自然也就不可能持久保持。 存放数据： Cookie：4k左右（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下） Localstorage和sessionstorage：可以保存5M的信息 是否跟随http请求发送出去： Cookie：每次都会携带在http头中，如果使用cookie保存过多数据会带来性能问题 其他两个：不会自动把数据发给服务器，仅在客户端即浏览器中保存，不参与和服务器的通信 API易用性： Cookie：需要程序员自己封装，原生的cookie接口不友好（document.cookie） 其他两个：即可采用原生接口（getItem和setItem），亦可再次封装 应用场景： 从安全性来说，因为每次http请求都回携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，不可以跨域调用，限制很多，但是对于用户识别用户登陆来说，cookie还是比storage好用 其他情况下可以用storage，localstorage可以用来在页面传递参数 sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。 作用域： cookie和localStorage：在所有同源窗口中都是共享的 sessionStorage：在同一个浏览器窗口是共享的（不同浏览器、同一个页面也是不共享的） 关于同源可参考阮一峰，简单来说就是A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓“同源”指的是”三个相同”。 协议相同 域名相同 端口相同 举例来说，http://www.example.com/dir/page.html这个网址，协议是http://，域名是www.example.com，端口是80（默认端口可以省略）。它的同源情况如下。 http://www.example.com/dir2/other.html：同源 http://example.com/dir/other.html：不同源（域名不同） http://v2.www.example.com/dir/other.html：不同源（域名不同） http://www.example.com:81/dir/other.html：不同源（端口不同） Cookie和session的区别 cookie数据存放在客户的浏览器上，session数据放在服务器上。（session可以存放于文件，数据库，内存中） cookie不是很安全，server端可以修改cookie并返回给浏览器，浏览器中也可以通过javascript修改cookie（有限制）。别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。server端放置信息不会被前端获取到，更安全。且server端空间大，可存储更多信息。 session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用redis。 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 Cookie的最大的作用就是存储sessionId用来唯一标识用户。也可存放不敏感的信息，比如用户设置的网站主题。 前端性能优化怎么看网站的性能如何检测页面加载时间一般有两种方式 一种是被动去测：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析 另一种主动监测的方式，即主动的搭建分布式受控环境，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说性能极客 前端优化降低请求量：合并资源，减少HTTP请求数，minify / gzip 压缩，webP，lazyLoad。雪碧图加快请求速度：预解析DNS，减少域名数，并行加载，CDN 分发。web worker多线程，react中异步组件（懒加载）缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存localStorage。尽量命中强缓存，减少http请求。（具体见下方“前端缓存最佳实践”）渲染：JS/CSS优化，加载顺序（js放最后防止阻塞js、css的解析，css放在html前防止出现html渲染完成才开始合并CSSOM树），服务端渲染，pipeline。 说一下浏览器缓存前端缓存 强缓存和协商缓存（web性能优化） 图解流程详解、参考、参考1/参考2、前端缓存最佳实践、DNS缓存、CDN缓存、浏览器缓存 缓存是Web性能优化的重要方式。 缓存分为两种：强缓存和协商缓存，根据响应的header内容来决定。 注意：强缓存也会有状态码，是200 区别：如果浏览器命中强缓存，则在设置好的失效时间内不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。 总之，强缓存就是强制从缓存中读取，不管是否更新。而协商缓存就是和 服务器协商是否从缓存取，如有更新则返回新数据。 强缓存是利用http的返回（响应）头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。 Expires是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串。缺点：由于失效时间是一个绝对时间，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。 Cache-Control是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个相对时间，例如Cache-Control:max-age=3600，代表着资源的有效期是3600秒。 Cache-Control除了max-age还有以下常用字段： no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store：直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private（默认）：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 图解参考 协商缓存相关字段有 http响应头中的Last-Modified/请求头中的If-Modified-Since，http响应头中的Etag/请求头中的If-None-Match（具体参考） 通过响应头的2个字段 设置协商缓存： etag：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。 last-modified：文件的修改时间，精确到秒 浏览器在第一次请求发生后，再次请求时： 浏览器会先获取该资源缓存的header信息，根据其中的expires和cahe-control判断是否命中强缓存，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信； 如果没有命中强缓存，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（IF-Modified-Since、IF-None-Match，这2个字段值是上次响应头中的Last-Modified和Etag保存而来）,由服务器根据请求中的相关header信息来对比结果是否命中协商缓存。 若命中协商缓存，则服务器返回新的响应header信息（Last-Modified和Etag）更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取（304）；否则返回最新的资源内容（Last-Modified和Etag以及200状态码） 访问缓存优先级 先在内存中查找,如果有,直接加载。 如果内存中不存在,则在硬盘中查找,如果有直接加载。 如果硬盘中也没有,那么就进行网络请求。 请求获取的资源缓存到硬盘和内存。 DNS缓存、CDN缓存、浏览器缓存 前端缓存最佳实践 前端缓存最佳实践：缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。 更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在问题了（webpack打包时会把静态资源的路径加上hash值） 较为合理的缓存方案： HTML：使用协商缓存。 CSS&amp;JS&amp;图片：使用强缓存，文件命名带上hash值。 在做前端缓存时，我们尽可能设置长时间的强缓存，通过文件名加hash的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"前端基础-HTTP/HTML/浏览器（1）","slug":"前端基础-HTTP HTML 浏览器（1）","date":"2020-04-02T02:08:27.000Z","updated":"2020-11-01T09:57:56.292Z","comments":true,"path":"2020/04/02/前端基础-HTTP HTML 浏览器（1）/","link":"","permalink":"http://yoursite.com/2020/04/02/前端基础-HTTP HTML 浏览器（1）/","excerpt":"HTTP介绍HTTP协议(特征) 可参考 HTTP 基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）","text":"HTTP介绍HTTP协议(特征) 可参考 HTTP 基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等） HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。 它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。 后来的改进：随着时间的推移，网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要建立一次 TCP 连接就显得很低效。后来，Keep-Alive 被提出用来解决这效率低的问题。Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接 无状态：HTTP协议是无状态协议，无状态是指协议对于事务处理没有记忆能力，意味着每个请求都是独立的，Keep-Alive 没能改变这个结果。缺少状态，意味着如果后续处理需要前面的信息，则他必须重传，这样可能导致每次传输的数据量增大。另一方面，在服务器不需要先前信息时他的应答就很快。 后来的改进：两种用于保持 HTTP 连接状态的技术就应运而生了——Cookie和Session。 Cookie可以保持登录信息到用户下次与服务器的会话，换句话说，下次访问同一网站时，用户会发现不必输入用户名和密码就已经登录了 而Session是通过服务器来保持状态的。 简单快速：客户向服务器请求服务时，只需要传送请求方式和路径，请求方法常用的有GET、POST、PUT、DELETE。每种方法规定了客户与服务器联系的类型的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 灵活：HTTP协议允许传输任意类型的数据对象，不同的传输类型由content-Type加以标记。 HTTP协议工作于客户端-服务端架构：浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。Web服务器根据接收到的请求后，向客户端发送响应信息。 说一下http和https【HTTPS = HTTP + SSL/TSL(安全层)】 http和https的基本概念 http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。 https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层（https的SSL加密是在传输层实现的），HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。 http和https的区别【看第四点】 http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。 主要的区别如下： Https协议需要ca证书，费用较高。 http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。 使用端口不同，一般而言，http协议的端口为80，https的端口为443 http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 补充HTTP、HTTPS、TCP、UDP的区别HTTP、HTTPS是应用层协议，为应用系统服务，他们都用TCP传输方式来传输UDP TCP 是传输层协议，为应用层协议提供服务。IP是网络层协议，为传输层提供服务。上层利用下层的服务，下层为上层服务，每层解决不同的网络问题 https协议的工作原理客户使用https url访问服务器，则要求web 服务器建立ssl链接。web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。web服务器通过自己的私钥解密出会话密钥。web服务器通过会话密钥加密与客户端之间的通信。（关于“公钥和私钥”可参考知乎文章） https协议的优点 使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器； HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。 HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。 谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。 https协议的缺点 https 握手阶段比较费时耗电（校验证书，交换密钥），会使页面加载时间延长50%，增加10%~20%的耗电。 https 缓存不如http高效，会增加数据开销。 SSL证书也需要钱，功能越强大的证书费用越高。 SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗 说一下http2.0简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。 提升访问速度（相比http1.0，请求资源所需时间更少，访问速度更快，） 允许多路复用：就是说 HTTP/2 可以重复使用同一个 TCP 连接，并且连接是多路的，多个请求或响应可以同时传输。对比之下，HTTP/1.1 的长连接也能复用 TCP 连接，但是只能串行，不能“多路”。 二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码。 HTTP/2 允许取消某个正在传输的数据流（通过发送 RST_STREAM 帧），而不关闭 TCP 连接。这正是二进制协议的好处之一，可以定义多种功能的数据帧。 首部压缩 服务器端推送：服务端能够直接把资源推送给客户端，当客户端需要这些文件的时候，它已经在客户端了。（该推送对 Web App 是隐藏的，由浏览器处理） HTTP与WebSocket HTTP协议和WebSocket协议都是应用层的网络通信协议，两者应用场景不一样。（而Socket 是传输控制层协议） HTTP 协议有一个缺陷：通信只能由客户端发起。 HTTP主要用来一问一答的方式交付信息，而WebSocket让通信双方都可以主动去交换信息，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息（实时传输消息）。 WebSocket是基于HTTP1.1的协议，可以简单理解为创建了一条TCP连接，在JS中用new WebSocket(&quot;ws://hostname/chattingrom/&quot;)来创建，具有双向传输二进制等特性。 在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并可以直接进行双向数据传输。 而HTTP2.0则是对HTML、CSS等JS资源的传输方式进行了优化，允许服务端直接把资源推送给客户端，但并没有提供新的JS API，也不能用于实时传输消息。 比起传统的ajax请求轮询，HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 WebSocket其他特点（1）建立在 TCP 协议之上，服务器端的实现比较容易。（2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且在握手阶段采用 HTTP/1.1 协议（暂时不支持 HTTP/2），因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。（3）数据格式比较轻量，性能开销小，通信高效。（4）可以发送文本，也可以发送二进制数据。（5）没有同源限制，客户端可以与任意服务器通信。（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 常见的HTTP的头部参考、HTTP报头中Accept与Content-Type的区别可以将http首部分为请求首部/响应首部，通用首部，实体首部 请求首部就是请求报文中独有的 cookie 和缓存相关的如If-Modified-Since、If-None-Match Accept系列: 定义请求结果的要求，如Accept（客户端希望接受的数据类型），Accept-Encoding，Accept-Language，Accept-Charset等。 Host: 目标服务器的域和端口号，如Host:www.demo.com。 Referer: 发起请求的页面URI，即Referer:${window.location.href} User-Agent: 客户端信息，如1User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 响应首部就是响应报文中独有的，如set-cookie，和重定向相关的location ETag: 某一个固定的URI资源发生变化时，ETag会更新，如ETag:W/&quot;92d8a6509d07d749ee661d8af47d2fbd&quot;（和请求头中If-None-Match是一对） Server: HTTP服务器的应用程序信息，如Server:Apache/2.2.6 (Unix) PHP/5.2.5 Location: 引导客户端向某资源发起访问，一般配合状态码3xx使用，重定向请求，如Location:http://www.demo2.com/index.html。 WWW-Authenticate: 告诉客户端认证方案，一般配合状态码401 Unauthorized使用，如WWW-Authenticate:Basic realm=&quot;Usagidesign Auth&quot; 通用首部表示一些通用信息，比如date表示报文创建时间 Cache-Control: 对于缓存服务器下达缓存控制的相关指令，具体指令有no-cache, no-store, max-age = ${秒} , public, private等。 Connection: 控制代理不再转发的字段，管理持久连接。如Connection:Upgrade，那么在经过代理后，Upgrade首部字段将不会被发送至服务器。如Connection:Keep-Alive。 Date: 表示HTTP报文创建时间，如Date:Fri, 19 Oct 2018 09:45:13 GMT。 Pragma: 兼容HTTP1.1以前的版本，控制缓存，如Pragma:no-cache。 Transfer-Encoding: 报文传输时的编码方式，HTTP1.1仅对分块传输的编码形式有效，如Transfer-Encoding:chunked。 实体首部用来描述实体部分 Allow: 资源允许的请求方法，如Allow:GET, HEAD。 Expires: 资源过期时间(绝对时间)，如Expires:Fri, 20 Oct 2018 09:45:13 GMT。 Last-Modified: 资源最后一次修改的时间，如Last-Modified:Fri, 15 Oct 2018 09:45:13 GMT。(和请求头中的if-Modified-Since是一对) 还有一些表示资源具体信息的，如Content-Encoding描述主体的编码方式, Content-Type代表发送端（客户端/服务器）发送的实体数据的数据类型, Content-Language, Content-Range等。 http常用请求头参考 介绍知道的http返回的状态码 1xx （临时响应）表示临时响应并需要请求者继续执行操作的状态代码。 2xx （成功）表示成功处理了请求的状态代码。 3xx （重定向） 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。 4xx （请求错误） 这些状态代码表示请求可能出错，妨碍了服务器的处理。 5xx （服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。 100 Continue 继续。客户端应继续其请求101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的PUT请求是可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 301和302的区别 301 Moved Permanently : 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替。除非额外指定，否则这个响应也是可缓存的。（统一资源标志符URI 和 统一资源定位符URL） 302 Found : 临时移动。与301类似。但资源只是临时被移动。由于这样的重定向是临时的，客户端应继续使用原有URI。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 字面上的区别就是301是永久重定向，而302是临时重定向。 301比较常用的场景是使用域名跳转。302用来做临时跳转，比如未登陆的用户访问用户中心重定向到登录页面。 状态码304和 200 状态码200：请求已成功，请求所希望的响应头或数据体将随此响应返回。即返回的数据为全量的数据，如果文件不通过GZIP压缩的话，文件是多大，则要有多大传输量。 状态码304：如果客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。即客户端和服务器端只需要传输很少的数据量来做文件的校验，如果文件没有修改过，则不需要返回全量的数据。 400和401、403状态码 400状态码：请求无效 产生原因：前端提交数据的字段名称和字段类型与后台的实体没有保持一致前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。 解决方法：对照字段的名称，保持一致性将obj对象通过JSON.stringify实现序列化 401状态码：当前请求需要用户验证 403状态码：服务器已经得到请求，但是拒绝执行 HTTP支持的方法 HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。 HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 对于除GET请求以外的HTTP请求，如果存在跨域请求，浏览器必须首先使用OPTIONS方法询问服务端是否允许跨域请求，然后才发起真正的请求，OPTIONS请求称为预检请求。（这也就是为什么ajax/fetch请求存在2次HTTP请求的原因） 详细参考 GET和POST的区别 GET和POST的底层都是TCP/IP，GET/POST都是TCP链接。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。 get参数通过url传递，post放在request body中。 GET从指定的资源请求数据，POST向指定的资源提交要被处理的数据。 get请求在url中传递的参数是有长度限制的，而post没有。 get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。 get请求只能进行url编码，而post支持多种编码方式 get请求会浏览器主动cache，而post不会,除非手动设置。 get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。 GET产生一个TCP数据包；POST产生两个TCP数据包。 GET请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 一句话概括RESTFUL 用URL定位资源，用HTTP描述操作 RESTful是目前最流行的API架构风格，用于Web数据接口的设计。 RESTful的核心思想：请求方式 + URL的方式对资源发起命令。 比如：GET /user GET 查询动作，user是被查询的对象。 比如：POST /user POST 新增动作，user是被新增的对象。 参考","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS 开发环境","slug":"JS 开发环境","date":"2020-04-01T02:08:27.000Z","updated":"2020-06-12T02:12:49.370Z","comments":true,"path":"2020/04/01/JS 开发环境/","link":"","permalink":"http://yoursite.com/2020/04/01/JS 开发环境/","excerpt":"关于开发环境 面试官想通过开发环境了解候选人的实际工作情况 开发环境的工具，能体现工作产出的效率 会以聊天形式为主，不会问具体的问题","text":"关于开发环境 面试官想通过开发环境了解候选人的实际工作情况 开发环境的工具，能体现工作产出的效率 会以聊天形式为主，不会问具体的问题 git 最常用的代码版本管理工具 大型项目需要多人协作开发，必须熟用git 如果你不知道或者之前不用git，不会通过面试 Mac OS自带git命令，windows可去官网下载安装git 服务端常见的有github和coding.net等 大公司会搭建自己的内网git服务 常用git命令可参考博客借助coding管理项目 123456789101112131415161718git add 文件名 //添加单个指定文件到暂存区git add . //添加所有文件到暂存区git checkout 文件名 //将某个文件还原到上一次提交的状态（撤回修改）git checkout . //将所有文件还原到上一次提交的状态（撤回修改）git commit-m\"相关描述\" //提交文件到本地仓库git push origin master //将文件推送到服务端（master也可以是其他分支）git pull origin master //从服务端下载整个分支的内容git status //查看当前修改过/新增的文件git diff //查看被修改的内容git branch //查看当前所有分支git checkout -b 分支名 //增加分支git checkout 分支名 //切换分支（注意：在a分支的内容不会显示在b分支中）git log //查看提交记录git show 某个id //查看某次提交内容（id为git log中某次修改对应的commit后内容）git fetch //下载所有分支到本地git merge 待合并分支名 //将待合并分支合并到当前分支中git stash //暂存修改git stash pop //将修改放出 chrome调试工具 一般不会面试时考察，但这是前端工程师必备的技能（不算知识） 也就是常用的F12 Elements Network：不同资源的加载情况，其中和ajax相关的在XHR中 Console Application debugger：即Sources 抓包 移动端h5页，查看网络请求，需要用工具抓包 windows一般用fiddler Mac OS一般用charles 移动端抓包步骤 手机和电脑连同一个局域网 将手机代理到电脑上 手机浏览网页，即可抓包 查看网络请求 网址代理（设置map from与map to） https：有叉号的就说明是https协议的，需要另外设置才可抓包 webpack和babel 存在意义： 浏览器暂不支持ES6模块化 浏览器并不完全支持ES6语法 压缩代码，整合代码，可以让网页更多的命中缓存，加载更快 webpack和bebal使用思路： 使用webpack插件进行第一次打包，将项目中js文件打包到bundle.js中（多文件打包参考这里） 使用webpack-dev-server插件启动server服务 我们访问的html是通过html-webpack-plugin插件在解析html产出新的html文件时带上bundle.js，这样就能看到bundle.js被挂载在最后生成的html内 配置babael后，使用webpack-dev-server插件时node_modules以外的js文件都经过babel-loader插件（它只是babel提供给webpack的插件，真正语法编译在@babel/core），去@babel/core进行语法转译。此时bundle.js中的ES6以上的语法也会被编译到ES5及以下后再放到最后显示的html中 注意：以上所有插件都是需要配置才能实现这些效果的 命令总结（例子中）build命令：用于生产环境下进行项目打包（因为配置文件使用的是webpack.prod.js，去掉--config webpack.prod.js则使用默认配置文件webpack.config.js，即开发环境下进行项目打包）dev命令：用于开发环境下启动server服务， webpack webpack：前端标配的项目打包工具，配置繁琐且易忘 插件： 使用webpack和webpack-cli打包项目 使用html-webpack-plugin解析html 使用webpack-dev-server启动server服务 webpack打包方法 首先需要安装node(查看node版本node -v) 初始化环境：npm init -y 安装webpack：npm install webpack webpack-cli -D 根目录下新建src文件夹-index.js，随便写点东西： 根目录下新建配置文件webpack.config.js（webpack默认的名字）：path.join()和path.resolve()的异同 package.json中增加webpack打包命令： 运行build命令，进行打包： 查看打包好的文件，在dist-bundle.js：可以发现代码很多，这是因为webpack自己模块化的关系，且我们配置时设定的是开发环境，顾不压缩 webpack在网页显示 src下新建index.html： 安装html-webpack-plugin插件，用于解析html：npm install html-webpack-plugin -D 安装webpack-dev-server插件，用于启动server服务：npm install webpack-dev-server -D 更改配置文件，在webpack.config.js中： package.json中增加dev命令，用于启动server服务： 运行dev命令，开启server服务，由于html-webpack-plugin插件的配置，服务开启后只要访问index.html就会在产出新的html文件的时候带上bundle.js 访问3000端口： 查看最后生成的html，bundle.js被挂载在index.html中，而打印的字符之前被打包在bundle.js中，故显示： webpack与ES6模块化ES6模块化就是一个导入导出的过程，他是默认支持，不需额外配置的。 在src下新建a.js进行模块导出： 在index.js中解构导入： 直接刷新网页（因为刚刚开过webpack-dev-server插件）： babel babel：编译ES6以上语法的工具 经常结合webpack使用 插件（”@babel”是“组”的意思，”/“说明时里面单个的模块，比如“@babel/core”即为babel模块的core）： @babel/core：babel核心 @babel/preset-env：babel环境配置 babel-loader：给webpack使用的插件 使用步骤： 安装上面三个插件 新建.babelrc文件（json格式）进行babel配置（使用@babel/preset-env插件） 在webpack.config.js中进行module配置，让js文件都经过babel-loader插件去@babel/core插件进行语法编译 运行 webpack-dev-server插件 启动服务器，则打包后的源码是经过转译的（不含有ES6以上语法） 使用方法 在webpack例子的文件夹中，修改index.js，写入含有ES6语法的代码： 安装@babel/core(babel核心)、@babel/preset-env(babel环境配置)、babel-loader(给webpack使用的插件)（”@babel”是“组”的意思，”/“说明时里面单个的模块，比如“@babel/core”即为babel模块的core）：npm install @babel/core @babel/preset-env babel-loader -D 根目录下新建.babelrc文件（json格式），使用刚安装的@babel/preset-env来配置babel： 在webpack.config.js中进行module配置（针对不同的模块做不同的解析）：在src下node_modules以外的js文件都经过babel-loader插件（它只是babel提供给webpack的插件，真正语法编译在@babel/core），去@babel/core进行转译 运行dev命令，启动server服务：npm run dev。出现compiled successfully说明编译成功： 查看源码中的bundle.js，可发现ES6语法已转译： webpack配置生产环境之前我们配置的webpack是开发环境下的，使用的是默认的webpack.config.js文件。打包的内容不会被压缩。而生产环境下产生的打包bundle文件是被压缩后的。 根目录下新建webpack.prod.js作为生产环境的配置文件：其中和webpack.config.js基本一致，不同的3个地方都已在图上标出 修改package.json中build命令：原本build直接使用webpack，他会找到默认的配置文件webpack.config.js。现在改成让他去找webpack.prod.js： 将原本的dist文件夹删除，以防干扰。运行build命令：npm run build 查看dist文件夹：可以看见bundle后跟着内容哈希值，代码内容不变则该哈希值就不会发生改变 验证：在代码不变时再次执行build进行打包，哈希值不变。修改代码后再打包，则改变： linux常用命令 学习linux常用命令原因： 公司的线上机器一 般都是linux（参考阿里云） 测试机也需要保持一 致，用linux 测试机或者线上机出了问题，本地又不能复现，需要去排查（常见） 登录：比如ssh work@192.168.10.21回车后输入密码，work也可以是root（更高权限），@后跟公司IP地址 创建文件夹mkdir 文件夹名 查看当前文件夹中文件： 平铺形式查看ls(以.开头的文件都是隐藏文件，想查看可使用ls -a,即all) 列表形式查看ll 查看单个文件夹中文件：ls 文件夹名/ll 文件夹名 删除文件夹：rm -rf 文件夹名，rm即remove，参数中-r是递归删除（不管多少层都删了），-f是强制删除（如果没他就每个文件都会问你“是否删除”） 删除文件：rm 文件名，因为文件中不存在嵌套关系，所以不需要设置参数（没有回收站之类的，删完就没了） 清屏clear 定位到目录：cd 文件夹名则可到达该文件夹下，上级目录为../ 创建文件： 纯新建：touch 文件名，新建后就放置不管 新建后立即打开该文件:vi 文件名，打开的页面是vim编辑器，下面是常用的vim命令（更多命令可搜vimtutor） 点击i后可进行输入 点击键盘上ESC键可退出输入 点击:后点击回车按钮，即可保存 点击:后点击q,即可退出该文件（不想保存可使用:q!强制退出） 查看文件内容： （新窗口显示）有则打开，无则新建：vi 文件名或者vim 文件名 当前位置打印文件全部内容：cat 文件名 当前位置打印文件前几行：head 文件名 当前位置打印文件末尾几行：tail 文件名 查找文件中带某些关键字的内容：grep &quot;关键字&quot; 文件名 修改文件名：mv 当前文件名 新文件名，mv即move，填写文件名时可以写 前面的字母+tab 将智能补充 移动文件：mv 文件名 被移动位置后的文件名，好像比较难理解，她和修改文件名都是使用move。比如：将index.html移动到 上级目录下 则是：mv index.html ../index.html 拷贝文件：cp 被拷贝的文件名 拷贝的文件名，比如将a.js拷贝一份a1.js出来，则cp a.js a1.js","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS Web API 面试题","slug":"JS Web API 面试题","date":"2020-03-31T13:23:01.000Z","updated":"2020-11-05T10:10:13.142Z","comments":true,"path":"2020/03/31/JS Web API 面试题/","link":"","permalink":"http://yoursite.com/2020/03/31/JS Web API 面试题/","excerpt":"DOMDOM是哪种数据结构树（DOM树），基于树状结构才有了父节点、子节点。","text":"DOMDOM是哪种数据结构树（DOM树），基于树状结构才有了父节点、子节点。 DOM操作的常用API DOM节点操作： 获取1个DOM元素：getElementByld()/querySelector() 获取多个DOM元素（nodeList集合）：getElementsByTagName()/getElementsByClassName()/querySelectorAll() DOM结构操作（具体可参考“JS中修改/创建/移动/删除 HTML DOM元素“）： document.createElement()创建 元素节点 document.createTextNode() 创建 文本节点 Node.appendChild() 添加/移动 子节点 Node.removeChild() 删除 子节点 attribute和property的操作： getAttribute()获取attribute setAttribute()修改attribute removeAttribute()删除attribute createAttribute()仅建立一个attribute attribute和property的区别 attribute：修改html属性，会改变html结构 attribute 是 DOM元素 在文档中作为 html 标签拥有的属性 property：修改JS对象属性，不会体现到html结构中 property 是 DOM元素 在 js 中作为对象拥有的属性 两者都有可能引起DOM重新渲染，但建议尽量使用property HTML attribute(特性) DOM property(属性) 值永远是字符串或 null 值可以是任意合法 js 类型 大小写不敏感 大小写敏感 不存在时返回 null 不存在时返回 undefined 对于 href, 返回 html 设置的值 对于 href 返回解析后的完整 url 更新 value, 属性也更新 更新 value, 特性不更新 （可参考这篇博客） 一次性插入多个DOM节点，考虑性能将频繁操作改为一次性操作： 通过createDocumentFragment()先创建一个文档片段，这个文档片段是保存在JS中的（不是在DOM树中） 将循环10次产生的子节点都添加到文档片段中 将 文档片段 添加到DOM树上： BOM如何识别浏览器的类型通过navigator.userAgent识别浏览器的类型。 分析拆解url各个部分 location.href:整个网站地址 location.protocol:采用的协议（比如https:/http:） location.host:域名 location.search:路由参数，即?后的内容 location.hash:网址的哈希，即#后的内容 location.pathname:路径 事件通用的事件监听函数 【简单版】可监听 普通绑定 的通用事件监听函数： 【正式版】可以同时监听 普通绑定 和 代理绑定 的通用事件监听函数： Element.matches() 如果元素匹配指定的选择器字符串，则Element.matches()返回true，否则返回false。 语法：let result = element.matches(selectorString); result 的值为 true 或 false. selectorString 是个css选择器字符串. MDN文档 event事件对象 可参考“DOM基础” DOM事件的回调函数中的第一个参数event指的是事件对象 可以使用event.preventDefault()取消事件的默认动作，比如：如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。注意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。 事件对象.target就是事件绑定函数对应的事件触发的DOM元素 target 事件属性 target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。 具体可参考菜鸟教程 描述事件冒泡的流程 基于DOM树形结构 事件会顺着触发元素往上冒泡 应用场景：事件代理 无限下拉的图片列表，如何监听每个图片的点击？ 事件代理 用e.target获取触发元素 用matches来判断是否是触发元素 AJAX手写简易ajax 模拟404情况，换成不存在的地址： 跨域的实现方式 jsonp原理：可参考博客JS Web API AJAX cors（纯服务端）：可参考博客JS Web API AJAX 存储描述cookie localStorage sessionStorage区别 共同点：都保存在浏览器端。 区别： 生命周期： Cookie：设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。未设置则默认为关闭浏览器后失效。(不是浏览器标签页，而是整个浏览器) Localstorage:除非被手动清除，否则永久保存，窗口或浏览器关闭也一直保存，因此用作持久数据。 Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除（刷新页面不会被清除），自然也就不可能持久保持。 存放数据： Cookie：4k左右（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下） Localstorage和sessionstorage：可以保存5M的信息 是否跟随http请求发送出去： Cookie：每次都会携带在http头中，如果使用cookie保存过多数据会带来性能问题 其他两个：不会自动把数据发给服务器，仅在客户端即浏览器中保存，不参与和服务器的通信 API易用性： Cookie：需要程序员自己封装，原生的cookie接口不友好（document.cookie） 其他两个：即可采用原生接口（getItem和setItem），亦可再次封装 应用场景： 从安全性来说，因为每次http请求都回携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，不可以跨域调用，限制很多，但是对于用户识别用户登陆来说，cookie还是比storage好用 其他情况下可以用storage，localstorage可以用来在页面传递参数 sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。 作用域： cookie和localStorage：在所有同源窗口中都是共享的 sessionStorage：在同一个浏览器窗口是共享的（不同浏览器、同一个页面也是不共享的） 关于同源可参考阮一峰，简单来说就是A网页设置的 Cookie，B网页不能打开","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS Web API 存储","slug":"JS Web API 存储","date":"2020-03-30T09:00:43.000Z","updated":"2020-06-08T13:22:08.757Z","comments":true,"path":"2020/03/30/JS Web API 存储/","link":"","permalink":"http://yoursite.com/2020/03/30/JS Web API 存储/","excerpt":"cookie 原本用于浏览器和server通讯（hhtp请求），最早是被“借用”到本地存储来的（因为localstorage和sessionstorage是html5才提出的） js中可用docuiment.cookie =&#39;...&#39;来修改cookie","text":"cookie 原本用于浏览器和server通讯（hhtp请求），最早是被“借用”到本地存储来的（因为localstorage和sessionstorage是html5才提出的） js中可用docuiment.cookie =&#39;...&#39;来修改cookie cookie是字符串形式，通过分号分隔 可查看分隔开的cookie： 前端设置（添加）/查看cookie，键=值： 每次只能设置（添加）一个键值对 同key则覆盖，不同key则追加 cookie做本地存储 在localstorage和sessionstorage未出现前，cookie是唯一可做本地存储的，只要不清除cookie，不管页面怎么刷新，cookie都不变 缺点： 存储大小，最大4KB 每次http请求时需要同时将本地存储的数据发送到服务端，增加了请求数据量（毕竟他的本职就是和server通讯，不适合带上太多数据） 只能用document.cookie =&#39;...&#39;来修改，api太过简陋 html5存储localStorage和sessionStorage HTML5专门为存储而设计，最大可存5M（每个域名下） API简单易用（setItem getItem） 不会随着http 请求被发送出去 例子注意：key和value最终都会被强转为字符串形式 区别 localStorage数据会永久存储，除非代码或手动删除 sessionStorage数据只存在于当前会话，浏览器关闭则清空 一般用localStorage会更多一些 相关面试题描述cookie localStorage sessionStorage区别 共同点：都保存在浏览器端。 区别： 生命周期： Cookie：设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。未设置则默认为关闭浏览器后失效。(不是浏览器标签页，而是整个浏览器) Localstorage:除非被手动清除，否则永久保存，窗口或浏览器关闭也一直保存，因此用作持久数据。 Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除（刷新页面不会被清除），自然也就不可能持久保持。 存放数据： Cookie：4k左右（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下） Localstorage和sessionstorage：可以保存5M的信息 是否跟随http请求发送出去： Cookie：每次都会携带在http头中，如果使用cookie保存过多数据会带来性能问题 其他两个：不会自动把数据发给服务器，仅在客户端即浏览器中保存，不参与和服务器的通信 API易用性： Cookie：需要程序员自己封装，原生的cookie接口不友好（document.cookie） 其他两个：即可采用原生接口（getItem和setItem），亦可再次封装 应用场景： 从安全性来说，因为每次http请求都回携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用，此外cookie还需要指定作用域，不可以跨域调用，限制很多，但是对于用户识别用户登陆来说，cookie还是比storage好用 其他情况下可以用storage，localstorage可以用来在页面传递参数 sessionstorage可以用来保存一些临时的数据，防止用户刷新页面后丢失了一些参数。 作用域： cookie和localStorage：在所有同源窗口中都是共享的 sessionStorage：在同一个浏览器窗口是共享的（不同浏览器、同一个页面也是不共享的） 关于同源可参考阮一峰，简单来说就是A网页设置的 Cookie，B网页不能打开","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"实现首页搜索功能","slug":"实现首页搜索功能","date":"2020-03-29T14:08:34.000Z","updated":"2020-04-29T14:11:37.484Z","comments":true,"path":"2020/03/29/实现首页搜索功能/","link":"","permalink":"http://yoursite.com/2020/03/29/实现首页搜索功能/","excerpt":"思路 前端header组件中增加搜索框，给button绑定点击事件，点击搜索按钮时发送ajax请求将input框中内容传给后端 后端service层创建函数模糊查询，controller层，路由层… 前端新增search.ejs用于显示查询结果，view-blog.js下新建页面路由，注册路由","text":"思路 前端header组件中增加搜索框，给button绑定点击事件，点击搜索按钮时发送ajax请求将input框中内容传给后端 后端service层创建函数模糊查询，controller层，路由层… 前端新增search.ejs用于显示查询结果，view-blog.js下新建页面路由，注册路由 前端 header.ejs中，增加搜索框： 给button 绑定点击事件，点击搜索按钮时发送ajax请求（/api/search)将input框中内容传给后端页面路由： 新建search.ejs用于显示查询结果： widgets下新建search-user.ejs用于显示用户查询结果： 页面路由 【service层】创建2个函数=》getBlogList函数根据searchContent模糊的连表分页查询blogs表和users表；getUserList函数根据searchContent模糊查询users表中userName： service-blog.js和user.js： 【controller层】创建getSearchBlogList, getSearchUserList函数=》调用service层getBlogList，getUserList函数进行2个模糊查询，根据返回的blogId分页查询blogs表，根据返回的userName查询users表，将2个数组以及查询到的总用户count返回给路由层： controller下新建blog-search.js： 【路由层】调用controller层getSearchBlogList, getSearchUserList函数=》将blogData和userData返回给前端的页面路由： view-blog.js下新建页面路由/search，接受动态参数searchContent（不需要登录验证）： 实现加载更多 【前端】 search.ejs中调用load-more组件时多传递一个动态参数searchContent： 【路由层】 routes-api下新建search.js： 【app.js注册路由】 效果 搜索“z”： 搜索“加油”：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"实现首页输入框敏感词过滤","slug":"实现首页敏感词过滤","date":"2020-03-28T05:56:02.000Z","updated":"2020-04-27T06:18:44.686Z","comments":true,"path":"2020/03/28/实现首页敏感词过滤/","link":"","permalink":"http://yoursite.com/2020/03/28/实现首页敏感词过滤/","excerpt":"思路在controller层去调用service层函数创建微博之前，使用mint-filter工具将微博内容content进行过滤，使用过滤后的微博内容在数据库中创建blog","text":"思路在controller层去调用service层函数创建微博之前，使用mint-filter工具将微博内容content进行过滤，使用过滤后的微博内容在数据库中创建blog 步骤 【定义敏感词数组】 在conf-constants.js中，定义敏感词数组 【controller层】使用mint-filter工具将微博内容content进行过滤： controller下blog-home.js： 实现效果敏感词数组中有“法轮功”的字眼，尝试输入“支持法轮功”并发布，效果如下： 借助算法 开发工具的作者的文章 基于Aho–Corasick算法实现的敏感词过滤方案，Aho–Corasick算法是由Alfred V. Aho和Margaret J.Corasick 发明的字符串搜索算法，用于在输入的一串字符串中匹配有限组“字典”中的子串。它与普通字符串匹配的不同点在于同时与所有字典串进行匹配。算法均摊情况下具有近似于线性的时间复杂度，约为字符串的长度加所有匹配的数量。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"实现首页点赞功能","slug":"实现首页点赞功能","date":"2020-03-27T04:08:11.000Z","updated":"2020-04-27T04:09:19.383Z","comments":true,"path":"2020/03/27/实现首页点赞功能/","link":"","permalink":"http://yoursite.com/2020/03/27/实现首页点赞功能/","excerpt":"思路 创建likes表，用户每次点赞微博就存一条点赞关系（userId、blogId）。blogs表中添加likeCount记录总点赞数，isLike表示当前用户是否点赞该条微博 登录后，自动将userId拿去查likes表后遍历blogList去修改isLike 前端根据isLike显示不同的点赞按钮，根据likeCount显示点赞数 点击点赞按钮后，根据前端传回的isLike来判断当前用户是否已点赞当前微博，是则likeCount-1并改变isLike为false，否则 likeCount+1并改变isLike为true","text":"思路 创建likes表，用户每次点赞微博就存一条点赞关系（userId、blogId）。blogs表中添加likeCount记录总点赞数，isLike表示当前用户是否点赞该条微博 登录后，自动将userId拿去查likes表后遍历blogList去修改isLike 前端根据isLike显示不同的点赞按钮，根据likeCount显示点赞数 点击点赞按钮后，根据前端传回的isLike来判断当前用户是否已点赞当前微博，是则likeCount-1并改变isLike为false，否则 likeCount+1并改变isLike为true 创建likes表，添加blogs中列 创建likes表： blogs表中添加2列： 登录后改blogs表中isLike 登录后，自动将当前用户的userId拿去查likes表后遍历blogList去修改isLike。 controller-user.js的登录路由中： 修改前端 前端根据isLike显示不同的点赞按钮，根据likeCount显示点赞数 blog-list.ejs中点赞按钮的部分： blog-list.ejs中点赞按钮的点击事件： 实现点赞的接口路由点击点赞按钮后，根据前端传回的isLike来判断当前用户是否已点赞当前微博，是则likeCount-1并改变isLike为false，否则 likeCount+1并改变isLike为true。 【路由层】创建路由，传递isLike、likeCount、微博的id并调用controller层updateLikeCount函数=》返回blogData.likeCount给前端： api-blog-home.js中，创建路由：记得app.js中注册路由 【controller层】创建updateLikeCount函数=》根据isLike判断likeCount+1/-1、isLike为true/false的调用service层updateLikeCount函数更新数据库： controller下blog-home.js： 【service层】创建updateLikeCount函数=》更新blogs表中likeCount与isLike： service-blog.js：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"艾特提到我的","slug":"@提到我的","date":"2020-03-26T11:55:01.000Z","updated":"2020-04-24T06:34:31.716Z","comments":true,"path":"2020/03/26/@提到我的/","link":"","permalink":"http://yoursite.com/2020/03/26/@提到我的/","excerpt":"@提到我的实现功能：有人@我之后，会在首页/个人主页右侧给出@总数，点击进入@我的消息页，展示所有@我的内容","text":"@提到我的实现功能：有人@我之后，会在首页/个人主页右侧给出@总数，点击进入@我的消息页，展示所有@我的内容 数据模型回顾数据模型设计 创建数据模型：AtRelation&amp;同步到数据库 新建AtRelation.js，db-model-AtRelation.js下： 创建外键关系、统一输出，方便同步，db-model-index.js中：AtRelation中blogId是Blog中id的外键 同步到数据库：node src/db/sync.js 查看数据库：注意：sequelize中我们使用boolean保存的isRead到数据库中是tinyint，用很小的数字表示boolean，不影响功能使用 @关系【重点理解Promise.all()发送多个请求】 收集分析@的用户 建立AtRelation关系 获取@的数量显示在页面 收集分析@的用户&amp;建立AtRelation关系 【controller层】在创建微博之后，调用service层createAtRelation函数创建 @ 关系：在输入框中创建微博是通过controller下blog-home.js中的create方法完成的，所以我们需要在调用service层createBlog函数之前先收集分析@的用户： 我们让 替换不生效：REG_FOR_AT_WHO匹配的就是matchStr，返回matchStr则替换不生效。我们只是通过replace获取所有被@用户的userName列表 Promise.all()获取多个Promise实例的参数，用于发送多个请求 【service层】创建createAtRelation函数： service下新建atRelation.js，创建一个“创建微博 @ 用户的关系”的createAtRelation函数： 测试：成功添加进数据库： 获取@的数量显示在页面前端代码 user-info.ejs，通过从后端获取atCount来显示@的数量： 调用user-info.ejs的ejs模板需要获取并传递atCount，比如index.ejs：个人主页也是一样的 开发步骤 【controller层】创建getAtMeCount函数=》调用service层getAtRelationCount函数=》获取 @ 我的微博数量： controller下新建blog-at.js： 【service层】创建getAtRelationCount函数=》连表查询 获取 @ 用户的微博数量（未读的）： service下at-relation.js中： 【路由层】调用controller层getAtMeCount函数获取 @ 我的微博数量=》返回atCount给前端： routes-view-blog.js 首页路由中： 测试首页： 搞定个人主页：也是一样的，在routes-view-blog.js 个人主页路由中： 测试个人主页： 开发页面和路由实现功能:点击”提到我的”以后要跳转页面 开发页面路由（三表查询 获取第一页列表） views下新建atMe.ejs 【路由层】创建页面路由，调用controller层getAtMeBlogList函数=》获取第一页列表 和 列表总行数=》返回给前端： routes-view-blog.js中： 【controller层】创建getAtMeBlogList函数=》调用service层getAtUserBlogList函数=》获取 @我的微博列表第一页数据 和 列表总行数： controller下blog-at.js中： 【service层】创建getAtUserBlogList函数=》三表查询 获取第一页列表 和 列表总行数： service下at-relation.js中： 测试： 开发接口路由（加载更多） 【路由层】创建路由，返回数据给前端： routes-api下新建blog-at.js，逻辑基本和个人主页的加载更多一样，除了 路由地址 以及 调用的controller层的函数获取的微博列表 不同 app.js注册路由： 测试：进入@我的消息页，下滑出现“加载更多”，点击后加载下一页 标记为已读 【前端】读完at-me页后，首页右侧需显示“提到我的（0）”： user-info.js中，前端需要获取atCount来显示当前提到我的总数，如果读完就要使其显示回0： 【路由层】渲染页面后=》调用controller层的markAsRead函数=》将atRelations表中所有和当前userId（被@用户）相关的isRead都改为false： ，routes-view-blog.js的 atMe 路由 中： 【controller层】调用service层updateAtRelation函数=》将isRead改为false： controller下blog-at.js，不需要返回SuccessModel 或者 ErrorModel是因为 markAsRead是在渲染页面后调用的，SuccessModel 或者 ErrorModel是为了把数据返回给前端才使用的，而已读与否是不需要返回给前端的： 【service层】创建updateAtRelation函数=》更新 AtRelation表中isRead： service下at-relation.js： 测试：一开始进入是13条未读，退出@页面后显示0条未读： 注意： sequelize中isRead使用的true和false在数据库中实际是使用0和1来表示的（1是false），可看atRelations表：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"艾特和回复","slug":"@和回复","date":"2020-03-25T02:42:31.000Z","updated":"2020-04-24T06:34:19.469Z","comments":true,"path":"2020/03/25/@和回复/","link":"","permalink":"http://yoursite.com/2020/03/25/@和回复/","excerpt":"@功能（输入@&amp;显示@） 输入@&amp;显示@：可在输入框输入@后，给显示在页面上的@加超链接","text":"@功能（输入@&amp;显示@） 输入@&amp;显示@：可在输入框输入@后，给显示在页面上的@加超链接 at.js库 github中搜索at.js 使用方法：12345// 依赖于jquery&lt;link href=\"css/jquery.atwho.css\" rel=\"stylesheet\"&gt;&lt;script src=\"http://code.jquery.com/jquery.js\"&gt;&lt;/script&gt;&lt;script src=\"js/jquery.caret.js\"&gt;&lt;/script&gt;&lt;script src=\"js/jquery.atwho.js\"&gt;&lt;/script&gt; 12345// 使用atwho()，参数1：识别关键词，参数2：可被@的用户数组$('#inputor').atwho(&#123; at: \"@\", data:['Peter', 'Tom', 'Anne']&#125;) 前端使用at.js库做出接口 在views-layout-header.ejs中，引入所需： 在views-widgets-input.ejs中，使用at.js库： 测试效果：先使用模拟数据data: [&#39;Peter&#39;, &#39;Tom&#39;, &#39;Anne&#39;]: 开发接口 【路由层】创建/getAtList路由，调用controller层getFollowers函数，获取 at 列表，即关注人列表，返回前端需要的 字符串数组： routes-api-user.js：昵称有可能重名，所以需要将userName带上 测试：将zhangsan的昵称改为张三后，登录lisi帐号去@zhangsan：但是我们并不希望发布后的内容带着userName的后缀 @用户转为链接形式 在services-_format.js中，进行格式化微博内容=》格式化 @： 参数1（matchStr）：符合正则表达式的字符串。 参数2（nickName）：符合正则表达式中第1个括号内（即(.+?)）的字符串。 参数3（userName）：符合正则表达式中第2个括号内（即(\\w+?)）的字符串。 在services-_format.js中，调用： 正则表达式解析： .：匹配所有字符 +：匹配多个字符 ?：贪婪匹配（遇到空格就停止） \\s：空格 \\w：匹配字母和下划线 \\b：英语字母结尾（单词结束） 前端显示格式化后的数据，views-widgets下blog-list.ejs：注意使用-而不是=,如果是等号，则html标签被当成字符串显示在页面上，使用-则html标签不会被转译，直接作为html标签插入模板 测试：数据库存储的是原始信息，显示的链接是前端设置的 回复功能 实现思路：点击“回复”时自动往输入框中加入“//@xxx:微博内容” 步骤 回复是在微博列表触发的，所以先去views-widgets下blog-list.ejs，通过参数canReply来判断是否显示“回复”按钮：只有首页才有回复功能，广场页未登录不会有回复功能，个人主页都是自己的，不能自己回复自己 【拼接内容=》放入输入框】 views-widgets下blog-list.ejs，点击回复的click事件后： 【放入输入框后=》鼠标移到最前端方便输入】views-widgets下blog-list.ejs， 测试：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"首页功能（三表查询）","slug":"首页功能（三表查询）","date":"2020-03-24T01:01:19.000Z","updated":"2020-04-20T01:14:59.722Z","comments":true,"path":"2020/03/24/首页功能（三表查询）/","link":"","permalink":"http://yoursite.com/2020/03/24/首页功能（三表查询）/","excerpt":"数据模型回顾数据模型设计现在需要修改数据模型：将blogs表中的userId与userRelations表中的followerId 关联。","text":"数据模型回顾数据模型设计现在需要修改数据模型：将blogs表中的userId与userRelations表中的followerId 关联。 这样在首页中只需要知道userId就可通过userRelations知道followerId（我所有的关注人），然后通过followerId查blogs 得到我所有关注人的微博 修改数据模型（Blog关联UserRelation） 创建外键关系： db-model-index.js： 同步到数据库：node src/db/sync.js 查看数据库：可以看到blogs表的外键关系中并没有我们添加的外键关系： 原因：userId已经有自己的外键关系，mysql中无法创建2次外键关系 但是！并不影响sequalize连表查询！sequalize中2个模型之间的外键关系已经创建成功！之前讲过，sequalize中2个模型之间的外键关系创建成功后会试图同步到mysqsl上，但如果同步不成功也不会影响sequalize进行连表/3表查询 “自己关注自己”在首页应当显示 自己和关注人 的微博，但sequalize来操作这个会比较麻烦，如果在创建用户时就自己关注自己，则首页只需要查询关注人微博即可 【service层】创建用户时，调用同层user-relation中的addFollower函数=》设置自己关注自己： service-user.js： 测试：注册zhangsan，可看到右侧关注列表、粉丝列表中出现了自己： 使得粉丝、关注列表中不显示自己：到service下user-relation.js中，在获取粉丝列表的时候让userId不等于followerId才可查询，即增加筛选条件： Sequelize自带的“不等于”的表示方法：[Sequelize.Op.ne] Sequelize：引用自sequelize Op：Option ne：not equal（不等于） []：symbol类型 测试：成功 回顾模板和路由设计 首页右侧模板代码基本和个人主页右侧一样：在views-index.ejs中增添右侧代码： 页面路由 【页面路由返回前端右侧所需数据】在routes-view-blog.js首页路由中使用和个人主页基本相似的代码返回数据： 测试：访问首页： 首页左侧（微博列表&amp;加载更多）模板代码基本和个人主页一样：在views-index.ejs中增添代码： 开发路由（三表查询 微博首页列表第一页） 获取第一页数据： 【路由层】调用controller层getHomeBlogList函数，返回前端所需数据： routes-view-blog.js，首页路由中： 【controller层】创建getHomeBlogList函数=》调用service层getFollowersBlogList函数=》获取首页微博列表： controller下blog-home.js： 【service层】创建getFollowersBlogList函数=》三表查询： service-blog.js， 回顾外键关系：应当从Blog为主开始查询 三表查询的结果是3个表的内容：：但是最后格式化数据时只格式化Blog和User的内容，虽然3表数据都返回了，但前端只拿了Blog和User的内容来使用 测试：访问首页：发布微博后首页：进入zhangsan帐号，发布微博，回到lisi帐号首页： 开发路由（加载更多 渲染模板） 【路由层】：除了多需要一个id以及获取的是三表查询的数据以外，和广场页的基本一致，routes-api下blog-home.js： 测试：点击“加载更多”，成功","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"关注和取消关注","slug":"关注和取消关注","date":"2020-03-23T13:27:41.000Z","updated":"2020-04-19T18:30:59.028Z","comments":true,"path":"2020/03/23/关注和取消关注/","link":"","permalink":"http://yoursite.com/2020/03/23/关注和取消关注/","excerpt":"创建数据模型：用户关系回顾数据模型设计通过用户关系表存储用户之间的关系","text":"创建数据模型：用户关系回顾数据模型设计通过用户关系表存储用户之间的关系 回顾：关系型数据库的三大范式 属性的原子性：每一列都不可再拆解（比如userName和password） 记录的唯一性：有唯一标识（主键），其他属性都依赖于主键（比如userId） 字段的冗余性：避免数据冗余和传递依赖（也就是使用外键=》做到 数据引用 而不是 重复数据） 开发数据模型&amp;同步到数据库 【创建模型（表）】： db-model下新建USerRelation.js： 【创建外键关系、统一输出模型（表）】方便后面同步到数据库： db-model-index.js，特别注意两个外键的关系创建（可结合设计表理解）： 同步到数据库:执行node src/db/sync.js，查看数据库：windows下mysql表名是大小写不敏感的，所以sequalize建的表也是大小写不敏感的 开发 粉丝列表回顾技术方案设计 查看模板代码（个人主页模本中） views-profile.ejs中，在个人信息下方： views-widgets下新建fans.js组件： 给个假数据查看效果（注意ejs中的注释符号）： 开发路由：粉丝列表（个人主页路由中） 【路由层】调用controller层函数获取并返回前端所需数据： src-routes-view-blog.js中，到个人主页的/profile路由中： 【controller层】创建getFans函数=》根据 userid 调用service层函数 =》获取粉丝列表： controller下新建user-relation.js： 【service层】创建getUsersByFollower函数 连表查询数据库： service下新建user-relation.js（service层的文件基本和数据表是一一对应的）： 测试： 开发 关注接口-判断关注状态回顾架构设计 查看前端代码 widgets下user-info.js： 关注&amp;取消关注 按钮： 通过amIFollowed 判断显示哪个按钮： user-info.js是在profile.js中使用的，amIFollowed也由profile.js传入：profile.js中的数据是由routes-view-blog.js中个人主页的路由返回的 开发路由（关注&amp;取消关注）页面路由 【路由层】返回前端amIFollowed： user-info.js中需要的数据是由routes-view-blog.js中个人主页的路由返回给profile.js再传给user-info.js的。通过判断当前用户的粉丝列表中是否有我即可知道我是否关注该用户（即amIFollowed）： JavaScript Array some() 方法 测试：说明登录状态的判断生效，接下来需要实现：点击关注后改变关系且按钮变为“取消关注” 关注接口路由（关注） 在前端user-info.ejs中处理按钮的显示/隐藏，关注的api是’/api/profile/follow’，取消关注的api是’/api/profile/unFollow’：前端将当前用户的id传递给路由层 【路由层】传递 当前用户的id、我的id 并调用controller层follow函数：在routes-api-blog-profile.js中， 【controller层】创建follow函数，调用service层addFollower函数添加关注关系：在controller下user-relation.js中， 【service层】创建addFollower函数，往数据库添加关注关系：在service下user-relation.js中， 测试：点击关注后按钮变化且数据库中增添数据：此时刷新页面，zhangsan将出现在lisi的粉丝列表中： 关注接口路由（取消关注） 【路由层】传递 当前用户的id、我的id 并调用controller层unfollow函数：在routes-api-blog-profile.js中， 【controller层】创建follow函数，调用service层deleteFollower函数添加关注关系：在controller下user-relation.js中，这里和关注的区别就是删除可通过返回结果直接判断成功与否 【service层】创建deleteFollower函数，在数据库中删除关注关系：在service下user-relation.js中， 测试：点击“取消关注”后，按钮变化，且刷新页面后粉丝列表清空 开发 关注人列表查看前端代码 views-profile.ejs中，出现在右侧粉丝列表下方： widgets中新建follower.ejs：获取关注总数后对用户列表遍历渲染 开发路由 【路由层】调用controller层getFollowers函数，返回数据给前端： routes下view-blog.js中个人主页的路由： 【controller层】创建getFollowers函数，调用service层getFollowersByUser函数 获取关注人列表： controller下user-relation.js： 【service层】创建getFollowersByUser函数，： service下user-relation.js： 测试：使用zhangsan的账号关注lisi后：进入lisi页面后可取消关注# 关注和取消关注 标签（空格分隔）： Node.js title: 关注和取消关注date: 2020-03-23 21:27:41tags: Node.jscategories: [Node.js学习] [微博项目] 创建数据模型：用户关系回顾数据模型设计通过用户关系表存储用户之间的关系 回顾：关系型数据库的三大范式 属性的原子性：每一列都不可再拆解（比如userName和password） 记录的唯一性：有唯一标识（主键），其他属性都依赖于主键（比如userId） 字段的冗余性：避免数据冗余和传递依赖（也就是使用外键=》做到 数据引用 而不是 重复数据） 开发数据模型&amp;同步到数据库 【创建模型（表）】： db-model下新建USerRelation.js： 【创建外键关系、统一输出模型（表）】方便后面同步到数据库： db-model-index.js，特别注意两个外键的关系创建（可结合设计表理解）： 同步到数据库:执行node src/db/sync.js，查看数据库：windows下mysql表名是大小写不敏感的，所以sequalize建的表也是大小写不敏感的 开发 粉丝列表回顾技术方案设计 查看模板代码（个人主页模本中） views-profile.ejs中，在个人信息下方： views-widgets下新建fans.js组件： 给个假数据查看效果（注意ejs中的注释符号）： 开发路由：粉丝列表（个人主页路由中） 【路由层】调用controller层函数获取并返回前端所需数据： src-routes-view-blog.js中，到个人主页的/profile路由中： 【controller层】创建getFans函数=》根据 userid 调用service层函数 =》获取粉丝列表： controller下新建user-relation.js： 【service层】创建getUsersByFollower函数 连表查询数据库： service下新建user-relation.js（service层的文件基本和数据表是一一对应的）： 测试： 开发 关注接口-判断关注状态回顾架构设计 查看前端代码 widgets下user-info.js： 关注&amp;取消关注 按钮： 通过amIFollowed 判断显示哪个按钮： user-info.js是在profile.js中使用的，amIFollowed也由profile.js传入：profile.js中的数据是由routes-view-blog.js中个人主页的路由返回的 开发路由（关注&amp;取消关注）页面路由 【路由层】返回前端amIFollowed： user-info.js中需要的数据是由routes-view-blog.js中个人主页的路由返回给profile.js再传给user-info.js的。通过判断当前用户的粉丝列表中是否有我即可知道我是否关注该用户（即amIFollowed）： JavaScript Array some() 方法 测试：说明登录状态的判断生效，接下来需要实现：点击关注后改变关系且按钮变为“取消关注” 关注接口路由（关注） 在前端user-info.ejs中处理按钮的显示/隐藏，关注的api是’/api/profile/follow’，取消关注的api是’/api/profile/unFollow’：前端将当前用户的id传递给路由层 【路由层】传递 当前用户的id、我的id 并调用controller层follow函数：在routes-api-blog-profile.js中， 【controller层】创建follow函数，调用service层addFollower函数添加关注关系：在controller下user-relation.js中， 【service层】创建addFollower函数，往数据库添加关注关系：在service下user-relation.js中， 测试：点击关注后按钮变化且数据库中增添数据：此时刷新页面，zhangsan将出现在lisi的粉丝列表中： 关注接口路由（取消关注） 【路由层】传递 当前用户的id、我的id 并调用controller层unfollow函数：在routes-api-blog-profile.js中， 【controller层】创建follow函数，调用service层deleteFollower函数添加关注关系：在controller下user-relation.js中，这里和关注的区别就是删除可通过返回结果直接判断成功与否 【service层】创建deleteFollower函数，在数据库中删除关注关系： 在service下user-relation.js中， 测试：点击“取消关注”后，按钮变化，且刷新页面后粉丝列表清空 开发 关注人列表查看前端代码 views-profile.ejs中，出现在右侧粉丝列表下方： widgets中新建follower.ejs：获取关注总数后对用户列表遍历渲染 开发路由 【路由层】调用controller层getFollowers函数，返回数据给前端： routes下view-blog.js中个人主页的路由： 【controller层】创建getFollowers函数，调用service层getFollowersByUser函数 获取关注人列表： controller下user-relation.js： 【service层】创建getFollowersByUser函数，： service下user-relation.js： 测试：使用zhangsan的账号关注lisi后：进入lisi页面后可取消关注","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"广场页","slug":"广场页","date":"2020-03-22T13:37:45.000Z","updated":"2020-04-19T13:38:29.471Z","comments":true,"path":"2020/03/22/广场页/","link":"","permalink":"http://yoursite.com/2020/03/22/广场页/","excerpt":"页面和模板（后端渲染 缓存）回顾模板技术方案 广场页是每个人都能进行访问的，而且访问到的内容都一样，所以可以通过redis缓存微博列表数据来减少请求，优化代码，路由不再通过controller层去找service层获取数据库数据，而是通过cache层去看缓存中有无数据，没有再去找service层获取数据库数据","text":"页面和模板（后端渲染 缓存）回顾模板技术方案 广场页是每个人都能进行访问的，而且访问到的内容都一样，所以可以通过redis缓存微博列表数据来减少请求，优化代码，路由不再通过controller层去找service层获取数据库数据，而是通过cache层去看缓存中有无数据，没有再去找service层获取数据库数据 广场页的前端和个人主页的前端区别在于广场页没有右侧，且广场页加载更多的路由是api/square下的 查看模板代码 views下新建square.ejs 开发路由&amp;渲染数据页面路由 【路由层】创建页面路由，调用controller层getSquareBlogList函数： src-routes-view-blog.js： 【controller层】创建getSquareBlogList函数，调用cache层getSquareCacheList函数读取微博列表数据： controller下新建blog-square.js，这里和个人主页不同时因为controller层会访问cache层（redis）将缓存拿到并返回： 【cache层】使用redis的get读取数据，有则返回，无（即数据过期）则到service层getBlogListByUser函数去读取数据库数据，并使用set缓存到redis中： cache下新建blog.js： 【service层】getBlogListByUser函数中做了兼容，可以不传userName来查询数据库：service-blog.js： 测试：redis是每一页都缓存在了相应的key值中（key的命名是：前缀【weibo:square:】+当前页码+一页最多的条数）：进入广场页，点击“加载更多”加载第二页，查看redis缓存的所有键名： 接口路由（加载更多） 【路由层】创建 加载更多路由，和个人主页的加载更多逻辑基本一致：src-routes-api下新建blog-square.js： 【app.js注册路由】： 【controller层】还是和页面路由一样的getSquareBlogList函数","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"个人主页","slug":"个人主页","date":"2020-03-21T09:58:57.000Z","updated":"2020-04-19T10:00:45.439Z","comments":true,"path":"2020/03/21/个人主页/","link":"","permalink":"http://yoursite.com/2020/03/21/个人主页/","excerpt":"页面和模板回顾模板技术方案微博列表的第1页 和 个人信息 是 后端渲染数据SSR ，即直接通过后端渲染的数据（非AJAX请求）。加载更多则是通过AJAX请求获取。","text":"页面和模板回顾模板技术方案微博列表的第1页 和 个人信息 是 后端渲染数据SSR ，即直接通过后端渲染的数据（非AJAX请求）。加载更多则是通过AJAX请求获取。 前端模板代码 【个人主页】： views下新建profie.ejs 【个人信息 组件】： widgets下新建user-info.ejs 【微博列表 组件】： widgets下新建blog-list.ejs 【加载更多 组件】： widgets下新建load-more.ejs 开发路由（后端渲染数据SSR）处理 微博列表、加载更多（前端左侧） 【路由层】创建路由，调用controller层函数，获取微博第一页数据： routes-view-blog.js下新建/profile/:userName的路由：参数1：渲染profile页，参数2：传递前端需要的数据 【controller层】新建blog-profile.js，调用service层getBlogListByUser函数 获取个人主页微博列表： 【service层】创建getBlogListByUser函数： service-blog.js中，（可复习连表查询） 处理 用户数据（前端右侧） 【路由层】前端右侧需要userData（userInfo、isMe），判断并调用controller层isExist函数，返回前端所需用户数据： 格式化时间 【时间相关的工具函数】：utils-dt.js，安装使用date-fns工具： 【service层】格式化时间、内容后，创建 格式化微博信息 的函数：_format.js： 【service层】调用函数格式化微博信息：service-blog.js： 加载更多（ajax） 【前端load-more.ejs】获取的微博列表需要是 html字符串 而不是js对象的数据：前端拿到以后直接转为jquery对象后遍历渲染到页面上 【路由层】创建路由，调用controller层getProfileBlogList函数获取 微博列表 ，将其转换为 html字符串 后返回给前端： routes-api下新建blog-profile.js，调用getBlogListStr函数将json格式的微博列表转换为html字符串： 【app.js注册路由】 【转换为html字符串的思路】： 【使用EJS工具】根据 blogList 渲染出 html 字符串： utils下新建blog.js： EJS工具 EJS库可使js数据渲染为html代码（字符串格式的），这样后端返回的数据在前端就可直接渲染在页面上。 安装：npm i ejs --save 使用方法：12345678const ejs = require('ejs')// str：字符串格式的前端ejs模板// data：需要传给前端ejs模板的数据，多个数据使用对象传递// options：可省略ejs.render(str, data, options);// =&gt; Rendered HTML string// 返回值就是将数据渲染在html中的代码（字符串格式的）","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"创建微博","slug":"创建微博","date":"2020-03-20T15:17:11.000Z","updated":"2020-04-18T15:18:26.524Z","comments":true,"path":"2020/03/20/创建微博/","link":"","permalink":"http://yoursite.com/2020/03/20/创建微博/","excerpt":"创建数据模型回顾数据模型设计","text":"创建数据模型回顾数据模型设计 步骤 db-model下新建Blog.js： db-model-index.js中统一输出数据模型 并 创建外键关系： 同步到数据库（建表）：执行sync.js:node src/db/sync.js 查看数据库：建表成功：查看外键关系： 由于执行了同步，所以数据库中users表清空了，需要再次重新注册用户。 页面和模板回顾模板技术方案 查看模板代码 【首页】 src-views下，修改原本的index.ejs（首页）： 【input组件(微博输入框)】 src-views下，删除原本自带的widgets中的文件，新建input.ejs(微博输入框)： trim() 方法：去除字符串的头尾空格 注意：上传图片的change事件必须在插入图片的click事件外进行绑定，否则每次点击“插入图片”时就会绑定一个change事件（即点击几次“插入图片”就会绑定几个change事件=》发送几次ajax请求），这样子第3次点击上传图片时就会一次性发出3个ajax请求： $filePicture[0].files[0]: files[0]是JavaScript中DOM元素的files属性FileList 对象 $(&#39;xx&#39;)是jQuery对象 $(&#39;xx&#39;)[0]是将jQuery对象($(&#39;xx&#39;))转换为JavaScript对象，这样才可以使用JavaScript对象的属性和方法 jQuery对象只能使用jQuery对象的属性和方法，JavaScript对象只能使用JavaScript对象的属性和方法 补充：$(&#39;xx&#39;)[0].files[0].size可获得文件的大小，单位是字节（B），使用$(&#39;xx&#39;)[0].files[0].size可用于判断文件的大小。 开发页面路由 删除框架自带的routes下的index.js，同时删除app.js中该路由的引入和注册 新建页面路由：src-routes-view下，新建blog.js： app.js中注册页面路由：app.js，引入并注册页面路由： 测试：登录后访问首页：目前只有一个输入框 创建微博的上传图片功能 还是使用原本的上传图片api，上传的图片名称对应在页面上： 开发接口路由回顾架构设计图 步骤 【路由层】创建路由，获取前端数据，传递并调用controller层的create函数： input.ejs中可看到发布微博的路由是/api/blog/create，传递的参数是content、image，所以在routes-api下新建blog-home.js作为博客首页的API： app.js注册路由： 【controller层】创建create函数，调用service层createBlog函数来创建微博： controller下新建blog-home.js 【service层】创建createBlog函数：service下新建blog.js： 测试：输入“你好呀”后点击“发表”，数据库中添加成功：带图片测试： xss攻击 例子：如果在输入框输入这段js代码后成功存储到数据库后，前端读取时就会在弹框中带出cookie的信息 可参考博客项目安全/xss攻击（xss库（函数）） 使用xss工具（xss函数） 可以使用xss工具的xss函数帮助过滤尖括号（转译特殊字符） 安装：npm i xss --save --registry=https://registry.npm.taobao.org 使用：controller-blog-home.js中，引入并使用xss： 原理和具体效果：可参考博客项目安全/xss攻击（xss库（函数）） blogs表 数据格式校验 编写微博内容的校验规则、创建校验微博数据格式的函数： validator下新建blog.js： 和users表的数据校验通用一个genValidator来生成 格式校验的中间件 【路由层】添加中间件进行格式校验：routes-api-blog-home.js:","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"文件上传（input files FileList）","slug":"文件上传（input files FileList）","date":"2020-03-19T14:22:57.000Z","updated":"2020-04-18T14:24:07.192Z","comments":true,"path":"2020/03/19/文件上传（input files FileList）/","link":"","permalink":"http://yoursite.com/2020/03/19/文件上传（input files FileList）/","excerpt":"input元素做文件上传 可使用HTML &lt;input&gt; 元素，设置type为file,并通过accept=&quot;image/*&quot;限制图片的文件类型为图片（但一般建议后端做限制）","text":"input元素做文件上传 可使用HTML &lt;input&gt; 元素，设置type为file,并通过accept=&quot;image/*&quot;限制图片的文件类型为图片（但一般建议后端做限制） 比如：&lt;input type=&quot;file&quot; accept=&quot;image/*&quot; id=&quot;file-picture&quot;&gt; FileList对象 FileList对象 一个 FileList 对象通常来自于一个 HTML &lt;input&gt; 元素的 files 属性，可以通过这个对象访问到用户所选择的文件。 所有type属性(attribute)为file的 &lt;input&gt; 元素都有一个files属性,用来存储用户所选择的文件. 比如：12345//html中&lt;input id=\"fileItem\" type=\"file\"&gt;//js中//获取一个FileList对象中的第一个文件(File 对象)var file = document.getElementById('fileItem').files[0]; jquery中获取 FileList对象 首先需要明确：jQuery对象只能使用jQuery对象的属性和方法，JavaScript对象只能使用JavaScript对象的属性和方法 例子： 12345//html中&lt;input type=\"file\" accept=\"image/*\" id=\"file-picture\"&gt;//jquery中//获取一个FileList对象中的第一个文件(File 对象)var file = $('#file-picture')[0].files[0] $(&#39;#file-picture&#39;)[0].files[0]: files[0]是JavaScript中DOM元素的files属性FileList 对象 $(&#39;xx&#39;)是jQuery对象 $(&#39;xx&#39;)[0]是将jQuery对象($(&#39;xx&#39;))转换为JavaScript对象，这样才可以使用JavaScript对象的属性和方法 补充：$(&#39;xx&#39;)[0].files[0].size可获得文件的大小，单位是字节（B），使用$(&#39;xx&#39;)[0].files[0].size可用于判断文件的大小。","categories":[{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"微博用户设置","slug":"微博用户设置","date":"2020-03-18T07:33:26.000Z","updated":"2020-04-18T07:58:29.418Z","comments":true,"path":"2020/03/18/微博用户设置/","link":"","permalink":"http://yoursite.com/2020/03/18/微博用户设置/","excerpt":"创建页面回顾技术方案","text":"创建页面回顾技术方案 查看模板代码 src-views-setting.ejs: 使用的是bootstrap的模板 开发页面路由 创建渲染“设置页”的路由：src-routes-view-user.js中，注意需要先使用“登录验证中间件”，如果用户未登录则带着当前url（/setting）跳转到登录页,登录后自动跳转回“设置页”： 开发接口图片上传（文件上传）回顾技术方案 formidable-upload-koa工具(文件上传) koa要图片（文件）上传就要借助formidable-upload-koa工具 安装：npm i formidable-upload-koa 使用： 由于该中间件会将图片（文件）保存在本机或服务器的一个临时文件夹中，所以我们需要fse工具将其改成存储在我们指定的文件夹 options：配置，不写则使用默认配置 uploadDir：图片保存目录 keepExtensions：是否保留文件扩展名 fs-extra工具(文件操作) 涉及文件操作就要使用fs-extra工具12345678910const fse = require('fs-extra')//删除filePath路径的文件await fse.remove(filePath)//将filePath路径的文件移动到distFilePath路径await fse.move(filePath, distFilePath)//判断文件夹是否存在，DIST_FOLDER_PATH为文件夹路径fse.pathExists(DIST_FOLDER_PATH)//新建文件夹，在DIST_FOLDER_PATH路径下新建文件夹fse.ensureDir(DIST_FOLDER_PATH) 步骤 安装formidable-upload-koa工具、fs-extra工具：npm i formidable-upload-koa fs-extra --save 【路由层】创建上传图片的路由，使用formidable-upload-koa工具创建中间件将图片文件上传到服务器/本机的某个临时文件夹中：在前端页面中，用户通过调用/api/utils/upload上传图片，所以在src-routes-api下新建utils.js： 修改个人头像和上传微博时都需要上传图片，所以将上传图片的路由抽离到utils.js中，方便复用 引入formidable-upload-koa工具的koaForm函数创建中间件 前端上传文件的ajax方法（my-ajax.js）中文件保存在FormData對象的file值中：这个file就对应后端的src-routes-api-utils.js中ctx.req.files[&#39;file&#39;]的file，要修改的话两边要一起改。FormData 对象的使用、FormData使用方法详解 【controller层】限定文件大小、移动文件存储的位置：在路由层使用formidable-upload-koa工具的中间件时就已经将文件上传至某个临时文件夹，所以现在我们可以将文件移动到我们指定的位置。controller下新建util.js：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * @description utils controller * @author hlz */const path = require('path')const &#123; ErrorModel, SuccessModel &#125; = require('../model/ResModel')const &#123; uploadFileSizeFailInfo &#125; = require('../model/ErrorInfo')const fse = require('fs-extra')// 存储目录const DIST_FOLDER_PATH = path.join(__dirname, '..', '..', 'uploadFiles')// 文件最大体积 1Mconst MIX_SIZE = 1024 * 1024 * 1024// 是否需要创建目录fse.pathExists(DIST_FOLDER_PATH).then(exist =&gt; &#123; if (!exist) &#123; fse.ensureDir(DIST_FOLDER_PATH) &#125;&#125;)/** * 保存文件 * @param &#123;string&#125; name 文件名 * @param &#123;string&#125; type 文件类型 * @param &#123;number&#125; size 文件体积大小 * @param &#123;string&#125; filePath 文件路径 */async function saveFile(&#123; name, type, size, filePath &#125;) &#123; // 文件过大时 if (size &gt; MIX_SIZE) &#123; // 使用fs-extra工具删除文件（以防占用硬盘空间） await fse.remove(filePath) return new ErrorModel(uploadFileSizeFailInfo) &#125; // 移动文件（从filePath到distFilePath） const fileName = Date.now() + '.' + name // 防止重名 const distFilePath = path.join(DIST_FOLDER_PATH, fileName) // 目的地 await fse.move(filePath, distFilePath) // 返回信息 return new SuccessModel(&#123; url: '/' + fileName &#125;)&#125;module.exports = &#123; saveFile&#125; 为啥distFilePath中包含文件名： 查看通过formidable-upload-koa工具保存的文件路径可看到是包括到随机生成的文件名的（upload _xxx），这个路径是直接可以访问到图片的路径，所以移动的目的路径中也要包含文件名 新建uploadFiles文件夹并先保存一张图片2.png 【保证controller-util.js中saveFile返回的url可被访问到】：将uploadFiles文件夹设置为静态目录的文件夹=》什么东西放里面都可被访问=》保证controller-util.js中saveFile返回的url可被访问到。app.js中进行设置：设置后，我们可通过访问http://localhost:3000/2.png访问到uploadFiles文件夹下的图片2.png 【app.js注册路由】： 测试：http://localhost:3000/setting![测试](http://ww1.sinaimg.cn/large/005H7IVsgy1gdx1b9n6tzj31050i2jtk.jpg) 后端筛选文件格式：controller-util.js： 测试：尝试上传css后缀的文件： 前端筛选文件格式：accept 属性只能与 &lt;input type=&quot;file&quot;&gt; 配合使用,它规定能够通过文件上传进行提交的文件类型。image/*表示接受所有的图像文件。 前端限定后再选择文件时直接就不给选择css后缀的文件了。 补充：线上图片存储 我们现在是把图片存储在本地的uploadFiles文件夹中，但实际上线时应使用专业的文件服务（比如七牛云等）来保存图片文件，它再返回图片url供程序使用： 修改基本信息 【路由层】创建路由，传递前端数据，调用controller层函数：前端setting.ejs中修改基本信息的路由是/api/user/changeInfo，传递的前端数据是nickName,city,picture，所以在routes-api-user.js中创建changeInfo路由，将前端获取的数据传递并调用controller层的changeInfo函数：(新建用post，修改用patch) 【controller层】创建changeInfo函数，调用service层函数更新数据库数据，修改session.userInfo：src-controller-user.js： Object.assign()合并对象,当合并的多个对象拥有相同属性时后面的属性值覆盖前面的。 【service层】创建更新数据库中users表（User模型）的方法：src-service-user.js： updateData和whereData的属性名需要和de-model-User.js中User模型的属性名对应 测试：数据库的users表：此时无论怎么刷新页面，都会显示已修改的信息： 修改密码 【路由层】创建路由，传递前端数据，调用controller层函数：前端setting.ejs中修改密码的路由是/api/user/changePassword，传递的前端数据是password、newPassword，所以在routes-api-user.js中创建changePassword路由，将前端获取的数据传递并调用controller层的changePassword函数： 【controller层】创建changePassword函数，调用service层函数更新数据库数据，修改session.userInfo：src-controller-user.js： 【service层】还是和修改个人信息一样的方法来更新数据库中users表（User模型）的方法 测试： 退出登录 【路由层】创建路由，调用controller层函数：前端setting.ejs中退出登录的路由是/api/user/logout，所以在routes-api-user.js中创建logout路由，调用controller层的logout函数： 【controller层】创建logout函数，删除session.userInfo：src-controller-user.js中，我们判断登录状态时使用的是session.userInfo，删除它自然就退出登录了： delete关键词可用于删除ctx.session 测试：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"HTTP请求的类型","slug":"HTTP请求的类型","date":"2020-03-17T07:03:54.000Z","updated":"2020-04-17T07:07:18.631Z","comments":true,"path":"2020/03/17/HTTP请求的类型/","link":"","permalink":"http://yoursite.com/2020/03/17/HTTP请求的类型/","excerpt":"HTTP请求的类型 get:从服务器端获取数据，请求body在地址栏上 post:向服务器端提交数据，请求数据在报文body里 发送一个修改数据的请求，需求数据要重新创建","text":"HTTP请求的类型 get:从服务器端获取数据，请求body在地址栏上 post:向服务器端提交数据，请求数据在报文body里 发送一个修改数据的请求，需求数据要重新创建 put:向服务器端提交数据，请求数据在报文body里 发送一个修改数据的请求，需求数据更新（全部更新） patch:向服务器端提交数据，请求数据在报文body里 发送一个修改数据的请求，需求数据更新（部分更新） delete:向服务器端提交数据，请求数据在报文body里 发送一个删除数据的请求 补充jQuery ajax() 方法 $.ajax({name:value, name:value, ... })中type所规定请求的类型，不只GET/POST，还有所有上面提到的请求类型（注意大写）。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"微博用户管理（登录）","slug":"微博用户管理（登录）","date":"2020-03-16T03:46:26.000Z","updated":"2020-04-17T03:47:10.202Z","comments":true,"path":"2020/03/16/微博用户管理（登录）/","link":"","permalink":"http://yoursite.com/2020/03/16/微博用户管理（登录）/","excerpt":"开发登录API 【路由层】解析post请求获取userName和password，传递并调用controller层的login函数：src-routes-api-user.js中，","text":"开发登录API 【路由层】解析post请求获取userName和password，传递并调用controller层的login函数：src-routes-api-user.js中， 【controller层】创建登录函数，调用service层的getUserInfo函数判断用户是否存在数据库（即是否已登录）： 测试：登录lisi的帐号：查看redis：此时刷新页面，http请求头中将带有cookie： 判断已登录状态 实现功能：在进入注册页和登录页之前都会先进行判断，如果已登录就提示“xxx，您已成功登录，请直接访问首页” 添加获取登录信息的getLoginInfo函数，src-routes-view-user.js中： 调用函数判断是否已登录，并传递前端所需数据：src-routes-view-user.js中，登录路由和注册路由渲染页面时将getLoginInfo函数中返回的isLogin和userName传递到前端供其判断用户是否已登录： 测试：登录后再次访问登录和注册页： 登录验证的中间件 创建2个登录验证的中间件：一个是给routes-api中的路由使用，一个是给routes-view中的路由使用。middlewares中新建loginChecks.js: loginCheck给API做登录验证：未登录时直接返回错误信息 loginRedirect给页面登录验证：未登录时，用户访问各个页面时都将带着url去跳转登录页，登录成功后前端获取带过来的url自动跳转到用户所访问的页面：（ctx.redirect()页面跳转） 首页使用中间件：src-routes-index.js中： 测试：访问首页，可看到： /json路由使用中间件：src-routes-index.js中： 测试：访问/json路由,可看到未登录时之间返回错误信息：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"微博用户管理（注册）","slug":"微博用户管理（注册）","date":"2020-03-15T01:33:20.000Z","updated":"2020-04-17T01:34:08.235Z","comments":true,"path":"2020/03/15/微博用户管理（注册）/","link":"","permalink":"http://yoursite.com/2020/03/15/微博用户管理（注册）/","excerpt":"功能列表 用户管理（登录和注册） 用户设置（修改基本信息，修改密码，退出登录） 创建微博，暂不显示微博列表 个人主页，显示个人微博列表和个人信息，暂不做关注功能 广场页（使用缓存） 关注和取消关注，显示粉丝和关注人 首页，显示我的微博和我关注的人的微博 @和回复 @提到我的","text":"功能列表 用户管理（登录和注册） 用户设置（修改基本信息，修改密码，退出登录） 创建微博，暂不显示微博列表 个人主页，显示个人微博列表和个人信息，暂不做关注功能 广场页（使用缓存） 关注和取消关注，显示粉丝和关注人 首页，显示我的微博和我关注的人的微博 @和回复 @提到我的 用户管理 页面：模板和路由 数据建模 开发注册功能 开发登录功能 抽离loginCheck中间件 单元测试 注册创建页面：模板和路由回顾技术方案注册页直接通过一个api来判断用户名是否已存在，不需要点击注册后才通过请求从后端获取来判断是否重复，提高用户体验统一的header和footer：通过一些参数来判断是否显示导航 步骤 查看缓存是否清空：git status 增加项目分支：git checkout -b feature-login 增加的项目分支是新功能则git checkout -b feature-xxx，修改bug则git checkout -b fix-xxx 创建2个模板，src-views下新建register.ejs、login.ejs 创建路由，routes-views下新建user.js： 注册路由，app.js中引入并注册路由： 运行程序,访问登录、注册页： 数据建模回顾技术方案这里先只用到users表（DECIMAL是非常小的数据类型，很适合性别） 步骤 src-db下新建types.js封装sequelize的数据类型，这样在建表时就不需要每次都引一下sequelize了： src-db下新建model文件夹-新建User.js 创建用户数据模型（users表）：补充：unique:true规定“数据唯一”，也就是说无法传入同样的2个数据到这一列。defaultValue规定“默认值”，即这一项什么也没传入数据表中时的默认数据 src-db-model文件夹下新建index.js 数据模型入口文件，也就是做统一输出： 执行sequelize同步数据库时，src-db-sync.js中，注意引入需要同步的数据模型： 测试：手动删除原先的users表（users表中有blogs的外键，所以需要先删除blogs表），执行node src/db/sync.js将sequelize同步数据库： 开发注册功能（注册接口）回顾技术方案 routes层：根据路由，将相应的数据（req）传给controller层 controller层：获取routes层传递的数据，调用service层的方法处理业务逻辑，并返回统一处理格式的数据 service层：创建 增删查改的方法，并定义数据表的某些默认数据 db层：连接数据库，定义模型（创建表） 路由和分层 【routes层】创建注册页需要的路由：src-routes-api下新建user.js，创建2个src-views-register.ejs中需要用到的接口： 注册路由，app.js中： 【controller层】书写业务逻辑并统一返回格式：src下新建controller文件夹-新建user.js： 【services层】处理数据：src下新建services文件夹-新建user.js：(关于Object.assign()合并对象可参考笔记https://huanglizhu.github.io/2019/11/13/ES6%E6%89%A9%E5%B1%95%20%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95/#Object-assign-合并对象-类似-扩展运算符) 格式化用户信息 conf下新建constant.js 存放所以常量： 【services层】创建格式化用户信息的formatUser方法：src-services文件夹下新建_format.js：（注意区分typeof和instanceof运算符） 【services层】使用formatUser方法 格式化数据： src-services-user.js： 完成isExist（判断用户名是否已存在） 创建统一格式的模型： src下新建model文件夹-新建ResModel.js 用于统一返回格式:（大写字母开头的js文件一般表示 返回一个class） 统一管理错误信息：model文件夹下新建ErrorInfo.js： 【controller层】判断用户名是否已存在，并使用模型统一返回格式： src-controller-user.js中，根据services层返回的数据判断用户名是否已存在： 【路由层】判断用户名是否已存在： src-routes-api-user.js中,引入isExist，判断用户名是否已存在： 测试：运行程序,进入注册页，输入用户名: 完成register 【路由层】将注册相关数据传给controller层在src-routes-api-users.js中，通过解析前端post请求中所带数据调用controller层的register方法进行注册 【controller层】接受路有层传递的数据，使用services层的createUser方法来创建用户（使用对象的解构赋值可以传入乱序的函数参数） 【services层】新建在users表中创建用户的createUser方法： 测试：注册了1次zhangsan后无法再次进行注册： 密码加密 统一管理密钥常量： conf文件夹下新建secretKeys.js，统一管理session和用户密码的密钥常量： 修改session密钥：app.js中给session配置的密钥换成从secretKeys.js中获取： 创建加密方法： utils文件夹下新建cryp.js：123456789101112131415161718192021222324252627/** * @description 加密方法 * @author hlz */const crypto = require('crypto')const &#123; CRYPTO_SECRET_KEY &#125; = require('../conf/secretKeys')/** * md5 加密(hex:16进制) * @param &#123;string&#125; content 明文 */function _md5(content) &#123; const md5 = crypto.createHash('md5') return md5.update(content).digest('hex')&#125;/** * 加密方法 * @param &#123;string&#125; content 明文 */function doCrypto(content) &#123; const str = `password=$&#123;content&#125;&amp;key=$&#123;CRYPTO_SECRET_KEY&#125;` return _md5(str)&#125;module.exports = doCrypto （可参考crypto库 md5加密） 【controller层】引入并使用cryp.js中的doCrypto方法对密码加密：1const doCrypto = require('../utils/cryp') 测试：注册lisi，输入密码为123，存储到数据库的是加密后的16进制密码： schema格式校验 在routes层对页面传来的数据进行格式校验，比如微博的长度、登录校验等 在这我们使用json schema设置格式校验的校验规则 当数据从页面传到routes层时，我们就进行数据的格式校验，不符合规则的数据直接不往后传递，不再等到数据库才判断格式是否符合要求，提高用户体验 此时前端就算不做校验，也会在路由层就报错回去 在这规定用户名是字母开头，字母数字下划线结尾。可自定义规则 ajv库 ajv库可帮助操作schema校验 项目中安装ajv库：npm i ajv --save 使用示例： 参数1：schema校验规则 参数2：需要校验的数据 步骤 创建验证工具： validator文件夹下新建_validate.js，借助ajv创建 执行json schema 校验 的通用函数: 进行user的数据格式校验:src下新建validator文件夹-新建user.js，使用_validate.js中的函数并传入json schema的校验规则和需要校验的数据进行格式校验： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @description user 数据格式校验 * @author hlz */const validate = require('./_validate')// 校验规则const SCHEMA = &#123; type: 'object', properties: &#123; userName: &#123; type: 'string', pattern: '^[a-zA-Z][a-zA-Z0-9_]+$', // 字母开头，字母数字下划线 maxLength: 255, minLength: 2 &#125;, password: &#123; type: 'string', maxLength: 255, minLength: 3 &#125;, newPassword: &#123; type: 'string', maxLength: 255, minLength: 3 &#125;, nickName: &#123; type: 'string', maxLength: 255 &#125;, picture: &#123; type: 'string', maxLength: 255 &#125;, city: &#123; type: 'string', maxLength: 255, minLength: 2 &#125;, gender: &#123; type: 'number', minimum: 1, maximum: 3 &#125; &#125;&#125;/** * 校验用户数据格式（data默认值为&#123;&#125;） * @param &#123;Object&#125; data 用户数据 */function userValidate(data = &#123;&#125;) &#123; return validate(SCHEMA, data)&#125;module.exports = userValidate 注册路由（src-routes-api-user.js）中添加一个中间件进行格式校验，先执行格式校验再执行注册操作。这个中间件在很多地方都有可能使用，所以我们先抽离中间件 抽离中间件（格式校验） 创建”生成json schema 验证中间件“的方法： src下新建middlewares文件夹-新建validator.js： 注册路由中添加 验证中间件 进行格式校验： src-routes-users.js中： 测试：在前端我并没做密码长度的限制，但在路由中使用schema规则规定了密码长度最小是3：所以不会走到注册，可以看到数据表中无增加数据","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"完善koa2开发环境","slug":"完善koa2开发环境","date":"2020-03-14T04:02:53.000Z","updated":"2020-04-16T04:03:19.834Z","comments":true,"path":"2020/03/14/完善koa2开发环境/","link":"","permalink":"http://yoursite.com/2020/03/14/完善koa2开发环境/","excerpt":"完善koa2开发环境 配置eslint以及pre-commit inspect调试 404页和错误页","text":"完善koa2开发环境 配置eslint以及pre-commit inspect调试 404页和错误页 配置eslint配置eslint主要为了统一代码风格，只要遇到和我们自己在.eslintrc.json里的配置不同的情况就会报错。 根目录下新建.eslintignore，存放跳过的文件: 根目录下新建.eslintrc.json，根据个人习惯 规定代码风格: 项目文件下安装eslint和babel-eslint：npm i eslint babel-eslint --save-dev 在package.json中新建lint命令： 运行lint命令，使用vscode直接到相关文件中重新保存即可解决问题： 再次运行lint命令： 配置pre-commit 配置eslint只是统一代码风格，就算输入有误也可正确提交。 但pre-commit不同，他是“在提交（commit）之前”硬性做。 代码提交到coding是需要commit到本地仓库后再push到coding服务器的 项目文件下安装pre-commit：npm i pre-commit --save-dev 在package.json中配置pre-commit：规定在commit之前需要运行lint命令来检查代码 测试，提交代码到coding： 添加文件到本地仓库：git add . 提交文件到本地仓库：git commit -m &quot;feat:增加eslint&quot;执行这一步时pre-commit就会强制执行lint命令，如果报错就无法提交 没报错就可以继续将本地文件推送到coding服务器:git push origin master inspect调试 8.0以上的node就支持inspect调试，无需另外安装包。 inspect是借助node和chrome浏览器进行调试的。 访问chrome://inspect/#devices后点击Open dedicated DevTools for Node=》点击inspect进入调试页面 重点：打断点，在inspect调试页面中将自动运行到断点处停止运行，接下来可通过按钮手动运行下一部分的代码 在package.json中，dev命令中（调试都是在线下）添加inspect调试的端口号：默认的调试端口就是9229，如果两个node程序同时运行，并且都需要使用inspect调试，那么其中一个inspect就需要更改端口。 运行npm run dev: chrome浏览器中访问chrome://inspect/#devices：点击得到调试页面 测试：访问项目首页，调试工具中可看到：这个和程序控制台是一样的，光这样不够 停止运行，在路由中给项目加断点： 重新运行程序，重新点击inspect进入调试页面，访问项目首页： 此时可看到调试页面卡在debugger的断点位置：控制台目前只输出before debugger 点击按钮继续往下运行下一部分：点击2次后打印after debugger 404页和错误页 回顾：public文件夹下存放的都是静态文件，在app.js中我们注册了public作为静态资源的目录： css存放在public/css下，js存放在public/javascripts下，头部和底部组件存放在views/layout下，404和错误页存放在views/widgets下。 开发路由 routes文件夹下新建api文件夹：存放用于输出接口的路由；新建view文件夹 存放用于输出页面的路由 404路由 view下新建error.js： app.js中，引入并注册路由：404路由必须在所有路由的最下面注册，否则匹配路由时*就把所有路由都匹配了 测试：访问其他页面可正常访问，但访问不存在的路由： 错误页路由 app.js中本身就自带了错误页路由，修改错误页路由配置： 测试：在json路由中抛出一个错：再访问json路由： 但在开发环境下我们希望不要跳转错误路由，直接暴露错误信息，所以需要一个全局环境参数来判断： 此时在开发环境下访问错误的json路由：此时直接在控制台看错误并进行修改即可","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"微博项目使用sequelize","slug":"微博项目使用sequelize","date":"2020-03-13T15:08:07.000Z","updated":"2020-04-16T03:36:01.016Z","comments":true,"path":"2020/03/13/微博项目使用sequelize/","link":"","permalink":"http://yoursite.com/2020/03/13/微博项目使用sequelize/","excerpt":"安装mysql2、sequelize保持redis开启状态，weibo项目下安装mysql2、sequelize：npm i mysql2 sequelize --save","text":"安装mysql2、sequelize保持redis开启状态，weibo项目下安装mysql2、sequelize：npm i mysql2 sequelize --save 环境参数判断当前环境utils文件夹-env.js文件 管理全局环境参数：接下来就可以通过它来判断当前是否处于 线上/开发/测试环境 配置mysql的连接信息conf文件夹-db.js文件 存储redis和mysql的配置信息，分为线上和线下：其实线上和线下应该是连接不同的数据库，目前先都连接线下的 创建sequelize实例新建db文件夹-seq.js文件 创建sequelize实例，引入conf-db中的配置信息替换掉原本写死的配置信息： 测试环境下避免打印sql语句使用sequelize时控制台会打印出对应的sql语句，但测试环境下需要避免打印出sql语句：在创建Sequelize实例时，在测试环境下给参数4设置logging属性为空函数即可 执行sequelize同步到数据库db文件夹下新建sync.js，用于执行sequelize同步到数据库：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"redis与jest基本使用方法","slug":"单行 多行 文档注释 vscode快捷键","date":"2020-03-12T15:08:07.000Z","updated":"2020-04-16T01:36:31.987Z","comments":true,"path":"2020/03/12/单行 多行 文档注释 vscode快捷键/","link":"","permalink":"http://yoursite.com/2020/03/12/单行 多行 文档注释 vscode快捷键/","excerpt":"redis 内存数据库（mysql是硬盘数据库） redis相关基础知识（安装、使用、node链接redis）可参考这篇博客","text":"redis 内存数据库（mysql是硬盘数据库） redis相关基础知识（安装、使用、node链接redis）可参考这篇博客 nodejs操作redis 进入weibo项目中，安装redis：npm i redis --save --registry=https://registry.npm.taobao.org 获取全局环境参数，src下新建utils-env.js： 配置数据库（包括redis、mysql）的连接信息：在src下新建conf-db.js：根据全局环境参数来配置线上和线下的链接信息（现在先都用线下的来模拟） 连接redis并提供对redis中数据的读取方法（get/set），在src下新建cache-_redis.js（_的意思：该文件是内部文件，不对外公开）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @description 链接redis，提供读取redis数据的方法（get set） * @author hlz */const redis = require('redis')const &#123; REDIS_CONF &#125; = require('../conf/db')// 创建客户端const redisClient = redis.createClient(REDIS_CONF.port, REDIS_CONF.host)redisClient.on('error', err =&gt; &#123; console.log('redis error', err)&#125;)/** * redis set方法 * @param &#123;string&#125; key 键 * @param &#123;string&#125; val 值 * @param &#123;number&#125; timeout 过期时间，单位s */function set(key, val, timeout = 60 * 60) &#123; if (typeof val === 'object') &#123; val = JSON.stringify(val) &#125; redisClient.set(key, val) redisClient.expire(key, timeout) // 处理过期数据&#125;/** * redis get方法 * @param &#123;string&#125; key 键 */function get(key) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; redisClient.get(key, (err, val) =&gt; &#123; if (err) &#123; console.error(err) return &#125; if (val === null) &#123; resolve(null) return &#125; try &#123; resolve(JSON.parse(val)) &#125; catch (ex) &#123; resolve(val) &#125; &#125;) &#125;) return promise&#125;module.exports = &#123; set, get&#125; 注意： set()的参数3是数据有效时间（秒），过时即数据无效，到达指定时间后redis将自动清除数据 定义函数后在函数顶部输入jsDoc注释：写上注释的函数在被调用时鼠标移上去就会出现提示 set()的参数1、2都是字符串格式的，所以使用set()时需要判断参数2是否为引用类型，如果参数是引用类型就要先使用JSON.stringify()将其转换为字符串类型的数组/对象，否则会自动使用toString()方法进行转换，那结果会很麻烦。 redis客户端的expire()用于处理过期数据 get请求需要node向redis请求后获取一个redis返回的值，这是IO操作，而在node中IO操作是异步的。所以需要使用Promise对象对获取数据的过程进行封装。 由于之前存储数据时我们将对象转为JSON字符串了，所以输出数据时要先尝试将JSON字符串转回为JSON对象，而非JSON字符串则直接输出即可。同时要注意获取的值不存在时就返回空对象。 3-4","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"redis、session与jest基本使用方法","slug":"redis、session与jest基本使用方法","date":"2020-03-12T03:31:06.000Z","updated":"2020-04-16T03:32:22.812Z","comments":true,"path":"2020/03/12/redis、session与jest基本使用方法/","link":"","permalink":"http://yoursite.com/2020/03/12/redis、session与jest基本使用方法/","excerpt":"redis 内存数据库（mysql是硬盘数据库） redis相关基础知识（安装、使用、node链接redis）可参考这篇博客","text":"redis 内存数据库（mysql是硬盘数据库） redis相关基础知识（安装、使用、node链接redis）可参考这篇博客 nodejs操作redis 进入weibo项目中，安装redis：npm i redis --save --registry=https://registry.npm.taobao.org 获取全局环境参数，src下新建utils-env.js： 配置数据库（包括redis、mysql）的连接信息：在src下新建conf-db.js：根据全局环境参数来配置线上和线下的链接信息（现在先都用线下的来模拟） 连接redis并提供对redis中数据的读取方法（get/set），在src下新建cache-_redis.js（_的意思：该文件是内部文件，不对外公开）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * @description 链接redis，提供读取redis数据的方法（get set） * @author hlz */const redis = require('redis')const &#123; REDIS_CONF &#125; = require('../conf/db')// 创建客户端const redisClient = redis.createClient(REDIS_CONF.port, REDIS_CONF.host)redisClient.on('error', err =&gt; &#123; console.log('redis error', err)&#125;)/** * redis set方法 * @param &#123;string&#125; key 键 * @param &#123;string&#125; val 值 * @param &#123;number&#125; timeout 过期时间，单位s */function set(key, val, timeout = 60 * 60) &#123; if (typeof val === 'object') &#123; val = JSON.stringify(val) &#125; redisClient.set(key, val) redisClient.expire(key, timeout) // 处理过期数据&#125;/** * redis get方法 * @param &#123;string&#125; key 键 */function get(key) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; redisClient.get(key, (err, val) =&gt; &#123; if (err) &#123; console.error(err) return &#125; if (val === null) &#123; resolve(null) return &#125; try &#123; resolve(JSON.parse(val)) &#125; catch (ex) &#123; resolve(val) &#125; &#125;) &#125;) return promise&#125;module.exports = &#123; set, get&#125; 注意： set()的参数3是数据有效时间（秒），过时即数据无效，到达指定时间后redis将自动清除数据 定义函数后在函数顶部输入jsDoc注释：写上注释的函数在被调用时鼠标移上去就会出现提示 set()的参数1、2都是字符串格式的，所以使用set()时需要判断参数2是否为引用类型，如果参数是引用类型就要先使用JSON.stringify()将其转换为字符串类型的数组/对象，否则会自动使用toString()方法进行转换，那结果会很麻烦。 redis客户端的expire()用于处理过期数据 get请求需要node向redis请求后获取一个redis返回的值，这是IO操作，而在node中IO操作是异步的。所以需要使用Promise对象对获取数据的过程进行封装。 由于之前存储数据时我们将对象转为JSON字符串了，所以输出数据时要先尝试将JSON字符串转回为JSON对象，而非JSON字符串则直接输出即可。同时要注意获取的值不存在时就返回空对象。 登录-cookie和session cookie和session的基础知识 可参考笔记博客项目登录（cookie）、博客项目登录（session、redis） cookie通过http请求头部传递到server端，server端根据cookie中的userId取出session中对应的信息用来判断用于是否登录 session需要存储到redis中：从 session 到 redis koa2使用session 可参考koa2重构博客项目 安装插件koa-generic-session和koa-redis（koa-redis是基于redis的，所以必须安装redis）：npm i koa-generic-session koa-redis redis --save koa-redis是koa连接redis的一种方式，koa-generic-session是koa生成session的一个工具 app.js中，引入2个插件并配置： 在注册路由之前就需要配置session 注册session中间件时进行配置session并利用koa-redis将session存储到redis中 使用koa-redis时进行配置的信息从conf-db.js中获取 测试：在routes-index.js中获取并使用session来统计访问次数，在redis的cmd中看是否存储成功：注意：不使用session的情况下光是注册session则不会自动生成cookie/往redis中存储session 流程：用户每次访问网页时就会创建一个 ‘weibo.sid’前缀的cookie，值是’weibo:sess:’前缀的session名 cookie对象的属性值是存储在redis中的session对象的对象名 然后服务端会有一系列操作往session中存储用户名和密码等，那么下次用户再访问网页时，服务端就可通过用户请求中的cookie值到redis中去获取session对象，进行判断： jest 单元测试 单个功能或接口，给定输入，得到输出。看输出是否符合要求 需手动编写用例代码，然后统一执行 执行意义：能一次性执行所有单测，短时间内验证所有功能是否正常 注意：必须是.text.js后缀的文件 jest的基本使用 weibo项目下,(开发环境下）安装jest：npm i jest --save-dev 在package.json中，设置test命令： 根目录下新建test文件夹，存放测试用例，新建demo.test.js： 注意：必须是.text.js后缀的文件 常用的断言 判断数字/字符串：a是b：expect(数字/字符串a).toBe(数字/字符串b) 判断数字/字符串：a不是bexpect(数字/字符串a).not.toBe(数字/字符串b) 判断对象：a是b：expect(对象a).toEqual(对象b) 测试http请求 安装supertest插件：npm i supertest --save-devsupertest插件用于模拟http请求 测试get请求：test文件夹下新建server.js来模拟http请求，新建json.test.js用于测试http请求： 运行dev再运行test： 测试post请求：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"mysql与sequelize基本使用方法","slug":"mysql与sequelize基本使用方法","date":"2020-03-11T15:08:07.000Z","updated":"2020-11-08T08:28:08.952Z","comments":true,"path":"2020/03/11/mysql与sequelize基本使用方法/","link":"","permalink":"http://yoursite.com/2020/03/11/mysql与sequelize基本使用方法/","excerpt":"mysql mysql的下载安装等基本用法可参考博客：nodejs链接mysql及项目真实使用方法 操作mysql的客户端我选择的是SQLyog","text":"mysql mysql的下载安装等基本用法可参考博客：nodejs链接mysql及项目真实使用方法 操作mysql的客户端我选择的是SQLyog SQLyog中建库建表 首先新建数据库koa2_weibo_db 然后建表 users表： blogs表： sql语句增删查改 增删查改的sql语句 可参考博客：nodejs链接mysql及项目真实使用方法 在两个表中分别插入一些数据： 查询总数（select count()...from...） 查询总数和查一样，如果使用*来查询就很费性能，所以一般只查一列的总数即可 比如：SELECT COUNT(列名) FROM 表名; 或者：SELECT COUNT(列名) AS 重命名 FROM 表名; 例子： 分页（select...中limit与offset） limit x：限制只查询x行 offset x：跳过x行再查询 例子：假定一页是两行数据： 外键 这个在nodejs链接mysql及项目真实使用方法中没有提到的 在sqlyog中创建外键，创建外键时可设置 更新/删除是否级联 创建外键 首先需要保证2列数据的类型和限定长度一致 然后在sqlyog进行操作，创建外键、设置更新级联、删除级联： 刷新后，可看到blogs-indexes下出现了外键userid： 更新限制&amp;更新/删除级联 更新限制：blogs表中的userid被限制为users表中的id，不能输入其他的内容 例子： 更新级联（update cascade）：（创建外键时可设置）一旦users表中的id被更新，blogs表中对应的userid的那条数据将被自动更新 一般id是不更新的，所以这里只做了解 删除级联（delete cascade）：（创建外键时可设置）一旦users表中的id被删除，blogs表中对应的userid的那条数据将被自动删除 例子： 连表查询（inner join...on...=...） 连表查询：通过一条查询就可拿出两个表中对应的数据，注意有一个匹配条件（on...=...）来判断筛选出查询出来的表中数据 注意：没有外键也可连表查询，但一般我们会采取外键来做 匹配条件 语法：SELECT ... FROM ... INNER JOIN ... ON ...=... WHERE ...; INNER JOIN 关键字在表中存在至少一个匹配时返回行。 on 条件是在生成临时表时使用的条件，它不管 on 中的条件是否为真，都会返回左边表中的记录。 where 条件是在临时表生成好后，再对临时表进行过滤的条件。 例子： 通过 blogs表中的userid（users表中id的外键） 与 users表中id 匹配 来 连表查询所有数据：这样就把两个表中的id都查出来了，显然不行，由于微博内容是我们查询的主体，所以我们查询的时候可以只在两个表中选自己需要的数据组成临时表 匹配条件不变，只查需要的数据： 在此基础上，还可通过where来进一步筛选查询内容： sequelize sequelize是一个ORM工具，他封装了很多API，通过sequelize我们可通过操作一般对象的方式去操作数据库 Object Relational Mapping 即 对象关系映射（映射到数据库中），也就是通过对象的关系的形式映射到数据库中，即我们可通过操作一般对象的方式去操作数据库 sequelize不仅可以操作mysql，还可操作其他数据库 Sequelize返回的对象是Promise实例，也就是说从数据库中获取的数据是存在then()中的，此时使用async和await来获取数据库数据就很方便。而koa的处理函数都是async函数，所以我们实际上在koa的async函数中直接写await访问数据库就可以了 sequelize使用方法 注意：需要设置数据的字段长度可参考官方文档 sequelize与mysql mysql sequelize 数据表 用JS中的模型（class或对象）代替 一条或多条数据 用JS中一个对象或数组代替 sql语句 用对象方法代替 sequelize使用方法总结 方法 含义 创建sequelize实例，连接数据库 sequelize实例.define() 创建模型（数据表） sequelize实例.sync() 使用sequelize 将模型（表）同步到数据库 模型名A.belongsTo(模型名B,{foreignKey: &#39;外键名&#39;})模型名A.hasMany(模型名B,{foreignKey: &#39;外键名&#39;}) 创建外键关联，连表查询时都是以模型名A为主，带出模型名B的数据 模型名.create() 往模型（数据表）中增加数据 1.查询一条数据：模型名.findOne()2.查询一条数据中特定的列：模型名.findOne()的where属性3.查询多条数据（组成一个列表）：模型名.findAll()4.查询总数：模型名.findAndCountAll()5.连表查询：使用模型名.findAndCountAll()的include属性6. 查询数据 模型名.update() 修改数据 模型名.destroy() 删除数据 创建 sequelize实例：连接mysql数据库，使用sequelize库来new一个sequelize实例 创建模型（表）：使用sequelize实例.define()创建表并定义表中各列数据的名字、类型、长度、自动递增、主键、备注 等 将模型（表）同步到数据库：使用sequelize实例.sync()进行同步。注意要引入创建的模型（表），否则都不知道同步谁 创建外键关联：使Blog模型中的userId成为User模型中id的外键，有2种方法，如果想要方便后期查询，则可同时使用2种方法 方法1：Blog.belongsTo(User,{foreignKey: &#39;userId&#39;})，使用该方法创建的外键，在连表查询时以blogs表为主，带出users表 方法2：User.hasMany(Blog,{foreignKey: &#39;userId&#39;})，使用该方法创建的外键，在连表查询时以users表为主，带出blogs表 插入数据：往User和Blog模型（users表和blogs表）中插入数据 比如User.create() 参数：插入的数据对象 返回值：Promise实例=》对象，所以建议使用await User.create()可直接得到返回值，其中包含的dataValues是插入的数据对象 查询数据： 查询一条数据：模型名.findOne() 参数：对象，该对象包含众多属性 where：对象，筛选行 attributes：数组，筛选列 返回值：Promise对象=》对象，返回值的dataValues属性为对象，其中包含id等内容 查询多条数据（组成一个列表）：模型名.findAll() 参数：对象，该对象包含众多属性 where：对象，筛选行 order：数组（其中数组元素也是数组），每个数组元素都是排序规则（比如：order:[[&#39;id&#39;,&#39;desc&#39;]]就是根据id反向排序） limit：数字，限制本次查询条数 offset：数字，跳过多少条再进行查询 返回值：Promise对象=》数组，数组元素为数据对象。 每个数据对象都有自己的dataValues，需要获取则通过需map()遍历数组。 查询总数：模型名.findAndCountAll() 参数：和findAll()的参数一样 返回值：Promise对象=》对象，其中返回值.count为所有数据的总数，返回值.rows则是分页的数组（多行数据） 连表查询：使用模型名.findAndCountAll()的include属性，属性值是对象数组，对象中的model属性决定了连的表 返回值：Promise对象=》对象，其中返回值.count为所有数据的总数，返回值.rows则是所以行数据组成的数组，其中每个数据对象的dataValues中都包含一个连表查询出的数据对象，不过该对象也需要通过对象的dataValues来获取 修改数据：模型名.update() 参数1：对象，需要修改的数据 参数2：对象，where属性筛选需要修改的数据 返回值：Promise对象=》数组，表示被修改的行数，返回值[0]=0则修改失败，返回值[0]&gt;0则修改成功。 删除数据：模型名.destroy() 参数：对象，筛选条件 返回值：Promise对象=》数字，表示被删除的行数（注意不是数组，是数字！） 如果被删除的数据中有在别的表中当外键，则必须保证delete中设置的是“层叠/级联”才可正常删除，严格模式下会报错。注意：使用sequelize创建的外键关系是严格模式，需要手动去sqlyog中将delete改为“层叠/级联”。 例子我们现在使用sequelize来完成之前我们使用mysql与sqlyog共同完成的事情 创建连接 新建sequelize-test文件夹，初始化环境npm init -y 安装2个库：mysql2、sequelize：npm i mysql2 sequelize -d 在这使用mysql2库代替我们原本使用的mysql库，效率更高（mysql的使用方法和mysql2的使用方法大体上差不多） 我们将通过sequelize操作mysql2 创建sequelize实例 用于连接mysql中的某个数据库： 测试是否连接成功： 创建模型&amp;同步到数据库 src下新建model.js:暂时只创建User模型，同步到数据库看看是否成功 Sequelize实例.define()创建表： 参数1：表名（会自动变成复数后成为表名），比如设置user那么最后表名将是users 参数2：对象，即表中各项数据的 类型、是否允许为空 等 其中，id会自动创建，并设为主键、自增,不需我们手动创建 Sequelize.STRING即数据库中varchar(255)。数据库中varchar长度是可变的，也就是说虽然最长是255，但如果你只输入了2个字符，数据库也就会进行计算，最终将只占用2个字符的空间，所以直接使用sequelize默认的长度即可 allowNull: false即设置 不允许为空 comment：&#39;备注内容&#39; 删除原本我们在sqlyog中定义的users表和blogs表 src下新建sync.js将创建的模型同步到数据库： 所有需要连接数据库的地方都要引入sequelize实例 同步数据库就要引入需要同步的模型（表） Sequelize实例.sync()同步数据库内容： 参数：{ force: true }即强制，如数据库中已有该表，则删掉重新创建一个新的 注意：同步成功后需手动结束进程。即使用process.exit()退出程序，否则sequelize会一直占用进程 执行同步： sqlyog中查看同步结果： 设置数据字段长度 需要设置数据的字段长度可参考官方文档，例子如下：12345DataTypes.STRING // VARCHAR(255)DataTypes.STRING(1234) // VARCHAR(1234)DataTypes.STRING.BINARY // VARCHAR BINARYDataTypes.TEXT // TEXTDataTypes.TEXT('tiny') // TINYTEXT 创建关联（外键） 回到src-model.js中创建Blog模型（blogs表）： 同步到数据库： sqlyog中查看同步结果： 设置关联外键：在这我们同时采取2种方法设置外键，是为了搜索时2种主次关系都可行。 方法1（推荐）Blog.belongsTo(User,{foreignKey: &#39;xxx&#39;})：即 将Blog模型（blogs表）中的xxx列作为User模型（users表）中id（默认为id）的外键 使用该方法创建的外键，在连表查询时以blogs表为主，带出users表 语义化：Blog属于User，这是多对一的关系，多个Blog是属于一个User的 方法2（不推荐）Blog.belongsTo(User)：使用该方法则我们自己定义Blog模型时就不需要创建外键，Sequelize会自动创建userId并关联到users表中的id上 方法3（推荐）User.hasMany(Blog,{foreignKey: &#39;xxx&#39;})：与方法1创建的外键一致，只是 连表查询 是主次关系不同 使用该方法创建的外键，在连表查询时以users表为主，带出blogs表 语义化：User有很多Blog，这是一对多的关系，一个User可拥有多个Blog 同步到数据库 sqlyog中查看同步结果：（如果使用workbench则可同时看到外键的关系） sqlyog中自动绘制ER图：可以看到多对一的关系：1个users.id可拥有多个blogs.userid 插入数据 src下新建create.js,创建表中数据：插入数据属于IO操作，在node中IO操作都是异步的，而异步最好使用async和await 语法：模型.create({需要插入的数据对象}) 异步插入的结果：对象，其中dataValues对象为插入的数据 查看创建的数据： 为避免重复插入数据，我们先删掉之前的数据，将所有数据写好后一起插入数据库：（或者可以先执行同步，再插入数据，因为同步后能表中内容为空）!在这是逻辑非运算，可能是运算符优先级的原因？ sqlyog查看结果： 查询数据（1条/多条/分页/总数） src下，新建select.js 查询一条数据：模型名.findOne() 查询一条数据中特定的列：attributes属性 查询多条数据（组成一个列表）：模型名.findAll() 注意：数组中每条数据都是一个对象，每个对象都有自己的dataValues，需要使用map()来遍历获取对象.dataValues 实现分页：limit和offset属性 查询总数：模型名.findAndCountAll()： 参数：和findAll()的参数一样 返回值：对象，其中返回值.count为所有数据的总数，返回值.rows则是（各行）分页的数组 连表查询（include属性） 方法1：前提：使用Blog.belongsTo(User,{foreignKey: &#39;userId&#39;})建立的外键关系才可使用该方法进行连表查询 方法2：前提：使用User.hasMany(Blog,{foreignKey: &#39;userId&#39;})建立的外键关系才可使用该方法进行连表查询 更新和删除 更新数据：src下新建update.js，更新数据采用模型名.update()： 参数1：对象，需要修改的数据 参数2：对象，where属性筛选需要修改的数据 返回值：Promise对象=》数组，表示被修改的行数，返回值[0]=0则修改失败，返回值[0]&gt;0则修改成功： 删除数据：src下新建delete.js，删除数据采用模型名.destroy(): 参数：对象，筛选条件 返回值：Promise对象=》数字，表示被删除的行数（注意不是数组，是数字！） 如果被删除的数据中有在别的表中当外键，则必须保证delete中设置的是“层叠/级联”才可正常删除，严格模式下会报错。注意：使用sequelize创建的外键关系是严格模式，需要手动去sqlyog中将delete改为“层叠/级联”： 连接池 线下开发：我们在seq.js中使用的连接方法就属于上图左边的：这种方式不适合线上使用，但是适合线下开发，因为机制没那么复杂，有问题找起来比较快 线上建议使用连接池：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"ejs基本使用方法","slug":"ejs基本使用方法","date":"2020-03-10T03:12:00.000Z","updated":"2020-04-11T03:16:21.489Z","comments":true,"path":"2020/03/10/ejs基本使用方法/","link":"","permalink":"http://yoursite.com/2020/03/10/ejs基本使用方法/","excerpt":"EJS是高效的嵌入式 JavaScript 模板引擎 EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。 EJS 没有如何组织内容的教条，也没有再造一套迭代和控制流语法，有的只是普通的 JavaScript 代码而已。","text":"EJS是高效的嵌入式 JavaScript 模板引擎 EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。 EJS 没有如何组织内容的教条，也没有再造一套迭代和控制流语法，有的只是普通的 JavaScript 代码而已。 ejs语法总结 ejs中书写js变量：&lt;%= 变量 %&gt; ejs中书写js表达式：&lt;% js表达式 %&gt;，每一行js表达式都要加，html代码则不用 注意：如果js表达式中间插入了html代码，那么js表达式需要分开包裹，如下面“ejs循环”中的例子。如果js表达式只是单纯换行则只需一个尖括号包裹，如下“ejs引用组件”中的例子。 区分ejs中书写js变量与表达式：需要输出的变量才有等号！ ejs中引用ejs组件：&lt;%- include(&#39;相对路径/组件ejs文件名&#39;,{变量1，变量2，...，变量x}) %&gt; 组件中需要的变量通过参数2进行传递 ejs文件中可直接定义组件，文件名即为组件名 注意：ejs模板最后编译为html代码，所以ejs中也可正常使用script标签来书写js代码 为何路由可对应不同ejs文件 koa2框架中已帮我们在app.js中注册了ejs： 所以路由中只需要写文件名并将变量传过去ejs即可：index.ejs接受到变量后即可显示： ejs变量 ejs中的变量语法：&lt;%= 变量 %&gt; 例子 传递变量的路由、接收并显示变量的ejs文件、显示效果：例子 错误处理 当我们在ejs中使用了并未从路由中传递过来的变量时， 例子 ejs文件和显示页面： 原因：app.js中的onerror()处理了错误，显示了一个前端页面：此时可在控制台看到报错原因 解决方法：变量前加locals.:这样即使没有传递该变量就使用了也不会报错，它相当于传了一个空，即&lt;p&gt; &lt;/p&gt; 总结：在ejs模板中，不确定是否会传值过来的变量使用locals.变量,防止因未传变量而报错 ejs判断 ejs中书写js表达式时语法：&lt;% js表达式 %&gt;，每一行js表达式都要加，html代码则不用 注意：如果js表达式中间插入了html代码，那么js表达式需要分开包裹，如下面“ejs循环”中的例子。如果js表达式只是单纯换行则只需一个尖括号包裹，如下“ejs引用组件”中的例子。 区分ejs中书写js变量与表达式：需要输出的变量才有等号！ 注意：ejs模板最后编译为html代码，所以ejs中也可正常使用script标签来书写js代码 例子 routes-index.js中传入变量isMe: views-index.ejs中做判断: 测试： ejs引用组件 ejs中引用组件的语法：&lt;%- include(&#39;相对路径/组件ejs文件名&#39;,{变量1，变量2，...，变量x}) %&gt; 组件中需要的变量通过参数2进行传递 ejs文件中可直接定义组件，文件名即为组件名 例子 views文件夹下新建widgets文件夹，用于存放组件 widgets文件夹下新建user-info.ejs，将ejs判断例子中添加的逻辑挪过去创造组件： 在views-index.ejs中引用组件： 测试： ejs循环 和ejs判断类似 例子 routes-index.js中传入数组blogList： widgets文件夹下新建blog-list.ejs组件，循环渲染blogList： 注意：html属性值需要引号 在views-index.ejs中引用组件： 测试： 提交项目到coding 提交前最好使用git diff看看自己提交的是否包含什么不需要提交的 添加文件到本地仓库：git add . 提交文件到本地仓库：git commit -m &quot;feat:演示ejs&quot; 将本地文件推送到coding服务器:git push origin master（master也可以是其他分支） 补充：SSR与SP 所有的服务端渲染引擎（比如ejs、vue、react），本质上都是SSR（server side render） 通过服务端的能力将页面渲染出来的就是SSR 比如，在上面“ejs循环”的例子中，blog-list.ejs组件中可以通过判断blogList的长度然后将其每一条都显示出来。服务端通过模板输入浏览器的是一个静态的结果，这样的形式就是SSR： 与SSR相对的就是SP(前端渲染),比如AJAX。SP是不会显示一堆html代码的，只会有一个JS代码显示在浏览器上。通过JS的能力将页面渲染出来的就是SP","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"介绍koa2 创建微博项目","slug":"介绍koa2 创建微博项目","date":"2020-03-09T02:51:26.000Z","updated":"2020-04-11T01:26:25.395Z","comments":true,"path":"2020/03/09/介绍koa2 创建微博项目/","link":"","permalink":"http://yoursite.com/2020/03/09/介绍koa2 创建微博项目/","excerpt":"可参考博客koa2框架基本使用方法","text":"可参考博客koa2框架基本使用方法 使用koa2-创建项目 借助脚手架工具koa-generator创建项目 koa2框架基本使用方法 可参考这篇博客 使用koa-generator创建项目1.项目文件下，安装脚手架工具koa-generator： 1npm install -g koa-generator 2.选择koa2版本，-e说明使用ejs模板进行开发,创建项目： 1koa2 -e 3.安装依赖： 1npm install 运行项目4.启动项目： 1npm run dev 5.访问http://localhost:3000/： 生成文件 bin文件夹：启动文件 www.js中规定了3000端口，也就是运行起来以后可以通过`http://localhost:3000/`进行访问 src-App.js:项目的主文件，处理业务（他会将项目中写好的文件进行编译执行） node_moudles文件夹：依赖文件 public文件夹： images文件夹：存放图片 javascipts：存放js文件 stylesheets：存放css文件 routes文件夹：存放路由 views文件夹：ejs文件 package.json:基本命令（比如启动项目的npm run dev就是这里定义的） 借助coding管理项目 具体步骤在这篇博客中。 使用cross-env 安装cross-env:npm i cross-env -D 设置package.json： 这里就不用另外安装nodemon进行热更新了，框架中执行的dev命令中自带了 start基本用不到，可以删除 test是单元测试用的，此时可先清空： 设置原因 windows、linux、mac os三个系统中设置环境变量的方式都不同，但使用cross-env可以把他们统一起来，这样代码在3个系统中都能运行。 在node中，process对象是全局变量，它提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()。 env是process的一个属性，这个属性返回包含用户环境信息的对象。在终端输入node后，在输入process.env可以看到打印出来的信息。 NODE_ENV不是process.env对象上原有的属性，它是我们自己添加上去的一个环境变量，用来确定当前所处的开发阶段。 一般我们将 生产阶段 设为production，开发阶段 设为develop（在package.json中设置），然后在 脚本 中读取process.env.NODE_ENV即可知道现在是开发阶段还是生产阶段。 整理代码结构 目前的代码结构不符合我们所习惯的： 稍作调整，新建src文件夹，将public、routes、views、app.js剪切到src下： 修改bin-www.js下app的引用路径： 页面正常显示即调整成功： 重新提交coding项目进行重新提交，具体步骤在这篇博客中。 路由演示 自带的routes-index.js: 自带的routes-user.js： 异步渲染模板 在routes-index.js中key看到，ctx.render()是await的，即异步的，也就是说，node渲染ejs模板是异步的 原因：node中所有的IO操作都是异步的，而渲染模板实际上就是读取模板，读取模板是异步的 我们需要使用await将模板异步读取出来，然后再将变量返回给模板 处理get请求动态参数 访问个人页时，可通过ctx.params来获取路由中传递的参数： 点击“加载更多”时， 处理post请求post请求的数据 登录时，可通过ctx.request.body（对象）获取post请求中的数据： postman测试： 重新提交coding 添加文件到本地仓库：git add . git commit -m &quot;feat:演示路由&quot; 将本地文件推送到coding服务器:git push origin master（master也可以是其他分支）","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"博客项目上线及配置","slug":"博客项目上线及配置","date":"2020-03-08T02:51:26.000Z","updated":"2020-04-10T02:51:54.536Z","comments":true,"path":"2020/03/08/博客项目上线及配置/","link":"","permalink":"http://yoursite.com/2020/03/08/博客项目上线及配置/","excerpt":"PM2核心【重点记忆】 进程守护，系统崩溃自动重启 启动多进程，充分利用CPU和内存 自带日志记录功能","text":"PM2核心【重点记忆】 进程守护，系统崩溃自动重启 启动多进程，充分利用CPU和内存 自带日志记录功能 nodemon和PM2区别 nodemon是在控制台前端监听的服务器启动，一旦使用就不能再在控制台输入其他命令，必须停止nodemon才能输入其他命令 PM2是在控制台后台监听的服务器启动，所以使用PM2时还可以在控制台输入其他命令 下载安装 新建文件夹pm2-test，初始化环境，安装pm2：npm i pm2 -g 查看pm2版本：pm2 --version 基本使用 package.json： app.js： 控制台：使用pm2我们可以继续操作控制台，使用nodemon则是在前台运行，控制台上不可做其他操作 常用命令 运行进程：pm2 start ... 在上面的例子中，package.json中规定的prd命令中就使用了pm2 start ...：需要启动的 js文件名 或者 配置文件 “PM2常用配置”的例子中使用的就是pm2 start 配置文件 进程列表：pm2 list 上面的例子： 重启进程：pm2 restart &lt;AppName&gt;或&lt;id&gt; AppName和id都来源于进程列表 上面例子中则是：pm2 restart app/pm2 restart 0 停止进程：pm2 stop &lt;AppName&gt;或&lt;id&gt; 停止以后还可重新启动 删除进程：pm2 delete &lt;AppName&gt;或&lt;id&gt; 查看基本信息：pm2 info &lt;AppName&gt;或&lt;id&gt; 查看进程日志：pm2 log &lt;AppName&gt;或&lt;id&gt; 修改上方例子，添加自定义日志： 查看pm2处理结果： 没做配置的情况下，pm2将 通过console.log和console.error自定义的日志 保存在这两个文件中，故之前提到自定义日志不需要手动保存于文件中。后面可通过配置改变报错的文件路径。 监控进程的cpu和内存信息：pm2 monit &lt;AppName&gt;或&lt;id&gt; 可用于查看内存是否爆了或者cpu占的太满 例子：线上环境下想调试一些问题就可以在服务器上使用该命令 PM2进程守护 进程守护是保证服务器稳定性的重要手段 使用node app.js或nodemon appjs启动项目，进程崩溃则不能访问入 使用pm2启动项目，遇到进程奔溃会自动重启 出错的页面虽然出错，但pm2可以保证不出错的页面依旧可以访问，不至于一个地方崩溃就全部崩溃 例子 继续上面例子，模拟错误，使其崩溃： 先访问首页，正常显示 访问/err页面，显示错误 再访问首页，正常显示 但查看 进程列表 可以看到重启次数增加了3次（正常页面是不会重启的，次数不是关键，关键是能重启） 并且错误日志会被记录： PM2常用配置和日志记录 新建PM2配置文件（包括进程数量，日志文件目录等） 修改PM2启动命令，重启 访问server，检查日志文件的内容（日志记录是否生效） 例子 接上面从“基本使用”开始的例子，新建logs文件夹-新建err.log用于存放错误日志（console.err()打印的）、out.log存放console.log()打印的日志 新建pm2.conf.json，作为PM2的配置文件： 注意是json格式的 watch：是否热更新，true为是。建议填false 修改package.json，使配置文件生效: 删除进程后重新启动进程，可看到配置文件已被运行： 查看基本信息，可看到日志保存路径成功改变： 多次访问网页，查看日志文件：可以看到配置文件中的时间戳被自动加载每条日志前面 PM2多进程 多进程能充分利用服务器的内存和cpu资源 多进程内存不共享，但可通过redis解决此问题 为何使用多进程 分成多个进程，这样其中一个进程崩了不至于全都崩了 回顾之前session相关知识点说过，操作系统限制一个进程的最大内存： 单进程无法充分利用机器全部内存 单进程无法充分利用多核CPU的优势 几核cpu就擅长同时处理几个进程 多进程内存不共享和redis 使用多进程可能会带来一些问题，比如多个进程之间内存无法共享 比如，多个进程之间的session无法共享： 解决方法：多进程访问一个redis，共享session： 例子 延续上面的例子，在配置文件中设置4核： 运行程序，可看到进程列表中出现了4个进程： 多次访问页面，可发现4个进程分别对应不同的日志文件：pm2自有一套计算规则，哪个进程更闲就将请求派发到哪个进程 关于服务器运维 服务器运维，一般都由专业的OP人员和部门来处理 大公司都有自己的运维团队 中小型工期推荐使用一些云服务，如阿里云的node平台","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"koa2重构博客项目","slug":"koa2重构博客项目","date":"2020-03-07T02:58:24.000Z","updated":"2020-04-10T16:13:34.338Z","comments":true,"path":"2020/03/07/koa2重构博客项目/","link":"","permalink":"http://yoursite.com/2020/03/07/koa2重构博客项目/","excerpt":"实现session存储在redis中 基于koa-generic-session和koa-redis koa-redis是基于redis的，所以必须安装redis 在app.js中使用session中间件时，在session中间件内配置redis，则不需手动将session存储在redis内，直接将username等信息存储在session内即会同步到redis内","text":"实现session存储在redis中 基于koa-generic-session和koa-redis koa-redis是基于redis的，所以必须安装redis 在app.js中使用session中间件时，在session中间件内配置redis，则不需手动将session存储在redis内，直接将username等信息存储在session内即会同步到redis内 安装插件安装插件koa-generic-session和koa-redis（koa-redis是基于redis的，所以必须安装redis）： 1npm i koa-generic-session koa-redis redis --save app.js使用插件 配置session和redis app.js中引入插件： app.js中，在routes前使用插件配置session和redis： app.keys即我们之前配置过的密匙，这里就用原来的，也可以是更复杂的 session数据是放在服务端的，cookie数据则存放在客户的浏览器上 path：可使用cookie的路由 httpOnly：true时前端js无法访问cookie maxAge：cookie有效时间（毫秒） 先把redis的配置环境写死，实际应该本地配置本地，线上配置线上 配置好后，每次用户发送http请求时，都会根据用户请求中的cookie到redis中获取session数据 routes-user.js验证 routes-user.js中，添加一个测试路由： 运行redis（redis安装目录下打开cmd，运行redis-server.exe redis.windows.conf启动redis） 运行项目，访问测试路由http://localhost:8000/api/user/session-test：![访问测试路由](http://ww1.sinaimg.cn/large/005H7IVsgy1gdk3fwjoanj31c9089gn0.jpg) viewConut为访问次数，同一个浏览器多次访问会累加访问次数，但只存储一次session 查看是否存在redis中：redis目录下另启一个 cmd 窗口，原来的不要关闭（否则无法访问服务端），运行redis-cli后看到目前设置的所有key(keys *)： 回顾session和cookie 首先cookie是一个对象，里面存储的是userId、path等；session也是一个对象，其中存储的是username和password等。 cookie是存储在浏览器上的，session则可以存储在node中作为js变量或者存储在redis中。 流程总结： 用户登录网页，在登录路由中将输入的username等数据放入session中，并使用redis的set方法将session数据同步存储到redis中 接下来每次访问网页时，首先执行的app.js就会根据用户请求中的cookie的userId，使用redis解析（读取）session得到username等数据，以此判断用户是否登录。 开发路由项目安装mysqlnpm i mysql xss --save --registry=https://registry.npm.taobao.org 复用blog-1中部分代码 统一数据返回格式：将blog-1中的model整个文件夹拷贝到blog-koa2文件夹下 数据库配置信息：将blog-1中的conf整个文件夹拷贝到blog-koa2文件夹下 在blog-koa2的app.js中引入conf中关于redis的配置信息，修改之前写死的redis配置： 新建db文件夹，将blog-1中的db文件夹下的mysql.js拷贝过来。 拷贝controller整个文件夹，进行修改： 按照async语法 修改blog.js:在每个函数前面添加async，返回值使用await关键词：await处理Promise对象会直接得到resolve状态下返回的值，这样就没有Promise异步的问题了 blog.js中，async中遇到then时可这样修改： 修改user.js: user.js中需要用到cryp.js，所以拷贝blog-1中的utils文件夹下的cryp.js 一样按照async语法修改user.js： 创建 中间件（登录校验） 新建middleware文件夹： 新建loginCheck.js文件，一样是判断session中是否有username，有则认为已登录，继续执行下一个中间件，没有则返回“未登录”： 开发博客路由（routes-blog.js） list路由： detail路由： new路由： update路由： del路由： 给需要的路由添加登录校验： 开发用户路由（routes-user.js） 一样引入需要使用的： login路由：koa2框架中，app.js中我们时候用session中间件时配置了redis，故不需手动存储session到redis中 前端联调 运行前后端项目，前端运行在8001端口，后端运行在8000端口： 运行nginx和redis 测试所有功能： （未登录）进入首页就会产生一个和cookie的id：此时session并未存储到redis中 进入登录页，登录zhangsan帐号后，产生另一个id，这个id会存储在session中： 存储在redis中的cookie对应的session的内容： 接下来每次发送的请求进入app.js后就会根据cookie进入redis中读取对应的session，通过session中的username来判断用户登录与否 日志 现在只讲使用koa-morgan插件记录access log并写入文件 自定义日志先使用console.log和console.error即可，至于如何写入文件等后面再讲 记录access log 新建logs文件夹用于存放日志-新建access.log文件用于存放访问日志 koa2框架中自带的koa-logger插件起一个开发环境下规范打印格式的效果，比如： 但koa-logger插件只是美化打印效果，并不能用于记录access log koa-morgan插件 这里我们需要使用express框架的morgan插件来记录access log 但morgan只支持express框架，所以需要先做一个兼容，通过koa-morgan来安装，使其可以运行在koa2开发环境中： morgan插件的使用方法：morgan(参数1，参数2) 参数1：（字符串）可选&#39;dev&#39;/&#39;combined&#39;等,决定log字符串格式 比如,一般开发环境下选择dev：线上环境则选择完善一点的格式combined 参数2：可省略 默认为{stream:process.stdout}，即通过stream（流）的 打印在控制台上显示； 可以是{stream:process.写入文件的stream对象}，即 将log写入文件（写入文件的stream对象 可参考这篇笔记） 在app.js中： 需要写入文件就需要引入path和fs，需要记录access log就需要引入koa-morgan： 测试： 先测试开发环境： 再测试线上环境： package.json中，由于我们还没学pm2，先改nodemon： 运行线上环境： 访问几次不同的页面，可看到access.log中已有日志： 自定义日志 自定义日志先使用console.log和console.error即可，至于如何写入文件等后面再讲 比如，在routes-blog.js中，自定义日志： 效果： koa2中间件原理 可参考koa官网 app.use()用于注册中间件 next机制：即上一个中间件通过next()触发下一个中间件 注意：koa中间件不涉及路由功能，故不涉及method和path的判断！注意区分koa路由和koa中间件 官网的“级联”中有一个中间件示例 洋葱圈模型：中间件之间通过next函数联系,当一个中间件调用 next() 后，会将控制权交给下一个中间件, 直到下一个中间件不再执行 next() 后, 将会沿路折返,将控制权依次交换给前一个中间件。 中间件示例 新建koa2-test文件夹，npm init -y初始化环境 将package.js中的main改成app.js,新建app.js,将官网示例拷入： 该示例中有3个中间件： logger记录日志 x-response-time记录请求时间 response返回 安装koa框架：npm i koa --save --registry=https://registry.npm.taobao.org 运行node app.js，访问8000端口：再访问http://localhost:8000/aaa和http://localhost:8000/bbb 控制台可看到：访问8000端口耗时5ms，后面因为不需要加载东西，所以aaa和bbb都是0ms 代码执行过程： 运行项目时首先进入app.js app.js中注册了3个中间件 首先进入logger中间件，但马上就由next进入x-response-time中间件 在x-response-time中记录了当前时间，又由next进入response中间件 在response中间件返回Hello World显示在页面上 此时又返回继续执行response中间件，计算出时间差，并将时间差设置到ctx中 执行完后相当于第6行代码执行完，即又返回logger中间件中执行7、8行代码，从ctx中获取刚才设置的时间差，并最终打印出来 洋葱圈模型 上面示例的代码运行方式就是洋葱圈模型：各个中间件之间看似分离，实则是包裹的关系，第一个中间件包含了第二个中间件，第二个又包含了第三个 从代码来看： 比如，给每个中间件加上开始于结束： 结果：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"koa2框架基本使用方法","slug":"koa2框架基本使用方法","date":"2020-03-06T05:24:15.000Z","updated":"2020-04-10T16:14:56.350Z","comments":true,"path":"2020/03/06/koa2框架基本使用方法/","link":"","permalink":"http://yoursite.com/2020/03/06/koa2框架基本使用方法/","excerpt":"koa2框架 koa2框架是原生支持async/await的","text":"koa2框架 koa2框架是原生支持async/await的 async/await的简单示例 回顾以前使用Promise的例子：使用Promise的例子 通过以前的例子来对比使用使用Promise和使用async/await： 在async函数中，使用await我们可以获取到Promise对象成功时传递的数据，也可使用 try-catch 截获promise 中reject 的值： async/await 要点更多基础知识可参考笔记ES6 async函数与await关键词 await后面可以追加promise 对象，获取resolve()传递的值 await必须包裹在async 函数里面使用 执行 async 函数返回的也是一个promise 对象 可使用 try-catch 截获promise 中reject 的值 安装koa2框架（所有安装都可加上淘宝镜像--registry=https://registry.npm.taobao.org来加速） 安装脚手架工具koa-generator：npm install koa-generator -g 注意：这里是koa，没有2，因为它也可用于1版本的 初始化koa2项目：koa2 项目名 进入项目目录下，安装package.json中的所有依赖：npm install 由于package.json中缺少全局环境参数，所以手动安装一个：npm i cross-env --save-dev 安装完成后需要修改package.json: 运行项目(热更新)：npm run dev（package.json中显示已经有nodemon，所以无需重新添加，直接使用即可） 由package.json的dev可知项目运行先执行的是启动server的文件bin/www，原本端口为3000，现将端口设置为8000： 重新运行项目后测试： 项目目录分析 app.js: 各个插件的作用 思考各个插件的实现原理（结合之前学过的知识） 处理get请求和past请求 介绍路由 router.get()：定义处理get请求的路由 参数1：路由url 参数2：async函数，路由符合时做的事情 router.post()：定义处理post请求的路由 参数1：路由url 参数2：async函数 注意： router来自中间件’koa-router’ 定义路由后需要在app.js中引入路由并使用app.use()注册路由 ctx.render()是渲染的页面 ctx.body是返回的内容 ctx.params：对象，其中包含路由中传递的参数 比如：通过路由获取的参数userName ctx.request.body:对象，其中包含post请求中的数据 用自带的路由举例： 对应页面： 处理GET请求的路由新建博客路由（router.get()）routes下新建blog.js： app.js中注册路由（app.use()）app.js中引入并使用博客路由: 测试 没用框架的时候，query部分需要我们自己从req的url中的字符串提取query部分后，再使用querystring的parse()将字符串转换为JS对象，现在可以直接得到query对象 处理POST请求的路由新建用户路由（router.post()）routes下新建user.js： app.js中注册路由（app.use()）app.js中引入并使用博客路由: postman测试注意是json格式的数据： ctx.request.body ctx.request.body中的内容为： ctx.request中的内容为： 可以看到，我们通过ctx.body返回的数据，框架已经将格式定为json，就不需要我们手动使用stringify()设置了。 中间件机制 洋葱圈模型：中间件之间通过next函数联系,当一个中间件调用 next() 后，会将控制权交给下一个中间件, 直到下一个中间件不再执行 next() 后, 将会沿路折返,将控制权依次交换给前一个中间件。 app.use()注册中间件 注册中间件 语法：app.use() 参数1：路由地址，可省略，省略则所有路由都匹配 参数2：中间件，中间件必须返回async函数 async函数的参数1：ctx ctx包括了req和res 可通过ctx.request.body获取到req中的数据 可通过ctx.query获取get请求时？后面是数据（框架会自动将其转换为JSON对象，使用=、&amp;分隔） async函数的参数2：next async函数返回的是Promise对象 参数3：（可选）中间件，app.use()中可有多个中间件，顺序执行 使用方法：中间的中间件在外部定义 命名async函数，然后在app.use()中调用该函数，最后的中间件使用匿名函数直接书写。 一般最后一个中间件是主函数，前面的中间件做验证，比如登录验证，如果前面的中间件就发现密码不对则当即停止，不需要继续往下执行 中间件 中间件：app.use()的参数2就是中间件 中间件必须返回async函数 async函数的参数1：ctx ctx包括了req和res 可通过ctx.request.body获取到req中的数据 可通过ctx.query获取get请求时？后面是数据（框架会自动将其转换为JSON对象，使用=、&amp;分隔） async函数的参数2：next async函数返回的是Promise对象 async中可使用await关键词（await Promise对象/await async函数）执行异步函数 async函数返回的是Promise对象 next()执行下一个中间件 next()：即下一个使用app.use()注册是中间件 所有一块一块的函数之间就是通过next()联系的，如果没有next()，则一段代码执行完后就停止，不会继续往下跑了 注意：如果是get请求的，则只能往下找同样是处理get请求的中间件，post的则直接跳过。post同理。 await next()中next()返回下一个中间件，下一个中间件也是返回async函数，async函数返回的是Promise对象。使用它则会等下一个中间件执行完毕再继续往下执行（使用await Promise对象使用同步写法来写异步） 4.例子： - 例子1： - 例子2： - 可以通过路由去执行中间件：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"ES6 async函数与await关键词","slug":"ES6 async函数与await关键词","date":"2020-03-05T07:50:33.000Z","updated":"2020-06-27T11:58:17.114Z","comments":true,"path":"2020/03/05/ES6 async函数与await关键词/","link":"","permalink":"http://yoursite.com/2020/03/05/ES6 async函数与await关键词/","excerpt":"async函数与await关键词 async函数与await关键词其实都是Promise的语法糖（只是换了写法，背后还是Promise的运作原理）","text":"async函数与await关键词 async函数与await关键词其实都是Promise的语法糖（只是换了写法，背后还是Promise的运作原理） 知识要点 await后面可以追加promise 对象，获取resolve()传递的值 await必须包裹在async 函数里面使用 执行 async 函数返回的也是一个promise 对象 可使用 try-catch 截获promise 中reject 的值 async函数与普通函数的区别 之前我们是在普通函数中使用new Promise创建Promise对象来返回，使用async函数不需手动返回Promise对象，async会自动将函数的返回值变成状态为resolved的Promise实例 如果使用async function(){...}，则return之后引擎会去判断返回的是否为Promise实例，如果不是则引擎会进行处理，使之成为状态为resolved的Promise实例，返回的数据可通过then()获取： await关键词 await Promise实例是一个表达式 表达式就是有结果的！ await Promise实例得到的值 也就是Promise实例在resolve状态下所返回的值（即then()的参数1所接受到的参数/resolve()所传递的参数） 当函数执行的时候，一旦遇到await就会先执行await的相关异步操作，等到异步操作完成，再接着执行函数体内后面的语句（包括同步任务也先等着await执行）。 在async函数中想要使用Promise实例，且希望表现出单线程（从上到下）执行，则可使用await关键词来返回Promise实例的值 例子： 未使用await关键词： 使用await关键词： await后必须是Promise实例 await后必须是Promise实例，如果不是也不会报错，会自动处理为Promise对象 例子： await只能在async内使用 await不能单独使用，他只能在async内使用 使用 try-catch 截获promise 中reject 的值 在async函数中，使用await我们可以获取到Promise对象成功时通过resolve()传递的数据，错误信息则可通过try-catch包裹await表达式来捕捉reject()中传递的值 例子可参考笔记“koa2重构博客项目”中：","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"nodejs/html转译 与 html反转译","slug":"nodejs html转译 与 html反转译","date":"2020-03-04T04:12:44.000Z","updated":"2020-04-02T04:29:54.615Z","comments":true,"path":"2020/03/04/nodejs html转译 与 html反转译/","link":"","permalink":"http://yoursite.com/2020/03/04/nodejs html转译 与 html反转译/","excerpt":"nodejs转译 在nodejs中，为保证项目安全，可使用xss库（函数）转译js特殊字符（具体案例可看笔记“博客项目安全-xss攻击”）","text":"nodejs转译 在nodejs中，为保证项目安全，可使用xss库（函数）转译js特殊字符（具体案例可看笔记“博客项目安全-xss攻击”） 转译：也就是将尖括号等都转换为特殊字符： 比如：&lt;script&gt;alert(1)&lt;/script&gt;;转译后就是&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt; 这样可以预防xss攻击，但前端从数据库汇总读出&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;后显示在页面上，为使尖括号等字符正常显示，需要在前端进行 js反转译 html反转译 html反转译也就是让特殊字符显示回正常的字符 由于浏览器 innerHTML属性 会自动转译，所以先设置 innerHTML ,再显示即可： 123let a=document.createElement('a')a.innerHTML='&amp;nbsp; &amp;gt; &amp;lt; &amp;amp;';console.log(a.textContent);// &gt; &lt; &amp; jquery中则使用html()代替innerHTML属性： 12DOM元素.innerHTML = \"需要被反转译的字符串\"; //这个是原生js的写法DOM元素.html(\"需要被反转译的字符串\"); //这个是jquery写法 html 标签转译反转译可参考文章：html 标签转译反转译","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"博客项目安全","slug":"博客项目安全","date":"2020-03-03T13:37:31.000Z","updated":"2020-06-18T04:06:07.333Z","comments":true,"path":"2020/03/03/博客项目安全/","link":"","permalink":"http://yoursite.com/2020/03/03/博客项目安全/","excerpt":"安全 server端攻击方式非常多，预防手段也非常多","text":"安全 server端攻击方式非常多，预防手段也非常多 这里只讲解常见的、能通过web server（nodejs）层面预防的 sql注入：窃取数据库内容 XSS攻击：窃取前端的cookie内容 密码加密：保障用户信息安全（重要！） 有些攻击需要硬件和服务来支持（需要OP(服务器的运维人员)支持），如DDOS sql注入（mysql库的escape函数） 最原始、最简单的攻击，从有了web2.0就有了sql 注入攻击（十几年前） 攻击方式：（在应该输入正常内容的位置输入）输入一个sql片段，最终拼接成一段攻击代码 预防措施：使用mysql的escape函数处理输入内容即可 注意：所有设计sql语句拼接的地方都需要使用escape函数，放置sql注入 使用escape函数时，拼接变量不使用引号，escape函数会对引号进行转译 例子 运行redis、nginx、前端、后端项目，进入登录页： 在controller-user.js中可看到登录的逻辑： 到数据库中看查询语句： 测试： 此时，相当于整个数据库都暴露了，比如：可以通过这种方式删除整个users表内所有行： DELETE FROM table_name相当于DELETE * FROM table_name，可在不删除表的情况下删除所有的行。（表的结构、属性和索引都是完整的） 解决方法 在db-mysql.js中，已经引入mysql，所以直接输出mysql的escape函数给controller-user.js使用即可： 在controller-user.js中，引入escape函数，将所有需要拼接进sql语句中的变量都使用escape包裹，拼接sql语句时变量不使用引号： 测试： 使用escape后生成的sql语句： 放到sqlyog中进行对比：可以发现我们输入的引号被escape使用了转译符 xss攻击（xss库（函数）） 前端同学最熟悉的攻击方式，但server端更应该掌握 攻击方式：在页面展示内容中掺杂js代码，以获取网页信息 预防措施：转换生成js的特殊字符: 使用xss工具将&lt;/&gt;都进行转换，使之无法形成js代码块 例子 进入新建博客页（http://localhost:8080/new.html），在标题中输入js代码试图获取cookie信息: 结果就是非常惨烈，回到管理中心渲染页面时读取该js代码，cookie被带出 安装xss工具npm i xss --save --registry=https://registry.npm.taobao.org 解决方法（转换尖括号）将&lt;/&gt;都进行转换，使之无法形成js代码块 在controller-blog.js中， 引入xss工具： xss实际上是一个函数，使用xss函数将title包裹，则特殊字符会被转译： 测试： 此时管理中心中题目可正常显示，因为数据库中存储的标题是转译后的： 根据打印出来的信息对比：&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;可以看到xss函数将尖括号都进行了转译，但是详情页需要前端在detail.html中进行反转译再转译回尖括号： 由于浏览器 innerHTML 会自动反转译，所以如果是原生html，就可以使用innerHTML属性，jquery中则使用html()： 密码加密（crypto库 md5加密） 万一数据库被用户攻破，最不应该泄漏的就是用户信息 攻击方式：获取用户名和密码，再去尝试登录其他系统 预防措施：将密码加密，即便拿到密码也不知道明文（使用crypto库） 比如：密码是123，但数据库存储的不是123，这样即使攻破数据库拿到的也不是123 例子 utils文件夹下新建cryp.js： 引入crypto库： 使用crypto库，进行md5加密： 输出genPassword以供使用 将数据库中存储的密码改为加密后的密码 原本数据库中密码长度有所限制，先测试加密后密码的长度： 然后修改数据库中密码长度为32，更新 张三的密码：注意：这里没有修改李四的密码 在controller-user.js中引入并使用genPassword加密密码： 测试：此时zhangsan可输入123登录，lisi输入123是登录失败的，因为lisi在数据库中存储的密码不是加密后的，但登录时查询语句查询的是加密后的密码，所以对不上 需要在注册用户时就保存加密后的密码到数据库中","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"博客项目日志","slug":"博客项目日志","date":"2020-03-02T13:37:56.000Z","updated":"2020-04-01T13:38:49.838Z","comments":true,"path":"2020/03/02/博客项目日志/","link":"","permalink":"http://yoursite.com/2020/03/02/博客项目日志/","excerpt":"日志 系统没有日志，就等于人没有眼睛————抓瞎","text":"日志 系统没有日志，就等于人没有眼睛————抓瞎 第一，访问日志access log（server端最重要的日志） 每一次请求都会保存一个访问日志,以前端项目为例: 第二，自定义日志（包括自定义事件、错误记录等） 自定义日志并不是每次请求都保存，只有我们设置好的情况下才保存 上线之前，日志放在控制台方便查看，但上线之后日志就要放到文件中来方便查看了。 日志为何不放在redis中：日志文件非常大，且日志对性能要求不是特别高（写文件是个异步操作），放在redis（内存数据库）中不合适 日志为何不放在mysql中：mysql中存储的数据应当是表结构的，日志只是一行一行的，不涉及复杂的表操作，放在mysql（硬盘数据库）中没必要 日志为何存储在文件中：日志可能会考虑到各个服务器上去计算/运行，所有服务器都能识别文件，这样就不需要另外的环境/基础，比较方便。如果是mysql，不仅要考虑环境，还要考虑版本的统一 虽然存取速度上redis（内存）&gt;mysql（硬盘）&gt;文件（硬盘），但成本上 redis&gt;mysql&gt;文件 nodejs文件操作（nodejs stream） 所有的文件操作都是异步的！ 读取文件内容 fs.readFile() 新建file-test文件夹，不需要使用npm插件，所以不需要初始化，直接使用原生nodejs即可 file-test下新建data.txt，在里面随便写点东西作为测试文件 file-test下新建test1.js 引入fs库（文件操作） 引入path库（路径操作）：因为windows和linux、mac系统的文件路径不同，需要统一一下。 获取文件路径：const fileName = path.resolve(__dirname, &quot;data.txt&quot;); path.resolve()：拼接目录 __dirname：当前js文件的目录（nodejs自带的变量） 读取文件内容readFile()： readFile()：异步 读取文件 参数1：需要读取的文件路径 参数2：回调函数，该函数接受的参数1为读取失败后的错误信息，参数2为读取成功后获取的数据（获取的数据原生是二进制类型的，需要使用toString()转换为字符串类型） 运行： 写入文件内容 fs.writeFile() 在file-test下的test1.js中： 写入文件writeFile()： writeFile()写入文件（异步） 参数1：需要读取的文件路径 参数2：写入内容 参数3：写入方式 flag：a追加写入（append）/w覆盖写入（write） 参数4：回调函数，由于是写入，不需要返回数据，所以该函数只接受一个参数，即读取失败后的错误信息 运行：执行什么也没输出就说明写入成功，可以到txt文件中看 注意：content是js变量，如果一直写入内容则一直需要打开文件并修改js变量，频繁操作js变量会非常耗费进程 判断文件是否存在 exists() 在file-test下的test1.js中： exists()判断文件是否存在（异步） 参数1：需要读取的文件路径 参数2：回调函数，该函数只接受一个参数（boolean），为true时说明存在。 IO操作的性能瓶颈 IO包括”网络IO”和“文件IO” 相比于CPU计算和内存读写，IO的突出特点就是：慢！ 如何在有限的硬件资源下提高IO的操作效率？使用stream stream(stream对象.pipe()) 使用上面的方法去读取文件会一次读取所有内容，写入文件则需要操作js变量并操作文件，非常损耗性能 提高IO操作的性能的方法就是使用stream，一边读取一边显示 比如之前用到过的： req和res都有stream的特性,所以他们可以直接调用pipe()来实现stream。(req.pipe()/res.pipe()) 只需了解 标准的输入输出 即可，他其实是linux中的概念，node中可以通过API（pipe()）来实现。 stream演示 新建stream-test文件夹，一样不需要使用npm插件，所以不需要初始化，直接使用原生nodejs即可 stream-test文件夹下新建test1.js： 只需了解 标准的输入输出 即可，他其实是linux中的概念，node中可以通过API（pipe()）来实现。 stream操作文件 createReadStream()：创建读取文件的stream对象（左边的水桶） 参数：文件的路径 createWriteStream()：创建写入文件的stream对象（右边的水桶） 参数：文件的路径 pipe()： 两个stream对象/req与res 之间使用pipe()进行数据传递 a.pipe(b)表示a通过stream的方式传数据给b 例子： 使用stream读取res内容： 使用stream复制文件，将文件1的内容拷贝到文件2中： path.join()和path.resolve()的异同 两者都能拼接路径，也都能规范化的去解析以后再进行拼接 path.resolve()和path.join()的参数都是字符串 但join()只是简单的将路径片段进行拼接并规范化生成一个路径，而resolve()则一定会生成一个绝对路径，相当于执行cd操作。 __dirname当前js文件的目录 __dirname:即当前js文件的目录（nodejs自带的变量） path.join()拼接路径 path.join() 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。长度为零的 path 片段会被忽略。 如果连接后的路径字符串是一个长度为零的字符串，则返回 ‘.’，表示当前工作目录。 ————— nodejs官方文档 “平台特定的分隔符”： windows下文件路径分隔符使用的是\\ Linux下文件路径分隔符使用的是/ “path片段”：该方法接收的是多个路径的部分或全部，然后简单将其拼接。 “规范化”：如果你给出的路径片段中任一路径片段不是一个字符串，则抛出TypeError。 例子： 12path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');// 返回: '/foo/bar/baz/asdf' 注意：如果路径中出现”..”即代表上一级目录。 path.resolve()拼接路径 path.resolve() 方法会把一个路径或路径片段的序列解析为一个绝对路径。给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve(‘/foo’, ‘/bar’, ‘baz’) 会返回 /bar/baz。如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录会被用上。生成的路径是规范化后的，且末尾的斜杠会被删除，除非路径被解析为根目录。长度为零的 path 片段会被忽略。如果没有传入 path 片段，则 path.resolve() 会返回当前工作目录的绝对路径。 ———— nodejs官方文档 注意：如果没有传入path片段，则resolve会返回当前工作目录的绝对路径: 12path.resolve();// 'E:\\nodejsWorkspaces\\blog-1\\src\\utils\\log.js' 如果处理完全部给定的 path 片段后还未生成一个绝对路径，则当前工作目录（绝对路径）会被用上: 12path.resolve('bar', 'baz', 'foo');// 'E:\\nodejsWorkspaces\\blog-1\\src\\utils\\log.js\\bar\\baz\\foo' 拼接的时候需要小心使用斜杠/：生成的路径是规范化后的，且末尾的斜杠/会被删除，除非路径被解析为根目录: 123456path.resolve('/foo', 'bar/', 'baz/');// 'E:\\foo\\bar\\baz' // 注意：foo前面的 '/' 代表根目录，即'E:'; 并且baz末尾的斜线会删除path.resolve('/');// 'E:\\' 如果路径为根路径，末尾的斜线不会删除 给定的路径的序列是 “从右往左” 被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径： 123path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif');// 如果当前工作目录为 /home/myself/node，// 则返回 '/home/myself/node/wwwroot/static_files/gif/image.gif' 日志功能开发和使用 进入blog-1文件夹，运行 blog-1下新建logs文件夹： 新建access.log文件：存储访问日志 新建error.log文件：存储错误日志 新建event.log文件：存储自定义事件 src下新建utils文件-新建log.js文件，编写函数用于书写访问日志： 自定义的函数和fs自带的函数重名也无所谓 app.js中引入并使用函数： 测试：进入3次页面，查看access.log可看到3条数据： stream对象.write()写入文件内容 可以注意到这里并没使用pipe()进行数据传递，直接使用stream对象.write(&quot;内容&quot;)就可将内容写入stream对象(pipe适合于两个stream对象之间的数据传递) 拆分日志文件（了解即可） 日志内容会慢慢积累，放在一个文件中不好处理 可按时间划分日志文件，如2019-02-10.access.log 实现方式：linux的crontab命令，即定时任务(了解即可，不需要掌握，windows上需要虚拟机才能练习，这个一般是专门的运维做的事情) 分析日志内容（readline库） 如：针对access.log日志，分析chrome的占比 日志是按行存储的，一行就是一条日志 使用nodejs的readline库（基于stream，效率高） stream是一点一点读取的，一点不一定是一行，readline是一行一行读取的，效率更高。 utils下新建readline.js: 引入readline库 创建readStream对象 基于readStream对象创建readline对象 使用readline对象的on()逐行读取数据 on(&quot;data&quot;,func)是一块数据来了会触发func，on(&quot;line&quot;,func)是一行数据来了会触发func。 on(&quot;close&quot;,func)类似stream中的on(&quot;end&quot;,func)，当数据读取完成后执行func。 使用别的浏览器运行网页，测试：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"JS Web API AJAX","slug":"JS Web API AJAX","date":"2020-03-01T04:56:45.000Z","updated":"2020-11-19T12:15:33.224Z","comments":true,"path":"2020/03/01/JS Web API AJAX/","link":"","permalink":"http://yoursite.com/2020/03/01/JS Web API AJAX/","excerpt":"XMLHttpRequest（ajax核心API） XMLHttpRequest():用于创建 XMLHttpRequest 对象，XMLHttpRequest 对象用于和服务器交换数据","text":"XMLHttpRequest（ajax核心API） XMLHttpRequest():用于创建 XMLHttpRequest 对象，XMLHttpRequest 对象用于和服务器交换数据 onreadystatechange事件 onreadystatechange事件：和image对象的onload/onerror类似，都是对象状态发生改变时触发。 open() open():初始化一个请求，规定请求的类型、URL 以及是否异步处理请求。 参数1：请求的类型，”GET”或者”POST” 参数2：url，文件在服务器上的位置 参数3默认为true，表示服务器请求是异步进行的，也就是脚本执行send（）方法后不等待服务器的执行结果，而是继续执行脚本代码；当参数3为false时，服务器请求是同步进行的，也就是脚本执行send（）方法后等待服务器的执行结果的返回，若在等待过程中超时，则不再等待，继续执行后面的脚本代码！ send() send():将请求发送到服务器。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。 参数string：仅用于 POST 请求 readyState属性 XMLHttpRequest对象的readyState属性存有 XMLHttpRequest对象 的状态 属性值 含义 0 （请求未初始化）还没有调用send（）方法 1 （载入，服务器连接已建立）已调用send（）方法，正在发送请求 2 （载入完成，请求已接收）send（）方法执行完成，已经接收到全部响应内容 3 （交互，请求处理中）正在解析响应内容 4 （完成，请求已完成，且响应已就绪）响应内容解析完成，可以在客户端调用 status属性 XMLHttpRequest对象的status属性，其实就是http响应的状态码 必须在readyState属性值为4时才能去判断status属性，否则拿不到status属性值 属性值 含义 2xx 表示成功处理请求，如200 3xx 需要重定向，浏览器直接跳转，如301 302 304 4xx 客户端请求错误，如404 403 5xx 服务器端错误 responseText 与 responseXML 属性 使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性 可获得来自服务器的响应数据。 responseText 获得字符串形式的响应数据(如果请求未成功或尚未发送，则返回 null) responseXML 获得 XML 形式的响应数据 AJAX例子 创建XMLHttpRequest对象：使用XMLHttpRequest()来new一个XMLHttpRequest对象 判断对象状态：通过XMLHttpRequest对象的onreadystatechange事件（readyState还有status属性）判断对象状态（请求是否初始化、服务器连接是否建立、请求是否接收、请求是否处理中、请求是否已完成且响应已就绪）。 获取响应数据：判断到“请求已完成且响应已就绪”时可使用XMLHttpRequest 对象的 responseText 或 responseXML 属性来获得响应数据。 向服务器发送请求：使用XMLHttpRequest 对象的 open() 和 send() 方法向服务器发送请求。可参考这篇博客 get请求 一般将open()和send()都放到onreadystatechange事件之后来写。 post请求 浏览器的同源策略 同源策略：ajax请求时，浏览器要求当前网页和server必须同源（为了安全） 注意：同源是浏览器规定的，在服务端是可以发起跨域攻击的，比如爬虫，因为server端并无同源策略 同源：协议、域名、端口，三者必须一致 比如：前端http://a.com：8080/；server：https://b.com/api/xxx（默认443端口）那么这前后端是三者都不一致 同源策略限制了跨域时的以下行为： Cookie、LocalStorage 和 IndexDB 跨域无法读取，只有同源才能获取他们 DOM 和 JS 对象跨域无法获取 Ajax请求跨域时无效，可发送，但浏览器会拒绝接受响应 加载图片 CSS js可无视同源策略123&lt;img src=跨域的图片地址/&gt;&lt;link href=跨域的css地址/&gt;&lt;script src=跨域的js地址&gt; &lt;/script&gt; 比如我们经常引用的js/CSS的库，&lt;link/&gt;、&lt;script&gt;直接使用cdn地址就是跨域的。 &lt;script&gt;可实现JSONP 而图片比较特殊，如果该图片做了防盗链，则无法显示（比如百度） &lt;img/&gt;可用于使用第三方统计服务来统计打点（比如统计访问次数），也就是把需要的参数放入img，在地址处使用第三方统计服务，这样就可以避免跨域问题 跨域 跨域，是指浏览器不能执行其他网站的脚本，即，跨域名，跨端口，跨协议。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 所有的跨域，都必须经过server端允许和配合（包括前端jsonp） 未经server端允许就实现跨域，说明浏览器有漏洞，危险信号 可通过jsonp、nginx反向代理、CORS实现跨域 关于为什么会有跨域问题可参考这里，跨域问题 是浏览器对于ajax请求的一种安全限制：一个页面发起的ajax请求，只能是于当前页同域名的路径，这能有效的阻止跨站攻击。 实现跨域的常见方式注意：如果是协议和端口造成的跨域问题，“前端”无法解决。 jsonp 访问https://imooc.com/，服务端一定返回一个html文件吗？并不是，服务器可以任意动态拼接数据返回，只要符合html格式要求同理，&lt;script src=&quot;https://imooc.com/getData.js&quot;&gt;,也不一定返回一个js文件，服务器可以任意动态拼接数据返回，只要符合js格式要求即可【详细见例子】 注意：jsonp只能发起GET请求且需要服务的支持 jsonp原理： &lt;script&gt;可绕过跨域限制，所以script中src地址可以是跨域地址服务器可以任意动态拼接数据返回。所以，&lt;script&gt;就可以获得跨域的数据，只要服务端愿意返回。 例子（原理）： 在这用一简单例子讲解jsonp原理，真实使用可用jquery： 先定义一个全局函数callback用于打印跨域返回的内容，此函数已定义，可随时调用 然后在引入的script中设置src为跨域地址，该地址将返回一个执行callback函数 那么返回的代码会立即执行callback函数，并将相应内容打印 【扩展例子】： 跨域动态传递数据： 函数名可两域不同：我们可将callback定义为abc后传给跨域文件 动态插入script标签：现在是静态插入的，也可以和其他标签一样动态插入 jquery实现jsonp和发ajax非常类似 nginx反向代理 可参考博客“博客项目登录（前端联调）”中的“nginx的反向代理配置” 思路：利用nginx反向代理把跨域变为不跨域 优点：支持各种请求方式 缺点：需要在nginx进行额外配置，语义不清晰 例子：前后端分离的项目，当有前端部署在自己的服务器上，后端也部署在自己的服务器上的情况就会造成前端无法访问后端接口的情况，这时就需要Nginx做一个代理的配置。当a域名访问b域名下某一个接口的时候，先让a域名访问a域名下的某一个url在通过Nginx转发到b域名下的某个接口，这样就让浏览器感觉好像都是在请求同一个服务器下的资源。 CORS（纯服务端） 可参考阮一峰的跨域资源共享 CORS 详解 CORS是一个W3C标准，全称是”跨域资源共享“（Cross-origin resource sharing）。它规范化的跨域请求解决方案，安全可靠。 它允许浏览器向跨源服务器发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 浏览器端：目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。 服务端：CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。 优势：在服务端进行控制是否允许跨域，可自定义规则，支持各种请求方式 缺点：会产生额外的请求 cors是纯服务端的操作，通过服务端设置http header可实现允许跨域。 如果使用cors允许跨域，则跨域请求和发送ajax请求时完全一样的，不需要再考虑跨域问题 CORS是一种新标准，支持同源通信，也支持跨域通信。fetch是实现CORS通信的 虽然原理比较复杂，但是使用可以比较简单。浏览器端都有浏览器自动完成，我们无需操心。服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。所以可直接使用SpringMVC写好的CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。 ajax相关面试题手写简易ajax 模拟404情况，换成不存在的地址： 跨域的实现方式 jsonp原理 cors（纯服务端） nginx反向代理 实际项目中 ajax 的常用插件 jquery：老旧，未使用Promise，容易回调地狱 fetch：比XMLHttpRequest更加简洁，但兼容性不好 注意：从 fetch() 返回的 Promise 不会被标记为 reject， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），仅当网络故障时或请求被阻止时，才会标记为 reject。 不用了解太细，知道大概和去哪查就行 axios库：框架中使用较多，支持浏览器端、nodejs。在浏览器中axios使用的api就是XMLHttpRequest，是对他的一个封装。 安装/引入axios库后，直接使用axios.get(请求地址)即可发送get请求（完整例子）","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS Web API 事件","slug":"JS Web API 事件","date":"2020-02-29T04:56:45.000Z","updated":"2020-03-31T13:31:31.295Z","comments":true,"path":"2020/02/29/JS Web API 事件/","link":"","permalink":"http://yoursite.com/2020/02/29/JS Web API 事件/","excerpt":"事件流 在浏览器发展的过程中，开发团队遇到了一个问题。那就是页面中的哪一部分拥有特定的事件？","text":"事件流 在浏览器发展的过程中，开发团队遇到了一个问题。那就是页面中的哪一部分拥有特定的事件？ 可以想象画在一张纸上的一组同心圆，如果你把手指放在圆心上，那么你的手指指向的其实不是一个圆，而是纸上所有的圆。放到实际页面中就是，你点击一个按钮，事实上你还同时点击了按钮所有的父元素。 开发团队的问题就在于，当点击按钮时，是按钮最外层的父元素先收到事件并执行，还是具体元素先收到事件并执行？所以这儿引入了事件流的概念。 事件流所描述的就是从页面中接受事件的顺序。 因为有两种观点，所以事件流也分为两种，分别是事件冒泡和事件捕获。现行的主流是事件冒泡。 DOM事件流的三个阶段 DOM结构是一个树型结构，当一个DOM元素触发一个事件时，该事件会在元素结点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为 DOM 事件流（DOM event flow ）。 传播（Propagation）按顺序分三个阶段： 捕获阶段（capture phrase，从根节点window到目标节点，即最近的、最精确的元素节点） 目标阶段（target phrase，到达目标事件位置（事发地），触发事件） 冒泡阶段（bubbling phrase，从目标节点到根节点 ） 当一个元素同时绑定冒泡和捕获事件，如果没有子节点，那么就会按照JavaScript顺序执行（即先绑定的btn冒泡事件，后绑定的btn捕获事件，则先冒泡后捕获，反之亦然），当一个元素同时绑定冒泡和捕获事件，如果有子节点那么会先捕获。 事件绑定（addEventListener()） 注意：事件绑定函数可接受的参数1为事件对象，事件对象.target即触发事件的DOM元素 addEventListener的参数3默认为false，即表示使用事件冒泡模式，设置为true则代表使用事件捕获模式 事件对象.preventDefault()取消默认动作 事件对象.preventDefault()可取消事件的默认动作 例如：如果addEventListener()的参数1是 “submit”，通过调用preventDefault()可以阻止提交表单。 注意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。 例子：下面“事件代理”的例子中有所体现。 事件冒泡 当事件发生后，这个事件就要开始冒泡(从里到外)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。 例如我们点击一个按钮时，就会产生一个click事件，但这个按钮本身可能没有绑定js函数去处理这个事件，所以这个点击事件必须从这个按钮传播出去，从而到达能够处理这个事件的代码中（例如我们给按钮的绑定一个onclick事件函数），或者按钮的父级绑定有事件函数，当该点击事件发生在按钮上，按钮本身并无处理事件函数，则冒泡到父级去处理。 补充：捕获事件则是从外往里（只有特殊需要再使用事件捕获即可） 例子1： 点击事件的传播顺序：p、div2、body、document、window 例子2：给“取消”的文字上绑定click事件，由于取消按钮太多，所以直接绑定在body上，给“激活”的文字上也绑定click事件： 如果不使用事件对象.stopPropagation()，则 如果使用事件对象.stopPropagation()，则 事件对象.stopPropagation()阻止冒泡 事件对象.stopPropagation()可让事件传播到目标阶段后停止传播 即：终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。 注意：使用该方法的节点事件还是会被触发，只是不冒泡去让别的元素触发事件了 事件代理 注意：不要滥用（一般用在瀑布流或者元素数量太多/结构复杂的情况下） 事件代理是基于事件冒泡机制的。 事件代理，即需要绑定事件的元素太多时将事件绑定在他们的父元素上 例子：希望给所有a标签绑定点击事件（假设点击 加载更多 时会继续加载a标签，a标签的数量不定） 代码： 结果： 好处 代码简洁 减少浏览器内存占用 相关题目通用的事件监听函数 【简单版】可监听 普通绑定 的通用事件监听函数： 【正式版】可以同时监听 普通绑定 和 代理绑定 的通用事件监听函数： Element.matches() 如果元素匹配指定的选择器字符串，则Element.matches()返回true，否则返回false。 语法：let result = element.matches(selectorString); result 的值为 true 或 false. selectorString 是个css选择器字符串. MDN文档 描述事件冒泡的流程 基于DOM树形结构 事件会顺着触发元素往上冒泡 应用场景：事件代理 无限下拉的图片列表，如何监听每个图片的点击？ 事件代理 用e.target获取触发元素 用matches来判断是否是触发元素","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"博客项目登录（前端联调）","slug":"博客项目登录（前端联调）","date":"2020-02-28T08:40:16.000Z","updated":"2020-04-10T02:40:27.185Z","comments":true,"path":"2020/02/28/博客项目登录（前端联调）/","link":"","permalink":"http://yoursite.com/2020/02/28/博客项目登录（前端联调）/","excerpt":"html页面联调 登录功能依赖cookie，必须用浏览器来联调 cookie跨域不共享的，前端和server端必须同域 需要用到nignx做代理，让前后端同域","text":"html页面联调 登录功能依赖cookie，必须用浏览器来联调 cookie跨域不共享的，前端和server端必须同域 需要用到nignx做代理，让前后端同域 跑起前端页面 http-server是一个轻量级的基于nodejs的http服务器，好处：可以使任意一个目录成为服务器的目录，完全抛开后台的沉重工程，直接运行想要的js代码。 前端项目中，全局安装http-server:npm i -g http-server跑起静态页面 设置前端端口为8001：http-server -p 8001(前后端端口不能一样)： 访问前端首页： 此时我们需要nginx来使前后端使用同一个端口。 nginx 高性能的web服务器，开源免费 一般用于做静态服务、负载均衡（本课用不到） 还有反向代理（本课用到），即客户端不可见的代理： nginx下载与配置 官网下载 配置：（管理员权限打开记事本）Nginx所有配置文件都在Nginx根目录conf子目录中（可先不配置） 运行： nginx命令 含义 nginx命令 测试配置文件格式是否正确 nginx -t 启动nginx start nginx（注意顺序！） 重启nginx nginx -s reload 停止nginx nginx -s stop 查看版本 nginx -v 查看帮助信息 nginx -h 重启日志文件 nginx -s reopen nginx反向代理的配置（管理员权限打开记事本）修改Nginx核心配置文件：conf\\nginx.conf 修改worker_processes：我的电脑是4核的，所以设置为4 修改server: #就是注释，注释location： 进行反向代理： 如果location是静态页面就转发到8001端口，location是api开始的就转发到8000端口 测试： 启动nginx：start nginx（注意顺序！没有报错则启动成功） 之前后端8000端口，前端8001端口无法获取8000端口的数据，现在测试8080端口： 前端联调个人中心只显示自己的数据前端http-test中admin.html中发送ajax请求的地址中再加上一个isadmin=1参数，使用登录者的用户名： 后端 blog-1中的router-blog.js中，修改获取博客列表的路由： 之前没有isadmin时，博客列表的author是由req.query.author获取到的，现在有了isadmin后，则强制从req.session.username获取author，那么访问的就是本人的博客列表了。 联调 启动nginx，打开8080端口，进入首页： 点击进入详情页： 尝试在尚未登录情况下进入admin管理中心： 可以看到并未显示管理中心，此时前端可以做个提示框或者跳转信息之类的。此时创建博客也会显示数据错误。 进行登录： 登录后自动跳转管理中心： 点击创建博客，创建完成后自动跳转管理中心： 可点击进入查看博客内容： 可编辑博客： 可搜索博客： 总结cookie是什么？session 是什么？如何实现登录？ cookie是跨域不共享的存储在浏览器的一段字符串（最大5kb），每次发送http请求时都会将请求域的cookie一起发送给server端。 session即server端存储用户信息，也就是cookie中存储userid，server端对应username/个人信息。 实现登录： 用戶第一次发送登录的http请求时，请求头中并不存在cookie（即userid），此时server端生成一个cookie（即userid）返回给用户，这个userid对应用户的用户名和密码。下次访问时用户的请求头中就会携带这个userid，那么后端就会去解析cookie读取userid放到sessionId上，看sessionId对应的属性值（对象）中是否有username这个属性，有则判断为已登录。也就不需要重复登录了。 session是一个对象，它的属性名即cookie的userid，属性值是对象，这个对象中包括username、realname session是存储在redis中的，这样就不会刷新页面就要求重新登录。 redis在这里扮演什么角色？有什么核心的价值？ redis在这用于存储session。 这样一来session就不会保存在js变量中，不用担心访问量过大，内存暴增，也不会再正式线上运行时遇到多进程之间内存无法共享的问题。 nginx的反向代理配置，联调过程中的作用 使用nginx实现反向代理就可以根据url派发不同的接口，让前端页面可发生ajax请求去获取后端的数据。 假设前端页面是3000端口，后端页面是8000端口。那么用户打开页面时打开的就是3000端口的页面，前端页面中使用ajax请求获取数据时就会去获取3000端口下的对应路径的数据。而后端页面是8000端口，所以数据其实保存在8000端口下的对应路径中。这就无法获取数据。此时使用nginx进行反向代理，遇到/api/开头的url时就分配到8000端口，遇到/开头的url时就分配到3000端口，这样就没问题了。 补充：使用react书写前端页面时，将前端页面经过build编译后生成的html页面放入了后端项目，那么访问的就是后端项目的接口下的页面，那么前端页面发送ajax请求时也就不需要nginx进行反向代理了，因为此时前后端是用同一个接口运行起来的。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"npm常用命令","slug":"npm常用命令","date":"2020-02-27T04:05:54.000Z","updated":"2020-03-31T04:19:35.509Z","comments":true,"path":"2020/02/27/npm常用命令/","link":"","permalink":"http://yoursite.com/2020/02/27/npm常用命令/","excerpt":"npm文档","text":"npm文档 初始化nodejs项目 npm init -y 初始化 npm -y是为了不让他提很多问题让我们回复。 不使用-y的例子： 初始化后会在当前目录生成一个package.json package.json主要是用来记录这个项目的详细信息，它会将我们在项目开发中所要用到的包，以及项目的详细信息等记录在这个项目中。方便在以后的版本迭代和项目移植的时候会更加的方便。 好处 使用package.json可防止在后期的项目维护中误删除了一个包导致的项目不能够正常运行。 使用npm init初始化的项目在进行项目传递的时候不需要将项目依赖包一起发送给对方，对方在接受到你的项目之后再执行npm install(或者npm i)就可以将项目依赖全部下载到项目里。 当node_modeles被误删时，可以根据package.json里面的信息，重新安装下载：npm i。 误删某个包时也可以到package.json中看 安装包/依赖 npm i 包名称安装对应包名称的插件(i是install的缩写) 全局安装:npm install -g 模块名称 本地安装： 安装在生产环境依赖（即package.json的dependencies）中:npm install 模块名称 --save 安装在开发环境依赖（即package.json的devDepencies）中：npm install 模块名称 --save -dev 链接依赖环境指令：比如react-native link 模块名称 安装步骤： 先去找npm里面有没有这个包 如果没有该名的包，发出警告！ 如果找到有的话，会下载下来并安装到node_modules目录下 安装完成后，对应的包/依赖的信息会写到package.json里面。 误删的解决方法 当node_modeles被删除时，要找回来，可以根据package.json里面的信息，重新安装下载：npm i npm i后面什么都不加，表示把所有库重新安装。 删除包/依赖 如需删除 node_modules 目录下面的包（package），请执行：npm uninstall 包名称 如需从 package.json 文件中删除依赖，需要在命令后添加参数--save:npm uninstall --save 包名称 注意：如果你将安装的包作为 “devDependency”（也就是通过--save-dev参数保存在开发环境依赖），那么--save 无法将其从 package.json 文件中删除。所以必须通过--save-dev 参数将其卸载。 若安装时使用的是 链接依赖环境，则需先删除依赖环境链接，再删除包：123//比如(1)react-native unlink react-native-aliyun-push(模块名称) (2)npm uninstall react-native-aliyun-push(模块名称) 删除指定的某个包以及再次安装123npm uninstall xxxx --save-dev //删除包及删除配置项npm install xxx@version //安装指定版本npm install //覆盖 更新包/依赖 npm update 包名称可更新版本或者回到旧版本 npm update jquery表示更新jquery 如果要更新成旧的版本,可以指定版本号：npm update jquery@3.0.0","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"博客项目登录（session、redis）","slug":"博客项目登录（session、redis）","date":"2020-02-26T10:30:38.000Z","updated":"2020-04-15T14:58:30.015Z","comments":true,"path":"2020/02/26/博客项目登录（session、redis）/","link":"","permalink":"http://yoursite.com/2020/02/26/博客项目登录（session、redis）/","excerpt":"session 介绍 上一篇笔记中使用cookie存储username是很危险的，会暴露，所有明文的个人信息都最好不要放到cookie中。","text":"session 介绍 上一篇笔记中使用cookie存储username是很危险的，会暴露，所有明文的个人信息都最好不要放到cookie中。 解决方法：cookie中存储userid，server端对应username/个人信息。其实这就是session。 server端放置信息不会被前端获取到。 且server端空间大，可存储更多信息。 session，即server端存储用户信息。 session 的使用app.js解析session 定义一个全局变量SESSION_DATA(在整个项目中都有效)： 接下来项目所有路由中用到的req.session都是保存在该全局变量中的。 SESSION_DATA对象中保存的属性名为userId，属性值为对应的session对象，session对象中存储username和realname。 每次进入项目都要从该变量中取出和userId对应的属性值作为req.session来使用。 在解析cookie后解析session： req.cookie.userid作为SESSION_DATA的属性名userId存储在全局变量中 没有userId时随机生成一个 没有SESSION_DATA[userId]属性值时就使用{}空对象作为属性值 有SESSION_DATA[userId]属性值时就将其赋值给req.session,则接下来session变化时SESSION_DATA[userId]也会发生变化（即使用req.session作为SESSION_DATA[userId]） 将router-user.js中获取cookie的过期时间的函数剪切过来： 处理user路由，设置cookie： 将userId作为cookie传给客户端，客户端下次发送请求时就会使用cookie.userid。 router-user.js处理路由 登录路由，设置session： 测试登录路由，获取session并返回已显示在页面上： 测试注意：永远都从app.js开始！ 清空cookie后进入测试登录路由： 进入app.js，解析session时，没有req.cookie.userid，所以把needSetCookie设置为true，并使用${Date.now()}_${Math.random()}随机生成了userId放入SESSION_DATA[userId]再放到了req.session里。 处理user路由时（router-user.js），分配到登录验证，没有req.cookie.username所以返回“尚未登录”给app.js,由于needSetCookie此时为true，所以将userId（即${Date.now()}_${Math.random()}）设置为 Set-Cookie中的userid用以返回。 浏览器拿到返回的Set-Cookie以后就会用来设置自己的cookie并用于下一次发送请求。 此时进入登录路由： 进入app.js，解析session时，直接执行req.session = SESSION_DATA[userId];。 然后处理路由（router-user.js），判断了用户名和密码正确后，将username, password设置到req.session上： 再次进入登录测试路由: req.session中有username，则返回req.session给到app.js显示在页面上，登录成功。 思路打印SESSION_DATA和req.session可看到： 第一次进入测试路由时，没有userId和SESSION_DATA[userId],故生成userId放入SESSION_DATA对象中作为属性并设置属性值为空对象，最后将 SESSION_DATA[userId]（即空对象）赋值给req.session。 此时req.session为{} 此时SESSION_DATA为{&quot;时间_随机数&quot;:{}} 第一次进入登录路由时，此时请求中已经有之前生成的userId,故将 SESSION_DATA[userId]（即空对象）赋值给req.session。（他们指向一个地址，修改session则SESSION_DATA[userId]也会改变）通过路由（router-user.js）将username, realname 获取并设置到req.session.username、req.session.realname上。 此时req.session为{username:输入的username，realname：输入的realname} 此时SESSION_DATA为{&quot;时间_随机数&quot;:{username:输入的username，realname：输入的realname}} 第二次进入测试路由时，解析session时将 SESSION_DATA[userId]（即{username:输入的username，realname：输入的realname}）赋值给req.session,然后在路由（router-user.js）中因为有req.session.username，所以返回req.session显示在页面上。 从 session 到 redis目前使用session会造成的问题 目前session直接是js变量，放在nodejs进程内存中。 计算机基础中的“进程内存模型”，可以看到，操作系统会给每个进程分配这样一个有限的内存块，session作为对象时存储在堆中的，当他越来越多以至于接触到栈或者导致内存崩了就完了： 问题1：进程内存有限，访问量过大，内存暴增怎么办？ nodejs作为一个进程，他的内存是有限的，所以session作为进程中的一个变量，他的最大可用内存也是有限的： 问题2：正式线上运行是多进程，进程之间内存无法共享。 以3个进程为例： 操作系统对一个进程分配的内存是有限的，但服务器内存很大，所以如果一次只执行一个进程任务就很浪费。 现在都是多核处理器，双核/四核/六核，多少核就能并行处理多少个进程的任务执行，如果一次只执行一个进程任务就很浪费。 但多个进程之间内存无法共享： 比如，你同时开启了qq浏览器和百度，如果qq的进程想要去访问百度进程的内存中保存的变量，那安全隐患就大了。所以多个进程之间内存是无法共享的。 redis redis是web server最常用的缓存数据库，数据存放在内存中 相比于 mysql，访问速度快 mysql是硬盘数据库，redis是内存数据库。 内存和硬盘的速度不是一个数量级的，mysql无论做什么算法优化速度都没内存中的读取速度快。 但是成本更高，可存储的数据量更小（内存的硬伤） 解决方案：redis保存session 将web server和redis拆分为两个单独的服务 这样一来，session就不是存储在进程中的变量，那么访问量过大时也不会造成nodejs的进程内存暴增了。（因为此时session是存储在redis里的，独立于web server） 多个进程之间也可以同时访问redis，解决了多进程之间内存无法共享的问题。 双方都是独立的，都是可扩展的（例如都扩展成集群） 所以如果访问量暴增也不怕，可以通过扩展成集群等方式扩展内存。 包括mysql，也是一个单独的服务，也可扩展 但是存放在redis中的数据会断电丢失（这是内存数据库的硬伤） 为何使用redis而不是mysql session访问频繁，对性能要求极高 session作为访问的入口，每次访问网页都要经过session。mysql是只有更新的时候才执行，是比较滞后的。 session可不考虑断电丢失数据的问题（内存的硬伤） session丢了没关系，就相当于没登录，再登录即可。 其实session也可以断电不丢失（需要额外配置，此处不考虑） session数据量不会太大（相比于mysql中存储的数据） 所以没必要放到mysql中进行存储 为何网站数据不适合用redis 操作频率不是太高（相比于session操作），所以放在mysql中更合适 断电不能丢失，必须保留，如果使用redis还得另外配置来恢复数据，比较麻烦，所以mysql更合适 数据量太大，放在redis中则内存成本太高 redis 介绍安装redis 可参考菜鸟教程 做到这一步即可： 使用redis redis安装目录下打开cmd，运行redis-server.exe redis.windows.conf启动redis redis目录下另启一个 cmd 窗口，原来的不要关闭（否则无法访问服务端），运行redis-cli.exe -h 127.0.0.1 -p 6379(接下来的操作都在这个cmd中)或者redis-cli -p 6379 设置：set 关键字 值 获取：get 关键字 看到目前设置的所有key:keys * 删除：del 关键字 清空当前redis数据库缓存:flushdb 清空整个redis缓存:flushal nodejs链接redis的demo 启动redis：redis安装目录下打开cmd，运行redis-server.exe redis.windows.conf 新建redis-test文件夹-执行npm init -y进行初始化 项目中安装redis：npm i redis --save --registry=https://registry.npm.taobao.org 可以在package.json中看到，安装成功： 新建index.js： 引入redis 创建客户端 测试 set()的参数3redis.print可以在设置成功后打印出Reploy OK 注意：get()获取数据，参数2是异步的 到cmd中看看结果： nodejs连接redis 封装工具函数 进入blog-1项目中，安装redis：npm i redis --save --registry=https://registry.npm.taobao.org 在src-conf-db.js中，配置redis的连接信息 新建变量REDIS_CONF，port是redis端口号，host是连接的主机ip地址，记得输出 db文件夹下新建redis.js，使用conf中的配置信息 连接redis： 注意： set()的参数1、2都是字符串格式的，所以使用set()时需要判断参数是否为引用类型，如果参数2是引用类型就要先使用JSON.stringify()将其转换为字符串类型的数组/对象，否则会自动使用toString()方法进行转换，那结果会很麻烦。 get()是异步的，所以需要使用Promise对象进行封装。（get请求需要node向redis请求后获取一个redis返回的值，这是IO操作，而在node中IO操作是异步的。）由于之前我们将对象转为JSON字符串了，所以输出数据时要先尝试将JSON字符串转回为JSON对象，而非JSON字符串则直接输出即可。同时要注意获取的值不存在时就返回空对象。 一样的，“结束”在这不能用，因为我们只连接一次但要使用多次，如果结束就无法使用多次。 session存入redis 目前我们把session存在js中作为变量，所以每次刷新页面时数据就会丢失，但我们把session存入redis就不会有这个问题。 cookie是一个对象，里面存储的是userId、path等；session也是一个对象，其中存储的是username和password等。 流程总结： 用户登录网页，在登录路由中将输入的username等数据放入session中，并使用redis的set方法将session数据同步存储到redis中 接下来每次访问网页时，首先执行的app.js就会根据用户请求中的cookie的userId，使用redis解析（读取）session得到username等数据，以此判断用户是否登录。 例子 router-user.js中， 引入往redis中设置session的方法： 在登录路由中将输入的username等数据放入session中，并使用redis的set方法将session数据同步存储到redis中： app.js中， 引入使用redis的方法： 根据用户请求中的cookie的userId，使用redis解析（读取）session得到username等数据，以此判断用户是否登录。处理blog路由： 测试： 完成server端登录的代码 router-blog.js中，创建一个 统一的登录验证函数，调用该函数时，只要传入req，有返回数据就说明用户未登录： 将这个验证函数放在各个需要登录验证的博客路由中，这样只要用户未登录就直接return，结束函数，不会继续执行： 从session中提取数据： 修改router-user.js，将登录路由的get改回post，注释掉测试路由：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"博客项目登录（cookie）","slug":"博客项目登录（cookie）","date":"2020-02-25T14:30:09.000Z","updated":"2020-03-24T14:31:50.013Z","comments":true,"path":"2020/02/25/博客项目登录（cookie）/","link":"","permalink":"http://yoursite.com/2020/02/25/博客项目登录（cookie）/","excerpt":"cookie 介绍 cookie是存储在浏览器的一段字符串（最大5kb） 跨域不共享 比如：你同时打开了淘宝和百度，那么淘宝和百度对应的是2个cookie，他们是不共享的。 格式如k1=v1;k2=v2;k3=v3;因此可以存储结构化数据 每次发送http请求，会将请求域的cookie一起发送给server端 比如：你在淘宝中请求访问百度，那么就会将百度的cookie发送给server端。 server端可以修改cookie并返回给浏览器 浏览器中也可以通过javascript修改cookie（有限制）","text":"cookie 介绍 cookie是存储在浏览器的一段字符串（最大5kb） 跨域不共享 比如：你同时打开了淘宝和百度，那么淘宝和百度对应的是2个cookie，他们是不共享的。 格式如k1=v1;k2=v2;k3=v3;因此可以存储结构化数据 每次发送http请求，会将请求域的cookie一起发送给server端 比如：你在淘宝中请求访问百度，那么就会将百度的cookie发送给server端。 server端可以修改cookie并返回给浏览器 浏览器中也可以通过javascript修改cookie（有限制） 客户端JS操作cookie客户端（浏览器）查看cookie的三种方式 方式1 f12-Network： 客户端通过请求头将cookie传给服务端： 服务端将处理好的cookie通过响应头返回给客户端： 接下来客户端就可以使用服务端返回的cookie。 方式2 f12-Application-Cookies-找到对应域名： 这里面是解析过的cookie值： path为/即该网页下cookie都生效，不管是https://www.baidu.com/还是https://www.baidu.com/???xxx/yyy 可手动删除cookie： 方式3 通过JS查看（有限制）： JS查看、累加cookie（有限制） 可以通过JS查看cookie（上面的方式3），也可以累加cookie（有限制），但不能删除cookie。 累加cookie和查看cookie的方法一样： 但其实有了本地存储Local Storage后，js修改cookie变得很少： server端nodejs操作cookie获取cookie在server端可通过req.headers.cookie获取到cookie（req是http请求），因为cookie是保存在请求头部的。 操作cookieserver端可以将cookie通过res的setHeader方法设置到响应报文头部的Set-Cookie中，比如(res是http响应报文)： 1res.setHeader(`Set-Cookie`, `username=$&#123;data.username&#125;; path=/`); cookie用于登录验证app.js获取cookie转为对象blog-1中app.js，解析cookie，cookie为字符串，不好操作，所以将其转换为对象后放到req身上方便调用： 使用字符串的split方法将字符串分隔为数组。 使用数组的forEach方法将每个数组元素都分隔后放入对象中作为属性和属性值。 测试：刷新页面，获取到请求中的cookie并打印出来： router-user.js创建测试登录验证的路由 ctrl+shift+a+f将所有logincheck改为login： 创建一个路由用于测试登录验证： app.js需要路由返回一个Promise对象，所以使用Promise.resolve()来快速创建一个Promise对象。 测试： router-user.js测试登录 暂时将登录改为get，方便测试： 操作cookie 测试： 解决cookie的属性前有空格的问题注意：如果原本就有cookie则无法登录成功，因为后面加入的username字符串前出现空格，导致无法获取username： 解决方法：在app.js中，解析cookie时，使用字符串的trim()删除字符串的头尾空格，这样就能获取到username： 字符串的trim() 字符串的trim()删除字符串的头尾空格。 不会改变原始字符串。 server端给JS操作cookie做限制 要给JS操作cookie做限制，cookie中某些数据是不能修改的。 后端设置cookie时加上httpOnly即可，表示只允许后端修改。 为什么要做限制因为此时前端可修改cookie中的username，不安全： 给cookie做限制router-user.js中，设置cookie时加上httpOnly即可，表示只允许后端修改： 测试： 先传入username和password： 通过测试路由可看到httpOnly设置成功： 此时前端无法获取username，修改不会报错也不会成功： 修改username增添的只是假数据： 设置cookie过期时间（expires）可以看到此时cookie是不会过期的： router-user.js中，给cookie加属性expires，设置24小时后过期： toGMTString() 方法可根据格林威治时间 (GMT) 把 Date 对象转换为字符串，并返回结果。 不赞成使用此toGMTString方法。请使用 toUTCString() 取而代之！！得到的结果是一样的： 测试： toGMTString打印结果：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"nodejs博客项目中API对接mysql","slug":"nodejs博客项目中API对接mysql","date":"2020-02-24T08:47:58.000Z","updated":"2020-03-24T03:21:20.208Z","comments":true,"path":"2020/02/24/nodejs博客项目中API对接mysql/","link":"","permalink":"http://yoursite.com/2020/02/24/nodejs博客项目中API对接mysql/","excerpt":"API对接mysql 接上一篇笔记“nodejs链接mysql及项目真实使用方法”。","text":"API对接mysql 接上一篇笔记“nodejs链接mysql及项目真实使用方法”。 博客详情 controller-blog.js处理数据库数据: router-blog.js规范数据格式，返回给app.js: app.js中已经统一对handleBlogRouter()返回的数据做了处理，将其显示在页面上，故不需再修改。 测试： 新建博客 controller-blog.js处理数据库数据: 可以通过打印看到对象insertData所包含的属性： router-blog.js规范数据格式，返回给app.js: postman测试： 博客更新 controller-blog.js处理数据库数据: 可以通过打印看到返回对象updateData所包含的属性： router-blog.js规范数据格式，返回给app.js: postman测试： sqlyog查看数据库中blogs表： 删除博客注意：真实开发要保证数据的可恢复性，使用“软删除”，这里作为练习使用“硬删除。” controller-blog.js处理数据库数据: 需要传入author：防止删除他人数据 router-blog.js规范数据格式，返回给app.js: postman测试： sqlyog查看数据库中blogs表： 登录博客controller中引入exec函数操作数据库controller-user.js中，引入db-mysql.js中的exec函数用于处理数据库数据: 注意：插入时关键字password需要使用反引号，但查询时不用： router中规范数据格式router-user.js规范数据格式，返回给app.js: app.js处理handleUserRouter修改app.js中对handleUserRouter的处理： postman测试postman测试：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"nodejs链接mysql及项目真实使用方法","slug":"nodejs链接mysql及项目真实使用方法","date":"2020-02-23T08:47:58.000Z","updated":"2020-08-10T05:38:47.423Z","comments":true,"path":"2020/02/23/nodejs链接mysql及项目真实使用方法/","link":"","permalink":"http://yoursite.com/2020/02/23/nodejs链接mysql及项目真实使用方法/","excerpt":"mysql 下载mysql 查询mysql版本：","text":"mysql 下载mysql 查询mysql版本： mysql只要是5以上的版本，则数据类型括号中的size统一为字符长度，不管中英文都是统一的，比如varchar(10)就代表显示10个汉字/英文。 varchar(size)或者int(size)等SQL数据类型中的size指的不是字节也不是位！是字符的显示长度！ users表的例子: 操作mysql的客户端 操作mysql的客户端有很多，官方出的有workbench，我常用的是SQLyog。 workbench可以在官网下载. SQLyog基本使用方法 数据库操作 建库 建表 表操作 注意 SQL 对大小写不敏感：SELECT 与 select 是相同的。 SQL数据类型 mysql 5以上的版本，size统一为长度，不管中英文都是统一的（比如varchar(10)就代表显示10个汉字/英文）。varchar(size)或者int(size)等SQL数据类型中的size指的不是字节也不是位！是字符的显示长度！ 区分 字符 和 字节、位！ 1个字节(Byte)= 8位二进制。（1 Byte =8 bit）二进制数系统中，每个0或1就是一个位(bit)，是存储信息的最小单位。 不同编码里，字符和字节的对应关系不同： 在ASCII码中，1个英文字符（不分大小写）占1个字节的空间，1个中文字符占2个字节的空间。对于符号来说，英文标点占一个字节，中文标点占两个字节。 UTF-8编码中，1个英文字符等于1个字节，1个中文字符（含繁体）等于3个字节。 建库 创建myblog数据库： 执行语句进行查询： 建表 注意： 主键是不能重复的，可以使用AI自动增加 时间采用毫秒数来计算时，int不够用，可采用bigint 普通长度可采用varchar，长文可采用longtext users表和blogs表： users表： blogs表： 新建表： users表： blogs表： 补充：修改表或者删除表： 表操作 注意：id是自增的，你删除了id为1的那条数据，id为2的数据依旧是2，不会改变。 所有操作之前都要先选中数据库： 增加表中数据（insert into...values） 增加第1条数据: 增加第2条数据: 查询表中数据(select...from) *查询所有数据【尽量少用*，耗费性能，除非查的都是需要的】: 查询单独/几列数据 where条件筛选： and并列条件筛选： or或者条件筛选： like和%模糊条件筛选： order by xx根据xx排序，顺序输出: order by xx desc根据xx排序，倒序输出: 修改表中数据（update...set）update...set修改表中数据： - 如果报错，提示现在使用的是安全模式，则输入SET SQL_SAFE_UPDATES=0;再进行修改即可。 删除表中数据（delete from） delete删除表中数据： 注意： 此时使用insert添加李四的数据，可以看到id不是2，是3，因为2已经用过了： 实际上不应该直接删除数据，应该在表中增加state列用于存储状态，1表示存在（数据可用），0表示已被删除（数据可用），通过修改state的数据来表示该条数据是否删除。 实际运用“软删除”（state与update） 在users表中增加一列state，默认值为1，表示数据可用： 用修改来实现“删除”的功能，实际是并没删除，只是我们查找数据的时候都只查state为1的可用数据，为0的我们就当已经删除了： 补充：&lt;&gt;表示不等于： “软删除”的好处就是 数据可恢复： 补充blogs表数据 使用Date.now()获取时间，放入表中作为模拟数据： 插入2条数据： 连表查询 内连接INNER JOIN：只取两张表有对应关系的记录 左连接LEFT JOIN:包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行; 右连接RIGHT JOIN:包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行; 全连接FULL OUTER JOIN:包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行; nodejs操作mysql 在实际开发中我们当然不可能借助sqlyog对数据库进行操作，这就需要node直接连接数据库了，思路其实和使用sqlyog差不多。 示例：用demo演示，不考虑真实使用 封装：将其封装为系统可用的工具（API） 使用：项目中通过API直接操作数据库，不再使用假数据 示例 新建mysql-test文件夹-初始化node环境：npm init -y 使用淘宝镜像安装mysql：npm i mysql --registry=https://registry.npm.taobao.org 根目录下新建index.js: 在index.js中： 引入 mysql 使用mysql.createConnection创建链接对象（相当于登录sqlyog） 使用链接对象.connect开始连接 使用链接对象.query执行sql语句 query(): 参数1：sql语句 参数2：回调方法 参数1：错误执行的返回值 参数2：成功时的返回值 查询：返回查询到的内容(数组) 修改数据：返回OkPacket对象 增加数据：返回OkPacket对象（insertId发生改变） 使用链接对象.end关闭连接(不关闭数据库的链接则无法结束进程) 查询数据1234567891011121314151617181920212223242526const mysql = require(\"mysql\");// 创建链接对象conconst con = mysql.createConnection(&#123; host: 'localhost', user: 'root', password: 'rootroot', port: \"3306\", // database为需要链接的数据库名称 database: 'myblog'&#125;)// 开始链接con.connect(); // 执行sql语句const sql=\"SELECT * FROM users;\";con.query(sql, (err, result) =&gt;&#123; if (err) &#123; console.log(err); &#125; console.log(result);&#125;);// 关闭连接con.end(); 运行结果：返回值是查询的内容，其实和sqlyog是一样的，只是sqlyog是表格形式，而这里是json对象的形式： 修改数据在上面的代码中修改sql语句（注意引号）： 1const sql = 'update users set realname=\"李四2\" where username=\"lisi\";'; 运行结果：返回值为OkPacket对象，对象中有一些数据表示是否修改成功，那么实际运用的时候我们就可以通过这些数据来返回true/false给前端来代表是否修改成功： 增加数据在上面的代码中修改sql语句（注意引号）： 1const sql = 'INSERT INTO blogs(title,content,createtime,author) VALUES (\"标题C\",\"内容C\",1584888893495,\"lisi\");'; 运行结果：返回值为OkPacket对象，对象中insertId: OkPacket对象中insertId对应数据表中的id： 结合blog-1中的blog.js来看，我们模拟的假数据中的id就是通过OkPacket对象中insertId得到的： node项目真实使用mysql的方法nodejs 链接 mysql 做成工具（API）总结：src-conf-db.js中根据环境变量NODE_ENV进行链接的不同的数据库配置。scr-db-mysql.js中引用db.js链接不同数据库后，生成执行sql语句的函数，输出供外界使用。 在blog-1文件夹中按照上面安装mysql： src下新建conf文件夹-新建db.js，配置数据库信息： 注意：这里是根据环境变量（package.json中设置的NODE_ENV）链接不同的数据库的，线下是连接本地数据库，线上就不能连接本地数据库了(但是现在我们没有服务器，所以还是先使用本地的数据库)。 scr下新建db文件夹-新建mysql.js，创建统一执行sql语句的函数： 其实这里和上面“示例”逻辑就是一样的，只是链接对象的配置信息从conf-db.js中获取。 我们需要执行了函数后能返回数据，又因执行sql语句过程是异步的，所以使用Promise将query的函数2的两个参数返回值返回，最终返回Promise对象，则外界可通过Promise对象的then()/catch()拿到返回数据。 在这不能使用end结束链接了，因为我们只创建一个链接对象con，而我们多次调用exec函数执行sql语句都是针对对象con的，如果我们使用了end，那么第一次使用exec以后就没有链接对象con，即无法多次执行exec函数。 API对接mysql（博客列表） 在controller-blog.js中，引入db-mysql.js中的exec函数，先将getList()中返回的假数据改为数据库中读取出来的： 注意： where 1=1是为了保证查询语句一直正确存在的，因为1=1是true，所以无论有没有author/keyword都能保证sql语句正确执行。 exec函数返回的是Promise对象。 在router-blog.js中，使得匹配上该路由时返回从数据库中读出的数据（数组）： 注意： controller-blog.js中返回的是Promise对象，通过Promise对象的then()即可获取返回数据。 这里路由返回的也是Promise对象。 路由写完就被app.js引用，然后显示在页面上，所以现在将app.js中显示在页面上的数据改为从路由中获取的数据： 测试：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"借助coding管理项目","slug":"借助coding管理项目","date":"2020-02-22T08:11:58.000Z","updated":"2020-06-09T05:29:42.915Z","comments":true,"path":"2020/02/22/借助coding管理项目/","link":"","permalink":"http://yoursite.com/2020/02/22/借助coding管理项目/","excerpt":"借助coding管理项目 更多命令可参考官方帮助文档","text":"借助coding管理项目 更多命令可参考官方帮助文档 例子：开发者a开发了登录功能的分支，开发者b开发了注册功能的分支，管理者c在master分支下使用git fetch下载所有分支并依次合并各分支功能 在coding创建一个项目 我们做的每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。比如我们项目中的npm包(node_modules)，它在我们项目中是很重要的，但是它占的内存也是很大的，所以一般我们用Git管理的时候是不需要添加npm包的。 注意：如果是先创建coding项目，那么此时需要在本地上git clone 项目地址将其下载在本地。（如果项目地址使用SSH，则需要将公钥添加到coding-个人设置-SSH公钥） 首次提交项目到coding（如果将coding项目克隆到了本地，则忽略此步骤） 在存放需要push到coding上的文件夹中单击右键-git bash here 创建本地git仓库git init 此步操作完成后，会在此文件夹下生成一个隐藏的.git后缀文件 添加文件到暂存区：git add . 提交文件到本地仓库：git commit -m &quot;init project&quot; git commit –m “项目描述”（具体的描述方法见下方） 将本地文件推送到coding服务器: git remote add origin https://e.coding.net/hlzzz/weibo.git（origin后的是项目地址） git push origin master（master也可以是其他分支） 修改项目后提交 查看当前修改过/新增的文件:git status 查看被修改的内容:git diff 添加文件到暂存区：git add . 提交文件到本地仓库：git commit -m &quot;相关描述&quot; 具体的描述方法见下方 将本地文件推送到coding服务器:git push origin master（master也可以是其他分支） commit的不同项目描述的前缀 我们应当按照规范将每次上传做的修改进行描述，不同的修改使用的描述前缀也是不同的。 调整项目结构用refactor,比如：git commit -m &quot;refactor:调整目录结构&quot; 添加/修改功能用feat（即feature 功能），比如：git commit -m &quot;feat:演示路由&quot; 修改bug：git commit -m &quot;fix:修改的bug描述&quot; 查看日志 可使用git log查看日志： 增加分支git checkout -b 分支名 合并分支 git fetch如果本地没有全部分支，则使用fetch下载所有分支 git merge 待合并分支名将待合并分支合并到当前分支中 git push origin master将文件推送到服务端（master也可以是其他分支） 暂存修改 如果在创建分支前进行了修改，但这个修改不应属于当前分支，则可用git stash暂存修改，然后新建/切换分支，到相应的分支下用git stash pop将修改放出 push时报错 error: failed to push some refs to ‘git@e.coding.net:hlzzz/weibo.git’ 原因：是因为在coding创建项目时生成了README.md文件，而本地代码目录中并没有README.md文件。 解决方法可以通过如下命令进行代码合并【注：pull=fetch+merge】： 1git pull --rebase origin master 执行后可以看到本地代码库中多了README.md文件,此时重新push即可。 合并时冲突（conflict）假设之前已经合并的分支和现在正要合并的分支中有同一部分代码被做了不同的修改，那么就会产生冲突vscode提供便利的解决方法：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"微博项目","slug":"微博项目","permalink":"http://yoursite.com/categories/微博项目/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"登录页面开发（2）、懒加载、项目上线流程","slug":"登录页面开发（2）、懒加载、项目上线流程","date":"2020-02-21T08:23:01.000Z","updated":"2020-03-31T13:37:38.476Z","comments":true,"path":"2020/02/21/登录页面开发（2）、懒加载、项目上线流程/","link":"","permalink":"http://yoursite.com/2020/02/21/登录页面开发（2）、懒加载、项目上线流程/","excerpt":"登录鉴权实现功能：只有用户登录以后点击“写文章”才会跳转写文章页面，若未登录就跳转登录页","text":"登录鉴权实现功能：只有用户登录以后点击“写文章”才会跳转写文章页面，若未登录就跳转登录页 新建write页src-pages.js下新建write文件夹，新建index.js识别是否登录，如果已登录就跳转写文章页面，若未登录就使用 重定向 跳转登录页: App.js中创建write页的路由src-App.js中创建路径为/write时的路由： 点击“写文章”跳转write页在src-common-header-index.js中，给Header组件设置，点击“写文章”跳转write页： 异步组件（懒加载）及withRouter路由方法 目前我们所有的页面都是放在bundle.js上的，点击详情页、登录页都不会发生新的js请求，这就说明当我们加载首页的时候是把所有页面都加载了一次，这就导致首页加载速度慢： 想单独加载不同的页面就要使用异步组件（懒加载），只有使用该页面时才加载该页面。 异步组件（懒加载）底层复杂，但可以使用第三方模块react-loadable。 安装react-loadable模块项目中安装react-loadable： 1yarn add react-loadable 使用react-loadable模块实现功能：只有进入详情页才加载详情页 pages-detail-新建loadable.js，将官方案例复制来使用将Detail组件变为异步组件： 在src-App.js中进行修改，之前加载的是普通Detail组件，现在要加载的是异步组件： 报错：路由参数无法获取此时会报错： TypeError: Cannot read property ‘params’ of undefined 原因 之前我们可以获取动态路由参数，是因为之前Route包裹的Detail组件就是Detail组件，所以Detail组件可以获取到路由的配置信息 而现在Route包裹的是LoadableComponent组件，LoadableComponent组件可以获取路由的配置信息，但是LoadableComponent组件内部的Detail组件获取不到： 解决方法：使用withRouter路由 “react-router-dom”提供了withRouter，被withRouter()包裹的组件将有能力获取到Router中所有的参数和内容。 在pages-detail-index.js中，引入withRouter： 使用withRouter包裹Detail组件再进行输出： 结果展示此时加载首页是bundle.js，点击详情页是1.chunk.js: 项目上线流程删除模拟数据的文件将public-api文件夹删除，开发的时候我们需要借口模拟，但真正上线时后端已经将接口准备好了。 前端项目打包编译项目命令行输入： 1npm run build 此时前端项目的目录下会生成一个build文件夹，该文件夹内的内容就是前端所有的内容（包括html文件）。 放到后端项目文件夹内 只需要将build文件夹内的文件全部复制到后端文件夹中，即可在后端正常显示所有前端页面。（注意，不是把文件夹复制过去） 此时，将前端页面经过build编译后生成的html页面放入了后端项目，那么访问的就是后端项目的接口下的页面，那么前端页面发送ajax请求时也就不需要nginx进行反向代理了，因为此时前后端是用同一个接口运行起来的。 补充：如果前后端页面使用的是不同的接口运行起来的，假设前端页面是3000端口，后端页面是8000端口。那么用户打开页面时打开的就是3000端口的页面，前端页面中使用ajax请求获取数据时就会去获取3000端口下的对应路径的数据。而后端页面是8000端口，所以数据其实保存在8000端口下的对应路径中。这就无法获取数据。此时使用nginx进行反向代理，遇到/api/开头的url时就分配到8000端口，遇到/开头的url时就分配到3000端口，这样就没问题了。 补充：图片的懒加载react的react-lazy-load库 react中可使用react-lazy-load库来实现图片的懒加载。 原生js 原生js实现图片懒加载可参考这篇文章和这篇博客，如有需要可以了解JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解 面试题：预加载 与 懒加载 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"让google收录github pages（hexo）","slug":"让google收录github pages（hexo）","date":"2020-02-21T04:23:14.000Z","updated":"2020-03-21T05:12:15.541Z","comments":true,"path":"2020/02/21/让google收录github pages（hexo）/","link":"","permalink":"http://yoursite.com/2020/02/21/让google收录github pages（hexo）/","excerpt":"查看是否被收录首先查看你的博客地址是否已经被Google收录，在Google的搜索栏中搜索：","text":"查看是否被收录首先查看你的博客地址是否已经被Google收录，在Google的搜索栏中搜索： 1site:https://xxxx.github.io 其中https://xxxx.github.io为你的博客地址，如果结果是尝试使用Google Search Console，则意味着没有被收录。 使用Google Search Console进入Google Search Console-登录谷歌帐号-选择“前缀”的方式-下载HTML文件- 修改HTML文件注意！！：为了使 hexo 不处理这个HTML验证文件，并且不生成关于这个文件的 sitemap，我们需要打开验证文件，在最上面添加以下代码： 12layout: false--- ---下要空一行！！ 放到hexo/source文件夹下将修改好的HTML文件放到hexo/source文件夹下，正常上传即可： 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 接下来就是等待了： 留个坑以后弄百度和分流 参考这个 可参考这篇博客实现国内的走coding，海外的走github，只要配置2个CNAME就行","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"记coding升级后搭建静态网站（hexo）遇到的坑","slug":"记coding升级后搭建静态网站（hexo）遇到的坑","date":"2020-02-21T03:20:11.000Z","updated":"2020-03-21T05:11:28.279Z","comments":true,"path":"2020/02/21/记coding升级后搭建静态网站（hexo）遇到的坑/","link":"","permalink":"http://yoursite.com/2020/02/21/记coding升级后搭建静态网站（hexo）遇到的坑/","excerpt":"coding升级coding今年1月份升了个级，网上的教程似乎都不好使了，故把我遇到的坑和解决方法都记录一下。","text":"coding升级coding今年1月份升了个级，网上的教程似乎都不好使了，故把我遇到的坑和解决方法都记录一下。 配置ssh报错网上教程大多是执行ssh -T git@git.coding.net来看是否配置成功，但是我使用以后会 解决方法根据官网,命令改了： 1ssh -T git@e.coding.net 得到中文的提示即成功： Coding 提示: Hello oka, You’ve connected to Coding.net via SSH. This is a personal key.xxx，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥 如果还是不行就试试这个输入： 1eval `ssh-agent` 再输入(这里的new是你自己存放ssh的文件)： 1ssh-add ~/.ssh/new 再输入： 1ssh -T git@e.coding.net 配置Hexo-_config.yml同步上传github因为我原本就上传了github，所以想要两边同步更新，就跑来设置_config.yml，但是按照网上的教程都只能deploy到github，后来发现下面这种格式可以一次deploy到coding和github： coding搭建静态网站 先放个官方帮助文档，基本找到了“构建与部署”以后的步骤官方都给出来了。 问题就在我一开始进去项目是找不到“构建与部署”的！！ 解决方法 进入项目-点击左下角“项目设置”： 现在后退就有“构建与部署”了，接下来就跟着官方帮助文档步骤即可。 coding.me的问题在很多教程里都有这段话： 新建一个名为username.coding.me的项目，其中这里的username是coding注册时的username，等项目部署成功后它就是你博客的访问地址。 但是升级以后coding取消了username，改为手机号和邮箱，所以我找了半天都没找到username在哪，好像只能使用随机生成的域名了。 解决方法 买个域名在“设置”里自定义域名吧，听说现在域名一年在几十块一下，我觉得还可。 官方的自定义域名教程 可参考这篇博客实现国内的走coding，海外的走github，只要配置2个CNAME就行 百度收录【留着以后填坑】 弄好以后记得让百度收录，不然也很难受 登录百度搜索资源平台-&gt;链接提交。即可，没有绑定过的需要先新增站点并验证。注意https和http有区别，需要自己选择，选错了会验证不了 我还没弄域名，所以这个留着以后填坑吧 可以参考这篇博客来弄 推荐使用sitemap方式提交，推荐一个hexo的sitemap生成插件：hexo-generator-baidu-sitemap","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"react-router-dom的使用","slug":"react-router-dom的使用","date":"2020-02-20T05:21:04.000Z","updated":"2020-07-24T09:15:44.947Z","comments":true,"path":"2020/02/20/react-router-dom的使用/","link":"","permalink":"http://yoursite.com/2020/02/20/react-router-dom的使用/","excerpt":"参考资料 英文文档","text":"参考资料 英文文档 React Router中的组件 React Router中的组件主要分为3类，他们都从react-router-dom中获取到： 路由器组件：&lt;BrowserRouter&gt;和&lt;HashRouter&gt; 路线匹配器组件：&lt;Route&gt;和&lt;Switch&gt; 导航组件：&lt;Link&gt;，&lt;NavLink&gt;和&lt;Redirect&gt; 路由器组件 每个React Router应用程序的核心应该是路由器组件。 对于Web项目，react-router-dom提供&lt;BrowserRouter&gt;和&lt;HashRouter&gt;路由器。两者之间的主要区别是它们存储URL和与Web服务器通信的方式。 &lt;BrowserRouter&gt;使用常规的URL路径。这些通常是外观最好的URL，但是它们要求正确配置服务器。具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面。Create React App在开发中即开即用地支持此功能，并附带有关如何配置生产服务器的说明。 &lt;HashRouter&gt;将当前位置存储在URL 的hash一部分中，因此URL看起来像http://example.com/#/your/page。由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置。 要使用 路由器组件，只需确保将其呈现在元素层次结构的根目录下即可。 使用方法 通常会在src-index.js中将顶级&lt;App&gt;元素包装在路由器组件中，如下所示： 然后在src-APP.js中使用路线匹配器组件 路线匹配器组件 路线匹配器组件：&lt;Route&gt;和&lt;Switch&gt; &lt;Route&gt;组件 &lt;Route&gt;组件：定义路由组件。 path属性：（字符串）匹配路径，没有定义 path 的 &lt;Route&gt; 总是会被匹配。 exact属性：（可省略属性值）表示准确匹配路径。如不使用该属性，则默认是模糊匹配path。如果为 true，则只有在 path 完全匹配 location.pathname 时才匹配。 渲染方式的属性见下方，一般选component属性。其他更多属性可参考官网 渲染方式(&lt;Route&gt;属性) &lt;Route&gt;组件渲染方式（在不同的情况下使用不同的方式，只使用一种即可）： component属性：（组件）路径匹配成功后渲染的组件。【优先使用该属性】 指定只有当位置匹配时才会渲染的 React 组件，该组件会接收 route props 作为属性。具体使用方法可见下方。 render属性：（函数）在该路径下渲染的内容 使用 render 可以方便地进行内联渲染和包装，而无需进行上文解释的不必要的组件重装。可以传入一个函数，以在位置匹配时调用，而不是使用 component 创建一个新的 React 元素。render 渲染方式接收所有与 component 方式相同的 route props。（使用方法参考官网） 警告：&lt;Route component&gt; 优先于 &lt;Route render&gt;，因此不要在同一个 &lt;Route&gt;中同时使用两者。 children属性：（函数）在该路径下渲染的内容 有时候不论 path 是否匹配位置，你都想渲染一些内容。在这种情况下，你可以使用 children 属性。除了不论是否匹配它都会被调用以外，它的工作原理与 render 完全一样。 使用方法可参考官网 警告：&lt;Route component&gt; 优先于 &lt;Route render&gt;优先于 &lt;Route children&gt;，因此不要在同一个 中同时使用多个。 三种渲染方式都将提供相同的三个路由属性：match、location、history 使用方法 &lt;Route&gt;组件应在&lt;Switch&gt;内部，他们都应该在路由器组件内部作为子元素存在。 方法1：如果你已经在src-index.js中使用路由器组件包裹App组件，那么可以在src-App.js中使用&lt;Route&gt;组件： 注意：路由器组件中始终包含&lt;header/&gt;组件。 这意味着如果应用程序的位置是 /，那么 UI 的层次结构将会是：&lt;header /&gt;&lt;Home /&gt;。 或者，如果应用程序的位置是 /detail/1(1可以是任意id值)，那么 UI 的层次结构将会是：&lt;header /&gt;&lt;Detail /&gt; 方法2：页可以直接在src-index.js中的路由器组件内部使用&lt;Route&gt;组件。 &lt;Switch&gt;组件 &lt;Switch&gt;组件用于渲染与路径匹配的第一个子 &lt;Route&gt; 或 &lt;Redirect&gt;。 &lt;Switch&gt;组件工作原理: 当&lt;Switch&gt;被渲染时，它会搜索其子元素&lt;Route&gt;组件，以查找路径与当前URL匹配的元素。当它找到一个时，它将渲染那个&lt;Route&gt;并且忽略所有其他的&lt;Route&gt;组件。 这意味着应该将具有更特定(通常更长的)路径的&lt;Route&gt;放在不太特定的路径之前。 如果没有&lt;Route&gt;匹配，&lt;Switch&gt;将不呈现任何内容(null)。 总结：&lt;Switch&gt; 路由中的Switch 代表只匹配一个路由，如果不使用 &lt;Switch&gt; 嵌套，路由会多次匹配。 例子在src-index.js中： 123456789101112131415161718192021222324252627282930313233343536373839404142import React from \"react\";import ReactDOM from \"react-dom\";import &#123; BrowserRouter as Router, Switch, Route&#125; from \"react-router-dom\";function App() &#123; return ( &lt;div&gt; &lt;Switch&gt; &#123;/* 如果当前URL是/about，则渲染此路由，而其余的则被忽略 */&#125; &lt;Route path=\"/about\"&gt; &lt;About /&gt; &lt;/Route&gt; &#123;/* 注意这两条路由是如何排序的。更具体的路径=\"/contact/:id\"放在路径=\"/contact\"的前面 */&#125; &lt;Route path=\"/contact/:id\"&gt; &lt;Contact /&gt; &lt;/Route&gt; &lt;Route path=\"/contact\"&gt; &lt;AllContacts /&gt; &lt;/Route&gt; &#123;/* 如果之前的路径都没有匹配渲染任何东西，这条路线是退路。重要提示:带有path=\"/\"的路由将始终能匹配到，因为所有的URL都以/开头。这是为什么我们把这个放在最后 */&#125; &lt;Route path=\"/\"&gt; &lt;Home /&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;Router&gt; &lt;App /&gt; &lt;/Router&gt;, document.getElementById(\"root\")); 注意：&lt;Route path&gt;匹配的是URL的开头，而不是整个URL。因此，&lt;Route path=&quot;/&quot;&gt;将始终与URL匹配。因此，我们通常把这个&lt;Route&gt;放在&lt;Switch&gt;的最后。另一种可能的解决方案是使用&lt;Route exact path=&quot;/&quot;&gt;，它准确匹配整个URL。 导航组件 导航组件：&lt;Link&gt;，&lt;NavLink&gt;和&lt;Redirect&gt; &lt;Link&gt;组件&lt;Link&gt;组件：类似于 &lt;a&gt; 标签(最终也会被渲染为 a 标签)。 123import &#123; Link &#125; from 'react-router-dom';&lt;Link to=\"/about\"&gt;About&lt;/Link&gt; to 属性：可理解为 a 标签的 href属性。 属性值可以是一个字符串形式的链接地址，通过 pathname、search 和 hash 属性创建：&lt;Link to=&#39;/courses?sort=name&#39; /&gt; 也可以是对象形式的链接地址，可以具有以下任何属性： pathname：要链接到的路径 search：查询参数 hash：URL 中的 hash，例如 #the-hash state：存储到 location 中的额外状态数据12345678&lt;Link to=&#123;&#123; pathname: '/courses', search: '?sort=name', hash: '#the-hash', state: &#123; fromDashboard: true &#125;&#125;&#125; /&gt; replace属性: 布尔值，当设置为 true 时，点击链接后将替换历史堆栈中的当前条目，而不是添加新条目。默认为 false。 1&lt;Link to=\"/courses\" replace /&gt; innerRef属性: 函数，允许访问组件的底层引用。(类似普通组件的ref属性) 12345const refCallback = node =&gt; &#123; // node 指向最终挂载的 DOM 元素，在卸载时为 null&#125;&lt;Link to=\"/\" innerRef=&#123;refCallback&#125; /&gt; &lt;NavLink&gt;组件一个特殊版本的 &lt;Link&gt;，它会在与当前 URL 匹配时为其呈现元素添加样式属性。 123import &#123; NavLink &#125; from 'react-router-dom';&lt;NavLink to=\"/about\"&gt;About&lt;/NavLink&gt; activeClassName属性: string，当元素处于激活状态时应用的类，默认为 active。它将与 className 属性一起使用。 1&lt;NavLink to=\"/faq\" activeClassName=\"selected\"&gt;FAQs&lt;/NavLink&gt; activeStyle属性: object，当元素处于激活状态时应用的样式。 123456const activeStyle = &#123; fontWeight: 'bold', color: 'red'&#125;;&lt;NavLink to=\"/faq\" activeStyle=&#123;activeStyle&#125;&gt;FAQs&lt;/NavLink&gt; exact属性: bool，默认为false，如果为 true，则只有在位置完全匹配时才应用激活类/样式。 1&lt;NavLink exact to=\"/profile\"&gt;Profile&lt;/NavLink&gt; strict属性: bool，默认为false，如果为 true，则在确定位置是否与当前 URL 匹配时，将考虑位置的路径名后面的斜杠。有关更多信息，请参阅 文档。 1&lt;NavLink strict to=\"/events/\"&gt;Events&lt;/NavLink&gt; isActive属性: func添加额外逻辑以确定链接是否处于激活状态的函数。如果你要做的不仅仅是验证链接的路径名与当前 URL 的路径名相匹配，那么应该使用它。 1234567891011// 只有当事件 id 为奇数时才考虑激活const oddEvent = (match, location) =&gt; &#123; if (!match) &#123; return false; &#125; const eventID = parseInt(match.params.eventID); return !isNaN(eventID) &amp;&amp; eventID % 2 === 1;&#125;&lt;NavLink to=\"/events/123\" isActive=&#123;oddEvent&#125;&gt;Event 123&lt;/NavLink&gt;location: object isActive 属性：默认比较当前历史位置（通常是当前的浏览器 URL）。你也可以传递一个不同的位置进行比较。 &lt;Redirect&gt;组件 重定向使用 &lt;Redirect&gt;会导航到一个新的位置。新的位置将覆盖历史堆栈中的当前条目，例如服务器端重定向（HTTP 3xx）。使用&lt;Link&gt;类似&lt;a&gt;,需要点击才能跳转，而使用 &lt;Redirect&gt;会直接导航到一个新的位置。 to属性: string要重定向到的 URL，可以是 path-to-regexp 能够理解的任何有效的 URL 路径。所有要使用的 URL 参数必须由 from 提供。 1&lt;Redirect to=\"/somewhere/else\" /&gt; to属性: object要重定向到的位置，其中 pathname 可以是 path-to-regexp 能够理解的任何有效的 URL 路径。 1234567&lt;Redirect to=&#123;&#123; pathname: '/login', search: '?utm=your+face', state: &#123; referrer: currentLocation &#125;&#125;&#125; /&gt; 上例中的 state 对象可以在重定向到的组件中通过 this.props.location.state 进行访问。而 referrer 键（不是特殊名称）将通过路径名 /login 指向的登录组件中的 this.props.location.state.referrer 进行访问。 更多属性可参考官方文档或者这篇笔记 路由传值 在 react 中 有两种方式进行路由传值: 方法1：通过动态路由传值(占位符)。类似于/a/:id/:value。在组件内部可使用 this.props.match.params.xxxx 来获取所传参数值。【推荐使用该方法，因为可以获取所传参数值】 例子： 在src-App.js中，定义路由匹配的路径时使用动态路由传值：符合要求就跳转Detail组件。 detail-index.js中，使用 this.props.match.params.id获取所传参数值，并将其传给action： detail-store-actionCreators.js中， action根据路径中获取到的id进行不同的AJAX请求，后端接受AJAX请求后根据不同地址返回不同数据给客户端： 方法2：通过 原始的 GET 路径后面，添加 ?key=value 的方式。在 组件内部 可使用 this.props.location.search的方式获取键值对(只不过获取过后还是一个字符串，需要进一步的解析才能获取所传参数值) 补充：node中使用querystring获取？后的参数可直接得到json格式对象 子路由的嵌套 这种情况很常见，比如 A 组件内部还有许多其他的子组件。需要路由匹配选择对应的子组件时，就需要使用路由嵌套 一个简单案例 官方示例是在Topics下又嵌套了3个子路由： 点击Topics下的Link组件时会传递对应的参数topicId（Rendering…React/Components/props-v-state）,嵌套的子Route组件识别到有参数就会去渲染Topic组件，而Topic组件中的内容由传递的参数决定。 关于useRouteMatch()和useParams()的用法可参考下方。注意：useRouteMatch()和useParams()都只能在 函数组件 的内部调用。 案例效果可在此查看 path和url的区别可参考这篇文章 API 钩子注意：以下钩子只能在 函数组件 的内部调用。 useRouteMatch() useRouteMatch()尝试以与&lt;Route&gt;相同的方式匹配当前URL。它主要用于在不实际呈现&lt;Route&gt;的情况下访问匹配数据。 获取的match对象包含的属性见下方补充。 例子： 补充：Route组件的match属性（对象） Route组件的match属性 一个match对象包含有关如何信息&lt;Route path&gt;相匹配的URL。match对象包含以下属性： params -（对象）从与路径的动态段相对应的URL解析的键/值对 isExact-（布尔值）true如果整个URL都匹配（没有结尾字符） path-（字符串）用于匹配的路径模式。用于构建嵌套&lt;Route&gt; url-（字符串）URL的匹配部分。用于构建嵌套&lt;Link&gt; path和url的区别可参考这篇文章 useParams() useParams将返回URL参数的键/值对的对象。使用它来访问当前&lt;Route&gt;的match.params。 例子：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"登录页面开发（1）","slug":"登录页面开发（1）","date":"2020-02-19T10:56:53.000Z","updated":"2020-03-19T05:34:45.370Z","comments":true,"path":"2020/02/19/登录页面开发（1）/","link":"","permalink":"http://yoursite.com/2020/02/19/登录页面开发（1）/","excerpt":"创建登录页面极其路由 src-pages下新建login文件夹： 新建index.js文件：","text":"创建登录页面极其路由 src-pages下新建login文件夹： 新建index.js文件： 在App.js中增加Login的路由： 登录页面样式布局 src-pages-login下新建style.js文件： src-pages-login-index.js中，引入并使用样式组件： common-header-style.js中设置一下，避免搜索框位于login下面： 登陆功能实现实现效果： 创建login的store login下新建store文件夹： 新建actionCreators.js 新建constants.js 新建index.js: 新建reducer.js: 合并到项目总store中此时虽然创建好了login的store，但还无法获取其中的数据。我们需要将login的reducer合并到src-store-reducer.js中： 此时可以看到store中已经有数据了: 判断用户是否登录，显示 登录/退出 实现功能：我们要让 头部组件 根据 用户是否登录 显示不同的文字。 header-index.js： 引入longin的store中保存的login数据来判断用户是否登录： 使用三目运算符来判断，如果login为true就显示“退出”，否则显示可跳转login页的“登录”： 效果： 登录按钮绑定事件，发送AJAX请求 实现功能：点击“登录”按钮后，用户的帐号、密码通过AJAX请求传递过去，查找是否存在。如果存在就登录成功，文字改为“退出”。 思路： 通过样式组件的ref属性的value值 获取到用户输入的帐号、密码。 给Button组件绑定onClick事件，事件函数中要发送AJAX请求，将帐号密码传递过去。AJAX请求要放到action中，而只有connect的参数2可以派发action，所以发送AJAX请求的函数要放在connect的参数2中 创建login.json模拟数据 在actionCreators.js中创建对应的action，通过AJAX请求获取“是否登录成功”，根据获取内容发送action意图去修改store中login值 reducer接受到action，修改store中login值，从而让页面显示不同。 获取用户输入的帐号密码通过样式组件的ref属性的value值 获取到用户输入的帐号、密码：效果： 绑定点击事件，发送AJAX请求给Button组件绑定onClick事件，事件函数中要发送AJAX请求，AJAX请求要放到action中，而只有connect的参数2可以派发action，所以发送AJAX请求的函数要放在connect的参数2中 login.json模拟数据我们先给个模拟数据，假设无论如何都是登录成功： 创建action（AJAX请求）在actionCreators.js中创建对应的action，通过AJAX请求将帐号、密码传递过去，获取“是否登录成功”，根据获取内容发送action意图去修改store中login值： 123456789101112131415161718192021import axios from \"axios\";import * as constants from \"./constants\";const changeLogin = () =&gt; (&#123; type: constants.CHANGE_LOGIN, value: true&#125;)export const login = (account, password) =&gt; &#123; return (dispatch) =&gt; &#123; axios.get(\"/api/login.json?account=\" + account + \"&amp;password\" + password).then((res) =&gt; &#123; const result = res.data.data; if (result) &#123; dispatch(changeLogin()); &#125; else &#123; alert(\"登录失败\"); &#125; &#125;) &#125;&#125; reducer处理数据reducer接受到action，修改store中login值，从而让页面显示不同： 此时点击成功后显示“退出”： “react-router-dom”的组件 导航组件包括：&lt;Link&gt;，&lt;NavLink&gt;和&lt;Redirect&gt; 使用&lt;Link&gt;类似&lt;a&gt;,需要点击才能跳转， 而使用 &lt;Redirect&gt;会直接导航到一个新的位置。新的位置将覆盖历史堆栈中的当前条目 登录成功跳转首页login-index.js中获取到store中的login来做判断，假如已登录就使用”react-router-dom”中的组件将页面重定向到首页：此时会报错，因为变量login和函数login重名了，将变量login重命名为loginStatus即可。 实现退出功能 思路：在header-index.js中，给“退出”按钮绑定点击事件，点击后将login的store中的login改为false。 注意： header中的actionCreators.js创建的是改变header的store中数据的action，我们要想改变login的store中的数据，action要到login下的actionCreators.js中去创建。 引入需要改变的login的actionCreators.jscommon-header-index.js中引入login的actionCreators.js: 1import &#123; actionCreators as loginActionCreators &#125; from \"../../pages/login/store\"; 注意： header中的actionCreators.js创建的是改变header的store中数据的action，我们要想改变login的store中的数据，action要到login下的actionCreators.js中去创建。 “退出”按钮 绑定点击事件给“退出”按钮绑定点击事件，点击后派发action去修改login值：在mapDispatchProps中添加logout函数，用于派发修改login值的action： 123logout() &#123; dispatch(loginActionCreators.logout());&#125;, 注意：这里是logout是方法，调用需要() 通过action传递需要改变的loginlogin-store-actionCreators.js创建action： reducer处理，改变login值login-store-reducer.js处理，改变login值：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JS Web API BOM","slug":"JS Web API BOM","date":"2020-02-18T04:56:45.000Z","updated":"2020-03-22T03:45:24.985Z","comments":true,"path":"2020/02/18/JS Web API BOM/","link":"","permalink":"http://yoursite.com/2020/02/18/JS Web API BOM/","excerpt":"BOM BOM操作是Browser Object Model（浏览器对象模型） DOM操作是Document Object Model（文件对象模型） BOM相对DOM来说简单许多，基本就是API的操作，了解即可，需要用到的时候再查就行。","text":"BOM BOM操作是Browser Object Model（浏览器对象模型） DOM操作是Document Object Model（文件对象模型） BOM相对DOM来说简单许多，基本就是API的操作，了解即可，需要用到的时候再查就行。 相关知识点 navigator：浏览器的信息 screen：屏幕的信息 location：地址的信息（url） history：前移、后退的信息 navigator的API常用的API就是navigator.userAgent,可以借此判断浏览器的信息。（agent：代理商）比如判断是否是Chrome：判断各种浏览器类型的方法很多，需要用到的时候再去查就好。 screen的API判断屏幕的宽度、高度： location的常用属性 location.href:整个网站地址(返回完整的URL) location.protocol:返回一个URL协议（比如https:/http:） location.host:域名(返回一个URL的主机名和端口) location.search:返回一个URL的查询部分，即?后的内容 location.hash:网址的哈希(返回一个URL的锚部分)，即#后的内容 location.pathname:返回的URL路径名 history的API history.back():后退一页，相当于点击“返回” history.forward():前进一页 相关题目如何识别浏览器的类型通过navigator.userAgent识别浏览器的类型。 分析拆解url各个部分 location.href:整个网站地址 location.protocol:采用的协议（比如https:/http:） location.host:域名 location.search:路由参数，即?后的内容 location.hash:网址的哈希，即#后的内容 location.pathname:路径","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"详情页面开发","slug":"详情页面开发","date":"2020-02-17T14:36:39.000Z","updated":"2020-03-17T14:47:24.080Z","comments":true,"path":"2020/02/17/详情页面开发/","link":"","permalink":"http://yoursite.com/2020/02/17/详情页面开发/","excerpt":"详情页面布局pages-detail下新建style.js文件创建样式组件：","text":"详情页面布局pages-detail下新建style.js文件创建样式组件： 12345678910111213141516171819202122232425262728import styled from \"styled-components\";export const DetailWrapper = styled.div` overFlow: hidden; width: 620px; margin: 0 auto; padding-bottom: 100px;`;export const Header = styled.div` margin: 50px 0 20px 0; line-height: 44px; font-size: 34px; color: #333; font-weight: bold;`;export const Content = styled.div` color: #2f2f2f; img&#123; width: 100%; &#125; p&#123; margin: 25px 0; font-size: 16px; line-height: 30px; &#125;`; 在pages-detail-index.js中引入并使用组件： 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from 'react';import &#123; DetailWrapper, Header, Content,&#125; from \"./style\";class Detail extends Component &#123; render() &#123; return ( &lt;DetailWrapper&gt; &lt;Header&gt;疫情就要结束了！&lt;/Header&gt; &lt;Content&gt; &lt;img src=\"http://ww1.sinaimg.cn/large/005H7IVsgy1gcuniztyfhj30dw09tai6.jpg\" alt=\"疫情就要结束了！\" /&gt; &lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt; &lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt; &lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt; &lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt; &lt;/Content&gt; &lt;/DetailWrapper&gt; ) &#125;&#125;export default Detail; 使用redux管理数据 detail下创建store文件夹，并在该文件夹下创建： actionCreators.js：创建action以及发生AJAX请求 constants.js：将action的type转为变量 reducer.js：放置state默认数据，处理action index.js：统一对外接口 创建 reducer.js先创建reducer.js，因为创建store需要reducer。 detail-store-reducer.js： 123456789101112131415161718192021import &#123; fromJS &#125; from \"immutable\";import * as constants from \"./constants\";const defaultState = fromJS(&#123; title: \"疫情就要结束了！\", content: `&lt;img src=\"http://ww1.sinaimg.cn/large/005H7IVsgy1gcuniztyfhj30dw09tai6.jpg\" alt=\"疫情就要结束了！\" /&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;`&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125; 创建 index.jsdetail-store-index.js： 12345import reducer from \"./reducer\";import * as actionCreators from \"./actionCreators\";import * as constants from \"./constants\";export &#123; reducer, actionCreators, constants &#125;; 将detail的reducer合并进项目的reducer中src-store-reducer.js是由项目中的小的reducer组合而来，我们要将detail的reducer合并进项目的reducer中，这样才能通过store获取到state中的数据。 src-store-reducer.js： 123456789101112import &#123; combineReducers &#125; from \"redux-immutable\";import &#123; reducer as headerReducer &#125; from \"../common/header/store\";import &#123; reducer as homeReducer &#125; from \"../pages/home/store\";import &#123; reducer as detailReducer &#125; from \"../pages/detail/store\";const reducer = combineReducers(&#123; header: headerReducer, home: homeReducer, detail: detailReducer&#125;)export default reducer; 通过connect使用store中数据detail-index.js： 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from \"react-redux\";import &#123; DetailWrapper, Header, Content,&#125; from \"./style\";class Detail extends Component &#123; render() &#123; return ( &lt;DetailWrapper&gt; &lt;Header&gt;&#123;this.props.title&#125;&lt;/Header&gt; &lt;Content dangerouslySetInnerHTML=&#123;&#123; __html: this.props.content &#125;&#125;&gt;&lt;/Content&gt; &lt;/DetailWrapper&gt; ) &#125;&#125;const mapStore = (state) =&gt; (&#123; title: state.getIn([\"detail\", \"title\"]), content: state.getIn([\"detail\", \"content\"]),&#125;)export default connect(mapStore, null)(Detail); 使用dangerouslySetInnerHTML属性 dangerouslySetInnerHTML属性可使字符串中的html代码解析为html样式 在react中，通过富文本编辑器进行操作后的内容，字符串中的html代码并不能正确展示: 效果是这样的： 使用dangerouslySetInnerHTML以后： 效果如下： 原理： dangerouslySetInnerHTMl 是React组件的一个属性，类似于angular的ng-bind； 有2个{}，第一个{}代表jsx语法开始，第二个{}是代表dangerouslySetInnerHTML接收的是一个对象键值对; 既可以插入DOM，又可以插入字符串； 不合时宜的使用 innerHTML 可能会导致 cross-site scripting (XSS) 攻击。 净化用户的输入来显示的时候，经常会出现错误，不合适的净化也是导致网页攻击的原因之一。dangerouslySetInnerHTML 这个 prop 的命名是故意这么设计的，以此来警告，它的 prop 值（ 一个对象而不是字符串 ）应该被用来表明净化后的数据。 异步获取数据 之前我们将数据写死在state中，可实际上应该在Detail组件中组件加载完毕以后通过AJAX请求获取到接口的数据放置在state中。 所以我们应该在componentDidMount()函数中通过一个action发送一个AJAX请求。 而action应该在actionCreators.js中统一创建，且还要新建一个action用于将接口中获取到的数据放置在state中。 而涉及派发action的操作都应该放在connect的参数2中进行，所以我们要在connect的参数2中创建一个函数用于派发action，然后在componentDidMount函数中调用此函数来发送AJAX请求。 detail-index.js: 1import &#123; actionCreators &#125; from './store'; 模拟接口数据public-api-新建detail.json模拟接口数据: 1234567&#123; \"success\": true, \"data\": &#123; \"title\": \"疫情就要结束了！\", \"content\": \"&lt;img src='http://ww1.sinaimg.cn/large/005H7IVsgy1gcuniztyfhj30dw09tai6.jpg' alt='疫情就要结束了！' /&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;&lt;p&gt;因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...&lt;/p&gt;\" &#125;&#125; 注意：JSON中不能使用模板字符串，值必须是 双引号 包裹，所以为避免冲突，标签内部引号皆使用单引号。 创建action，发送AJAX请求，获取数据传给storedetail-store-constants.js: 1export const CHANGE_DETAIL = \"detail/CHANGE_DETAIL\"; detail-store-actionCreators.js: 12345678910111213141516171819import axios from \"axios\";import * as constants from \"./constants\";const changeDetail = (title, content) =&gt; &#123; return &#123; type: constants.CHANGE_DETAIL, title, content &#125;&#125;export const getDetail = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get(\"/api/detail.json\").then((res) =&gt; &#123; const result = res.data.data; dispatch(changeDetail(result.title, result.content)) &#125;) &#125;&#125; 注意：dispatch()会被传递到actionCreators的getDetail函数中，在该函数中也可以使用dispatch()来给store传递数据 reducer处理action，改变state数据detail-store-reducer.js:正常显示： 页面路由参数的传递 存在问题：此时虽然detail页面正常显示，但不管点击home页面的哪一篇文章，进入的都是同一个detail页面。 实际上我们应该是点击不同的博客产生的页面路由参数是不同的，然后我们在发送AJAX请求的时候带上对应的路由参数（比如id），这样后端就可以根据不同的路由参数来分配不同的数据（页面）。 实现效果：在home页点击某一条博客时，将这条博客的id带给detail页，detail页再在AJAX请求中带上id，后端根据id来分配不同的数据。 home下的list.js中，点击&lt;Link&gt;组件时访问的to属性中带上item的id作为路由参数 App.js中&lt;Route&gt;组件匹配上路径后，跳转相应页面(detail页面)。 detail-index.js中，根据this.props拿到参数id，将参数id传给发出AJAX请求的action。 actionCreators.js中，发出的AJAX请求获取的文件地址中带上参数id，这样后端就能根据请求地址中不同的id回传不同的数据了。 建议使用动态路由的方法进行路由参数的传递，比较简单。 方法1：动态路由home-component-list.js中可以看到路由地址是写死的: home页传递参数id使用动态路由使得点击时将id同时传过去： App.js修改路由匹配规则此时点击第一条数据可以看到路由带上了id，但访问不到页面了：原因：我们原本在App.js中规定了要准确匹配才能跳转Detail组件：解决方法：将path=&quot;/detail&quot;改为path=&quot;/detail/:id&quot;，说明访问detail路径下还要传一个参数名为id的参数： detail页获取参数home页中传参给了detail页，那么detail页就要 获取参数 来发出 不同地址 的AJAX请求以获取显示不同的页面。 detail-index.js中，可以通过this.props.match.params.id拿到父组件（home页）传过来的路有参数id。 detail-index.js: 可以看到this.props下的match的params中有个id对应的就是路由参数的id： detail-index.js中，getDetail方法是用于派发“发送AJAX请求”的action给store的，actionCreators的getDetail方法是发送AJAX请求的函数，所以我们可以将前端获取的id传到getDetail方法中，让请求的接口地址带上这个id，这样后端就能拿到对应博客的id，从而返回不同的内容： 结果：分别点击第一条内容和第二条内容，可以看到发出的AJAX请求地址是不同的： 方法2home页传递参数idhome-component-list.js中，修改跳转的路由地址： App.js修改路由匹配规则修改App.js以识别可以跳转Detail组件的路径 detail页获取参数 detail-index.js中找参数id的位置： 可以发现id在this.props的loaction的search中，需要进行解析提取出id的值才能使用： 解析步骤就不写了，建议使用“动态路由”，可直接拿到参数，比较简单。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"react中的dangerouslySetInnerHTML属性","slug":"react中的dangerouslySetInnerHTML属性","date":"2020-02-17T11:53:03.000Z","updated":"2020-03-17T11:54:03.356Z","comments":true,"path":"2020/02/17/react中的dangerouslySetInnerHTML属性/","link":"","permalink":"http://yoursite.com/2020/02/17/react中的dangerouslySetInnerHTML属性/","excerpt":"例子在react中，通过富文本编辑器进行操作后的内容，字符串中的html代码并不能正确展示:","text":"例子在react中，通过富文本编辑器进行操作后的内容，字符串中的html代码并不能正确展示: 保存在state中的数据：如果我们直接使用保存在state中的content：效果是这样的： 使用dangerouslySetInnerHTML以后： 效果如下： dangerouslySetInnerHTML属性作用：使字符串中的html代码解析为html样式。 使用方法语法： 1&lt;组件名 dangerouslySetInnerHTML=&#123;&#123; __html: '&lt;h1&gt;你好呀&lt;/h1&gt;' &#125;&#125;&gt;&lt;/组件名&gt; dangerouslySetInnerHTMl 是React组件的一个属性，类似于angular的ng-bind； 有2个{}，第一个{}代表jsx语法开始，第二个{}是代表dangerouslySetInnerHTML接收的是一个对象键值对; 既可以插入DOM，又可以插入字符串； 不合时宜的使用 innerHTML 可能会导致 cross-site scripting (XSS) 攻击。 净化用户的输入来显示的时候，经常会出现错误，不合适的净化也是导致网页攻击的原因之一。dangerouslySetInnerHTML 这个 prop 的命名是故意这么设计的，以此来警告，它的 prop 值（ 一个对象而不是字符串 ）应该被用来表明净化后的数据。（可参考这篇）","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"“返回顶部”功能涉及知识点","slug":"“返回顶部”功能涉及知识点","date":"2020-02-16T15:05:29.000Z","updated":"2020-03-16T15:53:16.562Z","comments":true,"path":"2020/02/16/“返回顶部”功能涉及知识点/","link":"","permalink":"http://yoursite.com/2020/02/16/“返回顶部”功能涉及知识点/","excerpt":"window.scrollTo() window.scrollTo()用于滚动到文档中的某个坐标。","text":"window.scrollTo() window.scrollTo()用于滚动到文档中的某个坐标。 语法：window.scrollTo(x-coord,y-coord ) x-coord 是文档中的横轴坐标。 y-coord 是文档中的纵轴坐标。 可参考MDN window.onscroll 事件 为当前页面的页面滚动事件添加事件处理函数。也就是只要页面滚动就会触发该事件处理函数。 语法：window.onscroll = funcRef; funcRef :函数类型的对象引用或者匿名函数. 可参考MDN 补充：普通的元素也可以使用onscroll事件 EventTarget.addEventListener() EventTarget.addEventListener() 方法将指定的监听器注册到 EventTarget 上，当该EventTarget对象触发指定的事件时，指定的回调函数就会被执行。 事件目标可以是一个文档上的元素 Element,Document和Window或者任何其他支持事件的对象 (比如 XMLHttpRequest)。 语法：element.addEventListener(event, function, useCapture) event:必须。字符串，表示监听事件类型。 注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。 function:必须。指定当事件触发时执行的函数。 事件对象会作为第一个参数传入该函数。 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象。 useCapture：可选。布尔值，指定事件是否在捕获或冒泡阶段执行。 true - 事件句柄在捕获阶段执行 false- 默认。事件句柄在冒泡阶段执行 可参考这篇笔记 window.addEventListener(“scroll”,func) window.addEventListener(&quot;scroll&quot;,func)和window.scrollTo()= func;一样，用于滚动到文档中的某个坐标。 window 对象 window 对象表示浏览器中打开的窗口。 如果文档包含框架（&lt;frame&gt; 或 &lt;iframe&gt; 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 所有浏览器都支持 window 对象。它表示浏览器窗口。 所有 JavaScript 全局对象、函数以及变量均自动成为 window 对象的成员。 全局变量是 window 对象的属性。 全局函数是 window 对象的方法。 甚至 HTML DOM 的 document 也是 window 对象的属性之一： 123window.document.getElementById(\"header\");//与此相同：document.getElementById(\"header\"); 详细 document 对象 当浏览器载入 HTML 文档, 它就会成为 Document 对象。 Document 对象是 HTML 文档的根节点。 Document 对象使我们可以从JS脚本中对 HTML 页面中的所有元素进行访问。 提示：Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问。 document.documentElement document.documentElement 是一个会返回文档对象（document）的根元素的只读属性（如HTML文档的 &lt;html&gt;元素）。 对于任何非空 HTML 文档，调用 document.documentElement 总是会返回一个 &lt;html&gt; 元素，且它一定是该文档的根元素。借助这个只读属性，能方便地获取到任意文档的根元素。 注意： 如果 HTML 元素缺失，返回值为 null。 可参考[MDN]（https://developer.mozilla.org/zh-CN/docs/Web/API/Document/documentElement） document.body document.body 属性用于设置或返回文档体。 如果是返回, 该属性返回当前文档的 &lt;body&gt; 元素。 如果是设置, 该属性会覆盖所有在 &lt;body&gt; 元素中的子元素, 并用新的内容来替换它。 注意: 与 document.documentElement 属性不同的是， document.body 属性返回 &lt;body&gt; 元素， document.documentElement 属性返回 &lt;html&gt; 元素。 Element.scrollTop Element.scrollTop 属性可以获取或设置一个元素的内容垂直滚动的像素数。 一个元素的 scrollTop 值是这个元素的内容顶部（卷起来的）到它的视口可见内容（的顶部）的距离的度量。 当一个元素的内容没有产生垂直方向的滚动条，那么它的 scrollTop 值为0。 可参考MDN document.documentElement.scrollTop document.documentElement返回&lt;html&gt;元素 Element.scrollTop可获取一个元素的内容垂直滚动的像素数。 即可使用document.documentElement.scrollTop获取当前页面的滚动条纵坐标位置(也就是&lt;html&gt;元素的内容顶部（卷起来的）到它的视口可见内容（的顶部）的距离的度量。) js实现返回顶部实例js实现返回顶部实例","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"解决router相关报错","slug":"解决router相关报错","date":"2020-02-16T13:41:10.000Z","updated":"2020-03-16T13:48:22.774Z","comments":true,"path":"2020/02/16/解决router相关报错/","link":"","permalink":"http://yoursite.com/2020/02/16/解决router相关报错/","excerpt":"报错:Link不应该在router的外部在Header组件中使用”react-router-dom”的Link组件时，报错：Error: Invariant failed: You should not use &lt;Link&gt; outside a &lt;Router&gt;也就是说Link不应该在router的外部：","text":"报错:Link不应该在router的外部在Header组件中使用”react-router-dom”的Link组件时，报错：Error: Invariant failed: You should not use &lt;Link&gt; outside a &lt;Router&gt;也就是说Link不应该在router的外部： 原因到App.js中可以看到，Header和BrowserRouter组件是并列关系，也就是说，处于Header组件中的Link组件和BrowserRouter组件是并列关系，Link也就在router的外部了： 解决方法将Header组件放入BrowserRouter组件内部: 复习关于BrowserRouter可参考这篇笔记","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"首页开发（3）","slug":"首页开发（3）","date":"2020-02-15T13:50:12.000Z","updated":"2020-03-16T13:51:04.306Z","comments":true,"path":"2020/02/15/首页开发（3）/","link":"","permalink":"http://yoursite.com/2020/02/15/首页开发（3）/","excerpt":"实现“加载更多”的换页功能实现功能: 在List.js中增加“加载更多”按钮，点击按钮后换页。","text":"实现“加载更多”的换页功能实现功能: 在List.js中增加“加载更多”按钮，点击按钮后换页。 实现 点击 加载更多： 模拟接口数据（public-api-homeList.json） 定义组件（style.js） 点击后要发送AJAX请求，AJAX请求是写在action中的（actionCreators.js） 使用组件，绑定点击事件，在事件函数中调用方法去创建并派发action（相当于发送AJAX请求）（List.js） store拿到action后打包action和state传给reducer reducer拿到action和state后去改变articleList后返回新state（reducer.js） 页面重新渲染 实现 换页： 在reducer中新增 articlePage 用于存储当前页数，初始值为1（reducer.js） 在List.js中每点击一次按钮就使articlePage+1，所以要在调用的函数中传入page 要使 articlePage+1 改变就要通过action，所以在actionCreators.js中进行设置。 使AJAX请求的接口地址上使用articlePage，这也就保证了每次请求的地址都是带有不同页数的。 要让articlePage+1就要通过action改变store中数据 reducer其实还是返回homeList.json中的模拟数据，只是方便了后端。 实现 加载更多数据定义 组件LoadMore在style.js中定义 组件LoadMore： 12345678910export const LoadMore = styled.div` width: 100%; line-height: 40px; margin: 30px 0; background: #a5a5a5; text-align: center; border-radius: 20px; color: #fff; cursor: pointer;`; 模拟接口数据在public-api下新建homeList.json文件用于模拟接口数据： 1234567891011121314151617181920212223&#123; \"sucess\": true, \"data\": [ &#123; \"id\": 4, \"title\": \"疫情就要结束了！\", \"desc\": \"因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...\", \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcuniztyfhj30dw09tai6.jpg\" &#125;, &#123; \"id\": 5, \"title\": \"在家长厨艺\", \"desc\": \"今年，大家都过了一个 长长长长长长的假期 每天朋友圈里 除了有关疫情的新闻 就是晒自己做的“黑暗料理” 在这个没有了外卖的日子里 蛋糕、奶茶、火...\", \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcunif28rwj30rs0iitzs.jpg\" &#125;, &#123; \"id\": 6, \"title\": \"大家要坚持戴口罩！\", \"desc\": \"疫情对普通人的影响，很大程度上表现为一场魔幻式的恐慌。从朋友圈疯传的段子就可以看出，最搞笑的是某宝平台上的兽用双黄莲也被抢购一空。虽然我国制度优...\", \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcunhi0u4qj30ib0au79t.jpg\" &#125; ]&#125; 使用组件，绑定点击事件List.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React, &#123; Component, Fragment &#125; from 'react';import &#123; ListItem, ListInfo, LoadMore,&#125; from \"../style\";import &#123; connect &#125; from \"react-redux\";import &#123; actionCreators &#125; from \"../store\"class List extends Component &#123; render() &#123; const &#123; list, getMoreList &#125; = this.props; return ( &lt;Fragment&gt; &#123; list.map((item, index) =&gt; &#123; return ( &lt;ListItem key=&#123;index&#125;&gt; &lt;img className=\"pic\" src=&#123;item.get(\"imgUrl\")&#125; alt=&#123;item.get(\"title\")&#125; /&gt; &lt;ListInfo&gt; &lt;h3 className=\"title\"&gt;&#123;item.get(\"title\")&#125;&lt;/h3&gt; &lt;p className=\"desc\"&gt;&#123;item.get(\"desc\")&#125;&lt;/p&gt; &lt;/ListInfo&gt; &lt;/ListItem&gt; ) &#125;) &#125; &lt;LoadMore onClick=&#123;getMoreList&#125;&gt;加载更多&lt;/LoadMore&gt; &lt;/Fragment&gt; ) &#125;&#125;const mapState = (state) =&gt; (&#123; list: state.getIn([\"home\", \"articleList\"])&#125;)const mapDispatch = (dispatch) =&gt; (&#123; getMoreList() &#123; dispatch(actionCreators.getMoreList()); &#125;&#125;)export default connect(mapState, mapDispatch)(List); 在List.js中引入并使用 组件LoadMore，绑定点击事件，点击以后我们是要发送AJAX请求获取数据的，获取到的数据改变state中数据让页面重新渲染 AJAX请求要放到action中，在actionCreators.js中新建getMoreList()用于创建 发送AJAX请求的action,新建addHomeList()用于创建 改变store中数据的action。 要派发action给store就要在connect方法的参数2（回调函数）中新建函数getMoreList()用于派发action 事件绑定函数中只需调用函数getMoreList()即可完成AJAX的发送 创建2个actionactionCreators.js中添加以下代码，创建发送AJAX请求和改变state数据的action: 1import &#123; fromJS &#125; from \"immutable\"; 1234567891011const addHomeList = (list) =&gt; (&#123; type: constants.ADD_HOME_List, list: fromJS(list)&#125;)export const getMoreList = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get(\"/api/homeList.json\").then((res) =&gt; &#123; const result = res.data.data; dispatch(addHomeList(result)); &#125;) &#125; 新建getMoreList()用于创建 发送AJAX请求的action 新建addHomeList()用于创建 改变store中数据的action。 用于改变store中的数据的数据也必须是immutable类型的。 immutable提供的fromJS()和List()都可以使普通数组转换为immutable数组。 但是List只能使数组变immutable，数组元素若为对象，则还是普通对象。fromJS()是将数组元素也immutable化的。 reducer处理articleListreducer接收到action后,使用concat()将 articleList变成合并了新数据后的数组,返回给state: 12case constants.ADD_HOME_List: return state.set(\"articleList\", state.get(\"articleList\").concat(action.list)) 实现 换页reducer新增articlePage管理当前页码 在reducer中给state新增一个默认数据articlePage:1,默认起始页为1，接下来每点击一次“加载更多”就使articlePage+1123456const defaultState = fromJS(&#123; topicList: [], articleList: [], recommendList: [], articlePage:1,&#125;); List中获取articlePage传给action使用在List.js中获取articlePage: 1234const mapState = (state) =&gt; (&#123; list: state.getIn([\"home\", \"articleList\"]), page: state.getIn([\"home\", \"articlePage\"])&#125;) 调用点击事件绑定函数getMoreList()时传入articlePage: 1const &#123; list, page, getMoreList &#125; = this.props; 1&lt;LoadMore onClick=&#123;() =&gt; getMoreList(page)&#125;&gt;加载更多&lt;/LoadMore&gt; getMoreList()拿到page后传给 actionCreators.js中的getMoreList(): 12345const mapDispatch = (dispatch) =&gt; (&#123; getMoreList(page) &#123; dispatch(actionCreators.getMoreList(page)); &#125;&#125;) actionCreators中page+1actionCreators.js中，在请求后端接口数据时加上page（&quot;/api/homeList.json?page=&quot; + page） 12345678export const getMoreList = (page) =&gt; &#123; return (dispatch) =&gt; &#123; axios.get(\"/api/homeList.json?page=\" + page).then((res) =&gt; &#123; const result = res.data.data; dispatch(addHomeList(result)); &#125;) &#125;&#125; 可以看到每次点击“加载更多”请求的都是第一页：把page也通过addHomeList reducer处理articlePageaction传递了nextPage，reducer就将接收到的nextPage放到state中替换掉articlePage，则每一次点击后请求的接口都带有不同的页数： 12345case constants.ADD_HOME_List: return state.merge(&#123; \"articleList\": state.get(\"articleList\").concat(action.list), \"articlePage\": action.nextPage &#125;) 这样一来每次点击请求的页码都不同： 注意后端拿到不同的页码就可以返回不同的数据了。(但实际上我们每次返回的还是homeList.json中的模拟数据) 实现 返回顶部 功能 在home-index.js中我们实现一个点击以后返回顶部的按钮。 style.js中定义组件BackTop由于是一直在右下角的，所以该按钮是固定定位的: 12345678910export const BackTop = styled.div` position: fixed; right: 100px; bottom: 100px; width: 60px; line-height: 60px; text-align: center; border: 1px solid #ccc; font-size: 14px;`; home-index.js中使用BackTop BackTop绑定点击事件要想让按钮点击回到顶部，就需要给他绑定点击事件： 1&lt;BackTop onClick=&#123;this.handleScrollTop&#125;&gt;返回顶部&lt;/BackTop&gt; 由于此时和reducer并不关系，只是单纯回到顶部，所以只需要在Home组件中书写函数即可: 123handleScrollTop() &#123; window.scrollTo(0, 0);&#125; 我们需要借助window.scrollTo()方法把内容滚动到指定的坐标。scrollTo(x 坐标,y 坐标) 下滑到一定位置再显示该按钮实现功能：此时按钮一直显示在页面上，我们要实现下滑到一定位置再显示该按钮。 在reducer中添加showScroll:false默认不显示按钮： 到home-index.js中拿到数据showScroll： 使用三元运算符来根据showScroll决定是否显示按钮： 使用addEventListener()监听onScroll事件,元素滚动条在滚动时就触发 changeScrollTopShow(): 在 changeScrollTopShow()中根据document.documentElement.scrollTop得到滚动距离：由于我们需要通过改变store中数据来决定是否显示按钮，所以函数changeScrollTopShow要放在connect的参数2中。 在changeScrollTopShow()中设置判断，滚动距离顶部距离大于400才显示，否则隐藏按钮，要修改store中数据就要派发action，所以需要在 actionCreators.js中创建对应action： 在reducer中处理action： 注意：在home组件中给window绑定了一个事件，那么移除home组件时要记得解绑： 优化代码将修改state中数据的代码拿出来放在函数里，在switch…case中通过调用函数对state进行修改，精简switch…case的代码： 首页性能优化（PureComponent） 我们在首页所有组件都使用connect与store做了链接，这也就导致只要store发生改变，那么每个组件都会被重新渲染，也就是render函数会被重新执行，也就是说不管更新的数据和本组件是否有关系，本组件都会重新渲染，这样就导致性能不高。 解决方法： 所以可以使用 shouldCompUpdate()优化代码，判断只有和本组件有关的数据更新时，本组件的render函数才执行，否则return false不让组件重新渲染。通过避免虚拟DOM的比对来提高性能。 但是手写shouldCompUpdate太过麻烦，所以我们可以使用react提供的PureComponent 前提条件：必须使用immutable管理数据才能使用PureComponent，否则坑很多。 在首页index.js及其内部组件中都使用PureComponent代替Component： 路由跳转（react-router-dom的Link组件） 使用react-router-dom的Link组件帮助进行页面跳转，Link组件类似a标签，to属性类似a标签的href属性。 使用Link组件可使页面跳转时不发送另一个http请求，提升加载速度，提高性能。 注意：react是 单页应用的跳转，也就是说，不管怎么进行页面跳转，整个网站只会加载一次html文件，这也就决定了不能使用&lt;a&gt;标签进行页面跳转。 如果使用&lt;a&gt;标签进行页面跳转，跳转时会发送HTTP请求。 而借助react-router-dom的Link组件实现跳转则不会，因此加载速度会快很多，借此也可提高性能。 首页到详情页希望点击博客时可跳转到详情页： 在List.js中引入react-router-dom的Link组件： 1import &#123; Link &#125; from \"react-router-dom\"; 可以看到跳转时并没有发送另一个HTTP请求： 详情页到首页实现功能：点击Logo从详情页跳转到首页。 在common-header-styles.js中，原本我们的Logo组件使用的是a标签，现在改成div： 1234567891011export const Logo = styled.div` position:absolute; display:block; top:0; left:0; height:56px; width:100px; background:url($&#123;LogoPic&#125;); // contain：把x轴拉满，y轴够长的话会平铺重复显示图片 background-size:contain;`; 在common-header-index.js中引入并使用Link组件包裹Logo组件，使之可跳转首页: 1import &#123; Link &#125; from \"react-router-dom\"; 123&lt;Link to=\"/\"&gt; &lt;Logo /&gt;&lt;/Link&gt; 此时会报错：Error: Invariant failed: You should not use &lt;Link&gt; outside a &lt;Router&gt;也就是说Link不应该在router的外部：（关于Router组件可复习这篇笔记）到App.js中可以看到，Header和BrowserRouter组件是并列关系，也就是说，处于Header组件中的Link组件和BrowserRouter组件是并列关系，Link也就在router的外部了：解决方法：将Header组件放入BrowserRouter组件内部:","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"首页开发（2）","slug":"首页开发（2）","date":"2020-02-14T15:26:44.000Z","updated":"2020-03-15T15:27:35.712Z","comments":true,"path":"2020/02/14/首页开发（2）/","link":"","permalink":"http://yoursite.com/2020/02/14/首页开发（2）/","excerpt":"文章列表的制作（List.js）文章列表也就是home-components-List.js中的 List组件：","text":"文章列表的制作（List.js）文章列表也就是home-components-List.js中的 List组件： 步骤类似Topc组件： 在home-style.js中，定义List组件需要的样式 在List.js中，使用组件进行布局 在home-store-reducer.js中，存储ListItem中需要的数据 在List.js中，读取reducer中存储在state里的数据，循环渲染为ListItem组件 代码home-style.js中,定义List组件需要的样式： 1234567891011121314151617181920212223242526export const ListItem = styled.div` display: flow-root; padding: 20px 0; border-bottom: 1px solid #dcdcdc; .pic &#123; float: right; width: 125px; height: 100px; border-radius: 10px; &#125;`;export const ListInfo = styled.div` width: 500px; .title &#123; line-height: 27px; font-size: 18px; font-weight: bold; color: #333; &#125; .desc &#123; line-height: 24px; font-size: 13px; color: #999; &#125;`; home-store-reducer.js中,存储ListItem中需要的数据，在defaultState中增加articleList数组： 123456789101112131415161718192021222324252627const defaultState = fromJS(&#123; topicList:[&#123; id:1, title:\"社会热点\", imgUrl: \"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" &#125;,&#123; id:2, title:\"手绘\", imgUrl: \"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" &#125;], articleList:[&#123; id:1, title:\"疫情就要结束了！\", dexc: \"因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...\", imgUrl: \"https://upload-images.jianshu.io/upload_images/14964218-bbc6a0ef3f52889e.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/360/h/240\" &#125;,&#123; id:2, title:\"在家长厨艺\", dexc: \"今年，大家都过了一个 长长长长长长的假期 每天朋友圈里 除了有关疫情的新闻 就是晒自己做的“黑暗料理” 在这个没有了外卖的日子里 蛋糕、奶茶、火...\", imgUrl: \"https://upload-images.jianshu.io/upload_images/19325519-7ffb94bacd4ff304?imageMogr2/auto-orient/strip|imageView2/1/w/300/h/240\" &#125;,&#123; id:3, title:\"大家要坚持戴口罩！\", dexc: \"疫情对普通人的影响，很大程度上表现为一场魔幻式的恐慌。从朋友圈疯传的段子就可以看出，最搞笑的是某宝平台上的兽用双黄莲也被抢购一空。虽然我国制度优...\", imgUrl: \"https://upload-images.jianshu.io/upload_images/19972340-9a06362a842656a2.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/300/h/240\" &#125;]&#125;); List.js中,读取reducer中存储在state里的数据，循环渲染为ListItem组件: 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component, Fragment &#125; from 'react';import &#123; ListItem, ListInfo,&#125; from \"../style\";import &#123; connect &#125; from \"react-redux\";class List extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &#123; this.props.list.map((item) =&gt; &#123; return ( &lt;ListItem key=&#123;item.get(\"id\")&#125;&gt; &lt;img className=\"pic\" src=&#123;item.get(\"imgUrl\")&#125; alt=&#123;item.get(\"title\")&#125; /&gt; &lt;ListInfo&gt; &lt;h3 className=\"title\"&gt;&#123;item.get(\"title\")&#125;&#125;&lt;/h3&gt; &lt;p className=\"desc\"&gt;&#123;item.get(\"desc\")&#125;&#125;&lt;/p&gt; &lt;/ListInfo&gt; &lt;/ListItem&gt; ) &#125;) &#125; &lt;/Fragment&gt; ) &#125;&#125;const mapState = (state) =&gt; (&#123; list: state.getIn([\"home\", \"articleList\"])&#125;)export default connect(mapState, null)(List); 样式属性值可从使用组件（props）传递 style.js样式的属性值可以是从使用组件中传递过来的属性值，这样使用同一个样式组件时可以通过传递不同的属性值达到不同的效果。 在style.js中，使用 模板字符串 中的${(props)=&gt;props.属性名}来设置样式属性值 在使用组件时，通过&lt;组件名 属性名={属性值}&gt;&lt;/组件名&gt;将 属性值 传到style.js中作为 样式属性值 例子如下 RecommendItem组件 的background样式属性值就是由使用组件时传入的imgUrl属性值决定的。 可参考官网的实例 推荐部分的编写（Recommend.js）推荐部分也就是home-components-Recommend.js中的 Recommend组件： 步骤： 在home-style.js中，定义Recommend组件需要的样式 在 Recommend.js中，使用组件进行布局 在home-store-reducer.js中，存储Recommend中需要的数据 在 Recommend.js中，读取reducer中存储在state里的数据，循环渲染为RecommendItem组件 代码style.js: 1234567891011export const RecommendWrapper = styled.div` margin: 30px 0; width: 280px;`;export const RecommendItem = styled.div` width: 280px; height: 50px; background: url($&#123;(props)=&gt;(props.imgUrl)&#125;); background-size: contain;`; Recommend.js: 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from \"react-redux\";import &#123; RecommendWrapper, RecommendItem&#125; from \"../style\";class Recommend extends Component &#123; render() &#123; return ( &lt;RecommendWrapper&gt; &#123; this.props.list.map((item) =&gt; &#123; return ( &lt;RecommendItem imgUrl=&#123;item.get(\"imgUrl\")&#125; key=&#123;item.get(\"id\")&#125; &gt;&lt;/RecommendItem&gt; ) &#125;) &#125; &lt;/RecommendWrapper&gt; ) &#125;&#125;const mapState = (state) =&gt; (&#123; list: state.getIn([\"home\", \"recommendList\"])&#125;)export default connect(mapState, null)(Recommend); reducer.js中增加： 1234567recommendList: [&#123; id: 1, imgUrl: \"https://cdn2.jianshu.io/assets/web/banner-s-club-aa8bdf19f8cf729a759da42e4a96f366.png\"&#125;, &#123; id: 2, imgUrl: \"https://cdn2.jianshu.io/assets/web/banner-s-7-1a0222c91694a1f38e610be4bf9669be.png\"&#125;], Writer.js的编写思路其实还是差不多的。 style.js中增加: 1234567export const WriterWrapper = styled.div` width: 278px; border: 1px solid #dcdcdc; border-radius: 3px; line-height: 300px; text-align: center;`; Writer.js： 123456789101112import React, &#123; Component &#125; from 'react';import &#123; WriterWrapper &#125; from \"../style\";class Writer extends Component &#123; render() &#123; return ( &lt;WriterWrapper&gt;Writer~&lt;/WriterWrapper&gt; ) &#125;&#125;export default Writer; 异步获取首页数据 之前我们的数据都是放在前端reducer之中的，可实际上是应该通过接口从后端获取数据的。 所以我们需要： 在public-api文件夹下新建home.json文件，将模拟的接口数据放在json文件中 注意：JSON中除了boolean和数字、null，其他都要加双引号 在home-index.js（首页）中，页面加载完毕后，发送AJAX请求获取接口数据 通过connect的参数2的回调函数将获取到的数据通过dispatch派发到store中，store中的数据改变，页面自然重新渲染 思路：修改store中数据=&gt;需派发action=&gt;在react-redux中使用connect方法的参数2的dispatch home-reducer.js中处理store传送过来的action和state，将获取到的数据放入store中，state数据发生变化，页面自然重新渲染 注意： action被派发后，大的小的reducer都能接收到 使用set()修改immutable对象的方法时，必须保证替换的数据也是immutable类型的，如若不是，则可使用fromJS()将普通JS对象改为immutable对象 一开始的初始数据还是要给空数组，不能全部删除。 json文件模拟接口数据注意：JSON中除了boolean和数字、null，其他都要加双引号 public-api-home.json： 12345678910111213141516171819202122232425262728293031323334353637&#123; \"sucess\":true, \"data\":&#123; \"topicList\": [&#123; \"id\": 1, \"title\": \"社会热点\", \"imgUrl\": \"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" &#125;, &#123; \"id\": 2, \"title\": \"手绘\", \"imgUrl\": \"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" &#125;], \"articleList\": [&#123; \"id\": 1, \"title\": \"疫情就要结束了！\", \"desc\": \"因为一个人，人民摘掉口罩的愿望可能成为了泡影，学生返校，工人正常复工的时间可能又要推迟。一个人的不重视，就可能会导致全国人民努力白费。我不知道为...\", \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcuniztyfhj30dw09tai6.jpg\" &#125;, &#123; \"id\": 2, \"title\": \"在家长厨艺\", \"desc\": \"今年，大家都过了一个 长长长长长长的假期 每天朋友圈里 除了有关疫情的新闻 就是晒自己做的“黑暗料理” 在这个没有了外卖的日子里 蛋糕、奶茶、火...\", \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcunif28rwj30rs0iitzs.jpg\" &#125;, &#123; \"id\": 3, \"title\": \"大家要坚持戴口罩！\", \"desc\": \"疫情对普通人的影响，很大程度上表现为一场魔幻式的恐慌。从朋友圈疯传的段子就可以看出，最搞笑的是某宝平台上的兽用双黄莲也被抢购一空。虽然我国制度优...\", \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcunhi0u4qj30ib0au79t.jpg\" &#125;], \"recommendList\": [&#123; \"id\": 1, \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcunpxdxm5j30fk02sgli.jpg\" &#125;, &#123; \"id\": 2, \"imgUrl\": \"http://ww1.sinaimg.cn/large/005H7IVsgy1gcunq7zbr1j30fk02s3yi.jpg\" &#125;] &#125;&#125; 首页发送AJAX请求，获取数据传到store home-index.js（首页）中，页面加载完毕后，发送AJAX请求获取接口数据。 通过connect的参数2的回调函数将获取到的数据通过dispatch派发到store中，store中的数据改变，页面自然重新渲染 思路：修改store中数据=&gt;需派发action=&gt;在react-redux中使用connect方法的参数2的dispatch home-index.js： 12import axios from \"axios\";import &#123; connect &#125; from \"react-redux\"; 中间未改动部分省略 123456789101112131415161718192021 componentDidMount() &#123; axios.get(\"/api/home.json\").then((res) =&gt; &#123; const result = res.data.data; const action = &#123; type: \"change_home_data\", topicList: result.topicList, articleList: result.articleList, recommendList: result.recommendList &#125; this.props.changeHomeData(action); &#125;) &#125;&#125;const mapDisoatch = (dispatch) =&gt; (&#123; changeHomeData(action) &#123; dispatch(action); &#125;&#125;);export default connect(null, mapDisoatch)(Home); reducer处理数据home-reducer.js中处理store传送过来的action和state，将获取到的数据放入store中，state数据发生变化，页面自然重新渲染 注意： action被派发后，大的小的reducer都能接收到 使用set()修改immutable对象的方法时，必须保证替换的数据也是immutable类型的，如若不是，则可使用fromJS()将普通JS对象改为immutable对象 一开始的初始数据还是要给空数组，不能全部删除。 home-reducer.js： 1234567891011121314151617181920import &#123; fromJS &#125; from \"immutable\";const defaultState = fromJS(&#123; topicList: [], articleList: [], recommendList: [],&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case \"change_home_data\": return state.merge(&#123; topicList:fromJS(action.topicList), articleList:fromJS(action.articleList), recommendList:fromJS(action.recommendList) &#125;) default: return state; &#125;&#125; 异步操作代码拆分优化 home-index.js中的Home组件是UI组件，所以逻辑操作不应该放在Home组件中，我们可以将逻辑操作放到mapDisoatch方法中 AJAX请求可以使用redux-thunk中间件放在action中 home-store中新建actionCreators.js用于统一创建action，index.js作为唯一出口。 home-store中新建constants.js用于将action中的type值从字符串变为常量。 修改home-reducer.js中的type值 统一管理action的type值home-store中新建constants.js用于将action中的type值从字符串变为常量： 1export const CHANGE_HOME_DATA = \"change_home_data\"; index.js作为唯一出口: 1234import reducer from \"./reducer\";import * as constants from \"./constants\";export &#123; reducer, constants &#125;; 统一创建action（redux-thunk）home-store中新建actionCreators.js用于统一创建action。使用redux-thunk中间件，可使AJAX请求放在action中： 123456789101112131415161718import axios from \"axios\";import * as constants from \"./constants\";const changeHomeData = (result) =&gt; (&#123; type: constants.CHANGE_HOME_DATA, topicList: result.topicList, articleList: result.articleList, recommendList: result.recommendList&#125;)export const getHomeInfo = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get(\"/api/home.json\").then((res) =&gt; &#123; const result = res.data.data; dispatch(changeHomeData(result)); &#125;) &#125;&#125; index.js作为唯一出口: 12345import reducer from \"./reducer\";import * as actionCreators from \"./actionCreators\";import * as constants from \"./constants\";export &#123; reducer, actionCreators, constants &#125;; 逻辑放到容器组件的函数中home-index.js中,原本我在componentDidMount()中发送AJAX请求，现在将AJAX请求放到action中，在mapDispatch()中的changeHomeData()内创建并派发此action，在componentDidMount()中只需调用changeHomeData()即可发送AJAX请求： 1import &#123; actionCreators &#125; from \"./store\"; 123componentDidMount() &#123; this.props.changeHomeData();&#125; 123456const mapDisoatch = (dispatch) =&gt; (&#123; changeHomeData() &#123; const action = actionCreators.getHomeInfo(); dispatch(action); &#125;&#125;); 修改reducer的type值修改home-reducer.js中的type值： 123456789101112131415161718192021import &#123; fromJS &#125; from \"immutable\";import * as constants from \"./constants\";const defaultState = fromJS(&#123; topicList: [], articleList: [], recommendList: [],&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case constants.CHANGE_HOME_DATA: return state.merge(&#123; topicList:fromJS(action.topicList), articleList:fromJS(action.articleList), recommendList:fromJS(action.recommendList) &#125;) default: return state; &#125;&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JS Web API DOM(2)","slug":"JS Web API DOM(2)","date":"2020-02-14T04:56:45.000Z","updated":"2020-03-15T04:57:34.111Z","comments":true,"path":"2020/02/14/JS Web API DOM(2)/","link":"","permalink":"http://yoursite.com/2020/02/14/JS Web API DOM(2)/","excerpt":"DOM性能 DOM操作非常“昂贵”，占用CPU比较多，因为他可能会导致页面的回流、重绘，reflow和repain过程是非常消耗性能的,要尽量避免频繁的DOM操作。","text":"DOM性能 DOM操作非常“昂贵”，占用CPU比较多，因为他可能会导致页面的回流、重绘，reflow和repain过程是非常消耗性能的,要尽量避免频繁的DOM操作。 可以通过以下方法提高DOM性能：对DOM查询做缓存、将频繁操作改为一次性操作 对DOM查询做缓存如果每次循环都查询一次DOM，会很消耗性能。所以我们可以先查询出p节点的nodeList，将其缓存在变量pList中，接下来的操作也就不需要反复查询DOM了。 将频繁操作改为一次性操作假如现在要往id为list的ul标签中插入10个li标签，按照以前的操作，我们会分10次使用appendChild()进行子节点添加：这样频繁操作DOM是很消耗性能的。 我们可以通过createDocumentFragment()先创建一个文档片段，这个文档片段是保存在JS中的（不是在DOM树中），然后将循环10次产生的子节点都添加到文档片段中，最后再将 文档片段 添加到DOM树上： 相关问题DOM是哪种数据结构树（DOM树），基于树状结构才有了父节点、子节点。 DOM操作的常用API DOM节点操作： 获取1个DOM元素：getElementByld()/querySelector() 获取多个DOM元素（nodeList集合）：getElementsByTagName()/getElementsByClassName()/querySelectorAll() DOM结构操作： document.createElement()创建 元素节点 document.createTextNode() 创建 文本节点 Node.appendChild() 添加/移动 子节点 Node.removeChild() 删除 子节点 attribute和property的操作： getAttribute()获取attribute setAttribute()修改attribute removeAttribute()删除attribute createAttribute()仅建立一个attribute attribute和property的区别 attribute：修改html属性，会改变html结构 attribute 是 DOM元素 在文档中作为 html 标签拥有的属性 property：修改JS对象属性，不会体现到html结构中 property 是 DOM元素 在 js 中作为对象拥有的属性 两者都有可能引起DOM重新渲染，但建议尽量使用property HTML attribute(特性) DOM property(属性) 值永远是字符串或 null 值可以是任意合法 js 类型 大小写不敏感 大小写敏感 不存在时返回 null 不存在时返回 undefined 对于 href, 返回 html 设置的值 对于 href 返回解析后的完整 url 更新 value, 属性也更新 更新 value, 特性不更新 （可参考这篇博客） 一次性插入多个DOM节点，考虑性能将频繁操作改为一次性操作： 通过createDocumentFragment()先创建一个文档片段，这个文档片段是保存在JS中的（不是在DOM树中） 将循环10次产生的子节点都添加到文档片段中 将 文档片段 添加到DOM树上：","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"styled-components的使用方法","slug":"styled-components的使用方法","date":"2020-02-13T13:13:07.000Z","updated":"2020-03-13T13:13:55.289Z","comments":true,"path":"2020/02/13/styled-components的使用方法/","link":"","permalink":"http://yoursite.com/2020/02/13/styled-components的使用方法/","excerpt":"styled-components styled-components是一个React的第三方库，是CSS in JS的优秀实践。","text":"styled-components styled-components是一个React的第三方库，是CSS in JS的优秀实践。 顾名思义，styled-components 以组件的形式来声明样式，让样式也成为组件从而分离逻辑组件与展示组件。 styled-components 通过 模板字符串 来设置组件样式，它移除了组件和样式之间的映射。 当我们通过styled-components定义样式时,我们实际上是创建了一个附加了样式的常规 React 组件。 可参考官方文档以及中文文档 CSS与CSS in JS CSS的缺点： 全局污染：CSS 选择器的作用域是全局的，所以很容易引起选择器冲突；而为了避免全局冲突，又会导致类命名的复杂度上升 复用性低：CSS 缺少抽象的机制，选择器很容易出现重复，不利于维护和复用 CSS in JS：随着组件化时代的来临，前端应用开始从组件的层面对 CSS 进行封装。 也就是通过 JS 来声明样式、抽象样式从而提高组件的可维护性 在组件加载时动态的加载样式，动态生成类名从而避免全局污染。 安装styled-components项目中： 1yarn add styled-components 使用styled-components（例子可看官方文档） 在style.js中定义样式组件 在需要使用组件的js文件中引入style.js，即可正常使用。 例子通过styled在h1的基础上创建了Title组件，在section的基础上创建了Wrapper组件，然后使用这两个组件： 1234567891011121314151617181920// Create a Title component that'll render an &lt;h1&gt; tag with some stylesconst Title = styled.h1` font-size: 1.5em; text-align: center; color: palevioletred;`;// Create a Wrapper component that'll render a &lt;section&gt; tag with some stylesconst Wrapper = styled.section` padding: 4em; background: papayawhip;`;// Use Title and Wrapper like any other React component – except they're styled!render( &lt;Wrapper&gt; &lt;Title&gt; Hello World! &lt;/Title&gt; &lt;/Wrapper&gt; 通过props在使用样式组件时调整样式 style.js样式的属性值可以是从使用组件中传递过来的属性值，这样使用同一个样式组件时可以通过传递不同的属性值达到不同的效果。 在style.js中，使用 模板字符串 中的${(props)=&gt;props.属性名}来设置样式属性值 在使用组件时，通过&lt;组件名 属性名={属性值}&gt;&lt;/组件名&gt;将 属性值 传到style.js中作为 样式属性值 例子下面这个 Button 组件上有一个可以改变color的primary属性，将其设置为 ture 时,组件的background-color和color会交换： 1234567891011121314151617const Button = styled.button` background: $&#123;props =&gt; props.primary ? \"palevioletred\" : \"white\"&#125;; color: $&#123;props =&gt; props.primary ? \"white\" : \"palevioletred\"&#125;; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;render( &lt;div&gt; &lt;Button&gt;Normal&lt;/Button&gt; &lt;Button primary&gt;Primary&lt;/Button&gt; &lt;/div&gt;); styled()样式继承 创建新组件 希望使用某个经常使用的 自定义组件,在特定场景下可以稍微更改其样式.当然我们可以通过 props 传递插值的方式来实现,但是对于某个只需要重载一次的样式来说这样做的成本还是有点高. 此时可以创建一个继承其它组件样式的新组件，最简单的方式就是用构造函数styled()包裹被继承的组件. 下面的示例就是通过继承上一节创建的按钮从而实现一些颜色相关样式的扩展:12345678910111213141516171819202122// The Button from the last section without the interpolationsconst Button = styled.button` color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px;`;// A new component based on Button, but with some override stylesconst TomatoButton = styled(Button)` color: tomato; border-color: tomato;`;render( &lt;div&gt; &lt;Button&gt;Normal Button&lt;/Button&gt; &lt;TomatoButton&gt;Tomato Button&lt;/TomatoButton&gt; &lt;/div&gt;); 新的TomatoButton仍然和我们自定义的Button类似,我们只是添加了两条规则： as动态修改元素 使用as可使一个样式组件依赖于不同的元素。 在某些情况下，可能希望更改 自定义样式组件 所依赖的元素。 比如，构建导航栏时，有链接和按钮的混合，但是它们的样式应该是相同的。 那么如何使用相同的样式组件代表不同的元素呢？可以使用as，as可以动态地交换出元素，接收你写的样式1234567891011121314151617181920212223const Button = styled.button` display: inline-block; color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px; display: block;`;const TomatoButton = styled(Button)` color: tomato; border-color: tomato;`;render( &lt;div&gt; &lt;Button&gt;Normal Button&lt;/Button&gt; &lt;Button as=\"a\" href=\"/\"&gt;Link with Button styles&lt;/Button&gt; &lt;TomatoButton as=\"a\" href=\"/\"&gt;Link with Tomato Button styles&lt;/TomatoButton&gt; &lt;/div&gt;); as也可让样式组件用于修饰样式组件12345678910111213141516171819const Button = styled.button` display: inline-block; color: palevioletred; font-size: 1em; margin: 1em; padding: 0.25em 1em; border: 2px solid palevioletred; border-radius: 3px; display: block;`;const ReversedButton = props =&gt; &lt;Button &#123;...props&#125; children=&#123;props.children.split('').reverse()&#125; /&gt;render( &lt;div&gt; &lt;Button&gt;Normal Button&lt;/Button&gt; &lt;Button as=&#123;ReversedButton&#125;&gt;Custom Button with Normal Button styles&lt;/Button&gt; &lt;/div&gt;); &amp;伪元素,伪类选择器，组合选择器和嵌套 styled-component使用的预处理程序stylis 支持类似于scss的语法来自动嵌套样式。 与号&amp;可以用来引用主组件。 下面是一些关于它潜在用法的例子:1234567891011121314151617181920212223242526272829303132333435363738394041const Thing = styled.div.attrs((/* props */) =&gt; (&#123; tabIndex: 0 &#125;))` color: blue;// &lt;Thing&gt; 的 伪类选择器，当鼠标移上时字变红 &amp;:hover &#123; color: red; &#125;//&lt;Thing&gt; 的 所有同级选择器，背景色变红 &amp; ~ &amp; &#123; background: tomato; &#125;//&lt;Thing&gt; 的 直接相邻的同级选择器,背景变绿 &amp; + &amp; &#123; background: lime; &#125;//拥有className为something的&lt;Thing&gt; （注意这里没有空格） &amp;.something &#123; background: orange; &#125;// &lt;Thing&gt;在另一个标签为\".something-else\"的元素中 .something-else &amp; &#123; border: 1px solid; &#125;`render( &lt;React.Fragment&gt; &lt;Thing&gt;Hello world!&lt;/Thing&gt; &lt;Thing&gt;How ya doing?&lt;/Thing&gt; &lt;Thing className=\"something\"&gt;The sun is shining...&lt;/Thing&gt; &lt;div&gt;Pretty nice day today.&lt;/div&gt; &lt;Thing&gt;Don't you think?&lt;/Thing&gt; &lt;div className=\"something-else\"&gt; &lt;Thing&gt;Splendid.&lt;/Thing&gt; &lt;/div&gt; &lt;/React.Fragment&gt;) 如果只写选择器而不带&amp;,则指向组件的子节点： 12345678910111213141516const Thing = styled.div` color: blue;//&lt;Thing&gt;的子元素中带有className为something的子元素 .something &#123; border: 1px solid; display: block; &#125;`render( &lt;Thing&gt; &lt;label htmlFor=\"foo-button\" className=\"something\"&gt;Mystery button&lt;/label&gt; &lt;button id=\"foo-button\"&gt;What do I do?&lt;/button&gt; &lt;/Thing&gt;) attrs给组件附加额外的属性 可参考官方文档 比如用于在style.js中给a标签添加href属性const Logo = styled.a.attrs({href:/}),相当于在index.js中的&lt;Logo href=&quot;/&quot; /&gt;。 为了避免仅为传递一些props来渲染组件或元素而使用不必要的wrapper, 可以使用 .attrs ,通过.attrs可以添加额外的 props 或 attributes 到组件 注意：不一定是新属性，也可以使用.attrs给组件设置原生的属性，比如input的placeholder或者type attrs是一种可链接的方法，可通过attrs将 静态属性/动态属性 附加到样式化的组件上。attrs接受的唯一参数是一个对象/函数，对象/函数的返回值 将被合并到组件的其余props中。 例子12345678910111213141516171819202122232425const Input = styled.input.attrs(props =&gt; (&#123; // 静态属性 type: \"password\", // 动态属性，存在size则用size size: props.size || \"1em\",&#125;))`//注意，这里开始才设置样式 color: palevioletred; font-size: 1em; border: 2px solid palevioletred; border-radius: 3px; /* here we use the dynamically computed prop */ margin: $&#123;props =&gt; props.size&#125;; padding: $&#123;props =&gt; props.size&#125;;`;render( &lt;div&gt; &lt;Input placeholder=\"A small text input\" size=\"1em\" /&gt; &lt;br /&gt; &lt;Input placeholder=\"A bigger text input\" size=\"2em\" /&gt; &lt;/div&gt;); 动画 虽然使用@keyframes的 CSS 动画不限于单个组件,但我们仍希望它们不是全局的(以避免冲突). 这就是为什么 styled-components 导出 keyframes helper 的原因: 它将生成一个可以在 APP 应用的唯一实例. 可参考官方文档 用于React-Native styled-components 可以在 React-Native 中以同样的方式使用 注意:react-native不支持 keyframes. 可参考官方文档","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JS Web API DOM(1)","slug":"JS Web API DOM(1)","date":"2020-02-13T09:05:51.000Z","updated":"2020-08-10T09:01:55.745Z","comments":true,"path":"2020/02/13/JS Web API DOM(1)/","link":"","permalink":"http://yoursite.com/2020/02/13/JS Web API DOM(1)/","excerpt":"从JS基础到JS Web API JS基础知识用于规定语法（ECMA 262标准） JS基础包括：变量的类型和计算、原型和原型链、作用域和闭包。 JS Web API是网页操作的API（W3C标准） JS Web API包括：DOM、BOM、事件绑定、AJAX、存储。 JS基础知识 是 JS Web API 的基础，两者结合才能应用于实际。","text":"从JS基础到JS Web API JS基础知识用于规定语法（ECMA 262标准） JS基础包括：变量的类型和计算、原型和原型链、作用域和闭包。 JS Web API是网页操作的API（W3C标准） JS Web API包括：DOM、BOM、事件绑定、AJAX、存储。 JS基础知识 是 JS Web API 的基础，两者结合才能应用于实际。 DOM DOM操作，即Document Object Model（文件对象模型） 注意： vue和React框架都封装了DOM操作（也就是你不会直接操作DOM）。但DOM操作一直都会是前端工程师的基础、必备知识。 相关问题：DOM是哪种数据结构DOM操作的常用APIattribute和property的区别一次性插入多个DOM节点，考虑性能 DOM的本质 区分HTML文档和DOM：浏览器解析HTML文件构建DOM树（可参考网页的渲染过程） HTML文档： DOM树:DOM是由HTML文档解析出来的一棵“树”【基本的数据结构要有所了解】 总结，DOM的本质就是一颗树，他是有结构的，而HTML文档是没有结构的。 DOM节点类型 DOM规定，HTML文档中的每个成分都是一个节点。 整个文档是一个文档节点 每个HTML标签是一个元素节点 包含在HTML元素中的文本是文本节点 注意: 空格也被看作是文本，文本是文本节点。 每一个HTML属性是一个属性节点（属性节点是另一个层面的理解，在浏览器后台打印childNodes列表的时候，不存在属性节点） 在旧 DOM 规范中，属性继承自 Node，是一种特殊的节点。但是DOM4 中已废弃这一条，属性不再是节点。 注释属于注释节点 例子 文本总是存储在文本节点中 在 DOM 处理中一个普遍的错误是，认为元素节点包含文本,其实元素节点包含的是文本节点，文本节点中包含的才是文本！ 不过，元素节点的文本是存储在文本节点中的。 在这个例子中：&lt;year&gt;2005&lt;/year&gt;，元素节点 &lt;year&gt;，拥有一个值为 “2005” 的文本节点。 “2005” 不是 &lt;year&gt; 元素的值！ DOM节点的属性 每个节点都拥有包含着关于节点某些信息的属性。这些属性是：nodeName（节点名称） 、nodeValue（节点值） 、nodeType（节点类型） 以下面的demo为例： 12345678910111213&lt;script&gt;window.onload = function()&#123; var element = document.getElementById(\"span\"); var text = element.firstChild; var property=document.getElementById(\"span\").getAttributeNode(\"id\");&#125;&lt;/script&gt;&lt;body&gt; &lt;div&gt; &lt;span id=\"span\"&gt;文本节点&lt;/span&gt; &lt;/div&gt;&lt;/body&gt; nodeType属性 节点类型 nodeType 属性可返回节点的类型。 元素类型 节点类型 普通的DOM元素(ELEMENT_NODE) 1 属性(ATTRIBUTE_NODE) 2 文本元素(TEXT_NODE) 3 注释(COMMENT_NODE) 8 文档(DOCUMENT_NODE) 9 123alert(\"这是元素节点的返回值：\"+ element.nodeType);//元素节点返回1alert(\"这是文本节点的返回值：\"+ text.nodeType);//文本节点返回3alert(\"这是属性节点的返回值：\"+ property.nodeType);//属性节点返回2 nodeName属性 含有某个节点的名称 元素节点的 nodeName 是标签名称（返回的名称是大写的） 属性节点的 nodeName 是属性名称（返回的名称是大写的） 文本节点的 nodeName 永远是 #text 文档节点的 nodeName 永远是 #document 注释：nodeName 所包含的 XML 元素的标签名称永远是大写的123alert(\"这是元素节点的返回值：\"+ element.nodeName);//返回的标签名SPAN,注意是大写的alert(\"这是文本节点的返回值：\"+ text.nodeName);//返回的#textalert(\"这是属性节点的返回值：\"+ property.nodeName);//返回的是属性名，这里是id nodeValue属性 对于文本节点，nodeValue 属性包含文本。 对于属性节点，nodeValue 属性包含属性值。 nodeValue 属性对于文档节点和元素节点是不可用的。123alert(\"这是元素节点的返回值：\"+ element.nodeValue);//本身就没有意义，这里是试验下的，返回的是nullalert(\"这是文本节点的返回值：\"+ text.nodeValue);//返回的是文本值 文本节点alert(\"这是属性节点的返回值：\"+ property.nodeValue);//返回的是属性值，这里是id的属性值span DOM节点操作获取DOM节点 完整使用方法可参考DOM基础 综合案例： DOM property 和 HTML attribute property和attribute都是“属性”的意思，但修改property只影响页面效果，并不修改HTML/DOM结构。而修改attribute是同时修改页面效果和HTML/DOM结构的。 property是对DOM元素的JS对象的属性进行修改，不会修改HTML结构。 attribute是直接对DOM元素的属性进行修改，会改变HTML结构。 建议使用property，以减少不必要的DOM重新渲染。 可参考这篇博客 DOM property（属性） 当浏览器解析完 HTML 后，生成的 DOM 是一个继承自 Object 的常规 JavaScript 对象，因此我们可以像操作任何 JS 对象那样来操作 DOM 对象。 通过获取DOM元素的property（属性）可以获取/修改DOM元素的样式属性。 property是对DOM元素的JS对象的属性进行修改，不会修改HTML结构。 nodeName：DOM元素的标签名（比如p、a、div） nodeType：DOM元素的类型一般是1，但文本节点就是3 HTML attribute（特性） 和 DOM property（属性）类似，除了那些规范里定义的标准特性外，也可以通过attribute往HTML上添加非标准的属性。 通过getAttribute()和setAttribute()可获取、修改html的结构。 attribute是直接对DOM元素的属性进行修改，会改变HTML结构。 clonenode()拷贝节点DOM clonenode()创建指定的节点的精确拷贝 DOM结构操作DOM是“树”结构的，所以操作也围绕树来看。 appendChild()插入子节点 node1.appendChild(node2)可向节点的子节点列表的末尾添加新的子节点 node1:父节点 node2：新的子节点 如果node2已存在于js文件中，则appendChild()会将node2 移动 到node1之中 例子：p1原本存在于div1中，则使用appendChild后，div1中的p1移动到了div2中。 insertBefore()插入子节点 insertBefore(newnode,existingnode)可在已有的子节点前插入一个新的子节点 newnode,必须。要插入的节点对象 existingnode,必须。要添加新的节点前的子节点。 获取父元素parentNode使用parentNode获取p1元素的父元素： 获取子节点列表childNodes 注意：childNodes包括 文本节点 ！ 但是获取子元素列表时不会获取到 元素节点中包含的文本节点，获取到的文本节点实际上是 两个元素节点中的空格 ，空格也是文本节点 比如，p元素中的“一段文字 2”实际上就是 元素节点p 中包含的 文本节点 的内容。但这个文本节点不会显示在div1的childNodes上。 注意：该NodeList对象为LIVE类型的NodeList, 添加或删除子节点都会实时的改变整个NodeList对象，所以我们需要操作它的时候都应该先拷贝出一个对象，然后操作这个对象。 例子： 过滤出元素节点 使用call()去调用数组的slice方法先将nodeList转为数组 再使用数组的filter()把 文本节点 过滤掉 可以通过nodeType或者nodeName判断 文本节点的nodeType是3，元素节点是1 文本节点的nodeName是#text,而元素节点是p之类的 获取子元素节点列表children children 属性只返回元素节点。 childNodes 属性返回所有的节点，包括文本节点、注释节点。 具体可参考博客“DOM 元素的 children 与 childNodes 属性” 删除子节点removeChild()","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"首页开发（1）","slug":"首页开发（1）","date":"2020-02-12T14:09:36.000Z","updated":"2020-03-11T14:10:31.967Z","comments":true,"path":"2020/02/12/首页开发（1）/","link":"","permalink":"http://yoursite.com/2020/02/12/首页开发（1）/","excerpt":"注意 涉及浮动时要将浮动元素的父元素设为BFC元素，防止浮动元素溢出。 被包裹在BFC中的浮动不会影响BFC外部其他元素的布局（也就是可以使用BFC来清除浮动）","text":"注意 涉及浮动时要将浮动元素的父元素设为BFC元素，防止浮动元素溢出。 被包裹在BFC中的浮动不会影响BFC外部其他元素的布局（也就是可以使用BFC来清除浮动） &lt;img&gt;标签必须设置alt属性。 从App.js中可知Provider提供给Home组件的store是总store，而src-reducer.js中我们知道总store由header的store和home的store组成，所以我们需要先使用.get(&quot;home&quot;)获取到home的store才能继续获取她下面的数据。 路由 路由指根据url的不同显示不同的内容 在React中使用路由功能 需要借助第三方模块react-router-dom 安装react-router-dom1yarn add react-router-dom 使用react-router-dom 引入react-router-dom中的BrowserRouter和Route。 Route组件：定义路由组件。 path属性：（字符串）定义路由路径 render属性：（函数）在该路径下渲染的内容 component属性：（组件）在该路径下渲染的组件 exact属性：（可省略属性值）准确匹配路径。如不使用该属性，则默认是模糊匹配path BrowserRouter组件：包含各个路由组件。 在App.js中： 12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; Provider &#125; from \"react-redux\";import &#123; BrowserRouter, Route &#125; from \"react-router-dom\";import Header from \"./common/header\";import store from \"./store\";import &#123; Globalstyle &#125; from './style';import &#123; GlobalIconFontStyle &#125; from \"./statics/iconfont/iconfont\";class App extends Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Globalstyle /&gt; &lt;GlobalIconFontStyle /&gt; &lt;Header /&gt; &lt;BrowserRouter&gt; &lt;Route path=\"/\" render=&#123;() =&gt; &lt;div&gt;home&lt;/div&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\"/detail\" render=&#123;() =&gt; &lt;div&gt;detail&lt;/div&gt;&#125;&gt;&lt;/Route&gt; &lt;/BrowserRouter&gt; &lt;/Provider&gt; ); &#125;&#125;export default App; 可以看到访问/detail时同时出现了/和/detail的内容： 加上exact属性： 12&lt;Route path=\"/\" exact render=&#123;() =&gt; &lt;div&gt;home&lt;/div&gt;&#125;&gt;&lt;/Route&gt;&lt;Route path=\"/detail\" exact render=&#123;() =&gt; &lt;div&gt;detail&lt;/div&gt;&#125;&gt;&lt;/Route&gt; 首页组件的拆分 在src下新建pages文件夹，表示项目有多少个页面。 pages下新建detail文件夹和home文件夹，表示有home和detail两个页面 在这两个文件夹下分别新建index.js文件。在index.js中放置需要被渲染的组件。 在App.js中引入两个组件，分别渲染在两个Route组件中。 Home组件src-pages-home-index.js: 1234567891011import React, &#123; Component &#125; from 'react'class Home extends Component &#123; render() &#123; return ( &lt;div&gt;Home~&lt;/div&gt; ) &#125;&#125;export default Home; Detail组件src-pages-detail-index.js: 1234567891011import React, &#123; Component &#125; from 'react'class Detail extends Component &#123; render() &#123; return ( &lt;div&gt;Detail~&lt;/div&gt; ) &#125;&#125;export default Detail; App中引入并显示在路由上App.js中，引入Home、Home两个组件: 12import Home from \"./pages/home\";import Detail from \"./pages/detail\"; 使用component属性使路由分别显示对应的组件： 12&lt;Route path=\"/\" exact component=&#123;Home&#125;&gt;&lt;/Route&gt;&lt;Route path=\"/detail\" exact component=&#123;Detail&#125;&gt;&lt;/Route&gt; 完善Home组件刚刚只是写了最简单的一个样子，现在来完善一下。在src-pages-home下新建style.js文件： 1234567891011121314151617181920212223import styled from \"styled-components\";export const HomeWrapper = styled.div` overFlow: hidden; width: 960px; margin: 0 auto;`;export const HomeLeft = styled.div` float: left; width: 625px; margin-left: 15px; padding-top: 30px; .banner-img&#123; width: 625px; height: 270px; &#125;`;export const HomeRight = styled.div` float: right; width: 240px;`; 在Home组件中引入并使用： 123456789101112131415161718192021import React, &#123; Component &#125; from 'react';import &#123; HomeWrapper, HomeLeft, HomeRight,&#125; from \"./style\";class Home extends Component &#123; render() &#123; return ( &lt;HomeWrapper&gt; &lt;HomeLeft&gt; &lt;img className=\"banner-img\" src=\"https://upload.jianshu.io/admin_banners/web_images/4894/23ecc55accf5c6a6c9910be966c125853d1f04a5.png?imageMogr2/auto-orient/strip|imageView2/1/w/1250/h/540\" alt=\"banner图片\" /&gt; &lt;/HomeLeft&gt; &lt;HomeRight&gt;right&lt;/HomeRight&gt; &lt;/HomeWrapper&gt; ) &#125;&#125;export default Home; 注意：涉及浮动时要将浮动元素的父元素设为BFC元素，防止浮动元素溢出。 Home组件再拆分Home组件下还要拆分一些组件： home文件夹下新建components文件夹用于存放其他组件。 Topic.js List.js Recommend.js Writer.js components下的组件都先简单设置以后放入Home组件来展示一下位置：123456789101112131415161718192021222324252627282930import React, &#123; Component &#125; from 'react';import &#123; HomeWrapper, HomeLeft, HomeRight,&#125; from \"./style\";import List from \"./components/List\";import Recommend from \"./components/Recommend\";import Topic from \"./components/Topic\";import Writer from \"./components/Writer\";class Home extends Component &#123; render() &#123; return ( &lt;HomeWrapper&gt; &lt;HomeLeft&gt; &lt;img className=\"banner-img\" src=\"https://upload.jianshu.io/admin_banners/web_images/4894/23ecc55accf5c6a6c9910be966c125853d1f04a5.png?imageMogr2/auto-orient/strip|imageView2/1/w/1250/h/540\" alt=\"banner图片\" /&gt; &lt;Topic&gt;&lt;/Topic&gt; &lt;List&gt;&lt;/List&gt; &lt;/HomeLeft&gt; &lt;HomeRight&gt; &lt;Recommend&gt;&lt;/Recommend&gt; &lt;Writer&gt;&lt;/Writer&gt; &lt;/HomeRight&gt; &lt;/HomeWrapper&gt; ) &#125;&#125;export default Home; Topic区域布局 之前每个组件都放在一个文件夹中，样式就在style.js下。 但是为了防止过度开发，Home组件下的所有小的组件的样式我们统一放在Home组件的style.js去定义，包括Topic组件。 pages-home-style.js: 123456789101112131415161718192021222324export const TopicWrapper = styled.div` display:flow-root; padding: 20px 0 10px 0; margin-left: -18px;`;export const TopicItem = styled.div` float: left; line-height: 32px; background: #f7f7f7; font-size: 14px; color: #000; border: 1px solid #dcdcdc; border-radius: 4px; padding-right: 10px; margin-left: 18px; margin-bottom: 18px; .topic-pic&#123; width: 32px; height: 32px; margin-right: 10px; float: left; &#125;`; topic.js: 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react'import &#123; TopicWrapper, TopicItem,&#125; from \"../style\"class Topic extends Component &#123; render() &#123; return ( &lt;TopicWrapper&gt; &lt;TopicItem&gt; &lt;img className=\"topic-pic\" src=\"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" alt=\"社会热点\" /&gt; 社会热点 &lt;/TopicItem&gt; &lt;/TopicWrapper&gt; ) &#125;&#125;export default Topic; Topic的reducer设计 我们现在只写了一个TopicItem组件，实际上应该从数据中读取生成多个TopicItem组件。数据是保存在redux的store中的，整个项目的reducer在src的store中，它是由各个小的reducer合并而成的。 所以我们在Home组件下也新建一个store文件夹，用于管理home以及其下组件的数据。 新建reducer.js：管理home页面的数据（可将header的reducer复制一个框架过来）。 新建index.js：管理store中所有文件的输出，他是整个store中所有文件的出口文件。 项目的总reducer中引入home的reducer并将其合并。 Topic组件中循环读取state的数据、输出对应TopicItem组件。 Topic组件在Home组件内部，Home组件又在Provider组件内部，所以Topic组件有使用store中数据的能力，只需借助connect方法即可使用数据。 新建store-reducer.js管理数据home-store-reducer.js中，将header的reducer复制一个框架过来，放入一些模拟数据: 12345678910111213141516171819202122import &#123; fromJS &#125; from \"immutable\";// immutable对象 是不可改变的,注意list是immutable数组const defaultState = fromJS(&#123; topicList:[&#123; id:1, title:\"社会热点\", imgUrl: \"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" &#125;,&#123; id:2, title:\"手绘\", imgUrl: \"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" &#125;]&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; default: return state; &#125;&#125; 新建store-index.js管理文件输出home-store-index.js：管理store中所有文件的输出，他是整个store中所有文件的出口文件： 123import reducer from \"./reducer\";export &#123; reducer &#125;; 合并入项目总reducersrc-store-reducer.js,项目的总reducer中引入home的reducer并将其合并： 12345678910import &#123; combineReducers &#125; from \"redux-immutable\";import &#123; reducer as headerReducer &#125; from \"../common/header/store\";import &#123; reducer as homeReducer &#125; from \"../pages/home/store\";const reducer = combineReducers(&#123; header: headerReducer, home: homeReducer&#125;)export default reducer; Topic中循环读取state中数据 Topic组件中循环读取state的数据、输出对应TopicItem组件。 此时Topic组件在Home组件内部，Home组件又在Provider组件内部，所以Topic组件有使用store中数据的能力，只需借助connect方法即可使用数据。 由于我们只需要读取state中数据，不需要去改变数据，所以此时connect方法的参数2可以先使用null。 注意 state中的TopicList是immutable数组，需要使用get()获取数据。 从App.js中可知Provider提供给Home组件的store是总store，而src-reducer.js中我们知道总store由header的store和home的store组成，所以我们需要先使用.get(&quot;home&quot;)获取到home的store才能继续获取她下面的数据。 home-components-Topic.js： 1234567891011121314151617181920212223242526272829303132333435import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from \"react-redux\";import &#123; TopicWrapper, TopicItem,&#125; from \"../style\"class Topic extends Component &#123; render() &#123; return ( &lt;TopicWrapper&gt; &#123; this.props.list.map((item) =&gt; &#123; return ( &lt;TopicItem key=&#123;item.get(\"id\")&#125;&gt; &lt;img className=\"topic-pic\" src=&#123;item.get(\"imgUrl\")&#125; alt=&#123;item.get(\"title\")&#125; /&gt; &#123;item.get(\"title\")&#125; &lt;/TopicItem&gt; ) &#125;) &#125; &lt;/TopicWrapper&gt; ) &#125;&#125;const mapState = (state) =&gt; (&#123; list: state.get(\"home\").get(\"topicList\")&#125;)export default connect(mapState, null)(Topic);","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"解决：图片和文字不水平居中对齐","slug":"解决：图片和文字不水平居中对齐","date":"2020-02-12T13:20:11.000Z","updated":"2020-03-11T13:21:37.832Z","comments":true,"path":"2020/02/12/解决：图片和文字不水平居中对齐/","link":"","permalink":"http://yoursite.com/2020/02/12/解决：图片和文字不水平居中对齐/","excerpt":"问题往父组件中放入图片后，父组件TopicItem中的文字 与 img不能水平居中对齐显示。","text":"问题往父组件中放入图片后，父组件TopicItem中的文字 与 img不能水平居中对齐显示。 代码12345678&lt;TopicItem&gt; &lt;img className=\"topic-pic\" src=\"https://upload.jianshu.io/users/upload_avatars/3136195/484e32c3504a.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/96/h/96/format/webp\" alt=\"社会热点\" /&gt; 社会热点&lt;/TopicItem&gt; 样式： 12345678910111213export const TopicItem = styled.div` float: left; line-height: 32px; background: #f7f7f7; font-size: 14px; color: #000; border: 1px solid #dcdcdc; border-radius: 4px; .topic-pic&#123; width: 32px; height: 32px; &#125;`; 可以看到图片和文字不水平居中对齐：而没加图片之前文字是居中显示的。 原因默认情况，图片是置顶对齐，文字置底对齐，所以通常图片高，文字低，不能水平居中对齐。 解决:图片使用float 让图片左浮动，则脱离文档流，不影响父级元素文本布局。 注意：想清除浮动可将父元素设置为BFC元素。 123456.topic-pic&#123; width: 32px; height: 32px; margin-right: 10px; float: left;&#125; 补充：让图片和父级元素文字底部对齐设置图片的vertical-align属性可以设置图片的vertical-align属性使图片和父级元素文字底部对齐： 1vertical-align:text-bottom","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"ES6 模板字符串","slug":"ES6 模板字符串","date":"2020-02-11T14:17:41.000Z","updated":"2020-03-31T04:20:33.343Z","comments":true,"path":"2020/02/11/ES6 模板字符串/","link":"","permalink":"http://yoursite.com/2020/02/11/ES6 模板字符串/","excerpt":"模板字符串 模板字符串：允许嵌入表达式的字符串字面量。可以使用多行字符串和字符串插值功能。","text":"模板字符串 模板字符串：允许嵌入表达式的字符串字面量。可以使用多行字符串和字符串插值功能。 模板字符串使用反引号` 来代替普通字符串中的用双引号和单引号。 模板字符串可以包含特定语法（${expression}）的占位符。(expression可以是变量/表达式) 在模版字符串内使用反引号`时，需要在它前面加转义符\\: 1`\\`` === \"`\" // --&gt; true 语法： 12345678`string text``string text line 1 string text line 2``string text $&#123;expression&#125; string text`tag `string text $&#123;expression&#125; string text` 如果一个模板字符串由表达式开头，则该字符串被称为带标签的模板字符串，该表达式通常是一个函数，它会在模板字符串处理后被调用，在输出最终结果前，你都可以通过该函数来对模板字符串进行操作处理。 用于输入多行字符串123456789// 普通字符串console.log('string text line 1\\n' +'string text line 2');// 使用模板字符串，同样效果的多行字符串console.log(`string text line 1string text line 2`);// 结果都如下// \"string text line 1// string text line 2\" 用于在字符串中插入表达式123456789101112// 普通字符串中嵌入表达式var a = 5;var b = 10;console.log('Fifteen is ' + (a + b) + ' and\\nnot ' + (2 * a + b) + '.');// 通过模板字符串var a = 5;var b = 10;console.log(`Fifteen is $&#123;a + b&#125; andnot $&#123;2 * a + b&#125;.`);// 结果都如下// \"Fifteen is 15 and// not 20.\" 用于插入HTML代码 一般我们在JS字符串中插入多行HTML时会很麻烦（见例子2） 模板字符串中插入html代码时可以换行，行尾不需要插入转义符\\。 普通的字符串拼接插入html代码时不能换行，换行时行尾需要插入转义符\\。 更多高级用法 更多高级用法可参考MDN文档","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6 class与babel（2）","slug":"ES6 class与babel（2）","date":"2020-02-10T14:17:02.000Z","updated":"2020-03-31T04:21:29.081Z","comments":true,"path":"2020/02/10/ES6 class与babel（2）/","link":"","permalink":"http://yoursite.com/2020/02/10/ES6 class与babel（2）/","excerpt":"ES5中模拟类的流程 在ES6中提供了class这个 语法糖 来模拟类，但它并不是真正的类，实际上走的还是ES5中的模拟类的流程，只是看起来更像类了。","text":"ES5中模拟类的流程 在ES6中提供了class这个 语法糖 来模拟类，但它并不是真正的类，实际上走的还是ES5中的模拟类的流程，只是看起来更像类了。 ES5中模拟类的流程： 构造函数和正常创建函数方法一样 使用new关键字调用函数即相当于调用构造函数 使用new调用函数生成对象的流程当用new关键字调用函数时，发生了什么？为什么会获得个新的对象？ 创建一个空的对象 把构造函数的prototype属性作为空对象的原型 this赋值为这个空对象 执行函数 如果函数没有返回值则返回this[返回之前那个空对象] 使用原理模拟一个构造函数根据上面“使用new调用函数生成对象的流程”的原理，我们自己创建一个构造函数Constructor()，该函数的参数1接受一个函数作为构造函数，参数2接受数组 ES6中class的继承 继承（extends）可以让子类获得父类的方法、属性 可以扩充增加新的方法属性等 父类（基类）-被继承的类 子类-继承后的类 子类extends父类后，需要在构造函数中使用super();(相当于执行父类的构造函数) 简单例子：给子类也定义父类的属性值：单纯给子类定义属性值： 实际案例：网游职业系统 super 关键字注意：调用super时，父类的this 始终是 子类的this（MDN参考） super作为父类构造函数调用 比如上面的例子，也就是将子类的this丢到父类的构造函数中跑一遍 super作为对象的方式调用 非静态方法中访问super-&gt;super指向 父类原型 在静态方法中访问super-&gt;super指向 父类 非静态方法中访问super-&gt;super指向 父类原型： 在静态方法中访问super-&gt;super指向 父类：静态方法与静态属性 都是类自身的，通过类创建的对象不会拥有。所以有例子2： 简单的多态 ES6中没有提供接口来实现 多态 多态：同一个接口在不同情况下做不一样的事情，即 相同的接口不同的表现 接口：接口本身只是一组定义，实现都是在类里面。 也就是说我们可以通过方法的重写实现多态。 实现多态简单例子只需要在子类中定义和父类同名的方法覆盖掉父类方法就可以实现多态：子类依然可以通过super访问父类同名方法： 对比 重载 重载 不是发生在父子中间的，他是根据函数的参数类型、个数 让函数做不一样的事。而多态是方法的重写。 区分 多态、重载： 重载 只是给函数提供了更多可能性 多态 是方法的 重写，两者是没有关系的 ES5继承的实现方法有很多，这里只说其中一种。 方法：利用构造函数，但此方法不能继承父类原型链上的方法：让子类的原型=父类的实例，即可解决问题：原因：因为new一个对象的过程： 创建一个空的对象 把构造函数的prototype属性作为空对象的原型 this赋值为这个空对象 执行函数 如果函数没有返回值则返回this[返回之前那个空对象] babel babel是一个JS编译器，他可以将大部分浏览器还不支持的特性编译成浏览器可良好支持的JS代码。 可以在babel中文官网中看到编译效果： 安装babel 需要先安装node 然后可以在babel中文官网=&gt;设置=&gt;CLI中看到安装方法 虽然可以全局安装，但建议对单个项目进行本地安装，因为： 同一机器上的不同的项目可以依赖不同版本的Babel，这允许你一次更新一个项目。 这意味着在你的工作环境中没有隐含的依赖项。它将使你的项目更方便移植、更易于安装。 本地安装Babel CLI的命令： 1npm install --save-dev @babel/core @babel/cli 注意：安装之前项目中需要一个package.json（可以通过npm init-y来生成package.json），这可以保证npx命令产生合适的交互,安装成功后package.json中应包括 123456&#123; \"devDependencies\": &#123;+ \"@babel/cli\": \"^7.0.0\",+ \"@babel/core\": \"^7.0.0\" &#125;&#125; 其中，devDependencies的意思是生产时依赖的包，安装时使用的是--save-dev这些包上线时就不会使用了，因为上线的是编译后的结果。而相对的就有dependencies，安装时使用的是--save,它包含的包就是上线运行时依赖的包。 配置babel运行命令编译后显示在终端在package.json的scripts中，添加： 1\"build\": \"babel entry.js\" 则在entry.js中书写ES6代码后，在终端输入npm run build即可执行babel，在终端可查看编译后的代码（但此时ES6代码还是毫无变化，这是因为我们没有设置“转换规则”）。 编译后输出到别的文件中1\"build\": \"babel entry.js -o index.js\" 也就是执行npm run build则将entry.js进行babel编译后输出到index.js文件中。那么我们就能项目中就会生成index.js文件放置变异后的js代码。但此时我们每次修改entry.js代码后都需要手动执行npm run build来编译。 运行以后一直自动编译1\"build\": \"babel entry.js -o index.js -w\" 加上-w后则只需执行一次npm run build，接下来每次entry.js修改报错都会自动编译。 安装 转换规则babel-preset-env1.安装 转换规则: 1npm install @babel/preset-env --save-dev 2.devDependencies多了以下代码说明安装成功： 1\"babel-preset-env\": \"^1.7.0\" 创建配置文件(.babelrc) 配置文件(.babelrc)：用来告诉babel根据什么规则来编译代码的。 当运行babel命令时，就会去找.babelrc文件，根据该文件内规定的配置去编译代码。 注意：.babelrc文件中使用的是json格式，属性名必须加引号 在目录下新建.babelrc文件： 123&#123; \"presets\": [\"@babel/preset-env\"]&#125; 上面试最简单的配置，详细配置可参考官网。 例子entry.js: 1const add = (a, b) =&gt; (a + b); 运行npm run build后，index.js: 12345\"use strict\";var add = function add(a, b) &#123; return a + b;&#125;; babel插件 npmjs和babel官网都提供了很多babel插件，可以在上面进行查询。 通过插件可以实现一些ES6不支持的编译，比如ES6中不支持使用static生成静态属性，但我们可以通过@babel/plugin-proposal-class-properties插件使之成立。 例子 安装@babel/plugin-proposal-class-properties插件： 1yarn add @babel/plugin-proposal-class-properties --dev 配置：在配置文件(.babelrc)中添加： 1\"plugins\": [\"@babel/plugin-proposal-class-properties\"] 正常运行不报错了：将entry.js放到index.html上后可在index.html上看到效果。 额外知识点 遇到大量相同代码时，抽出作为一个方法，在不同地方调用该方法即可。如部分数据不同，可采用参数的方法进行传递： 实现链式操作：想要实现最后的链式操作，就需要每一次操作都返回操作的对象：","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6 class（1）","slug":"ES6 class（1）","date":"2020-02-09T14:17:02.000Z","updated":"2020-03-31T04:22:05.909Z","comments":true,"path":"2020/02/09/ES6 class（1）/","link":"","permalink":"http://yoursite.com/2020/02/09/ES6 class（1）/","excerpt":"类与对象 类：具有相同特征的事物可以看做是一类的。 比如：男生女生都是“人类”，自行车、卡车都是“车类”。 对象：由 类 生产的 具体的东西 就是对象。","text":"类与对象 类：具有相同特征的事物可以看做是一类的。 比如：男生女生都是“人类”，自行车、卡车都是“车类”。 对象：由 类 生产的 具体的东西 就是对象。 例子 “车类” 拥有共同特性 ，对每一辆车来说他们都有这些特性（属性/方法），只是值不同。 比如：颜色、材质、轮子（属性），会加速、能删车（方法）。 类 就像是工厂，工程生产出的就是对象。 比如“车类”就像是“造车工厂”，“造车工厂”造出来的每一辆车就是一个“对象”。 所以我们写好一个类就相当于有了一个工厂，只要我们给工厂一些数据就能得到我们想要的对象。 ES6中的类 使用class创建类(类相当于工厂) 类中有用于创建对象的构造函数constructer()(构造函数相当于工厂中的接头人) 实例化：类创建对象的过程(相当于造车的过程) 例子：注意：“剩余参数...是做聚合的，而扩展运算符...是做展开的，符号都是...,但含义不同。”(复习一下扩展运算符用于剩余参数的用法。) 面向过程开发（差）把不同的操作都封装在函数中是“面向过程开发”，复用率极低。 例子：贪吃蛇小游戏一条蛇看起来没什么问题，但如果我们希望多一条蛇则需要整个复制修改，以此让函数们作用于不同的蛇对象，复用率极低： 面向对象开发 OOP（面向对象开发）的核心是封装 同一个例子，我们使用类的写法就方便很多。创建Snake类，将函数们放入类中，通过类创建的每个对象之间都是独立的（即属性/方法都只作用于该对象）： 使用上面 ES6的类中的例子 来演示一下同一个类创建两个不同的对象： 类的三大基本特性 多态：同一个接口，不同的表现。即同一个操作用在不同的对象上会有不同的结果。（目前ES基本不支持多态） 继承（笔记在后面另一篇） 封装（笔记在后面另一篇） 实例：音乐播放器类在这个例子中我们并没有真正使用到Audio构造函数，只是演示一下。 index.html:index.js:使用方法：调用AudioPlayer类，将 DOM元素的id 传入 AudioPlayer类 即可创建一个音乐播放器对象。 代码思路 创建AudioPlayer类，构造函数 接受 containner参数（即我们调用时传入的DOM元素id）。 在类中创建函数getSongs()来获取歌曲资源地址及相关信息。 在类中创建函数createElement()来生成一个DOM元素用于放置“播放按钮、进度条”(假装)，将DOM元素绑定在调用类创建的对象的dom属性上。 在类中创建函数bindElement()给刚刚创建的元素绑定点击事件，点击则打印“开始播放”。 在类中创建函数render()来将 创建好的DOM元素 添加到 传入的DOM元素 的后面，以显示在页面上。 注意：在类中创建的方法都要在构造函数中调用才能在创建对象时自动执行。在构造函数中调用这些函数时使用的是this 函数名()，因为类中的函数们是挂在通过类创建出的不同对象身上的，不是构造函数内部的，所以在构造函数中我们要调用的是对象.函数名()，而对象名是多变的，但构造函数中this指向对象，所以可以使用this 函数名()。 静态方法与静态属性 静态方法与静态属性 都是类自身的，通过类创建的对象不会拥有。 静态方法与静态属性 都只能通过类名进行调用。（不是对象名！） 静态方法： 声明：在类中使用static关键字进行声明（static 函数名 (){...}）。（注意函数与构造函数并排，不包含） 使用：在类外通过类名.函数名(对象名);的方式让对象调用该静态方法。 静态属性： 声明：在类中/外使用类名.属性名=属性值;的方式进行定义。 使用：在类外通过类名.属性名;的方式让对象调用该静态方法。 静态方法的例子：静态属性的例子： 静态属性的例子使用 静态属性totalCar 来记录通过Car类生成了多少个对象：由于每生成一个对象就会调用一次构造函数，而构造函数中 静态属性totalCar 是累加的，所以生成多少个对象totalCar 就累加多少次。 静态方法的例子 通过 Programmer类 创建了一个 程序猿对象programmer ，此时programmer的 属性haveGilrFriend和hair都是false。 我们让 程序猿对象programmer 调用 Person类的静态方法format，在该方法中将 程序猿对象programmer 的两个属性都改为true。 此时 程序猿对象programmer 的两个属性姐发生了变化。 类的表达式 之前我们使用的都是类的声明，就像函数声明与表达式一样，类也有表达式的定义方法。 语法 const 常量名 = class {...}，使用new 常量名()创建对象 或者const 常量名 = class 类名 {...}，一样使用new 常量名()创建对象。其中，类名===常量名,但 类名 只能在类中使用，类外会报错！ 使用类表达式时想要在类内部定义 静态属性/方法 建议使用 类名，放置类名变化导致静态属性/方法失效。 有趣但少用的特点：使用类表达式定义的类可以自执行： getter和setter 类似于给属性提供钩子 在 获取属性值 和 设置属性值 的时候做一些额外的事情 回顾ES5的getter/setter在对象字面量中书写get/set方法 get()将在对象的属性被获取时被触发。 set()将在对象的属性被设置时被触发。 定义：在ES5中我们在对象字面量中定义get()/set()。 使用：对象名.get方法名;或对象名.set方法名=属性值;（注意不是去调用属性，是方法名！另，调用方法和普通函数的调用方法是不同的） 注意：get()/set()与属性不要同名,避免造成死循环。 调用get()的错误示范：注意：get()/set()与属性不要同名,避免造成死循环。20触发的是obj的get()。 调用set()的正确示范： Object.defineProperty()添加属性 Object.defineProperty()方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象。 语法：Object.defineProperty(对象名，&quot;属性名&quot;,属性描述符 ) 属性描述符：分为 数据描述符 和 存取描述符（详细的 可选描述符 可参考MDN文档，这里只列举了例子中用到的） 数据描述符是一个具有值的属性，该值可能是可写的，也可能不是可写的。 存取描述符是由getter-setter函数对描述的属性。 属性描述符 必须是这两种形式之一，不能同时是 数据描述符 和 存取描述符。 enumerable：当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举（遍历）属性中。默认为 false。（数据描述符和存取描述符均具有该键值） value：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。（数据描述符具有该键值） get：给属性提供 getter 的方法，如果没有 getter 则为 undefined。当访问该属性时，该方法会被执行，方法执行时没有参数传入，但是会传入this对象（由于继承关系，这里的this并不一定是定义该属性的对象）。 set：给属性提供 setter 的方法，如果没有 setter 则为 undefined。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。 注意：默认情况下，使用 Object.defineProperty() 添加的属性值是不可遍历/修改的。 而通过 赋值操作 添加的普通属性是可遍历的（for...in 或 Object.keys 方法），这些属性的值可以被改变，也可以被删除的。 数据描述符的例子：通过Object.defineProperty()给obj对象添加属性age，属性值由value设置：可以看到_name和age属性的颜色是不一样的，使用for...in遍历obj属性时也没有age，这是因为通过Object.defineProperty()生成的属性不可遍历。 在属性描述符中添加enumerable为true，则添加的属性可出现在对象遍历的属性中： 存取描述符的例子：通过 存取描述符get和set 给调用的对象obj添加了get()和set()，这里this指obj，参数2name是get()/set()的名字： ES6中的getter/setter ES6中在类中定义get与set，而ES5是在对象字面量中定义的。 使用：对象名.get方法名;或对象名.set方法名=属性值;，调用方法和ES5中是相同的。（与 静态属性/方法 的调用方式区分开） 例子： 用在播放器中的例子：也可以在构造函数中添加init(),使用Audio构造函数： name属性获取类名 name属性：用于获取类的名字。 采用“类的声明”的类名很好理解，如果采用的是“类的表达式”，则类有名字就返回类名，没有名字时返回常量的名字。 开发中极少使用，了解即可。 12345678class Person&#123;&#125;;console.log(Person.name);//Personconst Humen = class &#123;&#125;;console.log(Humen.name);//Humenconst Humen = class P&#123;&#125;;console.log(Humen.name);//P new.target属性 new.target属性不能直接访问，会报错。只能在 类的构造函数/new调用的普通函数 中使用。 new.target属性值 实际上是 new 后面的 函数体/构造函数体，如果没有new，则是undefined。 使用new普通函数也可使用new.target属性是因为：在ES5中普通函数前加new就相当于构造函数。 用在构造函数中的例子: 用在普通函数中，没有new的例子： 用在普通函数中，有new的例子： 实际运用普通函数容错判断容错判断（规定Car只能通过new调用，否则报错）： 在以前没有new.target属性时，我们使用instanceof判断Car是否是被new关键字调用的：因为this指向使用new调用Car()生成的对象，所以this的显示原型和Car是有关系的。this instanceof Car如果是true则说明this是使用new Car()创建的对象。 类中容错判断在类中不需要手动设置报错：","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"as与export/import","slug":"as与export、import","date":"2020-02-08T13:29:36.000Z","updated":"2020-03-31T04:22:45.307Z","comments":true,"path":"2020/02/08/as与export、import/","link":"","permalink":"http://yoursite.com/2020/02/08/as与export、import/","excerpt":"模块 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口。 import命令用于引入其他模块提供的功能。","text":"模块 模块功能主要由两个命令构成：export和import。 export命令用于规定模块的对外接口。 import命令用于引入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 理解“接口”export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 错误写法： 123456// 报错export 1;// 报错var m = 1;export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出 1，第二种写法通过变量m，还是直接输出 1。1只是一个值，不是接口!!! 正确的写法: 12345678910// 写法一export var m = 1;// 写法二var m = 1;export &#123;m&#125;;// 写法三var n = 1;export &#123;n as m&#125;; 他们都规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 同样的，function和class的输出，也必须遵守这样的写法。 export命令 export命令可以输出变量、函数或类（class） 优先使用{}来输出一组数据。 2种输出方法1.分别输出三个变量: 1234// profile.js，保存了用户信息export var firstName = 'Michael';export var lastName = 'Jackson';export var year = 1958; 2.使用大括号指定所要输出的一组变量(优先考虑使用这种写法,因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量: 123456// profile.jsvar firstName = 'Michael';var lastName = 'Jackson';var year = 1958;export &#123; firstName, lastName, year &#125;; 放置位置export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。 1234function foo() &#123; export default 'bar' // SyntaxError&#125;foo() 上面代码中，export语句放在函数之中，结果报错。 通过接口可获取模块内部实时的值export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 例子： 12export var foo = 'bar';setTimeout(() =&gt; foo = 'baz', 500); 上面代码输出变量foo，值为bar，500 毫秒之后变成baz。 这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新，详见Module 的加载实现。 export default命令 加上default相当是一个默认的入口，在一个文件里export default只能有一个。 建议使用export。 使用export default，则输出和引入的名字可以不同。12//输出export default var a='jspang'; 12//index.js引入import str from './temp'; import命令 使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 import命令接受{}，{}里面是从其他模块导入的变量名。 导入的变量名 必须与 export导出模块的对外接口的名称相同（如果使用的是export default=&gt;没规定对外接口名称 则不需要） 例子： 123456// main.jsimport &#123; firstName, lastName, year &#125; from './profile.js';function setName(element) &#123; element.textContent = firstName + ' ' + lastName;&#125; 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 只读变量（不可修改） import命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。 引入的变量不可修改，一旦修改就会报错。 但引入的对象，他的属性可以被修改且被别的模块读到修改后的值，不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。 例子： 12import &#123;a&#125; from './xxx.js'a = &#123;&#125;; // Syntax Error : 'a' is read-only; 上面代码中，脚本加载了变量a，对其重新赋值就会报错，因为a是一个只读的接口。但是，如果a是一个对象，改写a的属性是允许的。 123import &#123;a&#125; from './xxx.js'a.foo = 'hello'; // 合法操作 上面代码中，a的属性可以成功改写，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。 模块路径 import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径。 .js后缀可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置:1import &#123;myMethod&#125; from 'util'; 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 import提升 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 提升的本质：import命令是编译阶段执行的，在代码运行之前。 例子： 12foo();import &#123; foo &#125; from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 不含表达式由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构: 12345678910111213// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125; else &#123; import &#123; foo &#125; from 'module2';&#125; 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 import加载模块import语句会执行所加载的模块，因此可以有下面的写法。 1234567891011//仅执行lodash模块，但是不输入任何值import 'lodash';//多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。import 'lodash';import 'lodash';import &#123; foo &#125; from 'my_module';import &#123; bar &#125; from 'my_module';// 等同于import &#123; foo, bar &#125; from 'my_module'; 目前阶段，通过 Babel 转码，CommonJS 模块的 require命令 和 ES6 模块的 import命令 可以写在同一个模块里面，但是最好不要这样做。因为import在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。 123require('core-js/modules/es6.symbol');require('core-js/modules/es6.promise');import React from 'React'; as重命名 as的作用：重命名接口。 可以在 输出/引入 时使用as。 export时重命名接口通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 12345678function v1() &#123; ... &#125;function v2() &#123; ... &#125;export &#123; v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion&#125;; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。在别的文件中可使用别名进行引入 import时重命名接口如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 1import &#123; lastName as surname &#125; from './profile.js';","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"路由 API 路径","slug":"路由 API 路径","date":"2020-02-08T07:30:21.000Z","updated":"2020-04-11T13:52:05.883Z","comments":true,"path":"2020/02/08/路由 API 路径/","link":"","permalink":"http://yoursite.com/2020/02/08/路由 API 路径/","excerpt":"API API是 “前端和后端”或者“不同端（子系统）”之间对接的一个术语。 前端不需要关心API具体是如何实现的。 API的具体实现由后端完成后通过“路由”供前端调用。","text":"API API是 “前端和后端”或者“不同端（子系统）”之间对接的一个术语。 前端不需要关心API具体是如何实现的。 API的具体实现由后端完成后通过“路由”供前端调用。 API包含 url（即路由,比如后端提供给前段的/api/blog/list） 输入（比如:输入author或者keyword） 输出（比如:json文件，里面包含着需要返回的数据） 路由 路由（url）是API的一部分。（比如登陆页面/login） 是后端系统内部的一个模块。（比如在博客项目中使用的router文件夹） 路由与路径 前后端都有路由和路径，路由是网址地址（url）中的，路径是用于找文件的。 例子拿react中App.js举例： 我们在浏览器中输入一个url，前端 根据 url中的路由（/login）去找我们在前端定义好的路径下的文件(Login组件)，找到就渲染在页面上。 渲染组件时，需要后端某些数据时就发送AJAX请求 后端匹配到前端发送的 AJAX请求中的路由（比如/api/user/login）时，就会去我们在后端设置的对应的路径中读取数据来返回给前端(或者直接返回相应的数据给前端) 总结：所以前后端分离的项目中，前端和后端定义的都是路由，只不过前端定义的路由一般匹配一个页面，后端定义的路由一般返回数据","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"开发博客项目之接口(3)","slug":"开发博客项目之接口(3)","date":"2020-02-07T15:00:56.000Z","updated":"2020-03-01T07:20:19.243Z","comments":true,"path":"2020/02/07/开发博客项目之接口(3)/","link":"","permalink":"http://yoursite.com/2020/02/07/开发博客项目之接口(3)/","excerpt":"4-8 开发 博客详情路由","text":"4-8 开发 博客详情路由 controller-blog.js中定义一个getDetail()用于返回假数据： 12345678910const getDetail = () =&gt; &#123; //先返回假数据 return &#123; id: 1, title: \"标题A\", content: \"内容A\", createTime: 1579421639661, author: \"hlz\" &#125;&#125; router-blog.js中引入getDetail()，修改“获取博客详情”返回的内容: 123456//获取博客详情if (method === \"GET\" &amp;&amp; req.path === \"/api/blog/detail\") &#123; const id = req.query.id; const data = getDetail(id); return new SuccessModel(data);&#125; 将我们在发送get请求时的id获取并传入getDetail()，得到的对象data传入SucessModel()中去新建一个对象，该对象是格式化后的数据对象，在app.js中该对象会通过res.end()显示在页面上: nodejs读取文件的简单示例读取a.json文件内容新建文件夹promise-test，该文件夹下新建一个index.js用于读取文件。新建一个**files文件夹用于存放3个文件a.json、b.json、c.json**。 a.json： 1234&#123; \"next\": \"b.json\", \"msg\": \"this is a\"&#125; index.js: 1234567891011121314151617const fs = require(\"fs\");// fs是node自带的模块，用于读取文件const path = require(\"path\");//path是node自带的模块，用于获取路径//获取a.json文件的绝对路径fullFileName//path的resolve()用于拼接路径，__dirname是node的全局变量，可直接使用，表示当前文件的目录const fullFileName = path.resolve(__dirname, \"files\", \"a.json\")//通过fs.readFile()读取绝对路径的文件fs.readFile(fullFileName, (err, data) =&gt; &#123; //fs.readFile()读取文件是异步的 if (err) &#123; // 如果报错就抛出 console.log(err); return; &#125; // 没报错就将读取到的数据data转换为字符串打印（data默认二进制） console.log(data.toString());&#125;) 运行index.js可以打印出a.json的数据: 通过回调函数的方式获取文件内容修改index.js获取a.json文件的内容: 创建getFileContent() 回调函数（参数函数）callback：获取文件内容,转换为JSON对象后通过参数传给回调函数callback。 参数fileName：需要获取内容的文件名（a.json）。 调用getFileContent()时只需要传入需要获取的文件名，（回调函数接受获取到的数据对象作为参数）即可在回调函数中对获取到的内容进行操作。1234567891011121314151617181920212223242526const fs = require(\"fs\");// fs是node自带的模块，用于读取文件const path = require(\"path\");//path是node自带的模块，用于获取路径// callback方式获取文件内容function getFileContent(fileName, callback) &#123; //path的resolve()用于拼接路径，__dirname是node的全局变量，可直接使用，表示当前文件的目录 const fullFileName = path.resolve(__dirname, \"files\", fileName) //通过fs.readFile()读取绝对路径的文件 fs.readFile(fullFileName, (err, data) =&gt; &#123; //fs.readFile()读取文件是异步的 if (err) &#123; // 如果报错就抛出 console.log(err); return; &#125; // 读取到的数据data默认二进制 // 没报错就将data转换为字符串再转换为JSON对象后传给回调函数callback callback(JSON.parse(data.toString())); &#125;)&#125;// 测试getFileContent(\"a.json\", aData =&gt; &#123; console.log(\"a data\", aData)&#125;) 依次获取文件内容(回调地狱)b.json: 1234&#123; \"next\": \"c.json\", \"msg\": \"this is b\"&#125; c.json: 1234&#123; \"next\": null, \"msg\": \"this is c\"&#125; index.js: 12345678910// 依次获取三个文件内容，回调地狱getFileContent(\"a.json\", aData =&gt; &#123; console.log(\"a data\", aData) getFileContent(aData.next, bData =&gt; &#123; console.log(bData); getFileContent(bData.next, cData =&gt; &#123; console.log(cData); &#125;) &#125;)&#125;) 使用Promise避免回调地狱 使用getFileContent()只需要传入文件名fileName,(避免回调地狱，不需要使用回调函数)返回的是一个Promise对象。 then()返回的Promise对象可以通过我们的设置返回新的Promise对象。 then()中的参数函数（回调函数）获取到的参数是由调用它的Promise对象在决议为成功/失败时(即resolve()/reject()中作为参数)返回的数据。 关于Promise和resolve()、reject()： 在getFileContent()中我们返回的是一个Promise对象，这个对象中保存着一个异步操作的结果（成功/失败）。（异步操作放在Promise的参数函数中） 当Promise的参数函数中保存的异步操作成功，则可以调用resolve()将获取到的数据通过参数传递给then()的第一个参数函数。 如果异步操作失败，则可以调用reject()将错误信息通过参数传递给then()的第二个参数函数/catch()的参数函数。 注意：调用resolve()/reject()都不会终止Promise的参数函数的执行（他们只改变Promise对象的状态并传递参数），所以为了防止resolve()或reject()后面的函数还继续执行，最好在resolve或reject前面加上return语句，这样函数就结束了，后面语句自然也就不会执行了（return resolve();）。 index.js: 123456789101112131415161718192021222324252627282930313233343536373839const fs = require(\"fs\");// fs是node自带的模块，用于读取文件const path = require(\"path\");//path是node自带的模块，用于获取路径// 用Promise依次获取不同文件的内容// 使用getFileContent()只需要传入文件名fileName，返回的是promise对象function getFileContent(fileName) &#123; const promise = new Promise((resolve, reject) =&gt; &#123; //path的resolve()用于拼接路径，__dirname是node的全局变量，可直接使用，表示当前文件的目录 const fullFileName = path.resolve(__dirname, \"files\", fileName) //通过fs.readFile()读取绝对路径的文件 fs.readFile(fullFileName, (err, data) =&gt; &#123; //fs.readFile()读取文件是异步的 if (err) &#123; // 如果报错就将错误信息传给reject() reject(err); return; &#125; resolve( // 读取到的数据data默认二进制 // 没报错就将data转换为字符串再转换为JSON对象后传给resolve() JSON.parse(data.toString()) ) &#125;) &#125;) return promise;&#125;// 测试，getFileContent()会返回一个Promise对象// 成功获取的数据作为参数传入then()的参数函数中getFileContent(\"a.json\").then(aData =&gt; &#123; console.log(\"a data\", aData); // then()可以返回另一个Promise对象 return getFileContent(aData.next);&#125;).then(bData =&gt; &#123; console.log(\"b data\", bData); return getFileContent(bData.next);&#125;).then(cData =&gt; &#123; console.log(\"c data\", cData);&#125;) 补充：使用async await会更加简单，会在后面讲koa2框架时讲解。 4-9 处理post请求之前我们处理的两个路由都是get请求的，现在我们来处理post请求的路由。 复习：post请求的简单示例可参考笔记“开发博客项目之接口（1）”post请求的例子注意：数据流获取数据的方式是异步的，所以我们可以使用Promise来获取数据 通过Promise来解析postData 回到blog-1文件夹中，在app.js中新建函数getPostData(),在该函数中通过Promise来解析postData。 其中我们没有用到reject()是因为在这里我们并不把 get请求 或者 请求类型为JSON以外的类型的数据（比如form-data类型）判定为错误的，只需要返回空数据就好。 在app.js中的serverHandle()中，我们会处理不同的路由，在处理路由前就需要使用getPostData()解析PostData。解析成功以后的数据会作为参数传到then()中，此时我们需要将所有路由的处理都放在then()的回调函数中，让接下来在router中处理路由时都能拿到PostData。 app.js中添加函数getPostData()用于解析PostData: 12345678910111213141516171819202122const getPostData = (req) =&gt; &#123; const promise = new Promise((resolve, reject) =&gt; &#123; if (req.method !== \"POST\") &#123; return resolve(&#123;&#125;); &#125; if (req.headers[\"content-type\"] !== \"application/json\") &#123; return resolve(&#123;&#125;); &#125; // 数据流获取数据的方式是异步的，可以放在Promise中 let postData = \"\"; req.on(\"data\", chunk =&gt; &#123; postData += chunk.toString(); &#125;) req.on(\"end\", () =&gt; &#123; if (!postData) &#123; return resolve(&#123;&#125;); &#125; resolve(JSON.parse(postData)); &#125;) &#125;) return promise;&#125; app.js中使用函数getPostData()获取PostData，原本req.body是空的，现在把获取到的postData放进去。把所有 路由的处理 都放在then()的回调函数中，让接下来在router中处理路由时都能拿到PostData: 123456789101112131415161718192021222324252627282930313233343536373839404142434445const serverHandle = (req, res) =&gt; &#123; //设置返回格式 JSON res.setHeader(\"Content-type\", \"application/json\") //获取path const url = req.url req.path = url.split(\"?\")[0] //解析query,parse方法用于将一个 JSON 字符串转换为JS对象 req.query = querystring.parse(url.split(\"?\")[1]) // 处理postData getPostData(req).then(postData =&gt; &#123; // 原本req.body是空的，现在把获取到的postData放进去 req.body = postData; //处理blog路由，blogData是通过调用函数handleBlogRouter得到的对象 const blogData = handleBlogRouter(req, res) if (blogData) &#123; res.end( //记住end是一句字符串，故必须把JS对象转换为JSON字符串 JSON.stringify(blogData) ) //记住要使用return来结束 return &#125; //处理user路由(当路由命中handleUserRouter时) const userData = handleUserRouter(req, res) if (userData) &#123; res.end( //记住end是一句字符串，故必须把对象转换为字符串 JSON.stringify(userData) ) //记住要使用return来结束 return &#125; //未命中路由，返回404（这个了解即可，使用不多） res.writeHead(404, &#123; \"Content-type\": \"text/plain\" &#125;) res.write(\"404 Not Found\\n\") res.end() &#125;)&#125; 4-10 开发 新建和更新博客路由新建博客路由 在controller-blog.js中新建一个函数newBlog()，先通过它返回假数据。 在router-blog.js中引入newBlog()，开发新建博客的路由&quot;/api/blog/new&quot; 在controller-blog.js中新建一个函数newBlog()，先通过它返回假数据： 1234567// 兼容：(ES6)如果没有blogData就给一个空对象const newBlog = (blogData = &#123;&#125;) =&gt; &#123; // blogData是一个博客对象，包含title content 属性 return &#123; id: 3//表示新建博客，插入到数据表里面的id &#125;&#125; 在router-blog.js中引入newBlog()，将controller中处理好的数据经过SuccessModel格式化后显示在页面上: 123456//新建一篇博客if (method === \"POST\" &amp;&amp; req.path === \"/api/blog/new\") &#123; // req.body.js中获取到的postData const data = newBlog(req.body); return new SuccessModel(data);&#125; 启动项目，使用postman测试一下效果： 可以在控制台看到postData： 更新博客路由 和新建博客路由的思路类似，主要区别在更新博客我们还需要从get请求中获取一个id，以此判断更新哪一篇博客。 要更新就需要获取id，在“获取博客详情”时我们使用了id，现在“更新博客路由”也要使用id，那我们就可以把获取id的表达式提取到路由处理的外面。 controller-blog.js中处理数据: 123456789// 更新一篇博客const updateBlog = (id, blogData = &#123;&#125;) =&gt; &#123; // id是要更新的博客的id // blogData是一个博客对象，包含title content 属性 console.log(\"update blog...\", id, blogData); // 返回true说明更新成功 return true;&#125; router-blog.js中获取数据并以正确格式显示在页面上： 1234567891011//更新一篇博客if (method === \"POST\" &amp;&amp; req.path === \"/api/blog/update\") &#123; // id是从req.query中获取到的 const result = updateBlog(id, req.body); // result是updateBlog()返回的布尔值，true则更新成功 if (result) &#123; return new SuccessModel(); &#125; else &#123; return new ErrorModel(\"更新博客失败\"); &#125;&#125; 通过postman测试updateBlog()返回true时：控制台： 通过postman测试updateBlog()返回false时： 4-11 开发 删除博客路由和登录路由删除博客路由 删除博客就很简单，只需要获取一个id即可。 在controller-blog.js中新建方法delBlog(),根据传入的id删除博客。 在router-blog.js中引用delBlog()， controller-blog.js： 123456const delBlog = (id) =&gt; &#123; // id是要删除的博客的id // 返回true说明删除成功 return true;&#125; router-blog.js： 123456789//删除一篇博客if (method === \"POST\" &amp;&amp; req.path === \"/api/blog/del\") &#123; const result = delBlog(id); if (result) &#123; return new SuccessModel(); &#125; else &#123; return new ErrorModel(\"删除博客失败\"); &#125;&#125; 通过postman测试updateBlog()返回true时：注意：我们虽然没有post数据，但是由于我们规定了method === &quot;POST&quot;，所以必须通过postman进行测试。 登录路由blog.js中的路由就写完了，接下来就要处理user.js相关的路由。 在controller文件夹中新建user.js文件，创建函数loginCheck用于处理登录路由的逻辑。 在router-user.js中，引入函数loginCheck，在函数handleUserPouter接收app.js中传入的参数req、res,在该函数中处理登录路由，返回由SuccessModel格式后的数据。 controller-user.js： 1234567891011const loginCheck = (username, password) =&gt; &#123; // 先使用假数据 if (username === \"hlz\" &amp;&amp; password === \"123\") &#123; return true; &#125; return false;&#125;module.exports = &#123; loginCheck&#125; router-user.js: 1234567891011121314151617181920const &#123; loginCheck &#125; = require(\"../controller/user\");const &#123; SuccessModel, ErrorModel &#125; = require(\"../model/resModel\");const handleUserRouter = (req, res) =&gt; &#123; const method = req.method//GET POST //登录 if (method === \"POST\" &amp;&amp; req.path === \"/api/user/login\") &#123; // username和password都是从postData中获取的 // 之前我们将password存在了req.body内 const &#123; username, password &#125; = req.body; const result = loginCheck(username, password); if (result) &#123; return new SuccessModel(); &#125; else &#123; return new ErrorModel(\"登录失败\"); &#125; &#125;&#125;module.exports = handleUserRouter 通过postman测试登录数据正确时： 总结系统架构设计的四层第一层： www.js [开启 Server]第二层：app.js [通信设置层]第三层：router文件夹 [路由相关业务逻辑层]第四层：controller文件夹 [数据处理层] 一开始进入第一层，项目执行的是bin文件夹下的www.js,这里面只是createServer的逻辑，端口连通什么的，和我们的业务逻辑没有关系。 第二层：app.js ，用来设置系统比较基础的功能（处理blog、user路由）或者定义一些公共参数（可以通过res/req传给路由，比如：获取path、解析query、异步获取PostData）还有设置返回类型（JSON），还是不涉及业务逻辑的处理。 第三层：router文件夹下的两个路由文件 blog.js、user.js，稍微涉及逻辑层，但只管路由。 来了什么路由就分配什么数据，通过SuccessModel/ErrorModel 处理数据格式。 匹配到路由（接口）以后会去处理一些数据，然后（通过SuccessModel）会给你返回一个 正确的格式。至于这些数据是怎么去匹配的，怎么去筛选的，是正确的还是错误的他不管，他只管和路由（接口）有关的数据分配。 第四层：controller.js 是最关心数据的层次，他没有res、req、path、query这些东西，只是对传入的数据进行计算处理再返回。（我们目前还没有计算，接下来会有）。至于数据返回后是怎么分配给路由的controller.js是不管的。 一层层拆分是一个由最基础的http服务向逻辑层转变的过程。 我们一开始先在www.js上创建服务器server并监听8000端口，这个服务器做的事情放到app.js的serverHandle中。然后在app.js中将HTTP请求req和响应res传到路由组件（router文件夹），并设置一些 公共参数 通过req/res传给路由组件以供使用。在router文件夹下的路由组件blog.js、user.js中，根据app.js传过来的req、res匹配对应的接口并将从controller.js中得到的数据进行一些格式的处理。最终返回显示在页面上。在controller.js中对获取到的数据进行8计算处理再返回8。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"ES6 参数默认值","slug":"ES6 参数默认值","date":"2020-02-07T13:29:20.000Z","updated":"2020-02-29T13:35:36.075Z","comments":true,"path":"2020/02/07/ES6 参数默认值/","link":"","permalink":"http://yoursite.com/2020/02/07/ES6 参数默认值/","excerpt":"在学习解构赋值时我们有提到过给 对象的属性/数组元素 设置默认值的方法。","text":"在学习解构赋值时我们有提到过给 对象的属性/数组元素 设置默认值的方法。 同样的，我们也可以给函数的参数设置默认值，当没有接收到该参数时就会使用默认值。 使用方法：在传参时直接通过=赋值即可，具体可看下面的例子。 注意：当需要第一个参数使用默认值，而指定第二个参数时，需要显式指定第一个参数值为undefined。(当显式指定参数为null时，是不会使用默认值的) 例子12345678910function sum (a = 10, b = 5) &#123; return a + b;&#125; console.log(sum(1, 2)); // 3console.log(sum(5)); // 10console.log(sum()); // 15// 当需要第一个参数使用默认值，而指定第二个参数时，需要显式指定第一个参数值为undefined// 需要注意，当显式指定参数为null时，是不会使用默认值的console.log(undefined, 10); // 20","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JS基础知识面试题（3）","slug":"JS基础知识面试题（3）","date":"2020-02-07T09:19:47.000Z","updated":"2020-06-29T04:25:10.237Z","comments":true,"path":"2020/02/07/JS基础知识面试题（3）/","link":"","permalink":"http://yoursite.com/2020/02/07/JS基础知识面试题（3）/","excerpt":"异步队列来实现依次执行函数 要求：完成函数executeQueue()，使得执行executeQueue(a,b,c);时会依次执行传入的函数a、b、c。","text":"异步队列来实现依次执行函数 要求：完成函数executeQueue()，使得执行executeQueue(a,b,c);时会依次执行传入的函数a、b、c。 重点：Promise 思路：我们需要实现一个队列，将这些异步函数添加进队列并且管理它们的执行，队列具有First In First Out的特性，也就是先添加进去的会被先执行，接着才会执行下一个(注意跟栈作区别)1234567891011121314151617181920212223242526272829// 异步函数avar a = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(\"a\"); return resolve() &#125;, 2000) &#125;)&#125;// 异步函数bvar b = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(\"b\"); return resolve() &#125;, 1000) &#125;)&#125;// 异步函数cvar c = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; console.log(\"c\"); return resolve() &#125;, 500) &#125;)&#125; 思路：链式调用then可参考Promise.prototype.then()与 链式操作，可以解决问题，但不合题意，只是一个思路过渡 123456789//链式调用a() .then(function () &#123; return b() &#125;) .then(function () &#123; return c() &#125;)// a b c 方法1：构建队列特点：封装方法，可移植到别处使用 12345678910// 构建队列function queue(arr) &#123; var sequence = Promise.resolve() arr.forEach(function (item) &#123; sequence = sequence.then(item) &#125;)&#125;// 执行队列queue([a, b, c]) 注意：then里放的函数不需要()，联系事件绑定函数进行理解。下面方法2函数猴是需要()的。 方法2：使用async、await构建队列同方法二，只是显得更高大上点 123456async function queue(arr) &#123; for (let promise of arr) &#123; await promise() &#125;&#125;queue([a, b, c]) 扩展：顺序执行需要传值的异步任务 场景：有a、b、c三个异步任务，要求必须先执行a，再执行b，最后执行c。且下一次任务必须要拿到上一次任务执行的结果，才能做操作 模拟3个异步函数：123456789101112131415161718192021222324// 异步函数avar a = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve('a') &#125;, 1000) &#125;)&#125;// 异步函数bvar b = function (data) &#123; return new Promise(function (resolve, reject) &#123; resolve(data + 'b') &#125;)&#125;// 异步函数cvar c = function (data) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(data + 'c') &#125;, 500) &#125;)&#125; 思路：链式操作then1234567891011//链式调用a() .then(function (data) &#123; return b(data) &#125;) .then(function (data) &#123; return c(data) &#125;) .then(function (data) &#123; console.log(data)// abc &#125;) 方法1：构建队列1234567891011121314// 构建队列function queue(arr) &#123; var sequence = Promise.resolve() arr.forEach(function (item) &#123; sequence = sequence.then(item) &#125;) return sequence&#125;// 执行队列queue([a, b, c]) .then(data =&gt; &#123; console.log(data)// abc &#125;) 执行第一轮的时候 sequence 为a的Promise对象。执行第二轮时， sequence 为aPromise成功时才进行的b函数最后返回的b的Promise对象，且b函数接受aPromise成功时传入的data。执行第三轮时， sequence 同上，为c的Promise对象。最后返回的sequence是c的Promise对象 方法2：使用async、await构建队列123456789101112async function queue(arr) &#123;// 函数中传（resolve中所传）的值保存在res中 let res = null for (let promise of arr) &#123; res = await promise(res) &#125; return await res&#125;queue([a, b, c]) .then(data =&gt; &#123; console.log(data)// abc &#125;) 图片的懒加载图片的懒加载也就是 延迟加载 ，图片没有出现在页面可视区域内之前都只加载一个内存小的图片用于占位，等到图片出现在页面可视区域内时才加载真正的图片。 react的react-lazy-load库 react中可使用react-lazy-load库来实现图片的懒加载。 原生js 原生js实现图片懒加载可参考这篇文章和这篇博客，如有需要可以了解JS中offsetTop、clientTop、scrollTop、offsetTop各位置属性详解 面试题：预加载 与 懒加载 预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。 懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS基础知识面试题（2）","slug":"JS基础知识面试题（2）","date":"2020-02-06T09:19:47.000Z","updated":"2020-06-28T02:17:13.672Z","comments":true,"path":"2020/02/06/JS基础知识面试题（2）/","link":"","permalink":"http://yoursite.com/2020/02/06/JS基础知识面试题（2）/","excerpt":"异步与单线程同步和异步的区别，分别举例子 同步任务会阻塞代码执行，而异步不会 alert是同步，setTimeout是异步","text":"异步与单线程同步和异步的区别，分别举例子 同步任务会阻塞代码执行，而异步不会 alert是同步，setTimeout是异步 关于setTimeout的笔试题1连续打印1 3 5 2一秒后打印4 12345678910console.log(1);setTimeout(function () &#123; console.log(2)&#125;, 2000)console.log(3);setTimeout(function () &#123; console.log(4)&#125;, 1000)console.log(5);// 连续打印1 3 5 ，1秒后4 ，1秒后2 注意所有的同步任务在主线程上执行，形成一个执行栈。异步任务有了 运行结果 才会在任务队列中放置一个事件。脚本运行时先依次运行执行栈中的所有同步任务，然后会从任务队列里提取事件，选择需要首先执行的异步任务然后执行。 4先有结果，所以4先出现在任务队列了 补充一个微任务、宏任务的题目 前端使用异步的场景有哪些 定时任务：setTimeout，setInterval(可参考笔记“setTimeout()与setInterval()”） 网络请求：ajax请求，动态&lt;img&gt;加载 事件绑定：事件函数绑定以后并不会等触发事件函数才继续执行程序，程序照常执行，等需要触发的时候才会执行事件绑定函数。 ajax请求的例子可参考ajax请求完整笔记打印“start”、“end”,然后等./data1.json中的数据请求成功后执行函数-打印获取到的数据data1。（关于$.get()可参考笔记） 动态&lt;img&gt;加载的例子关于createElement()可以参考笔记“JS中修改/创建HTML DOM元素的方法”关于onload事件可参考笔记 执行顺序：1 打印“start”2 创建一个图片元素img（可参考笔记）7 打印“end”6 给img的src赋值，src 属性值更新时浏览器会自动加载并显示出新图像。(可参考笔记)3-5 等img加载完成才会执行onload绑定的函数，打印loaded（可参考笔记） 事件绑定的例子addEventListener()相关笔记或者通过object.onclick=function(){SomeJavaScriptCode};绑定onclick事件也是一样的。 异步编程的方法 回调函数，这是异步编程最基本的方法。 例：假设有两个函数f1 和 f2，f1 是一个需要一定时间的函数。因为 f1 需要一定时间，所以可将 f2 写成 f1 的回调函数，将同步操作变成异步操作，这样f1 不会阻塞程序的运行，f2 也无需空空等待，例如 JQuery 的 ajax。1234567891011121314151617181920// 假设有两个函数f1 和 f2，f1 是一个需要一定时间的函数function f1() &#123; setTimeout(function()&#123; console.log('先执行 f1') &#125;,1000)&#125;function f2() &#123; console.log('再执行 f2')&#125;// 将 f2 写成 f1 的回调函数function f1(f2)&#123; setTimeout(function()&#123; console.log('先执行 f1') &#125;,1000) f2()&#125;function f2() &#123; console.log('再执行 f2')&#125;// 打印：“再执行 f2” “先执行 f1” 事件监听，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 例：为f1绑定一个事件，当f1发生click事件，就执行f2。 发布/订阅，与”事件监听”类似。 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 Promises对象，Promises 对象是CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。 简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。 例：f1的回调函数f2，f1().then(f2); async,async函数返回的是一个 Promise 对象，可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。当函数执行的时候，一旦遇到await就会先执行await的相关异步操作，等到异步操作完成，再接着执行函数体内后面的语句（包括同步任务也先等着await执行）。 12345678910111213async function demo() &#123; try &#123; await new Promise(function (resolve, reject) &#123; // something &#125;); &#125; catch (err) &#123; console.log(err); &#125;&#125;demo().then(data =&gt; &#123; console.log(data) // &#125;) 事件循环（JS的执行机制）可参考笔记从输入url到页面显示都经历了什么注意：异步任务被挂起时会由浏览器的引擎去执行他们，而同步任务则是由JS的引擎去执行。 Date、Math、数组API、对象APIDate、Math、数组API、对象API 的相关题目。数组API、对象API可以理解为数组、对象他们自带的那些方法。 获取2017-06-10格式的日期 1-18 函数 formatDate 接受一个Date对象，返回一个格式化后的日期 2-4 为防止报错，如果没有传入参数，就新建一个Date对象作为参数dt 5 getFullYear()获取年份 6 getMonth()获取月份，由于获取到的是0-11，所以需要+1 7 getDate()获取日期 8-15 由于我们需要格式化的日期是两位数的，所以当month&lt;10的时候我们需要在前面添加0。日期也是同理。 这里涉及到之前讲的字符串拼接，字符串&quot;0&quot;和数字month拼接后相当于强制类型转换，month将成为字符串。 17 通过-连接，将数字拼接字符串 得到 字符串 19 新建一个Date对象dt 20 将dt传入函数formatDate，得到格式化后的日期formatDate 21 打印格式化后的日期formatDate 获取长度一致的字符串随机数题目：获取随机数，要求是长度一致的字符串格式 注意：字符串也有slice()，和数组的slice()类似，用于截取字符串1 获取随机数random，小数部分长度不确定2 随机数后加上10个0，保证截取的时候有10位（保证不报错）。数字拼接字符串后等于强制类型转换，random 变为字符串3 使用字符串的slice()截取random的前10位（注意：10不在截取范围） 遍历对象和数组的通用forEach函数题目：写一个能遍历对象和数组的通用forEach函数（jquery中有现成的方法,数组本身就有forEach()） 1-14 定义forEach函数 参数1：对象/数组。参数2：函数。 注意：我们这里定义的forEach函数的index和item的顺序和数组自己的forEach()是反的 3-7 判断传入的是对象/数组，如果是数组，就用数组自己的forEach()，遍历数组后将index和item传入 参数2（fn函数），通过fn函数将index与item的位置调换一下后打印。 8-13 如果是对象，就通过for in遍历对象属性，并将 属性名称key 和 属性值obj[key]传给 参数2（fn函数），被调用后会被打印。 注意：in运算符在 数组 中是判断有无 数组下标 的，不是数组元素。在 对象 中判断有无 属性。返回值是boolean。 15 定义一个数组arr 17-19 调用我们定义的forEach函数，传入参数1为数组arr，参数2为一个函数，该函数接收两个参数并打印他们。 注意：这里的index和item的顺序和数组的forEach()是反的，主要是为了照顾后面对象的key、value 21 定义一个对象obj 22-24 让对象obj调用我们定义的forEach函数 key：属性名称。value：属性值。 如果把后端的计算逻辑放到前端/移动端需要注意什么？ 性能, 数据一致性, 尤其是同步下来 / 同步上去的数据, 用什么规则合并, 丢弃 / 更新的原则是什么. 安全性问题，需要甄别哪些能放哪些不能放，web 前端 js 文件可以修改，而且网络请求还能被抓包和伪造，一些没什么影响的计算逻辑放在前端可以减轻服务器压力，但有些比较重要的计算逻辑还是不要放在前端了 setTimeout()与let、闭包与作用域12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, i);&#125; 结果：打印10个10原因：因为循环是同步的，setTimeout 是异步的，所以循环结束以后才会执行setTimeout。而变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所以每一次循环的i其实都是同一个，循环到最后时前面的i全部被最后的结果覆盖了。所以最后，每次执行setTimeout时到父级作用域（这里是全局作用域）中找到的i都是10，10次打印的都是最后保存的i。 解决方法：局部变量的话就是每循环一次产生一个新的i，就不会被覆盖。所以我们可以通过闭包（也就是把循环的过程放到一个函数中封闭起来） 闭包：函数a内部定义一个函数b，函数b可以访问函数a的变量,函数b中的变量就是局部变量 如何让他输出自增队列 方法1：将var改为let 12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, i); &#125; 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。 方法2：使用闭包(即局部变量) 1234567for (var i = 0; i &lt; 10; i++) &#123; ((i) =&gt; &#123; setTimeout(function () &#123; console.log(i)//0-9 &#125;, i) &#125;)(i)&#125; 【将i传进函数中作为 函数作用域 的变量】 i=0时生成一个函数，i=1时又生成另外一个函数，总共通过循环创建了10个函数，循环了10次函数就会产生10个局部变量j，最后每个函数中的setTimeout都对应不同的j值。 那么setTimeout的参数函数去获取i的值时就会到当前的 父级作用域（函数作用域）中找，自然也不会10个标签都找到同一个i了。 方法3：删除setTimeout，那么每一次循环就立即输出，也就不存在覆盖的问题了。 深拷贝二维数组123456var target = [0, 1, null, [1, 2], &#123; name: \"a\" &#125;, function a() &#123; return 1; &#125;]// 完成下面的深拷贝函数function deepCopy(src) &#123; return dest;&#125; 递归拷贝所有层级属性（如果并不确定深拷贝的是数组还是对象，则参考这个笔记，对象的深拷贝需要多判断一个 是否为自身（非继承）属性） 复习： typeof将引用类型(数组、对象、函数)都判断为object。 for...in主要用于对 数组元素/对象属性 进行遍历。for ... in 循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作。 for(key in obj)中，当obj为对象时，key是属性名。当obj为数组时，key是数组下标。（不是数组元素） Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。12345678910111213141516171819202122var target = [0, 1, null, [1, 2], &#123; name: \"a\" &#125;, function a() &#123; return 1; &#125;]// 完成下面的深拷贝函数function deepCopy(obj) &#123; let objClone = []; // 遍历 数组元素 for (key in obj) &#123; //判断 数组元素 是否为引用类型（数组、对象、函数），是则递归复制 if (obj[key] &amp;&amp; typeof obj[key] === \"object\") &#123; objClone[key] = deepCopy(obj[key]); &#125; else &#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; return objClone;&#125;var objClone = deepCopy(target);objClone[3][0] = 5;console.log(target);console.log(objClone); 不能通过JSON对象 原理:不拷贝引用对象，使用stringify()拷贝一个 JSON字符串 会新辟一个新的存储地址，这样就切断了引用对象的指针联系。 缺点：无法实现对 数组/对象中 方法 的深拷贝，会显示为undefined。（ES6提供了object.assign()可解决这个问题，可参考这篇博客） 12345678910var target = [0, 1, null, [1, 2], &#123; name: \"a\" &#125;, function a() &#123; return 1; &#125;]// 完成下面的深拷贝函数function deepCopy(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var objClone = deepCopy(target);objClone[4].name = \"zzz\";console.log(target);console.log(objClone);","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS异步与单线程、Date、Math","slug":"JS异步与单线程、Date、Math","date":"2020-02-06T09:05:51.000Z","updated":"2020-02-28T13:56:14.291Z","comments":true,"path":"2020/02/06/JS异步与单线程、Date、Math/","link":"","permalink":"http://yoursite.com/2020/02/06/JS异步与单线程、Date、Math/","excerpt":"异步和单线程什么是异步例子：setTimeout是异步，依次打印100 300 200，异步是不会阻塞后面程序的进行的。","text":"异步和单线程什么是异步例子：setTimeout是异步，依次打印100 300 200，异步是不会阻塞后面程序的进行的。 注意：就算setTimeout没有设置时间，但执行栈中还是先执行同步任务，setTimeout会被拿出去放在任务队列中，等同步任务执行完毕才执行他，这和他需不需要等待没关系。 对比同步例子： alert是同步，打印100 200后需要等待用户点击确认，如不点击将一直卡在200，永远不会打印300。同步是会阻塞后面程序的进行。 何时需要异步 同步异步的区别就是会不会阻塞后面程序的运行，那么我们需要后面程序不被阻塞的时候就要使用异步。 在可能发生等待的时候，等待过程中不能像alert一样阻塞程序运行，因此，所以的“等待的情况”都需要异步。 前端使用异步的场景 定时任务：setTimeout，setInverval(可参考笔记“setTimeout()与setInterval()”） 网络请求：ajax请求，动态&lt;img&gt;加载 事件绑定：事件函数绑定以后并不会等触发事件函数才继续执行程序，程序照常执行，等需要触发的时候才会执行事件绑定函数。 ajax请求的例子可参考ajax请求完整笔记打印“start”、“end”,然后等./data1.json中的数据请求成功后执行函数-打印获取到的数据data1。（关于$.get()可参考笔记） 动态&lt;img&gt;加载的例子关于createElement()可以参考笔记“JS中修改/创建HTML DOM元素的方法”关于onload事件可参考笔记 执行顺序：1 打印“start”2 创建一个图片元素img（可参考笔记）7 打印“end”6 给img的src赋值，src 属性值更新时浏览器会自动加载并显示出新图像。(可参考笔记)3-5 等img加载完成才会执行onload绑定的函数，打印loaded（可参考笔记） 事件绑定的例子addEventListener()相关笔记或者通过object.onclick=function(){SomeJavaScriptCode};绑定onclick事件也是一样的。 可用作JS异步编程的方法 回调函数，这是异步编程最基本的方法。 例：假定有两个函数f1和f2，后者等待前者的执行结果，如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。【此时f2是异步的，她耗费的时间并不影响同步任务的执行】12345678910111213function f2() &#123; console.log(\"f2\");&#125;console.log(\"start\");function f1(callback) &#123; console.log(\"f1\"); setTimeout(function () &#123; callback(); &#125;, 1000);&#125;f1(f2);console.log(\"end\");// start f1 end f2 事件监听，任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 例：为f1绑定一个事件，当f1发生done事件，就执行f2。 发布/订阅，与”事件监听”类似。 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 Promises对象，Promises 对象是CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。 简单说，它的思想是，每一个异步任务返回一个Promise对象，该对象有一个then方法，允许指定回调函数。回调函数变成了链式写法，程序的流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。 例：f1的回调函数f2，f1().then(f2); 单线程 单线程：一次只能做一件事情，js就是单线程的。 异步：为了让单线程不阻塞，就出现了异步。 例子：注意：setTimeout没有设置时间，但执行栈中还是先执行同步任务，setTimeout会被拿出去放在任务队列中，等同步任务执行完毕才执行他，这和他需不需要等待没关系。 执行第一行，打印100 执行setTimeout后，传入setTimeout的函数会被暂存到任务队列，不会立即执行（单线程的特点，不能同时干两件事） 执行最后一行，打印300 待所有程序执行完，处于空闲状态时，会立马看有没有在任务队列暂存起来的要执行。 发现暂存起来的setTimeout中的函数无需等待时间，就立即来过来执行 事件循环（JS的执行机制）可参考笔记从输入url到页面显示都经历了什么注意：异步任务被挂起时会由浏览器的引擎去执行他们，而同步任务则是由JS的引擎去执行。 相关题目同步和异步的区别，分别举例子 同步任务会阻塞代码执行，而异步不会 alert是同步，setTimeout是异步 关于setTimeout的笔试题连续打印1 3 5 2一秒后打印4 12345678910console.log(1);setTimeout(function () &#123; console.log(2)&#125;, 2000)console.log(3);setTimeout(function () &#123; console.log(4)&#125;, 1000)console.log(5);// 连续打印1 3 5 ，1秒后4 ，1秒后2 注意所有的同步任务在主线程上执行，形成一个执行栈。异步任务有了 运行结果 才会在任务队列中放置一个事件。脚本运行时先依次运行执行栈中的所有同步任务，然后会从任务队列里提取事件，选择需要首先执行的异步任务然后执行。 4先有结果，所以4先出现在任务队列了 补充一个微任务、宏任务的题目 前端使用异步的场景有哪些 定时任务：setTimeout，setInverval(可参考笔记“setTimeout()与setInterval()”） 网络请求：ajax请求，动态&lt;img&gt;加载 事件绑定：事件函数绑定以后并不会等触发事件函数才继续执行程序，程序照常执行，等需要触发的时候才会执行事件绑定函数。 异步编程的方法 回调函数 事件绑定 监听/订阅 Promise DateDate是日期的构造函数可参考笔记Date对象 Math.random() Math的其他方法可参考笔记Math对象 在前端，Math.random()一般用于清除缓存 在项目中，有时改完js文件之后怎么也不能生效，只有清除浏览器缓存或者CTRL+F5强制刷新之后才能出现最新的版本，这样调试起来十分的不方便，此时可以在请求地址之后加上: 1\"?ran=\" + Math.random(); //当然这里参数 ran可以任意取了 采用随机数的方式，使每一次的请求都是一个新请求，从而防止浏览器从缓存中读取旧版本。注意：因为Math.random() 只能在Javascript 下起作用，故只能通过Javascript的调用才可以。 除了加入随机数还可以加入当前时间： 1\"?time=\" + new Date().getTime(); 同样可以使每次请求的地址都是不一样的，从而防止浏览器使用缓存。 Date、Math相关题目Date、Math、数组API、对象API 的相关题目。数组API、对象API可以理解为数组、对象他们自带的那些方法。 获取2017-06-10格式的日期 1-18 函数 formatDate 接受一个Date对象，返回一个格式化后的日期 2-4 为防止报错，如果没有传入参数，就新建一个Date对象作为参数dt 5 getFullYear()getFullYear()获取年份获取年份 6 getMonth()获取月份，由于获取到的是0-11，所以需要+1 7 getDate()获取日期 8-15 由于我们需要格式化的日期是两位数的，所以当month&lt;10的时候我们需要在前面添加0。日期也是同理。 这里涉及到之前讲的字符串拼接，字符串&quot;0&quot;和数字month拼接后相当于强制类型转换，month将成为字符串。 17 通过-连接，将数字拼接字符串 得到 字符串 19 新建一个Date对象dt 20 将dt传入函数formatDate，得到格式化后的日期formatDate 21 打印格式化后的日期formatDate 获取长度一致的字符串随机数题目：获取随机数，要求是长度一致的字符串格式 注意：字符串也有slice()，和数组的slice()类似，用于截取字符串1 获取随机数random，小数部分长度不确定2 随机数后加上10个0，保证截取的时候有10位（保证不报错）。数字拼接字符串后等于强制类型转换，random 变为字符串3 使用字符串的slice()截取random的前10位（注意：10不在截取范围） 遍历对象和数组的通用forEach函数题目：写一个能遍历对象和数组的通用forEach函数（jquery中有现成的方法,数组本身就有forEach()） 1-14 定义forEach函数 参数1：对象/数组。参数2：函数。 注意：我们这里定义的forEach函数的index和item的顺序和数组自己的forEach()是反的 3-7 判断传入的是对象/数组，如果是数组，就用数组自己的forEach()，遍历数组后将index和item传入 参数2（fn函数），通过fn函数将index与item的位置调换一下后打印。 8-13 如果是对象，就通过for in遍历对象属性，并将 属性名称key 和 属性值obj[key]传给 参数2（fn函数），被调用后会被打印。 注意：in运算符在 数组 中是判断有无 数组下标 的，不是数组元素。在 对象 中判断有无 属性。返回值是boolean。 15 定义一个数组arr 17-19 调用我们定义的forEach函数，传入参数1为数组arr，参数2为一个函数，该函数接收两个参数并打印他们。 注意：这里的index和item的顺序和数组的forEach()是反的，主要是为了照顾后面对象的key、value 21 定义一个对象obj 22-24 让对象obj调用我们定义的forEach函数 key：属性名称。value：属性值。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS基础知识面试题（1）","slug":"JS基础知识面试题（1）","date":"2020-02-05T15:05:51.000Z","updated":"2020-11-24T03:53:51.523Z","comments":true,"path":"2020/02/05/JS基础知识面试题（1）/","link":"","permalink":"http://yoursite.com/2020/02/05/JS基础知识面试题（1）/","excerpt":"慕课 快速搞定前端技术一面 第四五六章 笔记总结","text":"慕课 快速搞定前端技术一面 第四五六章 笔记总结 JS变量类型和计算JS中使用typeof能得到的哪些类型 6种，number、undefined、string、boolean、Symbol、function、object 准确判断5种 值类型(值类型中不能判断null) ，但是 引用类型 中只能判断函数，其余的 数组、对象、正则、日期 都被识别为object。 注意：值类型中null（空指针）也被识别为object！ 想要区分引用类型可使用instanceof运算符 基本（原始）、复杂与全局数据类型 何时使用===何时使用== 注意：不要混淆，只有NaN和自己不相等，null和undefined都和自己是相等的。 【需要值为null或者undefined时使用==简写，因为null==undefined】 只有一种情况使用双等号==，其他时候全部使用三等号===：此时第三行代码相当于第四行代码的简写，这是jquery的源码推荐写法。 双等号==是值相等，而三等号===是严格相等（值及类型是否完全相等），双等号==在运算的时候会进行 类型转换，而三等号===则不会。 对于string,number等基础类型，==和===是有区别的 不同类型间比较，==会先“转化成同一类型后的值”看“值”是否相等，===如果类型不同，其结果就是不等 ==统一先转换为数字比较（其中Boolean只有两个值：true==1，false==0；null与undefined相等；字符串数字等于数字值，空字符串&quot;&quot;==0 同类型比较，直接进行“值”比较，两者结果一样 对于Array,Object等引用类型，==和===是没有区别的，都是进行“指针地址”比较 基础类型与高级类型之间进行比较，==和===是有区别的 对于==，将引用类型转化为基础类型，进行“值”比较 因为类型不同，===结果为false JS中有哪些内置函数内置函数（数据封装类对象）：Object、Array、Boolean、String、Function、Date、RegExp、Error、Number JS变量按存储方式分为哪些类型，有何特点 按照存储方式区分为：值类型、引用类型 值类型（基本类型）：名字和值都会储存在栈内存中。 引用类型：名字存在 栈内存 中，值存在 堆内存 中，但是 栈内存 会提供一个 引用的地址 指向堆内存中的值（指针）。 特点：值类型相当于复制，引用类型则是 指针复制 并不是真正的拷贝，两个变量会共用同一个属性，他们的值的修改是相互干预的。 如何理解JSON JSON是一种数据格式，但从JS来看JSON就是一个JS内置对象，他有两个方法，“JavaScript Object Notation” 即 “JavaScript 对象表示法”，它是存储和交换文本信息的语法。 stringify（）把对象变成字符串parse（）把字符串变成对象 手写深拷贝 注意判断值类型和引用类型 注意判断是数组还是对象(判断对象自身属性) 递归 12345678910111213141516171819202122232425/** * 深拷贝方法1 * @param &#123;Object&#125; obj 要拷贝的对象 */function deepClone(obj) &#123; // 如遇值类型则直接返回，否则继续执行 if (typeof obj !== \"object\" || obj === null) &#123; return obj; &#125; // 初始化返回结果 let cloneObj = Array.isArray(obj) ? [] : &#123;&#125;; // 遍历对象属性/数组元素 for (key in obj) &#123; // 筛选对象自身属性 if (obj.hasOwnProperty(key)) &#123; // 递归调用deepClone()， cloneObj[key] = deepClone(obj[key]) &#125; &#125; // 返回结果 return cloneObj;&#125; 123456789101112131415161718192021222324252627282930/** * 深拷贝方法2 * @param &#123;Object&#125; obj 要拷贝的对象 */function deepClone(obj)&#123; // 根据传入的参数obj判断拷贝数组还是对象 let objClone = Array.isArray(obj)?[]:&#123;&#125;; // 判断参数obj是否是引用类型（数组/对象） if(obj &amp;&amp; typeof obj===\"object\")&#123; // 是对象则用for in遍历 对象属性 for(key in obj)&#123; // 如果是非继承属性 if(obj.hasOwnProperty(key))&#123; //判断ojb子元素（数组元素/对象属性）是否为引用类型（数组、对象、函数） if(obj[key]&amp;&amp;typeof obj[key] ===\"object\")&#123; //是则递归复制 objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; let a=[0, 1, null, [1, 2], &#123; name: \"a\" &#125;, function a() &#123; return 1; &#125;], b=deepClone(a);b[3][0] = 5;console.log(a,b); 原型和原型链如何准确判断变量是不是数组（typeof不行） instanceof判断引用类型（对象、数组、函数）属于哪个构造函数（Object()、Array()、Funtion()） Array.isArray(obj) class的原型本质 class实际上是函数（typeof）的语法糖 原型规则： 引用类型可自由扩展属性 引用类型的__proto__属性（隐式原型），属性值是一个普通的对象 函数有prototype属性（显式原型），属性值也是一个普通的对象 引用类型（数组、对象、函数）的__proto__属性值 都指向它的 构造函数的prototype属性值 当试图得到一个对象的某个属性/方法时，如果这个对象本身没有这个属性，那么会去它的__proto__属性（即它的构造函数的prototype属性）中寻找。 class与原型规则： 每个class（本质是函数）都有显式原型prototype 每个实例都有隐式原型__proto__ 实例的__proto__指向对应class的prototype 子类的显示原型（可理解为一个对象）的隐式原型 指向 父类的显式原型 父类的显示原型（可理解为一个对象）的隐式原型 指向 Object（构造函数 ）的显式原型 手写一个简易的jQuery，考虑插件和扩展性 DOM元素.get(index)通过检索匹配jQuery对象得到对应的DOM元素。 遍历each() 方法遍历一个jQuery对象，为每个匹配元素执行一个函数。 事件绑定on()在选定的元素上绑定一个或多个事件处理函数。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class jQuery &#123; constructor(selector) &#123; // 使this为DOM元素组成的类数组 const res = document.querySelectorAll(selector); const length = res.length; // 遍历类数组对象，放入this中 for (let i = 0; i &lt; length; i++) &#123; this[i] = res[i]; &#125; this.length = length; this.selector = selector; &#125; // .get(index)匹配jQuery对象得到对应的DOM元素 get(index) &#123; return this[index]; &#125; // each() 方法遍历一个jQuery对象，为每个匹配元素执行一个函数 each(fn) &#123; for (let i = 0; i &lt; this.length; i++) &#123; let elem = this[i]; fn(elem); &#125; &#125; // on()在选定的元素上绑定一个或多个事件处理函数。 on(type, fn) &#123; this.each(elem =&gt; &#123; elem.addEventListener(type, fn, false) &#125;) &#125; // 扩展很多 DOM API...&#125;// 插件(做一个弹出提示框的插件)jQuery.prototype.dialog = function (info) &#123; alert(info);&#125;// “造轮子”class myJQuery extends jQuery &#123; constructor(selector) &#123; super(selector) &#125; // 扩展自己的方法 addClass(className) &#123; &#125; style(data) &#123; &#125;&#125;// let $p=new jQuery(\"p\");// $p.get(1)// $p.each((elem) =&gt; console.log(elem.nodeName))// $p.on('click', () =&gt; alert('clicked'))// $p.dialog(\"abc\") 写一个原型链继承的例子【原型扩展属性（函数）】 基础例子：1-12：创建两个构造函数Animal()、Dog():13：将Dog的显示类型prototype更改为Animal()的一个对象:15：new一个Dog()的对象hashiqi，此时hashiqi不仅有Dog()的属性bark，还有一个继承自Dog.prototype(即Animal()的一个对象)的eat属性。【eat属性 就来自原型链继承。】 【面试千万别写这么简单，写下面封装DOM查询的例子】 封装DOM查询的例子 功能：获取DOM节点的内容并给节点绑定一个事件。 原理：通过扩展原型的方式来：根据id获取一个DOM节点，扩展Elem的显式原型方法html(),调用html()可改变/返回节点的innerHTML。再扩展一个原型方法on()，调用on()可绑定一个事件函数。（调用html()或者on()时都是到对象的隐式原型（即构造函数的显式原型）中找到的，这就是原型链继承） 测试方法：先通过不传参的html()测试是否能成功获取该id的DOM节点的innerHTML，可以则传参改变该innerHTML，并使用on()绑定click函数用于点击节点后弹出警示框。12345678910111213141516171819202122232425262728293031//根据传入的id获取DOM元素elemfunction Elem(id) &#123; //获取DOM元素并赋予elem this.elem = document.getElementById(id);&#125;// 修改Elem的显式原型，增加html()，使得调用html()可改/返innerHTMLElem.prototype.html = function (val) &#123; var elem = this.elem;//绑定elem //如果有传参就用参数替换掉获取到的DOM元素的innerHTML if (val) &#123; elem.innerHTML = val; // 可不反回this，返回是为了实现链式操作 return this; &#125; else &#123; return elem.innerHTML; &#125;&#125;// 同上增on()，使调用on()可绑定事件函数,type是函数名，fn是函数Elem.prototype.on = function (type, fn) &#123; var elem = this.elem; elem.addEventListener(type, fn);&#125;var div1 = new Elem(\"main-navigation\");// console.log(div1.html());说明能够获取innerHTMLdiv1.html(\"&lt;p&gt;你好呀&lt;/p&gt;\");div1.on(\"click\", function () &#123; alert(\"你点击了我！\") ;&#125;) 【关于“addEventListener”可参考笔记DOM基础的添加事件句柄。要区别于xx.onclick=function(){函数名(参数);}】 测试：打开一个网页，找到菜单栏对应的id：将此id用作参数调用构造函数Elem()创建一个对象div1，可打印出菜单栏的innerHTML，说明可以成功获取到div1的innerHTML：调用div1的显式原型中的html()进行数据的替换，调用div1的显式原型中的on()进行事件函数的绑定，点击div1后弹出警示框： 补充：链式操作因为我们的html()返回的是this，相当于返回了div1，所以可以链式操作： 123div1.html(\"&lt;p&gt;你好呀&lt;/p&gt;\").on(\"click\", function () &#123; alert(\"你点击了我！\");&#125;) 描述new一个对象的过程【考察 构造函数】 创建一个新对象f 构造函数Foo()的this指向这个新对象f（这里的this是个空对象） 执行Foo()函数代码（即对this进行赋值） 返回this对象给f（屏蔽第5行代码也是一样的效果，默认返回，此时this已经不是空对象了） 作用域和闭包对变量提升的理解【变量定义、函数声明（注意和函数表达式的区别）】 首先要明确，变量是声明被提升，使用函数声明方式声明的函数在ES5中是整个函数被提升，在ES6中只提升函数的声明。使用函数表达式声明的函数不存在函数提升，和ES6一样只提升函数的声明（具体见例子），函数内容（变量初始化的值）是不会被提升的，他们将被留在原来的位置。 这导致了JavaScript 函数能够在声明之前被调用，不过会undefined，还是建议规范书写代码。 ES6之前只有全局作用域和函数作用域，这两个作用域都存在变量提升。 var命令声明的变量，不管在什么位置，变量声明都会被提升到当前作用域的头部。（变量的提升只会对var命令声明的变量有效，其他不是用var命令声明的变量，不会发生变量的提升。） 注意：变量的提升只存在全局/函数作用域中，if(){}或for(){}都不是函数作用域，他们里面的变量会提升到包裹他们的全局/函数作用域的顶部。 ES6中取代var的let命令的作用域限定在块级，使用let声明的变量不存在变量提升。 函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。 补充：当出现多个同名变量与同名函数时，调用该变量名时的优先级为：变量声明&lt; 函数声明 &lt; 变量赋值（具体参考牛客网20191215第7题） 通过函数声明方式创建的函数会被提升，通过表达式方法创建的函数不会被函数提升（他会类似于变量提升）：123456789101112console.log(a) // f a() &#123; console.log(a) &#125;console.log(b) //undefined// 函数声明，整个函数提升function a() &#123; console.log(a) &#125;// 函数表达式，只提升b的声明，即var b=undefinedvar b = function()&#123; console.log(b)&#125; this的不同使用场景 在普通函数中执行，this指向window window.fn1();和fn1()效果一样，所以函数fn1()是由window对象调用的，根据谁调用函数的this就指向谁的原则，this指向window。 借助call()/apply()/bind()绑定/改变this指向，绑定的this是谁就是谁。 注意：与call、apply不同，必须要使用函数表达式创建才能使用bind()，使用bind()传参的方式也不同，可参考笔记bind() 在对象属性（方法）中 执行，this指向对象本身 在class/构造函数 里使用this，this指向class实例/构造函数实例本身 在箭头函数 里使用this，this是该函数的上级作用域的this 手写bind函数类数组转换为数组的多种方法 123456789101112131415161718192021222324252627// fn1()的隐式原型 指向 Function的显式原型，所以fn1.bind1()在Function.prototype上定义// 模拟 bindFunction.prototype.bind1 = function () &#123; // 将参数拆解为数组 const args = Array.prototype.slice.call(arguments) // 获取 this（数组第一项） const t = args.shift() // fn1.bind(...) 中的 fn1 const self = this // 返回一个函数 return function () &#123; return self.apply(t, args) &#125;&#125;function fn1(a, b, c) &#123; console.log('this', this) console.log(a, b, c) return 'this is fn1'&#125;const fn2 = fn1.bind1(&#123;x: 100&#125;, 10, 20, 30)const res = fn2()console.log(res) 创建10个a标签，点击时弹出对应的序号错误的例子错误原因分析： 确实可以得到0-9的10个&lt;a&gt;标签。 但是addEventListener()中添加的函数时要点击以后才会执行的，当我们10个标签都出现在页面上以后，i值变为10。 而for循环这10下是个很快的过程，等循环结束我们点击a标签，触发click的函数时，i是个自由变量，他要去父级作用域中找i的值，此时i已经循环到了10。 所以不管点击哪个标签，弹出的警示框的i都是10，并不是对应的序号。 总结：之所以会错就是因为这里的i是 全局作用域 下的i。 理解方式2：1.循环是同步的，所以创建标签时得到0-9是没问题的。2.但 事件绑定是异步的，所以他会等循环全部结束以后才开始执行。3.可i是全局变量，也就是说每次循环改变的都是同一个i的值，循环结束后i值变为10，此时事件绑定函数才开始执行，那么他每次到父级作用域中取到的其实都是i=10,所以不管点击哪个标签弹出的都是10。 正确示例 方法1：【使用闭包的持久性，注意重点不在匿名自执行函数，将i传进函数中作为 函数作用域 的变量】: i=0时生成一个函数，i=1时又生成另外一个函数，总共通过循环创建了10个函数。 那么第9行代码去获取i的值时就会到当前作用域（函数作用域）中找，自然也不会10个标签都找到同一个i了。 方法2：【for中使用let代替var定义i】123456789101112// let 是块级作用域，所以 let代替var定义i 能起到和闭包相同的效果，每一次循环就产生一个块级作用域// 注意：let i在for外面没用，那样i的块级作用域太大了(全局作用域）var a;for (let i = 0; i &lt; 10; i++) &#123; a = document.createElement(\"a\"); a.innerHTML = i + \"&lt;br/&gt;\"; a.addEventListener(\"click\", function (e) &#123; e.preventDefault(); alert(i); &#125;) document.body.appendChild(a);&#125; 如何理解作用域 自由变量，即当前作用域还没有定义的变量 父级作用域：在函数定义时规定的，不需要管执行顺序。 补充：this指向时函数执行时确定的，箭头函数没有自己的this，它则指向自己的父级作用域的this。 作用域链：即自由变量的层层查找，函数中找不到 自由变量 的值时一层层向上面的 父级作用域 进行查找的链式流程。 闭包的使用场景（也和作用域有关）： 本质就是在一个函数内部定义另一个函数 作用：让一个函数有权访问另一个函数作用域中变量。（即让函数访问自己的父级作用域这个函数中的变量） 实际开发中闭包的应用隐藏数据,如做一个简单的cache工具: 12345678910111213141516// 闭包隐藏数据，只提供 APIfunction createCache() &#123; const data = &#123;&#125; // 闭包中的数据，被隐藏，不被外界访问 return &#123; set: function (key, val) &#123; data[key] = val &#125;, get: function (key) &#123; return data[key] &#125; &#125;&#125;const c = createCache()c.set('a', 100)console.log( c.get('a') ) 判断用户是不是第一次校验：好处：将存储用户id的 变量_list 封装起来,那么闭包外面就拿不到 变量_list，减少用户数据泄露的危险。 游戏中的作用：假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。如果不用闭包，你可以直接用一个全局变量：window.lives = 30 // 还有三十条命但这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？用局部变量。但是用局部变量别人又访问不到，怎么办呢？暴露一个访问器（函数），让别人可以「间接访问」生命值lives。使用闭包后，在其他的 JS 文件中就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS作用域和闭包","slug":"JS作用域和闭包","date":"2020-02-05T14:00:08.000Z","updated":"2020-11-23T14:00:03.158Z","comments":true,"path":"2020/02/05/JS作用域和闭包/","link":"","permalink":"http://yoursite.com/2020/02/05/JS作用域和闭包/","excerpt":"更新：慕课 前端技术一面 第六章","text":"更新：慕课 前端技术一面 第六章 执行上下文 范围：一段&lt;script&gt;或者一个函数,一段&lt;script&gt;生成一个全局上下文，一个函数声明一个函数上下文。 全局：在执行全局上下文之前会先将 变量定义、函数声明提升 函数：在函数执行之前（注意不是定义之前），会先将 变量定义、函数声明、this、arguments（所有参数的集合）提升 注意：“函数声明”function fn（）{...}和“函数表达式”var fn =function(){...}的区别。（“函数表达式”不会被提升） “提升”可参考笔记 变量、函数提升 首先要明确，变量是声明被提升，函数在ES5中是整个函数被提升，在ES6中是只提升函数的声明（具体见例子），函数内容（变量初始化的值）是不会被提升的，他们将被留在原来的位置。 这导致了JavaScript 函数能够在声明之前被调用，不过会undefined，还是建议规范书写代码。 ES6之前只有全局作用域和函数作用域，这两个作用域都存在变量提升。 var命令声明的变量，不管在什么位置，变量声明都会被提升到当前作用域的头部。（变量的提升只会对var命令声明的变量有效，其他不是用var命令声明的变量，不会发生变量的提升。） ES6中取代var的let命令的作用域限定在块级，使用let声明的变量不存在变量提升。 函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。 ES5中说，在全局和函数作用域中定义的函数的声明和定义都将会被提前到当前作用域的顶部。 补充：当出现多个同名变量与同名函数时，调用该变量名时的优先级为：变量声明&lt; 函数声明 &lt; 变量赋值（具体参考牛客网20191215第7题） 通过函数声明方式创建的函数会被提升，通过表达式方法创建的函数不会被提升： this this要在函数执行时才能确认值，函数定义时无法确认。 实际上this最终指向的是那个调用它的对象，谁调用函数的就指向谁。 this可作为 构造函数/对象属性/普通函数 执行，另外还有call/apply/bind。 1-6：无法确定this的值（注意：this不一定是a！） 7：此时this值是a，this.name也就是A 8：此时this被call()绑定在对象{name:&#39;B&#39;}上，this值是{name:&#39;B&#39;}，this.name也就是B 9：将a的函数fn()赋值给fn1(注意：此时fn1也成为了函数，它不是对象) 10：此时this指向 window （因为this指向的是对象而不是函数,而函数fn1是由window调用的，原因见下），this.name有可能是undefined或者其他值，反正不是A 关于this指向window在函数fn1()中console.log(this);将得到window,window.fn1();和fn1()效果一样，所以函数fn1()是由window对象调用的，根据谁调用函数的this就指向谁的原则，this指向window。 作用域JS在ES6之前没有块级作用域，只有函数和全局作用域。【ES6规定了块级作用域，相关知识可参考笔记[let命令](https://huanglizhu.github.io/2019/10/15/let/0】 自由变量 和 作用域链 父级作用域：在函数定义时规定的，不需要管执行顺序。（可看下方的第二个例子） 自由变量：在当前作用域还没有定义的变量。 作用域链：函数中找不到 自由变量 的值时一层层向上面的 父级作用域 进行查找的链式流程。 自由变量例子： 父级作用域（作用域链）例子：6：a在F2()中找不到，到F2()的父级作用域F1()中找，还是找不到就到F1()的父级作用域（也就是全局作用域）中找，找到，打印100. 函数作为参数传递的例子：函数fn1作为参数传入 立即执行函数 中，在执行到fn2(30)的时候，30作为参数传入fn1中，这时候if(x&gt;num)中的num取的并不是立即执行函数中的num（100），而是取fn1函数中的自由变量num的父级作用域（全局作用域）下的num，即15，而30&gt;15，所以打印30。【注意：父级作用域是函数定义时决定的，不是调用时决定的！所以fn1（）的父级作用域是全局作用域】 闭包 闭包的本质就是在一个函数内部定义另一个函数，所以闭包可以理解成“定义在一个函数内部的函数”。 闭包作用：让一个函数有权访问另一个函数作用域中变量。 MDN、知乎上一个很好的解释和更多的例子 「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。 实例： 假设上面三行代码在一个立即执行函数中 三行代码中，有一个局部变量 local（也就是“环境”），有一个函数 foo，foo 里面可以访问到 local 变量。 在这里“局部变量 local 和 函数 foo ”就是一个闭包。 闭包的3个特性： 函数中定义函数 封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口； 持久性：一般的函数调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在（参数和变量不会在函数被调用完后被垃圾回收机制回收） 例子游戏中的例子假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。如果不用闭包，你可以直接用一个全局变量：window.lives = 30 // 还有三十条命但这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？用局部变量。但是用局部变量别人又访问不到，怎么办呢？暴露一个访问器（函数），让别人可以「间接访问」生命值lives。使用闭包后，在其他的 JS 文件中就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。 作用帮助js回调函数获取this js回调函数中的this默认是指向window 例子：在使用回调函数之前利用闭包的特性先使用一个变量_this保存this：12345678910111213const xiaoming = &#123; name:\"xiaoming\", age: null, getAge: function () &#123; let _this = this; //...ajax setTimeout(function () &#123; _this.age = 15; console.log(_this); &#125;, 1000); &#125;&#125;;xiaoming.getAge();//&#123;name: \"xiaoming\", age: 15, getAge: ƒ&#125; 隐藏一个变量（闭包的封闭性） 用于隐藏一个变量，让外界无法直接访问这个变量，但可以主动向外界提供访问接口，将更改变量的函数绑在window对象上使外界可以间接更改变量 游戏中加减生命值的例子 保存一个变量特殊状态中的值（闭包的持久性） 持久性：一般的函数调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在（参数和变量不会在函数被调用完后被垃圾回收机制回收）（例子如下“创建10个a标签点击弹出相应数字”的解决方案） 好处与坏处 好处： 保护函数内的变量安全 ，实现封装，防止变量流入其他环境发生命名冲突 在内存中维持一个变量特殊状态中的值，可以做缓存（但使用多了同时也是一项缺点，消耗内存） 可以使用 匿名自执行函数 来保存某个特殊状态中的值，调用完毕之后，系统自动注销函数，可以减少内存消耗 注意:匿名函数自执行只是产生闭包的一种情况，闭包是现象或者情形，不实用匿名函数自执行也有很多情况产生闭包，所以两者之间根本就是两回事儿，不能混淆。 坏处： 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 外部无法访问到闭包里面的变量，但可以在闭包内部返回一个方法，该方法将闭包内部的变量设置为null，让变量失去引用，会被系统自动回收。 如果闭包不需要了，想删除闭包，直接将子函数设置为null就可以了。 注意：闭包不会造成内存泄漏（参考1参考2）： 相关题目说一下对变量提升的理解【变量定义、函数声明（注意和函数表达式的区别）】 首先要明确，变量是声明被提升，函数在ES5中是整个函数被提升，在ES6中是只提升函数的声明（具体见例子），函数内容（变量初始化的值）是不会被提升的，他们将被留在原来的位置。 这导致了JavaScript 函数能够在声明之前被调用，不过会undefined，还是建议规范书写代码。 ES6之前只有全局作用域和函数作用域，这两个作用域都存在变量提升。 var命令声明的变量，不管在什么位置，变量声明都会被提升到当前作用域的头部。（变量的提升只会对var命令声明的变量有效，其他不是用var命令声明的变量，不会发生变量的提升。） 注意：变量的提升只存在全局/函数作用域中，if(){}或for(){}都不是函数作用域，他们里面的变量会提升到包裹他们的全局/函数作用域的顶部。 ES6中取代var的let命令的作用域限定在块级，使用let声明的变量不存在变量提升。 函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。 ES5中说，在全局和函数作用域中定义的函数的声明和定义都将会被提前到当前作用域的顶部。 补充：当出现多个同名变量与同名函数时，调用该变量名时的优先级为：变量声明&lt; 函数声明 &lt; 变量赋值（具体参考牛客网20191215第7题） 通过函数声明方式创建的函数会被提升，通过表达式方法创建的函数不会被提升： this的不同使用场景 在普通函数中执行，this指向window window.fn1();和fn1()效果一样，所以函数fn1()是由window对象调用的，根据谁调用函数的this就指向谁的原则，this指向window。 借助call()/apply()/bind()绑定/改变this指向，绑定的this是谁就是谁。 注意：与call、apply不同，必须要使用函数表达式创建才能使用bind()，使用bind()传参的方式也不同，可参考笔记bind() 在对象属性（方法）中 执行，this指向对象本身 在class/构造函数 里使用this，this指向class实例/构造函数实例本身 在箭头函数 里使用this，this是该函数的上级作用域的this 手写bind函数类数组转换为数组的多种方法 123456789101112131415161718192021222324252627// fn1()的隐式原型 指向 Function的显式原型，所以fn1.bind1()在Function.prototype上定义// 模拟 bindFunction.prototype.bind1 = function () &#123; // 将参数拆解为数组 const args = Array.prototype.slice.call(arguments) // 获取 this（数组第一项） const t = args.shift() // fn1.bind(...) 中的 fn1 const self = this // 返回一个函数 return function () &#123; return self.apply(t, args) &#125;&#125;function fn1(a, b, c) &#123; console.log('this', this) console.log(a, b, c) return 'this is fn1'&#125;const fn2 = fn1.bind1(&#123;x: 100&#125;, 10, 20, 30)const res = fn2()console.log(res) 创建10个&lt;a&gt;标签，点击时弹出对应的序号错误的例子错误原因分析： 确实可以得到0-9的10个&lt;a&gt;标签。 但是addEventListener()中添加的函数时要点击以后才会执行的，当我们10个标签都出现在页面上以后，i值变为10。 而for循环这10下是个很快的过程，等循环结束我们点击a标签，触发click的函数时，i是个自由变量，他要去父级作用域中找i的值，此时i已经循环到了10。 所以不管点击哪个标签，弹出的警示框的i都是10，并不是对应的序号。 总结：之所以会错就是因为这里的i是 全局作用域 下的i。 理解方式2：1.循环是同步的，所以创建标签时得到0-9是没问题的。2.但 事件绑定是异步的，所以他会等循环全部结束以后才开始执行。3.可i是全局变量，也就是说每次循环改变的都是同一个i的值，循环结束后i值变为10，此时事件绑定函数才开始执行，那么他每次到父级作用域中取到的其实都是i=10,所以不管点击哪个标签弹出的都是10。 正确示例 方法1：【使用闭包的持久性，注意重点不在匿名自执行函数，将i传进函数中作为 函数作用域 的变量】: i=0时生成一个函数，i=1时又生成另外一个函数，总共通过循环创建了10个函数。 那么第9行代码去获取i的值时就会到当前作用域（函数作用域）中找，自然也不会10个标签都找到同一个i了。 方法2：【for中使用let代替var定义i】123456789101112// let 是块级作用域，所以 let代替var定义i 能起到和闭包相同的效果// 注意：let i在for外面没用，那样i的块级作用域太大了var a;for (let i = 0; i &lt; 10; i++) &#123; a = document.createElement(\"a\"); a.innerHTML = i + \"&lt;br/&gt;\"; a.addEventListener(\"click\", function (e) &#123; e.preventDefault(); alert(i); &#125;) document.body.appendChild(a);&#125; 如何理解作用域 自由变量，即当前作用域还没有定义的变量 作用域链，即自由变量的层层查找 闭包的使用场景（也和作用域有关） 实际开发中闭包的应用隐藏数据,如做一个简单的cache工具: 12345678910111213141516// 闭包隐藏数据，只提供 APIfunction createCache() &#123; const data = &#123;&#125; // 闭包中的数据，被隐藏，不被外界访问 return &#123; set: function (key, val) &#123; data[key] = val &#125;, get: function (key) &#123; return data[key] &#125; &#125;&#125;const c = createCache()c.set('a', 100)console.log( c.get('a') ) 判断用户是不是第一次校验：好处：将存储用户id的 变量_list 封装起来,那么闭包外面就拿不到 变量_list，减少用户数据泄露的危险。 游戏中的作用：假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。如果不用闭包，你可以直接用一个全局变量：window.lives = 30 // 还有三十条命但这样看起来很不妥。万一不小心把这个值改成 -1 了怎么办。所以我们不能让别人「直接访问」这个变量。怎么办呢？用局部变量。但是用局部变量别人又访问不到，怎么办呢？暴露一个访问器（函数），让别人可以「间接访问」生命值lives。使用闭包后，在其他的 JS 文件中就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。 setTimeout()与let、闭包（其实和上面的“创建10个&lt;a&gt;标签，点击时弹出对应的序号”类似，事件绑定和setTimeout都是异步。而他们到父级作用域（这里是全局作用域）中找i时拿到的都是同一个i，所以我们要想办法让他们的 父级作用域 变成 函数作用域，每个i都保存在不同的函数中，这样就不会重复了） 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, i);&#125; 结果：打印10个10原因：因为循环是同步的，setTimeout 是异步的，所以循环结束以后才会执行setTimeout。而变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所以每一次循环的i其实都是同一个，循环到最后时前面的i全部被最后的结果覆盖了。所以最后，每次执行setTimeout时到父级作用域（这里是全局作用域）中找到的i都是10，10次打印的都是最后保存的i。 解决方法：局部变量的话就是每循环一次产生一个新的i，就不会被覆盖。所以我们可以通过闭包（也就是把循环的过程放到一个函数中封闭起来） 闭包：函数a内部定义一个函数b，函数b可以访问函数a的变量,函数b中的变量就是局部变量 如何让他输出自增队列 方法1：将var改为let 12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, i); &#125; 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。 方法2：使用闭包(即局部变量) 1234567for (var i = 0; i &lt; 10; i++) &#123; ((j) =&gt; &#123; setTimeout(function () &#123; console.log(j)//0-9 &#125;, i) &#125;)(i)&#125; 【将i传进函数中作为 函数作用域 的变量】 i=0时生成一个函数，i=1时又生成另外一个函数，总共通过循环创建了10个函数，循环了10次函数就会产生10个局部变量j，最后每个函数中的setTimeout都对应不同的j值。 那么setTimeout的参数函数去获取i的值时就会到当前的 父级作用域（函数作用域）中找，自然也不会10个标签都找到同一个i了。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS class和继承 原型和原型链","slug":"JS class和继承 原型和原型链","date":"2020-02-04T13:26:39.000Z","updated":"2020-11-23T03:11:14.803Z","comments":true,"path":"2020/02/04/JS class和继承 原型和原型链/","link":"","permalink":"http://yoursite.com/2020/02/04/JS class和继承 原型和原型链/","excerpt":"更新：慕课 快速解决前端技术一面 第五章","text":"更新：慕课 快速解决前端技术一面 第五章 构造函数 构造函数命名使用大写字母开头。 所有的引用类型都有构造函数（对象、数组、函数） 所以精确判断 引用类型 时我们无法使用typeof，但可以通过 instanceof 判断她们的构造函数） 例子： 解析： 构造函数Foo，第五行代码屏蔽与都不影响，因为默认就是把this这个对象返回给调用这个构造函数的对象。当我们执行第7行代码时，实际先把Foo函数内的this变成了一个空对象，this再指向f，然后往Foo函数中传入两个参数赋值在this上，在Foo函数中完成绑定后再把this对象返回给f，可以得到f.name=’zhangsan’,f.age=20。 过程： 创建一个新对象f 构造函数Foo()的this指向这个新对象f（这里的this是个空对象） 执行Foo()函数代码（即降属性绑定在this上） 返回this对象给f（屏蔽第5行代码也是一样的效果，默认返回，此时this已经不是空对象了） 扩展 vara ={}其实是var a = new Object（）的语法糖 vara=[]其实是var a = new Array（）的语法糖 function Foo(){...}其实是var Foo = new Function(){...}的语法糖 可以使用instanceof判断 引用类型（数组、对象、函数） 属于哪个 构造函数。 判断一个变量是否为“数组”：变量 instanceof Array class和继承 ES6 class class： class的本质是函数（通过typeOf可判断），他是语法糖 继承：（例子见下） extends：子类继承父类，让子类获得父类的方法、属性 super：子类extends父类后，需要在子类的构造函数中使用super();(可传参，相当于执行父类的构造函数) 子类中扩展或重写方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 父类class People &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat something`) &#125;&#125;// 子类class Student extends People &#123; constructor(name, number) &#123; super(name) this.number = number &#125; sayHi() &#123; console.log(`姓名 $&#123;this.name&#125; 学号 $&#123;this.number&#125;`) &#125; eat() &#123; console.log(`$&#123;this.name&#125; 爱吃油炸食品`) &#125;&#125;// 子类class Teacher extends People &#123; constructor(name, major) &#123; super(name) this.major = major &#125; teach() &#123; console.log(`$&#123;this.name&#125; 教授 $&#123;this.major&#125;`) &#125;&#125;// 实例const xialuo = new Student('夏洛', 100)console.log(xialuo.name)console.log(xialuo.number)xialuo.sayHi()xialuo.eat()// 实例const wanglaoshi = new Teacher('王老师', '语文')console.log(wanglaoshi.name)console.log(wanglaoshi.major)wanglaoshi.teach()wanglaoshi.eat() class与原型关系 原型关系： 每个class（本质是函数）都有显式原型prototype 每个实例都有隐式原型__proto__ 实例的__proto__指向对应class的prototype 子类的显示原型（prototype属性值为一个对象）的隐式原型 指向 父类的显式原型 父类的显示原型（prototype属性值为一个对象）的隐式原型 指向 Object（构造函数 ）的显式原型 class与原型链 class实际上是函数 class的显式原型可以理解为一个对象 class与原型链图示：Student是子类，People是父类，子类的显式原型的隐式原型全等于父类的显式原型 子类的显式原型的隐式原型全等于父类的显式原型 图解： 例子：（代码在上面的“class和继承中”） 假设要访问xialuo.eat()，则先在xialuo实例里找，找不到就到xialuo的隐式原型__proto__中找，即子类Stuent的显式原型中找，而里面只有sayHi()没有eat()，所以会继续到子类的Student的显式原型的隐式原型__proto__里找，即父类People的显式原型，成功找到eat() 图示：class的显式原型 对象class的显式原型可以理解为一个对象，所以class的显式原型的隐式原型 指向 Object的显式原型 原型规则（5条）原型规则是学习原型链的基础 引用类型的自由扩展属性所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性。 引用类型的__proto__属性（隐式原型）所有的引用类型（数组、对象、函数），都有一个__proto__属性(隐式原型)，属性值是一个普通的对象。 函数的prototype属性（显式原型）所有的函数都有一个prototype属性（显式原型），属性值也是一个普通的对象。【注意：数组、对象没有prototype属性】 __proto__与prototype属性值所有的引用类型（数组、对象、函数）的__proto__属性值 都指向它的 构造函数的prototype属性值。【“指向”即“全等”，__proto__属性值===它的构造函数的prototype属性值】 第五条原型规则当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去它的__proto__属性（即它的构造函数的prototype属性）中寻找。 例子： 解析：看第15行代码，f是通过构造函数Foo创建的对象，f只有第10行添加的printName属性，没有alertName属性，根据第五条原则，f会去它的__proto__属性（即它的构造函数Foo函数的prototype属性）中寻找，找到第5行的alert（this.name)，弹出’zhangsan’。 注意：第6行的this也是指向对象f，14行打印出的也是’zhangsan’。 hasOwnProperty()判断原型属性在使用for in循环对象属性时，我们希望避开他来自原型的属性，虽然现在高级浏览器上已经回屏蔽，但为了保证 程序健壮性 还是建议大家加上这个判断，能在第6行打印的就是来自原型的属性。 原型链 例子： 解析： f中找不到toString()，根据第五条规则，去f的__proto__属性（即f的构造函数Foo()的prototype属性）中寻找,也没找到。 注意：原型规则中提到__proto__属性值是一个普通的对象，又因为每个对象都有一个__proto__属性，所以我们去f.__proto__（一个对象）的__proto__中查找。 根据第四条原则，我们知道 对象的__proto__ 全等于 它的构造函数（Object）的prototype属性值，也就是说要去Object的prototype属性值 中找toString()，Object.prototype.toString()是存在的。 注意： Object是构造函数，不是对象！ JS为了防止死循环，到Object.prototype（构造函数的显示类型）如果找不到再继续往下的话就是到null了 示意图： instanceof运算符 作用：判断引用类型（对象、数组、函数）属于哪个构造函数（Object()、Array()、Funtion()）。【也就是让我们去找这个 引用类型 里有没有 构造函数的显示原型】 语法：object instanceof constructor 参数：object（要检测的引用类型）；constructor（某个构造函数） 返回值：测试它 左边的引用类型 是否是它 右边的构造函数的实例，返回 boolean 的数据类型。是则返回true，否则返回false。 注意： 12typeof null === 'object' //truenull instanceof Object //false 例子：结合上一个例子，f instanceof Foo的判断逻辑是： 判断f是否是Foo函数的实例，即判断f中是否能找到Foo函数的显示原型prototype。 根据原则，f中找不到该属性时，顺着f的__proto__一层一层往上，看看能否对应到Foo.prototype 找到了，返回true 题目解答如何准确判断一个变量是数组类型（typeof肯定不行） 写一个原型链继承的例子基础例子：1-12：创建两个构造函数Animal()、Dog():13：将Dog的显示类型prototype更改为Animal()的一个对象:15：new一个Dog()的对象hashiqi，此时hashiqi不仅有Dog()的属性bark，还有一个继承自Dog.prototype(即Animal()的一个对象)的eat属性。【eat属性 就来自原型链继承。】 【面试千万别写这么简单，写下面的例子】 封装DOM查询的例子 功能：获取DOM节点的内容并给节点绑定一个事件。 原理：通过扩展原型的方式来：根据id获取一个DOM节点，扩展Elem的显式原型方法 html(),调用html()可改变/返回节点的innerHTML。再扩展一个原型方法on()，调用on()可绑定一个事件函数。 测试方法：先通过不传参的html()测试是否能成功获取该id的DOM节点的innerHTML，可以则传参改变该innerHTML，并使用on()绑定click函数用于点击节点后弹出警示框。12345678910111213141516171819202122232425262728293031//根据传入的id获取DOM元素elemfunction Elem(id) &#123; //this.elem是获取到的对象 this.elem = document.getElementById(id);&#125;// 修改Elem的显式原型,调用html()可改/返innerHTMLElem.prototype.html = function (val) &#123; var elem = this.elem;//绑定elem //如果有传参就用参数替换掉获取到的DOM元素的innerHTML if (val) &#123; elem.innerHTML = val; // 可不反回this，返回是为了实现链式操作 return this; &#125; else &#123; return elem.innerHTML; &#125;&#125;// 调用on()可绑定事件函数,type是函数名，fn是函数Elem.prototype.on = function (type, fn) &#123; var elem = this.elem; elem.addEventListener(type, fn);&#125;var div1 = new Elem(\"main-navigation\");// console.log(div1.html());说明能够获取innerHTMLdiv1.html(\"&lt;p&gt;你好呀&lt;/p&gt;\");div1.on(\"click\", function () &#123; alert(\"你点击了我！\") ;&#125;) 【关于“addEventListener”可参考笔记DOM基础的添加事件句柄。要区别于xx.onclick=function(){函数名(参数);}】 测试：打开一个网页，找到菜单栏对应的id：将此id用作参数调用构造函数Elem()创建一个对象div1，可打印出菜单栏的innerHTML，说明可以成功获取到div1的innerHTML：调用div1的显式原型中的html()进行数据的替换，调用div1的显式原型中的on()进行事件函数的绑定，点击div1后弹出警示框： 补充：链式操作因为我们的html()返回的是this，相当于返回了div1，所以可以链式操作： 123div1.html(\"&lt;p&gt;你好呀&lt;/p&gt;\").on(\"click\", function () &#123; alert(\"你点击了我！\");&#125;) 描述new一个对象的过程 创建一个新对象f 构造函数Foo()的this指向这个新对象f（这里的this是个空对象） 执行Foo()函数代码（即对this进行赋值） 返回this对象给f（屏蔽第5行代码也是一样的效果，默认返回，此时this已经不是空对象了） zepto（或其他框架）源码中如何使用原型链 阅读源码是高效提高技能的方式 但不能“埋头苦钻”有技巧在其中 慕课网搜索”zepto设计和源码分析”","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"hexo deploy中报错：unable to auto-detect email address","slug":"hexo deploy email address","date":"2020-02-03T05:02:18.000Z","updated":"2020-02-03T05:08:06.679Z","comments":true,"path":"2020/02/03/hexo deploy email address/","link":"","permalink":"http://yoursite.com/2020/02/03/hexo deploy email address/","excerpt":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。","text":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后未能成功部署到github上。 回到 git bush 中发现给出如下提示： 1234567891011121314*** Please tell me who you are.Run git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\"to set your account's default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got 'HLZ@DESKTOP-0N6K07S.(none)')Everything up-to-dateBranch 'master' set up to track remote branch 'master' from 'git@github.com:huanglizhu/huanglizhu.github.io.git'.INFO Deploy done: git 提示分析提示中出现了“unable to auto-detect email address”，也就是说他“无法自动检测电子邮件地址”。,并给出了解决方案： 12git config --global user.email \"you@example.com\"git config --global user.name \"Your Name\" 解决问题 结果","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"JS浅拷贝与深拷贝","slug":"JS浅拷贝与深拷贝","date":"2020-02-02T08:08:08.000Z","updated":"2020-06-28T01:32:51.602Z","comments":true,"path":"2020/02/02/JS浅拷贝与深拷贝/","link":"","permalink":"http://yoursite.com/2020/02/02/JS浅拷贝与深拷贝/","excerpt":"往期笔记实例引入 在ES6的解构赋值中我们提到过:使用扩展运算符复制对象是浅拷贝的。 在Redux入门（1）中我们提到过:不能修改state,所以我们需要对state进行深拷贝成newState。","text":"往期笔记实例引入 在ES6的解构赋值中我们提到过:使用扩展运算符复制对象是浅拷贝的。 在Redux入门（1）中我们提到过:不能修改state,所以我们需要对state进行深拷贝成newState。 基本类型与引用类型 数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和引用数据类型（ Object，Array，Date，Function）。 基本类型：名字和值都会储存在栈内存中。 引用类型：名字存在 栈内存 中，值存在 堆内存 中，但是 栈内存 会提供一个 引用的地址 指向堆内存中的值（指针）。 赋值和浅拷贝的区别 当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值. 如果属性是引用类型，拷贝的就是内存地址. 因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。 例子对比赋值与浅拷贝会对原对象带来哪些改变： 1234567891011// 对象赋值var obj1 = &#123; 'name' : 'zhangsan', 'age' : '18', 'language' : [1,[2,3],[4,5]],&#125;;var obj2 = obj1;obj2.name = \"lisi\";obj2.language[1] = [\"二\",\"三\"];console.log('obj1',obj1)console.log('obj2',obj2) 1234567891011121314151617181920// 浅拷贝var obj1 = &#123; 'name' : 'zhangsan', 'age' : '18', 'language' : [1,[2,3],[4,5]],&#125;;var obj3 = shallowCopy(obj1);obj3.name = \"lisi\";obj3.language[1] = [\"二\",\"三\"];function shallowCopy(src) &#123; var dst = &#123;&#125;; for (var prop in src) &#123; if (src.hasOwnProperty(prop)) &#123; dst[prop] = src[prop]; &#125; &#125; return dst;&#125;console.log('obj1',obj1)console.log('obj3',obj3) 上面例子中，obj1是原始数据，obj2是赋值操作得到，而obj3浅拷贝得到。我们可以很清晰看到对原始数据的影响，具体请看下表： 深拷贝与浅拷贝假设B复制了A，当修改A时，看B是否会发生变化，如果B也跟着变了，说明这是浅拷贝，如果B没变，那就是深拷贝。 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。 浅拷贝：拷贝一个变量的时候，复制了栈内存，没有复制 堆内存。 但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 深拷贝：拷贝一个变量的时候，复制了栈内存，同时也复制了 堆内存。 深拷贝实现思路在 堆内存 中也开辟一个新的内存专门为b存放值，就像基本类型那样，也就达到深拷贝的效果了。 浅拷贝：浅拷贝可以理解为就是复制一份来引用，所有引用对象都指向一份数据，并且都可以修改这份数据。 对于字符串类型，浅拷贝是对值的拷贝，对于对象来说，浅拷贝是对对象地址 的拷贝，也就是复制的结果是两个对象指向同一个内存地址，修改其中一个对象的属性，则另一个对象的属性也会改变。 深拷贝：深拷贝则是复制变量值，对于非基本类型的变量，则递归至基本类型变量后，再复制。深复制不同于浅复制，它会开辟新的内存地址，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 深、浅拷贝的优缺点 浅拷贝 优点：拷贝速度快，占用内存空间小。 缺点：如果你改变了对象B所指向的内存地址，你同时也会改变对象A指向这个地址的字段。 深拷贝 这种方式会完全拷贝所有数据，优点是B与A不会相互依赖（A,B完全脱离关联） 缺点：拷贝的速度更慢，代价更大 （可理解为耗费了更多内存空间）。 对象的浅拷贝Object.assign() 语法：Object.assign(目标对象, ...源对象) Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。 但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。 注意：当object只有一层的时候，是深拷贝 MDN文档12345// 浅拷贝var obj = &#123; a: &#123;a: \"kobe\", b: 39&#125; &#125;;var initalObj = Object.assign(&#123;&#125;, obj);initalObj.a.a = \"wade\";console.log(obj.a.a); // wade 特别情况深拷贝注意：当object只有一层的时候，是深拷贝 1234// 当object只有一层的时候，是深拷贝const obj = &#123; a: 1 &#125;;const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; 数组的浅拷贝slice和concat这两个方法，仅适用于对不包含引用对象的一维数组的深拷贝。对于包含引用对象的数组，这两个方法是浅拷贝（比如[{&quot;name&quot;:&quot;weifeng&quot;},{&quot;name&quot;:&quot;boy&quot;}]） Array.prototype.slice方法 对于array对象的slice函数，返回一个数组的一段。（仍为数组） 语法：arrayObj.slice(start, [end]) arrayObj 必选项。一个 Array 对象。 start 必选项。arrayObj 中所指定的部分的开始元素是从零开始计算的下标。 end 可选项。arrayObj 中所指定的部分的结束元素是从零开始计算的下标。 说明： slice 方法返回一个 Array 对象，其中包含了 arrayObj 的指定部分。 slice 方法一直复制到 end 所指定的元素，但是不包括该元素。 如果 start 为负，将它作为 length + start处理，此处 length 为数组的长度。 如果 end 为负，就将它作为 length + end 处理，此处 length 为数组的长度。 如果省略 end ，那么 slice 方法将一直复制到 arrayObj 的结尾。 如果 end 出现在 start 之前，不复制任何元素到新数组中。 深拷贝与浅拷贝 当数组元素是基本数据类型，比如String，Number，Boolean时，属于深拷贝 当数组元素是引用数据类型，比如Object，Array,Function时，属于浅拷贝12345var arr1 = [\"1\",\"2\",\"3\"];var arr2 = arr1.slice(0);arr2[1] = \"9\";console.log(\"数组的原始值：\" + arr1 );//1 2 3console.log(\"数组的新值：\" + arr2 );//1 9 3 Array.prototype.concat方法 concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 语法：arrayObject.concat(arrayX,arrayX,......,arrayX) 说明：返回一个新的数组。该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。 深拷贝与浅拷贝 当数组元素是基本数据类型，比如String，Number，Boolean时，属于深拷贝 12345var arr1 = [\"1\",\"2\",\"3\"];var arr2 = arr1.concat();arr2[1] = \"9\";console.log(\"数组的原始值：\" + arr1 );// 1 2 3console.log(\"数组的新值：\" + arr2 );//1 9 3 当数组元素是引用数据类型，比如Object，Array时，属于浅拷贝 12345var arr1 = [&#123;a:1&#125;,&#123;b:2&#125;,&#123;c:3&#125;];var arr2 = arr1.concat();arr2[0].a = \"9\";console.log(\"数组的原始值：\" + arr1[0].a ); // 数组的原始值：9console.log(\"数组的新值：\" + arr2[0].a ); // 数组的新值：9 二维数组/对象 通用深拷贝方法递归拷贝所有层级属性 原理：遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝。 复习： typeof将引用类型(数组、对象)都判断为object。 for...in主要用于对 对象属性 进行遍历。for ... in 循环中的代码每执行一次，就会对 对象的属性 进行一次操作。 for(key in obj)中，key是属性名。（注意：in操作符针对数组时，key是数组下标） 对象/数组/字符串 都有属性继承自原型。使用for...in遍历时会遍历到继承属性，所以需要提前筛选。Object的hasOwnProperty()方法返回一个布尔值，判断对象是否包含特定的自身（非继承）属性。（对数组使用for...of时不需判断） for...of主要用于对 数组元素 进行遍历，不使用for in是因为for in无法保证 索引顺序 ，所以使用for of或者forEach()遍历数组会更加合理。 for(key of arr)中，key是数组元素。（不同于for(key in arr)中key是数组下标） 123456789101112131415161718192021222324252627function deepClone(obj)&#123; // 根据传入的参数obj判断拷贝数组还是对象 let objClone = Array.isArray(obj)?[]:&#123;&#125;; // 判断参数obj是否是引用类型（数组/对象） if(obj &amp;&amp; typeof obj===\"object\")&#123; // 【这里应该加个判断，如果obj是数组就用for of遍历数组元素，且不需判断继承属性】 // 是对象则用for in遍历 对象属性 for(key in obj)&#123; // 如果是非继承属性 if(obj.hasOwnProperty(key))&#123; //判断ojb子元素（数组元素/对象属性）是否为引用类型（数组、对象、函数） if(obj[key]&amp;&amp;typeof obj[key] ===\"object\")&#123; //是则递归复制 objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; let a=[0, 1, null, [1, 2], &#123; name: \"a\" &#125;, function a() &#123; return 1; &#125;], b=deepClone(a);b[3][0] = 5;console.log(a,b); JSON.parse(JSON.stringify()) 这也是我在Redux入门（1）中对state进行深拷贝成newState时使用的方法。（由于这里的state对象中没有方法，所以可以使用JSON进行深拷贝） 原理:不拷贝引用对象，使用stringify()拷贝一个 JSON字符串 会新辟一个新的存储地址，这样就切断了引用对象的指针联系。 缺点：无法实现对 数组/对象中 方法 的深拷贝，会显示为undefined。 如果是对象第一层属性中含有方法，则可以使用ES6提供的object.assign()进行对象方法的拷贝 注意：仅限对象第一层属性的方法，因为assign是浅拷贝的，第二层属性的方法就只拷贝引用地址了。 assign处理数组的时候，会把数组视为对象，返回的是对象 使用assign可解决JSON拷贝的缺点，拷贝对象第一层属性中的方法： 12345678910111213141516let obj1 = &#123; a: 0, b: &#123; c: 0 &#125;, d: function()&#123; return 1; &#125;&#125;;//使用JSON拷贝不到方法let obj2 = JSON.parse(JSON.stringify(obj1));console.log(obj1,obj2); //使用assign可以拷贝到第一层属性的方法let obj3 = Object.assign(&#123;&#125;, obj1);obj3.d=function()&#123; return 2; &#125;;console.log(obj1,obj3); assign仅限拷贝对象第一层属性的方法，因为assign是浅拷贝的，第二层属性的方法就只拷贝引用地址了： 12345678910111213141516let obj1 = &#123; a: 0, b: &#123; c: 0 &#125;, d: &#123; e: function () &#123; return 1; &#125; &#125;&#125;;let obj2 = JSON.parse(JSON.stringify(obj1));console.log(obj1, obj2);let obj3 = Object.assign(&#123;&#125;, obj1);obj3.d.e = function () &#123; return 2;&#125;;console.log(obj1, obj3); 例子: 1var 新对象 = JSON.parse(JSON.stringify(老对象))； stringify()将 JS对象 转换为 JSON字符串parse()将 JSON字符串 转换为 JS对象 12345678910var target = [0, 1, null, [1, 2], &#123; name: \"a\" &#125;, function a() &#123; return 1; &#125;]// 完成下面的深拷贝函数function deepCopy(obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var objClone = deepCopy(target);objClone[4].name = \"zzz\";console.log(target);console.log(objClone); 函数库lodash该函数库也有提供_.cloneDeep 用来做 Deep Copy。 123456789var _ = require('lodash');var obj1 = &#123; a: 1, b: &#123; f: &#123; g: 1 &#125; &#125;, c: [1, 2, 3]&#125;;var obj2 = _.cloneDeep(obj1);console.log(obj1.b.f === obj2.b.f);// false 扩展运算符的深、浅拷贝 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝1234var car = &#123;brand: \"BMW\", price: \"380000\", length: \"5米\"&#125;var car1 = &#123; ...car, price: \"500000\" &#125;console.log(car1); // &#123; brand: \"BMW\", price: \"500000\", length: \"5米\" &#125;console.log(car); // &#123; brand: \"BMW\", price: \"380000\", length: \"5米\" &#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS变量类型和计算","slug":"JS变量类型和计算","date":"2020-02-01T11:22:57.000Z","updated":"2020-11-23T03:16:15.361Z","comments":true,"path":"2020/02/01/JS变量类型和计算/","link":"","permalink":"http://yoursite.com/2020/02/01/JS变量类型和计算/","excerpt":"更新：慕课 前端技术一面 第四章","text":"更新：慕课 前端技术一面 第四章 思考过程 拿到一个面试题，第一时间看到的是什么-&gt;考点 又如何看待网上搜出来的永远也看不完的题海-&gt;不变应万变 如何对待接下来遇到的面试题？-&gt;题目到知识再到题目 一些面试题和考察的知识点 JS中使用typeof能得到的哪些类型？【JS变量类型】 何时使用===何时使用==？【强制类型转换】 window.onload和DOMContentLoaded的区别？【浏览器渲染过程】 用JS创建10个&lt;a&gt;标签，点击的时候弹出来对应的序号【作用域】 简述如何实现个模块加载器，实现类似require.js的基本功能【JS模块化】 实现数组的随机排序 【JS基础算法】 变量类型和计算变量类型 值类型VS引用类型 typeof运算符详解 值类型（基本数据类型） 基本类型的值是不可变的 任何方法都无法改变一个基本类型的值，比如一个字符串：123//调用了toUpperCase()方法后返回的是一个新的字符串var name = 'hello';name.toUpperCase(); //输出HELLO 也不能给基本类型添加属性与方法: 12345var person = 'Mary';person.age = 22;person.method = function()&#123;&#125;;console.log(person.age); //underfinedconsole.log(person.method);//underfined 基本类型的变量和值都是存放在栈内存中： 1234var a = 200;var b = a;b = 21;console.log(a); //200 值类型中变量b相当于深拷贝了变量a，a和b是两个不同的存在。所以改变a以后b不变。 引用类型（引用/对象数据类型） 除了基本类型就是引用类型，也就是说对象。对象是属性与方法的集合。也就是说引用类型可以拥有属性与方法，属性又可以包含基本类型与引用类型。 引用类型的值是可变的,我们可以为引用类型添加属性与方法，也可以删除其属性与方法。如： 123456var person = &#123;&#125;; //创建一个对象 ---引用类型person.name = 'Mary';person.age = 22;person.sayName = function() &#123;console.log(person.name);&#125;person.sayName(); //'Mary'delete person.name; //删除person对象的name属性 引用类型将引用名称存储在栈内存中，真实的数据存放在堆内存里： 例子:1234var a = &#123; age: 20 &#125;;var b = a;b.age = 21;console.log(a.age); //21 引用类型中变量b和变量a都是指针，他们同样都指向同一个属性age，所以他们其实是共享属性age的。所以改变b的age属性时相当于改变a的age属性。 对象、数组、函数 是引用类型，这是因为如果他们的内容很多，采用 值类型 就要 复制 ，那就很耗内存，为了让内存共用（节省）空间，所以才存在 引用类型。 typeof运算符typeof能得到的6种类型：number、undefined、string、boolean、object、function。(注意：null 空指针，也是一个对象) 但是，typeof运算符 只能区分 值类型： 1234typeof undefined;//undefinedtypeof \"hlz\";//stringtypeof 123;//numbertypeof true;//boolean 对于 引用类型 ，typeof运算符只能区分出 函数 ： 1234typeof &#123;&#125;;//objecttypeof [];//objecttypeof null;//objecttypeof console.log;//function 变量计算-强制类型转换 字符串拼接 ==运算符 if语句 逻辑运算 字符串拼接 ==运算符运算符前后的变量会先被强转为true/false再进行比较 100被转换为字符串 再进行比较，所以相等 0和””都被转换为false 再进行比较，所以相等 null和undefined都被转换为false 再进行比较，所以相等 if语句变量做判断条件 时会先 强制转换 为boolean类型再判断： 逻辑运算首先要明确，逻辑与&amp;&amp;与逻辑或||返回的都是表达式，非!返回的是布尔值。 帮助理解返回表达式的原则：从前往后判断，只要到了能判断出 整个表达式的真假 的位置我们就停下来返回这个位置的部分表达式。 &amp;&amp;：前后都为真才是真，只要有一个是假的就是假。所以只要有第一个表达式是假的我们就不用继续判断了，返回第一个表达式。如果第一个表达式是真的我们就继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。 ||：只要有一个是真就是真。所以只要有第一个表达式是真的就可以判断整个表达式都是真的，故返回第一个表达式。如果第一个表达式是假的那我们就要继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。 例子： 123console.log(10 &amp;&amp; 0);//0console.log(\"\" || \"abc\");//\"abc\"console.log(!window.abc);//true 可以使用!!判断一个变量会被当做true还是false： 12var a = 100console.log(!!a);//true 题目解答JS中使用typeof能得到的哪些类型6种，number、undefined、string、boolean、object、function可以准确判断4种 值类型 ，但是 引用类型 中只能判断函数，其余的 数组、对象、正则、日期 都被识别为object。 注意：null（空指针）也被识别为object！ 何时使用===何时使用==只有一种情况使用双等号==，其他时候全部使用三等号===：此时第三行代码相当于第四行代码的简写，这是jquery的源码推荐写法。 JS中有哪些内置函数内置函数（数据封装类对象）：Object、Array、Boolean、Number、String、Function、Date、RegExp、Error JS变量 按 存储方式 分为哪些类型，有何特点按照存储方式区分为：值类型、引用类型特点：值类型相当于复制，引用类型则是 指针复制 并不是真正的拷贝，两个变量会共用同一个属性，他们的值的修改是相互干预的。 如何理解JSONJSON是一种数据格式，但从JS来看JSON就是一个JS内置对象，他有两个方法，“JavaScript Object Notation” 即 “JavaScript 对象表示法”，它是存储和交换文本信息的语法。stringify（）把对象变成字符串parse（）把字符串变成对象 手写深拷贝 注意判断值类型和引用类型 注意判断是数组还是对象(判断对象自身属性) 递归 12345678910111213141516171819202122232425/** * 深拷贝方法1 * @param &#123;Object&#125; obj 要拷贝的对象 */function deepClone(obj) &#123; // 如遇值类型则直接返回，否则继续执行 if (typeof obj !== \"object\" || obj === null) &#123; return obj; &#125; // 初始化返回结果 let cloneObj = Array.isArray(obj) ? [] : &#123;&#125;; // 遍历对象属性/数组元素 for (key in obj) &#123; // 筛选对象自身属性 if (obj.hasOwnProperty(key)) &#123; // 递归调用deepClone()， cloneObj[key] = deepClone(obj[key]) &#125; &#125; // 返回结果 return cloneObj;&#125; 123456789101112131415161718192021222324252627282930/** * 深拷贝方法2 * @param &#123;Object&#125; obj 要拷贝的对象 */function deepClone(obj)&#123; // 根据传入的参数obj判断拷贝数组还是对象 let objClone = Array.isArray(obj)?[]:&#123;&#125;; // 判断参数obj是否是引用类型（数组/对象） if(obj &amp;&amp; typeof obj===\"object\")&#123; // 是对象则用for in遍历 对象属性 for(key in obj)&#123; // 如果是非继承属性 if(obj.hasOwnProperty(key))&#123; //判断ojb子元素（数组元素/对象属性）是否为引用类型（数组、对象、函数） if(obj[key]&amp;&amp;typeof obj[key] ===\"object\")&#123; //是则递归复制 objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone;&#125; let a=[0, 1, null, [1, 2], &#123; name: \"a\" &#125;, function a() &#123; return 1; &#125;], b=deepClone(a);b[3][0] = 5;console.log(a,b);","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6对象简写","slug":"ES6对象简写","date":"2020-02-01T10:03:13.000Z","updated":"2020-02-01T10:08:57.632Z","comments":true,"path":"2020/02/01/ES6对象简写/","link":"","permalink":"http://yoursite.com/2020/02/01/ES6对象简写/","excerpt":"基本原则 属性名与属性值相同时，可省略其中一个。 对象中包含的方法的: function 可省略不写。","text":"基本原则 属性名与属性值相同时，可省略其中一个。 对象中包含的方法的: function 可省略不写。 例子ES5中： 12345678910var studentES5 = &#123; name: '珠', age: 2, sex: '女', getName: function () &#123; return this.name; &#125;&#125;console.log('ES5', studentES5);console.log('ES5'studentES5.getName()); ES6中： 1234567891011121314const name = '珠';const age = 2;const sex = '女';const studentES6 = &#123; //同名的属性可以省略不写 name, age, sex, getName() &#123;//可以省略方法中的 :function return this.name; &#125;&#125;;console.log('ES6', studentES6);console.log('ES6',studentES6.getName());","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"HTML/JS/React中的事件处理","slug":"HTML JS React中的事件处理","date":"2020-01-31T11:46:58.000Z","updated":"2020-07-27T05:22:39.955Z","comments":true,"path":"2020/01/31/HTML JS React中的事件处理/","link":"","permalink":"http://yoursite.com/2020/01/31/HTML JS React中的事件处理/","excerpt":"总结 HTML和JS中，DOM事件都是类似onclick这样的小写，而 React 事件绑定属性的命名采用 驼峰式写法 。 尽量不要把DOM事件写在HTML中。","text":"总结 HTML和JS中，DOM事件都是类似onclick这样的小写，而 React 事件绑定属性的命名采用 驼峰式写法 。 尽量不要把DOM事件写在HTML中。 HTML 事件处理 DOM事件写在html中不符合 行为、结构、样式 相分离的原则 尽量不要把DOM事件写在HTML中。 多元素绑定相同事件时，效率低。 不建议在HTML元素中写JavaScript代码。（将页面元素写在HTML内，JS代码写在&lt;script&gt;内会更好） 以onclick举例HTML中的语法： 1&lt;element onclick=\"SomeJavaScriptCode\"&gt; 例子： 123&lt;button onclick=\"activateLasers()\"&gt; 激活按钮&lt;/button&gt; 然后activateLasers()写在JS代码中。 JS 事件处理 注意：JS代码要在HTML代码加载完成后执行 获取DOM元素=&gt;绑定事件函数 DOM 0级事件处理 优点：符合 行为、结构、样式 相分离的原则。还可以选出DOM元素集合通过for循环统一操作。 缺点：每个DOM元素只能绑定一个同类事件。例如绑定onclick，当你想再绑定onclick会发现他被覆盖了。 以onclick举例JavaScript 中语法: 1object.onclick=function()&#123;SomeJavaScriptCode&#125;; 例子： 12345&lt;body&gt; &lt;p&gt;单击按钮触发函数。&lt;/p&gt; &lt;button id=\"btn\"&gt;点我&lt;/button&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;/body&gt; 12345&lt;script&gt; document.getElementById(\"btn\").onclick=function()&#123; document.getElementById(\"demo\").innerHTML=\"Hello World\"; &#125;&lt;/script&gt; DOM 2级事件处理（事件监听） addEventListener(&quot;事件名&quot; , &quot;事件处理函数&quot; , &quot;布尔值&quot;); false 事件冒泡;true 事件捕获 优点相比前两个就多了。可以选择是事件流。可绑定多个同类事件。事件名可以组成字符串。 注意：使用addEventListener绑定事件，等结束后及时使用removeEventListener移除监听 React事件处理 React 元素的事件处理和 DOM 元素类似。但是有一点语法上的不同: React 事件绑定函数的命名采用驼峰式写法，而不是小写。 在类中书写时注意在构造函数中使用bind()绑定事件函数的this指向。 以onClick举例在JSX语法中： 123&lt;button onClick=&#123;activateLasers&#125;&gt; 激活按钮&lt;/button&gt; activateLasers函数另写 具体事例当使用 ES6 class 语法来定义一个组件的时候，事件处理函数会成为类的一个方法。例如，Toggle 组件渲染一个让用户切换开关状态的按钮的例子","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"简书Header组件开发（性能优化）","slug":"简书Header组件开发（性能优化）","date":"2020-01-31T07:12:30.000Z","updated":"2020-03-10T07:34:31.111Z","comments":true,"path":"2020/01/31/简书Header组件开发（性能优化）/","link":"","permalink":"http://yoursite.com/2020/01/31/简书Header组件开发（性能优化）/","excerpt":"避免无意义的AJAX请求发送之前我们设置的有点问题，每次点击搜索框都会获取一次AJAX请求：但实际上我们只需要获取一次就够了。","text":"避免无意义的AJAX请求发送之前我们设置的有点问题，每次点击搜索框都会获取一次AJAX请求：但实际上我们只需要获取一次就够了。 解决方法调用 点击事件函数handleInputFocus 时传入list数据，函数中判断只有list===0时才发送AJAX请求。 解决代码1. 调用 点击事件函数handleInputFocus 时传入list数据： 2. 函数handleInputFocus接受并打印list：可以看到两次点击获取到的list中size是不同的，所以我们可以通过list.size判断是否发送AJAX请求：只有当list.size===0时才发送请求，其实这行代码就相当于下面的3行代码： 123if(list.size === 0)&#123;dispatch(actionCreators.getList())&#125; 结果：点击多次也只发送一次请求 优化样式实现样式：鼠标移到“换一批”上则变手形状： 优化方法：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"简书Header组件开发（热门搜索换页功能、换页旋转动画效果）","slug":"简书Header组件开发（热门搜索换页功能、换页旋转动画效果）","date":"2020-01-30T14:52:03.000Z","updated":"2020-03-10T07:11:11.145Z","comments":true,"path":"2020/01/30/简书Header组件开发（热门搜索换页功能、换页旋转动画效果）/","link":"","permalink":"http://yoursite.com/2020/01/30/简书Header组件开发（热门搜索换页功能、换页旋转动画效果）/","excerpt":"涉及知识点总结热门搜索换页功能知识点： 想从state中获取数据就到connect的参数1mapStateToProps()中设置映射，再从this.props上去拿 在组件上绑定事件函数要注意事件名称是驼峰形式的 函数如果要处理state中的数据就要通过action 需要涉及action操作的函数都放在connect的参数2mapDispatchProps()中进行定义 （connect来自redux-thunk中间件）","text":"涉及知识点总结热门搜索换页功能知识点： 想从state中获取数据就到connect的参数1mapStateToProps()中设置映射，再从this.props上去拿 在组件上绑定事件函数要注意事件名称是驼峰形式的 函数如果要处理state中的数据就要通过action 需要涉及action操作的函数都放在connect的参数2mapDispatchProps()中进行定义 （connect来自redux-thunk中间件） 换页旋转功能知识点： 在设置动画时可以使用ref获取对应的DOM元素进行操作 js中的react 样式是字符串类型的，所以在组件中设置DOM元素样式时属性值需要引号 想要获取 样式属性值 中的数字，可使用字符串的relpace()结合正则表达式将所有非数字部分替换为空，则剩余的就是数字，但注意：得到的数字是字符串类型的 ParseInt()将字符串=&gt;数字，空字符串=&gt;Nan，Nan+数字=Nan 简单的 旋转，缩放，倾斜或平移效果可以使用transform样式属性来完成，transform-origin属性可设置中心点，动画效果可以使用transition属性来实现。 注意： transition仅对block元素生效，需要使用display:block;** block会使iconfont和“换一批”分成上下两行，所以需要float:left使iconfont脱离文档流左浮动以出现在文字左边。 热门搜索换页功能现在我们的热门搜索框内数据是全部显示的：实现效果：每次只显示10个标签，点击“换一批”后显示另一批标签，也就是1页存放10个标签，点击“换一批”则下一页，到最后一页后又返回第一页。 每页显示10个标签思路： 在header组件的store中添加两个数据page（当前所在页）和totalPage（总页数） 在获取list的action函数中改变totalPage的值。 actionCreators中获取标签数据后进行分页再传给reducer reducer拿到totalPage数据后添加到state中 在index.js中获取page，根据page显示list数据 store中添加两个数据header-store-reducer.js中添加两个数据page和totalPage： 123456const defaultState = fromJS(&#123; focused: false, list: [], page: 1, totalPage: 1&#125;); 获取数据后进行分页我们在index中使用actionCreators.js中的getList()来获取热门标签数据，而获取到的数据是通过changeList()传给reducer的，所以分页处理也放到changeList()中完成即可。 header-store-actionCreators.js: 12345const changeList = (data) =&gt; (&#123; type: constants.CHANG_LIST, data: fromJS(data), totalPage: Math.ceil(data.length / 10)&#125;); reducer将totalPage添加到statereducer拿到totalPage数据后添加到state中。 header-store-reducer.js: redux效果：可以通过redux看到state中数据（当前所在页page和总页数totalPage）的变化。 组件中根据page显示list数据在index.js中，我们原本将整个list循环显示在页面上，但现在我们应先获取page，根据page显示list数据 header-index.js:1.在connect的参数1mapStateToProps()中获取到state的page： 1234567const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.getIn([\"header\", \"focused\"]), list: state.getIn([\"header\", \"list\"]), page: state.getIn([\"header\", \"page\"]) &#125;&#125; 2.根据page循环10个标签： 页面效果：一页只显示10个标签，但鼠标点击“热门搜索框”时搜索框消失。 immutable数组的toJS() immutable数组是不可改变的，增删查改都比较麻烦，所以我们可以通过toJS()将immutable数组转换为JS数组。 语法：const jsList = toJS(immutable数组); 设置“热门搜索”显示条件实现效果：鼠标停在“热门搜索”内时搜索框会一直显示。 思路： 在state中添加mouseIn数据 当鼠标移入“热门搜索”中时，mouseIn变为true:也就是给SearchInfo组件绑定onMouseEnter事件函数，触发时通过action改变state中mouseIn的值。 鼠标移入热门搜索时mouseIn变为true，移出时要变回false，所以同2的流程处理一下。 原本“热门搜索”显示条件为focused，现在要增加一个“或者mouseIn”，我们要让她符合一个就能显示。 state中添加mouseIn数据header-store-reducer.js: 1234567const defaultState = fromJS(&#123; focused: false, mouseIn: false, list: [], page: 1, totalPage: 1,&#125;); onMouseEnter事件改变mouseIn 当鼠标移入“热门搜索”中时，mouseIn变为true:也就是给SearchInfo组件绑定onMouseEnter事件函数，触发时通过action改变state中mouseIn的值。 要想改变mouseIn就要通过action 1.在SearchInfo组件上绑定onMouseEnter事件函数handleMouseEnter： 1234567&lt;SearchInfo onMouseEnter=&#123;handleMouseEnter&#125;&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt; &lt;SearchItemList&gt;&#123;pageList&#125;&lt;/SearchItemList&gt;&lt;/SearchInfo&gt; 2.在mapDispatchProps()中定义函数handleMouseEnter，通过action（即mouseEnter）改变mouseIn： 123handleMouseEnter()&#123; dispatch(actionCreators.mouseEnter())&#125; 3.在actionCreators.js中创建mouseEnter(): 123export const mouseEnter = () =&gt; (&#123; type: constants.MOUSE_ENTER&#125;); 4.在reducer.js中处理action： 验证redux: onMouseLeave事件改变mouseIn 鼠标移入热门搜索时mouseIn变为true，移出时要变回false，所以同样的流程处理一下。 一样，要想改变mouseIn就要通过action 在SearchInfo组件上绑定onMouseLeave事件函数handleMouseLeave 在mapDispatchProps()中定义函数handleMouseLeave，通过action（即mouseLeave）改变mouseIn 在actionCreators.js中创建mouseLeave() 在reducer.js中处理action 验证：同样使用redux进行验证，鼠标移入“热门搜索”时mouseIn变为true，移出时mouseIn变为false。 改变“热门搜索”显示条件原本“热门搜索”显示条件为focused，现在要增加一个“或者mouseIn”，我们要让她符合一个就能显示。 store中引入mouseIn: 12345678const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.getIn([\"header\", \"focused\"]), list: state.getIn([\"header\", \"list\"]), page: state.getIn([\"header\", \"page\"]), mouseIn: state.getIn([\"header\", \"mouseIn\"]), &#125;&#125; 增加一个mouseIn作为判断条件： 点击“换一批”换页引入totalPage，给SearchInfoSwitch组件绑定onClick事件handleChangePage，执行handleChangePage函数时传递page和totalPage，在handleChangePage函数中进行判断后决定action（即将被使用的page）的值。 index.js: 1234&lt;SearchInfoSwitch onClick=&#123;() =&gt; &#123; handleChangePage(totalPage, page) &#125;&#125;&gt; 换一批&lt;/SearchInfoSwitch&gt; actionCreator.js: 1234export const changePage = (page) =&gt; (&#123; type: constants.CHANGE_PAGE, page&#125;); reducer.js: 解决key值报错虽然我们在循环中给每一项都设置了key值： 12345for (let i = (page - 1) * 10; i &lt; page * 10; i++) &#123; pageList.push( &lt;SearchInfoItem key=&#123;newList[i]&#125;&gt;&#123;newList[i]&#125;&lt;/SearchInfoItem&gt; )&#125; 但还是报错了： 原因：通过打印可以看到前面10次循环的key值都是undefined，因为初始化页面时render函数就执行了，带动getListArea()执行了for循环，但list中数据是通过AJAX获取的，而我们的AJAX请求时点击搜索框才发出的，所以初始化时list还是空数组，也就拿不到数组元素了。 解决方法：list拿到数据时才进行循环即可： 1234567if (newList.length) &#123; for (let i = (page - 1) * 10; i &lt; page * 10; i++) &#123; pageList.push( &lt;SearchInfoItem key=&#123;newList[i]&#125;&gt;&#123;newList[i]&#125;&lt;/SearchInfoItem&gt; ) &#125;&#125; 优化：merge()代替多次set() 使用多次set()修改immutable数据时可使用merge()代替来合成多次修改后的immutable对象。 reducer中： 123456state.set(\"list\", action.data).set(\"totalPage\", action.totalPage);//改为state.merge(&#123; list: action.data, totalPage: action.totalPage&#125;) 换页旋转动画效果实现效果：点击“换一批”后，图标旋转 思路： iconfont中找到spin图标放到相应位置并设置样式 使用ref获取到spin图标的DOM元素 点击“换一批”时触发的事件绑定函数中，使用transform样式属性使每次点击spin图标就增加360度来旋转 设置transform-origin属性让图标围绕中心点旋转。 由于度数需要每次增加360度，而点击时设置样式属性为360度则是写死了，无法递增。所以我们每次点击都需要获取当前transform样式属性值中的度数作为原始度数，在原始度数基础上加360度作为transform样式属性值。 原始度数的获取：首先明确js中样式是字符串形式的，所以可以使用字符串的replace()替换属性值中所有非数字字符串为空，这样剩下的就是数字（即度数）。 注意： 获取到的原始度数是字符串类型的，使用ParseInt转换为数字后再进行加操作。 一开始是0度，替换字符串后得到空字符串，ParseInt(空字符串)=Nan,Nan+360=Nan,如果这样第一次设置旋转角度就会失败，所以要加个判断，让原始度数是空字符串时转换为数字0。 在spin图标的样式中使用transition属性使旋转产生动画效果 注意： transition仅对block元素生效，需要使用display:block;** block会使iconfont和“换一批”分成上下两行，所以需要float:left使iconfont脱离文档流左浮动以出现在文字左边。 iconfont下载、替换本地图标搜索“spin”，添加到项目后下载到本地，解压后拷贝所需的5个文件到static中的iconfont文件夹中： 将文件夹中的iconfont.css内容拷贝到static-iconfont-iconfont.js中，一点点进行替换（记得@font-face中，只要不是data开头的路径前都要加./将其改为相对路径） 使用spin图标、设置样式1.index.js中使用spin图标: 12345&lt;SearchInfoSwitch onClick=&#123;() =&gt; &#123; handleChangePage(totalPage, page) &#125;&#125;&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe851;&lt;/span&gt; 换一批&lt;/SearchInfoSwitch&gt; 结果图标出现在右下角：原因：因为在style中我们设置了：SearchWrapper组件下的iconfont都相对SearchWrapper进行绝对定位在右下角。 解决方法： 2.设置spin图标样式index.js中给spin图标增加样式spin： 12345&lt;SearchInfoSwitch onClick=&#123;() =&gt; &#123; handleChangePage(totalPage, page) &#125;&#125;&gt; &lt;span className=\"iconfont spin\"&gt;&amp;#xe851;&lt;/span&gt; 换一批&lt;/SearchInfoSwitch&gt; style.js中： 12345678export const SearchInfoSwitch = styled.div` float:right; font-size: 13px; .spin&#123; font-size: 12px; margin-right: 2px; &#125;`; 点击旋转360度 使用ref获取到spin图标的DOM元素,传入点击事件函数handleChangePage中 handleChangePage函数拿到spin以后往spin的样式中添加transform属性 使每次点击spin图标就增加360度来旋转 设置transform-origin属性让图标围绕中心点旋转。 由于度数需要每次增加360度，而点击时设置样式属性为360度则是写死了，无法递增。所以我们每次点击都需要获取当前transform样式属性值中的度数作为原始度数，在原始度数基础上加360度作为transform样式属性值。 原始度数的获取：首先明确js中样式是字符串形式的，所以可以使用字符串的replace()替换属性值中所有非数字字符串为空，这样剩下的就是数字（即度数）。 注意： 获取到的原始度数是字符串类型的，使用ParseInt转换为数字后再进行加操作。 一开始是0度，替换字符串后得到空字符串，ParseInt(空字符串)=Nan,Nan+360=Nan,如果这样第一次设置旋转角度就会失败，所以要加个判断，让原始度数是空字符串时转换为数字0。 结果：通过打印spin可以看到点击以后旋转角度有所变化，但看不到效果，所以接下来要设置动画效果。 动画效果 在spin图标的样式中使用transition属性使旋转产生动画效果 注意： transition仅对block元素生效，需要使用display:block;** block会使iconfont和“换一批”分成上下两行，所以需要float:left使iconfont脱离文档流左浮动以出现在文字左边。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"react中模拟假数据的方法总结","slug":"react中模拟假数据的方法总结","date":"2020-01-29T10:47:37.000Z","updated":"2020-11-12T11:47:01.634Z","comments":true,"path":"2020/01/29/react中模拟假数据的方法总结/","link":"","permalink":"http://yoursite.com/2020/01/29/react中模拟假数据的方法总结/","excerpt":"初次学习react时教程使用的是charles抓包分配假数据的方式来模拟后端数据，但我希望有更加方便/全能的模拟假数据方式，几经周折后有了这篇文章。","text":"初次学习react时教程使用的是charles抓包分配假数据的方式来模拟后端数据，但我希望有更加方便/全能的模拟假数据方式，几经周折后有了这篇文章。 总结 方法1 使用charles：不推荐使用 方法2 使用mock.js：适合于模拟数据较多的情况 方法3 ：适合于模拟数据较少的情况使用 使用charles 不推荐，因为抓包很麻烦，使用Charles抓取localhost包需要注意更换url 步骤： 使用Charles抓包，让Charles代理Chrome，然后将相应的接口通过Map Local Settings设置到本地文件上。 在本地文件上存储模拟数据。 但是Charles代理Chrome后如果想抓localhost的包，那还需要从charlesproxy上转一下，十分麻烦。 具体案例可参考“React高级内容（3）”中的”使用Charles实现本地接口数据mock” 使用mock.js 可参考“Mock.js的使用方法”、“react中使用mock.js模拟接口数据” 步骤： 在 src目录下新建 mock文件夹 用于存放我们 mock数据 的js文件。 在mock数据的js文件中引入mock并输出模拟数据的组件 在发出AJAX请求的js文件中，引入的mock组件，接下来只要正常书写AJAX请求即可，一旦对应的请求发出，Mock就会拦截并返回数据。 直接放在项目public文件夹下 在项目的按照 请求地址 在public文件夹下 新建json文件=&gt;将假数据写在json文件中。 当js页面中向某个接口发出AJAX请求获取数据时，项目会先去node中找，找不到就会去public文件夹中找相应的路径下是否有数据。 比如：接口是/api/headerList.json,那可以在public文件夹下=&gt;新建api文件夹=&gt;新建headerList.json，放置相应假数据 注意：public下的文件夹内不能放js文件，因为他是直接读取数据的，不会进行任何操作！","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"简书Header组件开发（热门搜索样式布局、Ajax获取推荐数据、代码优化）","slug":"简书Header组件开发（热门搜索样式布局、Ajax获取推荐数据、代码优化）","date":"2020-01-28T13:19:48.000Z","updated":"2020-03-08T13:29:24.768Z","comments":true,"path":"2020/01/28/简书Header组件开发（热门搜索样式布局、Ajax获取推荐数据、代码优化）/","link":"","permalink":"http://yoursite.com/2020/01/28/简书Header组件开发（热门搜索样式布局、Ajax获取推荐数据、代码优化）/","excerpt":"热门搜索样式布局 那么我们就需要在style.js中创建以下组件：","text":"热门搜索样式布局 那么我们就需要在style.js中创建以下组件： 组件名 | 类型 | 含义 | 备注—|—|—SearchInfo | div | 整个外框 | 绝对定位SearchInfoTitle | div | “热门搜索” |SearchInfoSwith | span | “换一批” | 右浮动SearchInfoList | div | 所有标签的外框 | overflow：hidden(BFC、解决浮动元素的父元素高度塌陷）SearchInfoItem | a | 各个标签 | display：block，左浮动 热门搜索框SearchInfo1.header-style.js定义组件SearchInfo(绝对定位)： 123456789export const SearchInfo = styled.div` position: absolute; left: 0; top: 56px; width: 240px; padding:0 20px; height:100px; box-shadow:0 0 8px rgba(0, 0, 0, .2);`; 2.header-index.js引入、使用组件SearchInfo: 12345678910111213141516171819&lt;SearchWrapper&gt; &lt;CSSTransition in=&#123;props.focused&#125; timeout=&#123;200&#125; classNames=\"slide\" &gt; &lt;NavSearch className=&#123;props.focused ? \"focused\" : \"\"&#125; onFocus=&#123;props.handleInputFocus&#125; onBlur=&#123;props.handleInputBlur&#125; /&gt; &lt;/CSSTransition&gt; &lt;span className=&#123;props.focused ? \"focused iconfont\" : \"iconfont\"&#125;&gt; &amp;#xe62d; &lt;/span&gt; &lt;SearchInfo&gt; &lt;/SearchInfo&gt;&lt;/SearchWrapper&gt; “热门搜索”SearchInfoTitle1.header-style.js定义组件 SearchInfoTitle： 1234567export const SearchInfoTitle = styled.div` margin-top: 20px; margin-bottom: 15px; line-height: 20px; font-size:14px; color: #969696;`; 2.header-index.js引入、使用组件 SearchInfoTitle: 123&lt;SearchInfo&gt; &lt;SearchInfoTitle&gt;热门搜索&lt;/SearchInfoTitle&gt;&lt;/SearchInfo&gt; “换一批”SearchInfoSwitch1.header-style.js定义组件 SearchInfoSwitch（右浮动）： 1234export const SearchInfoSwitch = styled.div` float:right; font-size:13px;`; 2.header-index.js引入、使用组件 SearchInfoSwitch: 123456&lt;SearchInfo&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt;&lt;/SearchInfo&gt; 标签 SearchInfoItem1.header-style.js定义组件 SearchInfoItem（左浮动，块级以定义宽高）： 123456789101112export const SearchInfoItem = styled.a` display: block; float: left; line-height: 20px; padding: 0 5px; margin-right: 10px; margin-bottom: 10px; font-size: 12px; border: 1px solid #ddd; color: #787878; border-radius: 3px;`; 2.header-index.js引入、使用组件 SearchInfoItem: 1234567891011121314&lt;SearchInfo&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt; &lt;SearchInfoItem&gt;理财&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;毕业&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;手帐&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;简书交友&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;spring&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;古风&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;故事&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;暖寄归人&lt;/SearchInfoItem&gt;&lt;/SearchInfo&gt; 可以看到此时标签没有撑起框，因为之前我们把外边框高度写死了 SearchInfoList 所有标签的外框 了解一下BFC 通过overflow属性控制父元素宽高,解决父级元素高度塌陷通过overflow属性控制父 浮动时给父组件添加overflow属性放置浮动元素溢出 1.header-style.js中，删除SearchInfo中的死高度100px，定义组件 SearchInfoList： 123export const SearchItemList = styled.div` overflow: hidden;`; 2.header-index.js引入、使用组件 SearchInfoList: 12345678910111213141516&lt;SearchInfo&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt; &lt;SearchItemList&gt; &lt;SearchInfoItem&gt;理财&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;毕业&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;手帐&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;简书交友&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;spring&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;古风&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;故事&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;暖寄归人&lt;/SearchInfoItem&gt; &lt;/SearchItemList&gt;&lt;/SearchInfo&gt; 实现点击显示效果 实现效果：点击搜索框则显示“热门搜索框”，搜索框失去焦点时“热门搜索框”消失。 实现思路： 新建一个函数getListArea(),该函数接收一个参数show,show为true时显示“热门搜索框”，为false时隐藏“热门搜索框”。 show为true时，返回“热门搜索框”的所有组件。 show为false时，返回null（空对象）。 在SearchWrapper组件中调用函数getListArea()，参数为props.focused。 1.header-index.js新建函数getListArea(): 123456789101112131415161718192021222324const getListArea = (show) =&gt; &#123; if (show) &#123; return ( &lt;SearchInfo&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt; &lt;SearchItemList&gt; &lt;SearchInfoItem&gt;理财&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;毕业&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;手帐&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;简书交友&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;spring&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;古风&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;故事&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;暖寄归人&lt;/SearchInfoItem&gt; &lt;/SearchItemList&gt; &lt;/SearchInfo&gt; ) &#125; else &#123; return null; &#125;&#125; 2.header-index.js调用函数getListArea(): 1234567891011121314151617&lt;SearchWrapper&gt; &lt;CSSTransition in=&#123;props.focused&#125; timeout=&#123;200&#125; classNames=\"slide\" &gt; &lt;NavSearch className=&#123;props.focused ? \"focused\" : \"\"&#125; onFocus=&#123;props.handleInputFocus&#125; onBlur=&#123;props.handleInputBlur&#125; /&gt; &lt;/CSSTransition&gt; &lt;span className=&#123;props.focused ? \"focused iconfont\" : \"iconfont\"&#125;&gt; &amp;#xe62d; &lt;/span&gt; &#123;getListArea(props.focused)&#125;&lt;/SearchWrapper&gt; Ajax获取推荐数据上面我们显示的标签是写死的，现在我们要实现点击搜索框以后 通过AJAX获取数据： 思路： 往组件的state中增添一个list数组用于存储标签数据 使用redux-thunk中间件使action可以是函数 中间件指的是action和store的“中间”，实际是对dispatch的一个升级 原本actionCreators中返回的action都只能是对象，使用redux-thunk后可返回函数（该函数接受dispatch方法作为参数） 在创建store时添加中间件（dispatch是store的方法） public文件夹下新建api文件夹，新建json文件，模拟假数据 注意：当js页面中向某个接口发出请求获取数据时，项目会先去node中找，找不到就会去public文件夹中找相应的路径下是否有数据。 所以假设接口是/api/headerList.json,那可以在public文件夹下=&gt;新建api文件夹=&gt;新建headerList.json，放置相应假数据 将AJAX请求写在函数action中，异步AJAX请求需要借助第三方模块axios reducer处理action，将AJAX获取到的数据放到state的list中 组件使用connect的参数1获取state的list，使用map()循环渲染list数组于页面上。 将Header改回容器组件目前header-index.js中Header组件是无状态组件，只能通过函数嵌套来添加函数，但接下来会添加比较多东西，所以先将Header组件转回 容器组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Header extends Component &#123; getListArea(show) &#123; if (show) &#123; return ( &lt;SearchInfo&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt; &lt;SearchItemList&gt; &lt;SearchInfoItem&gt;理财&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;毕业&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;手帐&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;简书交友&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;spring&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;古风&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;故事&lt;/SearchInfoItem&gt; &lt;SearchInfoItem&gt;暖寄归人&lt;/SearchInfoItem&gt; &lt;/SearchItemList&gt; &lt;/SearchInfo&gt; ) &#125; else &#123; return null; &#125; &#125; render() &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt; &lt;NavItem className=\"left active\"&gt;首页&lt;/NavItem&gt; &lt;NavItem className=\"left\"&gt;下载App&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;登录&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe636;&lt;/span&gt; &lt;/NavItem&gt; &lt;SearchWrapper&gt; &lt;CSSTransition in=&#123;this.props.focused&#125; timeout=&#123;200&#125; classNames=\"slide\" &gt; &lt;NavSearch className=&#123;this.props.focused ? \"focused\" : \"\"&#125; onFocus=&#123;this.props.handleInputFocus&#125; onBlur=&#123;this.props.handleInputBlur&#125; /&gt; &lt;/CSSTransition&gt; &lt;span className=&#123;this.props.focused ? \"focused iconfont\" : \"iconfont\"&#125;&gt; &amp;#xe62d; &lt;/span&gt; &#123;this.getListArea(this.props.focused)&#125; &lt;/SearchWrapper&gt; &lt;/Nav&gt; &lt;Addition&gt; &lt;Button className=\"writting\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe6e5;&lt;/span&gt; 写文章 &lt;/Button&gt; &lt;Button className=\"reg\"&gt;注册&lt;/Button&gt; &lt;/Addition&gt; &lt;/HeaderWrapper&gt; ); &#125;&#125; 使用class和Component，将props转回this.props（可使用ctrl+d多选辅助） 将函数getListArea放入容器组件中，使用this.getListArea()进行调用(注意：写在组件中的函数是getListArea(){...}，写在组件外的函数是const getListArea = ()=&gt;{...}) state中增添一个list数组headet-store-reducer.js往state中增添一个list数组用于存储标签数据: 1234const defaultState = fromJS(&#123; focused: false, list: []&#125;); 配置redux-thunk中间件使用redux-thunk使action中可以写函数，我们将AJAX请求写在函数action中。 1.安装redux-thunk： 1yarn add redux-thunk 复习中间件：指的是action和store的“中间”，实际是对dispatch的一个升级。 2.创建store时（即src-store-index.js）添加中间件： 12345678910import &#123; createStore, compose, applyMiddleware &#125; from \"redux\";import reducer from \"./reducer\";import thunk from \"redux-thunk\"const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;const store = createStore(reducer, composeEnhancers( applyMiddleware(thunk)));export default store; 通过redux提供的applyMiddleware可将redux-thunk中引入的thunk添加进store。 public下模拟假数据 AJAX请求的接口下得返回数据给页面，那么返回的数据就需要我们进行模拟。 注意：当js页面中向某个接口发出请求获取数据时，项目会先去node中找，找不到就会去public文件夹中找相应的路径下是否有数据。 所以假设接口是/api/headerList.json,那可以在public文件夹下=&gt;新建api文件夹=&gt;新建headerList.json，放置相应假数据 注意：这种写法就不能使用mock.js去模拟假数据，因为public下的文件中获取到的内容是被直接显示的，不会进行编译。而且mockjs会帮助拦截请求，写到public下也没办法让使用AJAX的组件引入mockjs。 public文件夹下=&gt;新建api文件夹=&gt;新建headerList.json： 1234&#123; \"sucess\":true, \"data\":[\"简书\",\"理财\",\"毕业\",\"手帐\",\"简书交友\",\"spring\",\"古风\",\"故事\",\"暖寄归人\"]&#125; 组件中发送含有AJAX的action当搜索框NavSearch聚焦时会触动handleInputFocus函数，所以我们将AJAX获取数据的action(即actionCreators.js中的getList())写在handleInputFocus函数中即可： 1234567891011const mapDispatchProps = (dispatch) =&gt; &#123; return &#123; handleInputFocus() &#123; dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); &#125;, handleInputBlur() &#123; dispatch(actionCreators.searchBlur()); &#125; &#125;&#125; action中使用axios库进行AJAX请求 异步请求需要借助第三方模块axios 1.安装axios库： 1yarn add axios 2.header-store-actionCreators.js中，引入axios并创建getList()用于获取AJAX数据： 123456789101112131415const changeList = (data) =&gt; (&#123; type: constants.CHANG_LIST, data&#125;);export const getList = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get(\"/api/headerList.json\").then((res) =&gt; &#123; const data = res.data; dispatch(changeList(data.data)); &#125;).catch(() =&gt; &#123; console.log(\"error\"); &#125;); &#125;;&#125;; 原本actionCreators中返回的action都只能是对象，使用redux-thunk后可返回函数（该函数接受dispatch方法作为参数） 3.注意：fromJS会自动将对象中的数组变成immutable类型的数组，所以在reducer中使用set()修改数组的时候要求修改的数据也是immutable类型的，否则数据类型就乱了。所以我们要在actionCreators.js中使用fromJS使data也成为immutable类型 1import &#123; fromJS &#125; from \"immutable\"; 1234export const changeList = (data) =&gt; (&#123; type: constants.CHANG_LIST, data: fromJS(data)&#125;); reducer处理action中AJAX获取到的数据action发出以后就要到reducer.js中处理这个action，将AJAX获取到的数据放到list中： 123if (action.type === constants.CHANG_LIST) &#123; return state.set(\"list\", action.data);&#125; 获取list数据循环显示在页面上原本我们把标签数据都写死了，现在我们要在connect方法的参数1 mapStateToProps函数中将store的list取到，然后修改getListArea方法，循环显示list中的数据。 header-index.js:1.使用mapStateToProps函数将store的list取到： 123456const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.getIn([\"header\", \"focused\"]), list: state.getIn([\"header\", \"list\"]) &#125;&#125; 2.修改getListArea方法，循环显示list中的数据： 123456789101112131415161718192021getListArea() &#123; if (this.props.focused) &#123; return ( &lt;SearchInfo&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt; &lt;SearchItemList&gt; &#123; this.props.list.map((item) =&gt; &#123; return &lt;SearchInfoItem key=&#123;item&#125;&gt;&#123;item&#125;&lt;/SearchInfoItem&gt; &#125;) &#125; &lt;/SearchItemList&gt; &lt;/SearchInfo&gt; ) &#125; else &#123; return null; &#125;&#125; 代码优化actionCreator.js需要导出的函数放一起 actionCreator中作为AJAX请求的函数changeList是不需要导出的，建议将不需要导出的函数统一放在顶部/底部。 明确表示哪些函数是自己用的，哪些函数是导出给别人用的。 actionCreator.js： 123456789101112131415161718192021222324252627import &#123; constants &#125; from \"../store\";import axios from \"axios\";import &#123; fromJS &#125; from \"immutable\";const changeList = (data) =&gt; (&#123; type: constants.CHANG_LIST, data: fromJS(data)&#125;);export const searchFocus = () =&gt; (&#123; type: constants.SEARCH_FOCUS&#125;);export const searchBlur = () =&gt; (&#123; type: constants.SEARCH_BLUR&#125;);export const getList = () =&gt; &#123; return (dispatch) =&gt; &#123; axios.get(\"/api/headerList.json\").then((res) =&gt; &#123; const data = res.data; dispatch(changeList(data.data)); &#125;).catch(() =&gt; &#123; console.log(\"error\"); &#125;); &#125;;&#125;; 函数顶部解构赋值一次性获取props上的值组件中很多地方会重复使用this.props.xxx来取值，那么我们可以在函数顶部使用const {xx,xxx,xxx} = this.props;来一次性获取props上的值，接下来只要使用xx即可。 header-index.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106import React, &#123; Component &#125; from 'react'import &#123; connect &#125; from \"react-redux\";import &#123; actionCreators &#125; from \"./store\";import &#123; CSSTransition &#125; from 'react-transition-group';import &#123; HeaderWrapper, Logo, Nav, NavItem, NavSearch, Addition, Button, SearchWrapper, SearchInfo, SearchInfoTitle, SearchInfoSwitch, SearchInfoItem, SearchItemList,&#125; from \"./style\";class Header extends Component &#123; getListArea() &#123; const &#123; focused, list &#125; = this.props; if (focused) &#123; return ( &lt;SearchInfo&gt; &lt;SearchInfoTitle&gt; 热门搜索 &lt;SearchInfoSwitch&gt;换一批&lt;/SearchInfoSwitch&gt; &lt;/SearchInfoTitle&gt; &lt;SearchItemList&gt; &#123; list.map((item) =&gt; &#123; return &lt;SearchInfoItem key=&#123;item&#125;&gt;&#123;item&#125;&lt;/SearchInfoItem&gt; &#125;) &#125; &lt;/SearchItemList&gt; &lt;/SearchInfo&gt; ) &#125; else &#123; return null; &#125; &#125; render() &#123; const &#123; focused, handleInputFocus, handleInputBlur &#125; = this.props; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt; &lt;NavItem className=\"left active\"&gt;首页&lt;/NavItem&gt; &lt;NavItem className=\"left\"&gt;下载App&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;登录&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe636;&lt;/span&gt; &lt;/NavItem&gt; &lt;SearchWrapper&gt; &lt;CSSTransition in=&#123;focused&#125; timeout=&#123;200&#125; classNames=\"slide\" &gt; &lt;NavSearch className=&#123;focused ? \"focused\" : \"\"&#125; onFocus=&#123;handleInputFocus&#125; onBlur=&#123;handleInputBlur&#125; /&gt; &lt;/CSSTransition&gt; &lt;span className=&#123;focused ? \"focused iconfont\" : \"iconfont\"&#125;&gt; &amp;#xe62d; &lt;/span&gt; &#123;this.getListArea()&#125; &lt;/SearchWrapper&gt; &lt;/Nav&gt; &lt;Addition&gt; &lt;Button className=\"writting\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe6e5;&lt;/span&gt; 写文章 &lt;/Button&gt; &lt;Button className=\"reg\"&gt;注册&lt;/Button&gt; &lt;/Addition&gt; &lt;/HeaderWrapper&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.getIn([\"header\", \"focused\"]), list: state.getIn([\"header\", \"list\"]) &#125;&#125;const mapDispatchProps = (dispatch) =&gt; &#123; return &#123; handleInputFocus() &#123; dispatch(actionCreators.getList()); dispatch(actionCreators.searchFocus()); &#125;, handleInputBlur() &#123; dispatch(actionCreators.searchBlur()); &#125; &#125;&#125;export default connect(mapStateToProps, mapDispatchProps)(Header); 用switch替换大量if 在reducer中我们使用了大量的if语句，使用switch替换会更好。 一般要使用 break 来阻止代码自动地向下一个 case 运行。但由于我们使用了return，也就不需要break了。 header-store-reducer.js: 123456789101112131415161718192021import * as constants from \"./constants\";import &#123; fromJS &#125; from \"immutable\";// immutable对象 是不可改变的const defaultState = fromJS(&#123; focused: false, list: []&#125;);export default (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case constants.SEARCH_FOCUS: return state.set(\"focused\", true); case constants.SEARCH_BLUR: return state.set(\"focused\", false); case constants.CHANG_LIST: return state.set(\"list\", action.data); default: return state; &#125;&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"简书Header组件开发（使用immutable.js库、redux-immutable库）","slug":"简书Header组件开发（使用immutable.js库、redux-immutable库）","date":"2020-01-27T13:19:48.000Z","updated":"2020-03-09T15:56:56.464Z","comments":true,"path":"2020/01/27/简书Header组件开发（使用immutable.js库、redux-immutable库）/","link":"","permalink":"http://yoursite.com/2020/01/27/简书Header组件开发（使用immutable.js库、redux-immutable库）/","excerpt":"总结 immutable.js库/redux-immutable库 都可生成不可改变的immutable对象,但使用场景不同。 immutable.js库的fromJS()：接受组件的state对象，返回immutable对象类型的state。 redux-immutable库的combineReducers()：接受各个组件的reducer，返回immutable对象类型的 总state。","text":"总结 immutable.js库/redux-immutable库 都可生成不可改变的immutable对象,但使用场景不同。 immutable.js库的fromJS()：接受组件的state对象，返回immutable对象类型的state。 redux-immutable库的combineReducers()：接受各个组件的reducer，返回immutable对象类型的 总state。 想要获取immutable对象的属性则需要使用get()。 immutable对象的set()不会改变原本的immutable对象，它返回的是新的immutable对象。 注意：fromJS会自动 将对象中的数组 变成 immutable类型的数组，所以使用set()修改immutable类型数组时要求修改的数据也是immutable类型的，否则数据类型就乱了。所以我们要使用fromJS使set()的参数2也成为immutable类型 拆分actionCreators与constants actionCreators.js里都是函数，每个函数都返回对应的action。 constants.js即我们之前使用过的actionTypes.js,用于将action的type从字符串定义为常量的文件。 在common-header-store文件夹下新建actionCreators.js和constants.js，他们都要通过index.js进行输出（store文件夹下的所有文件都通过index.js输出，这样 外部文件 引用时统一引用到store文件夹即可） 拆分constants.js1.common-header-store 新建constants.js 将action的type从字符串定义为常量： 123//加一个`header/`表示是header下的，对后续维护有好处export const SEARCH_FOCUS = \"header/SEARCH_FOCUS\";export const SEARCH_BLUR = \"header/SEARCH_BLUR\"; 2.在common-header-store-index.js中引入、输出constants.js，统一对外接口路径： 1234import reducer from \"./reducer\";import * as constants from \"./constants\";export &#123; reducer, constants &#125;; 3.header-index.js中，引入constants并修改原本的action的type（字符串=&gt;常量）: 123456789101112131415161718import &#123; constants &#125; from \"./store\";//中间未修改部分省略const mapDispatchProps = (dispatch) =&gt; &#123; return &#123; handleInputFocus() &#123; const action = &#123; type: constants.SEARCH_FOCUS &#125;; dispatch(action); &#125;, handleInputBlur() &#123; const action = &#123; type: constants.SEARCH_BLUR &#125;; dispatch(action); &#125; &#125;&#125; （注意：两个常量都是从constants中获取的，constants输出时使用了*，所以调用常量时都要使用constants前缀） 4.common-header-store-reducer.js中,引入constants并修改action.type： 12345678910111213141516171819import * as constants from \"./constants\";const defaultState = &#123; focused: false&#125;;export default (state = defaultState, action) =&gt; &#123; if (action.type === constants.SEARCH_FOCUS) &#123; return &#123; focused: true &#125; &#125; if (action.type === constants.SEARCH_BLUR) &#123; return &#123; focused: false &#125; &#125; return state;&#125; 拆分actionCreators.js1.common-header-store新建actionCreators.js，里面的每个函数都返回对应的action： 123456789import &#123; constants &#125; from \"../store\";export const searchFocus = () =&gt; (&#123; type: constants.SEARCH_FOCUS&#125;);export const searchBlur = () =&gt; (&#123; type: constants.SEARCH_BLUR&#125;); 2.在common-header-store-index.js中统一对外接口： 12345import reducer from \"./reducer\";import * as constants from \"./constants\";import * as actionCreators from \"./actioncreators\";export &#123; reducer, constants, actionCreators &#125;; 3.在common-header-store-reducer.js中引入并使用actionCreators中的函数来返回对应action： 123456789101112import &#123; constants, actionCreators &#125; from \"./store\";//中间未修改部分省略const mapDispatchProps = (dispatch) =&gt; &#123; return &#123; handleInputFocus() &#123; dispatch(actionCreators.searchFocus()); &#125;, handleInputBlur() &#123; dispatch(actionCreators.searchBlur()); &#125; &#125;&#125; （注意：调用的是actionCreators中的函数，所以记得()） immutable.js库 生成不可改变的对象 mutable 可变的，易变的 =&gt; immutable 不可变的 immutable.js是facebook推出的第三方模块（库），它可以帮我们建一个不可改变的immutable对象。 更多知识点可参考immutable.js官网文档，比如fromJS()的详细用法 使用immutable.js管理store中的数据 reducer中拿到的store的state是不应该被改变的，为防止不小心改变，我们可以将state变成immutable对象。 生成immutable对象：使用 immutable库 的fromJS() 获取immutable对象的属性：使用 immutable对象 的get()（注意参数是字符串） 修改并返回新的immutable对象：使用 immutable对象 的set() 安装immutable库可参考immutable.js官方文档： 1yarn add immutable immutable库的fromJS()生成immutable对象 immutable库的fromJS可用于生成immutable对象 引入：import {fromJS} from &quot;immutable&quot;; 使用：const immutable = fromJS({对象属性：属性值})；(fromJS()接受一个对象，并返回immutable对象) header-reducer.js中，使用immutable库的fromJS来生成immutable对象，替代原本的state默认值： 12345import &#123; fromJS &#125; from \"immutable\";const defaultState = fromJS(&#123; focused: false&#125;); immutable对象的get()获取对象属性 想要获取immutable对象的属性值不能通过对象名.属性名的方式，需要使用对象名.get(&quot;属性名&quot;) 注意：get()接受的参数为字符串 header-index.js中,原本的state已经变成immutable对象，所以需要使用get()来获取属性： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.header.get(\"focused\") &#125;&#125; 注意：state是JS对象，state.header是immutable对象，所以获取属性的方法才不同。 immutable对象的set()返回新对象 immutable对象的set()接受两个参数，返回新对象 参数1：（字符串）想要修改的对象的属性 参数2：想要修改的属性值 语法：immutable对象.set(&quot;属性名&quot;,属性值) 注意：immutable对象 是不可改变的，set()不会改变 immutable对象，他会结合 之前的immutable对象的值 和 通过参数修改的值，返回全新的对象。 header-reducer.js中，需要返回新的state，即新的immutable对象： 1234567891011export default (state = defaultState, action) =&gt; &#123; if (action.type === constants.SEARCH_FOCUS) &#123; // set()不会改变 immutable对象 // 他会结合 之前的immutable对象的值 和 通过参数修改的值，返回全新的对象 return state.set(\"focused\", true); &#125; if (action.type === constants.SEARCH_BLUR) &#123; return state.set(\"focused\", false); &#125; return state;&#125; 补充：getIn()代替连续get() 想要获取immutable对象的属性的属性时可使用getIn() 详细用法可参考immutable.js官方文档 getIn()接受一个数组作为参数，数组元素为字符串类型 immutable对象.getIn([&quot;参数1&quot;,&quot;参数2&quot;])表示获取immutable对象的参数1下的属性2。 123immutable对象.get(\"属性名a\").get(\"属性名b\")//等同于immutable对象.getIn([\"属性名a\",\"属性名b\"]) 补充：merge()代替连续set() 详细用法可参考官方文档 需要连续修改数据后返回immutable对象时，可使用merge()合成多次修改。 123456immutable对象.set(\"属性名a\",属性值a).set(\"属性名b\",属性值b)//等同于merge(&#123; 属性名a:属性值a, 属性名b:属性值b&#125;) 补充：ToJS()将immutable对象=&gt;JS对象 注意：对象包括数组 语法:const JS对象 = immutable对象.toJS(); 作为state，我们不希望他改变，但是state中的数组我们是可以允许改变的，将state生成为immutable对象时顺便生成的immutable数组就可使用ToJS()将其转换为JS数组，以方便修改。 在reducer中，我们将state生成为immutable对象后，其中的数组也会成为immutable数组： 那后续的数组修改就会变得很麻烦，所以想要修改数组前可使用ToJS()将immutable数组转回JS数组： 1const newList = list.toJS(); redux-immutable库 生成不可改变的对象 上面我们知道了，通过 immutable库的fromJS() 可在组件的reducer中生成immutable对象类型的state。 使用redux-immutable库的combineReducers()合成各个组件的reducer得到的就是immutable对象 想要获取immutable对象的属性的属性时可使用getIn() 使用redux-immutable统一数据格式 header下的reducer中的state是immutable对象。 但项目最外层的state还是JS对象，这个state是在src-store-reducer.js中创建的。 在header-index.js中,state是JS对象，state.header是immutable对象： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.header.get(\"focused\") &#125;&#125; 原本项目最外层的state是使用redux的combineReducers()合成各个组件的reducer得到的。 但immutable库的fromJS()接受的参数是对象，不具有结合reducer们的能力，最外层state是由许多reducer合成而来，不能使用fromJS()。 而使用redux-immutable库的combineReducers()合成各个组件的reducer得到的就是immutable对象 安装redux-immutable库1yarn add redux-immutable redux-immutable库的combineReducers()生成immutable对象 state是由reducer进行 定义/修改 返回给store的。 原本我们使用redux提供的combineReducers()生成的reducer返回的state是JS对象 现在改成使用redux-immutable库提供的combineReducers()生成immutable对象类型的state返回给store src-store-reducer.js：只需改成使用redux-immutable库提供的combineReducers()即可使生成的reducer（即state）为immutable对象 使用immutable对象的get()header-index.js中,由于最外层state也成为了immutable对象，所以获取state的header时要使用get()： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.get(\"header\").get(\"focused\") &#125;&#125; immutable对象的getIn()获取属性的属性上面header-index.js的代码可改为： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.getIn([\"header\", \"focused\"]) &#125;&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"简书Header组件开发（React-Redux管理数据、combineReducers拆分数据）","slug":"简书Header组件开发（React-Redux管理数据、combineReducers拆分数据）","date":"2020-01-26T13:19:48.000Z","updated":"2020-03-07T12:10:08.056Z","comments":true,"path":"2020/01/26/简书Header组件开发（React-Redux管理数据、combineReducers拆分数据）/","link":"","permalink":"http://yoursite.com/2020/01/26/简书Header组件开发（React-Redux管理数据、combineReducers拆分数据）/","excerpt":"","text":"使用React-Redux进行应用数据的管理目前我们只在state中存放了一个数据focused，但一旦数据多起来考虑到react传递数据的特点，我们就必须借助React-Redux来帮助管理数据。 项目中安装React-Reduxredux是数据框架，而react-redux是第三方模块，他可以让我们在react中更方便的使用redux： 123//首先安装redux，再安装react-reduxyarn add reduxyarn add react-redux 复习redux的工作流程: 首先我们需要有一个store，然后页面从store中取数据 如果页面想改变store中的数据，他需要： 派发一个action给store store将之前的数据和action一起给reducer reducer结合action和之前的数据返回一个新的state给store store拿到新的数据后替换自身的state，告诉页面自己更新了 页面的state也更新，页面重新渲染 使用redux和react-redux 创建store：src下创建文件夹store，创建index.js文件,在该文件中创建store实例 注意：在创建store时就要将reducer传给store，否则store不会处理数据。 创建reducer：在文件夹store中创建reducer.js文件用于放置reducer。 reducer.js中导出的是一个纯函数（给定固定输入就有固定输出，且不能改变参数值。涉及异步/时间的就不是纯函数） 导出的函数接受两个参数，参数1state其实就是store的state，参数2是action. 导出的函数返回一个state（默认值）/newState（修改后的state）给store。（注意newState是深拷贝出来的） 在项目的根组件（入口组件）App.js中，引入store，并使用react-redux中的Provider组件,使所有组件都有能力连接store。 Header组件中，使用react-redux的connect方法连接store，原本我们导出的是Header组件，现在改成导出“使用connect(mapStateToProps,mapDispatchToProps)()生成的组件”。 reducer.js中，将Header组件的state中数据放到reducer的defaultState中作为store的默认数据。 在Header组件中想要使用this.props.数据名从store中获取原本放在state中的数据，此时需要先使用connect方法的参数1mapStateToProps()进行store中的数据与props的映射（将store中获取到的数据绑在props上），才能使用this.props.数据名拿到store中的数据。 mapStateToProps()接受的参数state是store的state。 处理事件绑定函数，原本两个绑定函数中都是处理state中数据的，现在我们需要将这两个函数挂在props上（即放在connect的参数2mapDispatchToProps()内定义），新建action并通过dispatch将action传给store，store将action和state传给reducer，在reducer中添加判断，通过action的type决定给store的state返回值。 创建storesrc-store-index.js创建store: 123456import &#123; createStore &#125; from \"redux\";import reducer from \"./reducer\";const store = createStore(reducer);export default store; 创建reducer2.src-store-index.js创建reducer: 12345const defaultState = &#123;&#125;;export default (state = defaultState, action) =&gt; &#123; return state;&#125; 引入store，使用Provider组件App.js中 引入store，并使用react-redux中的Provider组件使所有组件都有能力连接store: 1234567891011121314151617181920import React, &#123; Component &#125; from 'react';import &#123; Provider &#125; from \"react-redux\";import Header from \"./common/header\";import store from \"./store\";import &#123; Globalstyle &#125; from './style';import &#123; GlobalIconFontStyle &#125; from \"./statics/iconfont/iconfont\";class App extends Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Globalstyle /&gt; &lt;GlobalIconFontStyle /&gt; &lt;Header /&gt; &lt;/Provider&gt; ); &#125;&#125;export default App; （注意：一般我们将组件的引用放在前面，样式的引用放在后面，） 使用connect方法连接storecommon-header-index.js中，使用react-redux的connect方法连接store，原本我们导出的是Header组件，现在改成导出“使用connect()生成的组件”： 1import &#123; connect &#125; from \"react-redux\"; 12345678910111213const mapStateToProps = (state) =&gt; &#123; return &#123; &#125;&#125;const mapDispatchProps = (dispatch) =&gt; &#123; return &#123; &#125;&#125;export default connect(mapStateToProps, mapDispatchProps)(Header); 观察页面正常就可以继续写。 将数据放入store中（reducer）reducer.js中，将Header组件的state中数据放到reducer的defaultState中作为store的默认数据： 123const defaultState = &#123; focused: false&#125;; 组件从store中取值 先使用connect方法的参数1mapStateToProps()进行store中的数据与props的映射，才能使用props拿到store中的数据。（mapStateToProps()接受的参数state是store的state） 在Header组件中使用props从store中获取原本放在state中的数据focused。 common-header-index.js:先修改mapStateToProps(),将focused绑在props上: 12345const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.focused &#125;&#125; 再将this.state.focused改成this.props.focused即可获取store中的数据focused 此时绑定函数还没迁移，所以在页面上我们只能通过手动改true和false来看效果。 处理事件绑定函数 原本两个绑定函数中都是处理state中数据的。 现在我们需要： 将这两个函数挂在props上（即放在connect的参数2mapDispatchToProps()内定义） 新建action并通过dispatch将action传给store，store将action和state传给reducer 在reducer中添加判断，通过action的type决定给store的state返回值。 注意：两个函数中间使用逗号分隔 common-header-index.js:将这两个函数挂在props上（即放在connect的参数2mapDispatchToProps()内定义），新建action并通过dispatch将action传给store，store将action和state传给reducer： 12345678910111213141516const mapDispatchProps = (dispatch) =&gt; &#123; return &#123; handleInputFocus() &#123; const action = &#123; type: \"search_focus\" &#125;; dispatch(action); &#125;, handleInputBlur() &#123; const action = &#123; type: \"search_blur\" &#125;; dispatch(action); &#125; &#125;&#125; 调用时从props上获取： 12345&lt;NavSearch className=&#123;this.props.focused ? \"focused\" : \"\"&#125; onFocus=&#123;this.props.handleInputFocus&#125; onBlur=&#123;this.props.handleInputBlur&#125;/&gt; store-reducer.js:在reducer中添加判断，通过action的type决定给store的state返回值 1234567891011121314151617const defaultState = &#123; focused: false&#125;;export default (state = defaultState, action) =&gt; &#123; if (action.type === \"search_focus\") &#123; return &#123; focused: true &#125; &#125; if (action.type === \"search_blur\") &#123; return &#123; focused: false &#125; &#125; return state;&#125; 页面动画效果也实现好了。 处理无状态组件 此时Header组件只有render函数，所以可成为无状态组件，为提升性能，我们可以将其转换为无状态组件。 转换步骤： 直接让Header组件等于一个箭头函数（const Header = (props) =&gt; {}） 将原本render函数中的内容复制到箭头函数中return出去（不返回则外部无法获取，因为调用Header组件相当于调用它返回的东西） 注意该函数接收父级的props作为参数，所以所有this.props.xxx都改成props.xxx header-index.js: 1234567891011121314151617181920212223242526272829303132333435363738const Header = (props) =&gt; &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt; &lt;NavItem className=\"left active\"&gt;首页&lt;/NavItem&gt; &lt;NavItem className=\"left\"&gt;下载App&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;登录&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe636;&lt;/span&gt; &lt;/NavItem&gt; &lt;SearchWrapper&gt; &lt;CSSTransition in=&#123;props.focused&#125; timeout=&#123;200&#125; classNames=\"slide\" &gt; &lt;NavSearch className=&#123;props.focused ? \"focused\" : \"\"&#125; onFocus=&#123;props.handleInputFocus&#125; onBlur=&#123;props.handleInputBlur&#125; /&gt; &lt;/CSSTransition&gt; &lt;span className=&#123;props.focused ? \"focused iconfont\" : \"iconfont\"&#125;&gt; &amp;#xe62d; &lt;/span&gt; &lt;/SearchWrapper&gt; &lt;/Nav&gt; &lt;Addition&gt; &lt;Button className=\"writting\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe6e5;&lt;/span&gt; 写文章 &lt;/Button&gt; &lt;Button className=\"reg\"&gt;注册&lt;/Button&gt; &lt;/Addition&gt; &lt;/HeaderWrapper&gt; )&#125; 使用combineReducers对数据拆分管理 虽然我们已经使用redux和react-redux进行数据管理，但页面上的开发者工具Redux DevTools还是灰色的，也就是说F12中的redux测试是不好用的： 想要使用Redux DevTools就需要在项目的store-index.js中进行配置。 配置开发者工具REDUX_DEVTOOLS_EXTENSIONgithub中搜索redux-devtools-extension,在文档中查看他的高级用法Advanced store setup 配置成功：（展示 REDUX_DEVTOOLS_EXTENSION 的具体用法） 为什么使用combineReducers拆分数据 如果一个reducer中存放过多数据，就会导致后期代码维护十分困难。（一般一个文件超过300行代码就是没设计好） 所以我们可以将一个reducer拆分成很多个小的reducer，最终再整合起来。 redux提供了一个combineReducers模块用于将小的reducer们整合成大的一个reducer combineReducers使用步骤 header文件夹下=&gt;新建store文件夹=&gt;新建reducer.js文件，用于存储和Header组件相关的store数据/操作。 在src-store-reducer.js中，将分开的小reducer通过 combineReducers 结合成完整的一个reducer。（键名是自定义的，用于在组件中获取store中的数据） 由于原本放在reducer中的数据迁移到了小reducer中，所以在组件中规定 store映射到props 的函数（connect方法的参数2mapStateToProps()）中的state.focused也应当改为state.header.focused，组件才能获取到store中的数据。 优化：在 总reducer 中引入 分reducer 的路径太长，此时可以在 分reducer 的文件夹中新建index.js用于 “引入、输出 分reducer”，这样在 总reducer 中引入 分reducer 时就可以直接从这个index中引入了。 1.header文件夹下=&gt;新建store文件夹=&gt;新建reducer.js文件，用于存储和Header组件相关的store数据（即原本store中reducer的内容）： 1234567891011121314151617const defaultState = &#123; focused: false&#125;;export default (state = defaultState, action) =&gt; &#123; if (action.type === \"search_focus\") &#123; return &#123; focused: true &#125; &#125; if (action.type === \"search_blur\") &#123; return &#123; focused: false &#125; &#125; return state;&#125; 2.在src-store-reducer.js中，将分开的小reducer通过 combineReducers 结合成完整的一个reducer： 12345678import &#123; combineReducers &#125; from \"redux\";import headerReducer from \"../common/header/store/reducer\";const reducer = combineReducers(&#123; header: headerReducer&#125;)export default reducer; 此时可以看到focused不是在顶层state中了，她在header（也就是我们使用combineReducers时规定的键中）下，focused值会变，但动画效果不生效： 3.由于原本放在reducer中的数据迁移到了小reducer中，所以在组件中规定store和props的映射的函数（connect方法的参数2mapStateToProps()）中的state.focused也应当改为state.header.focused，组件才能获取到store中的数据： 12345const mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.header.focused &#125;&#125; 4.优化：在 总reducer 中引入 分reducer 的路径太长，此时可以在 分reducer 的文件夹中新建index.js用于 “引入、输出 分reducer”，这样在 总reducer 中引入 分reducer 时就可以直接从这个index中引入了。 common-header-store新建index.js: 123import reducer from \"./reducer\";export &#123; reducer &#125;; src-store-reducer.js中引用路径就变短（as是ES6的语法，用于起别名。否则两个reducer会报错）： 12345678import &#123; combineReducers &#125; from \"redux\";import &#123; reducer as headerReducer &#125; from \"../common/header/store\";const reducer = combineReducers(&#123; header: headerReducer&#125;)export default reducer;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"简书Header组件开发（使用iconfont、实现搜索框动画效果）","slug":"简书Header组件开发（使用iconfont、实现搜索框动画效果）","date":"2020-01-25T14:40:52.000Z","updated":"2020-03-06T13:36:13.654Z","comments":true,"path":"2020/01/25/简书Header组件开发（使用iconfont、实现搜索框动画效果）/","link":"","permalink":"http://yoursite.com/2020/01/25/简书Header组件开发（使用iconfont、实现搜索框动画效果）/","excerpt":"总结 上一篇笔记中，我们在定义组件样式时，使用过 &amp;.yourClassName来给使用同一组件名创造的不同组件设置独特的样式 比如：在style.js中我们给&lt;A&gt;组件规定了统一的样式,在统一的样式中又使用&amp;.aa{样式们}和&amp;.bb{}设置了不同的样式，那么在index.js中我们就可以使用&lt;A className=&quot;aa&quot;&gt;&lt;A/&gt;和&lt;A className=&quot;bb&quot; &gt;&lt;A/&gt;来创建样式有些许不同的A组件了。","text":"总结 上一篇笔记中，我们在定义组件样式时，使用过 &amp;.yourClassName来给使用同一组件名创造的不同组件设置独特的样式 比如：在style.js中我们给&lt;A&gt;组件规定了统一的样式,在统一的样式中又使用&amp;.aa{样式们}和&amp;.bb{}设置了不同的样式，那么在index.js中我们就可以使用&lt;A className=&quot;aa&quot;&gt;&lt;A/&gt;和&lt;A className=&quot;bb&quot; &gt;&lt;A/&gt;来创建样式有些许不同的A组件了。 也在定义组件的样式中使用过 &amp;::placeholder给组件的placeholder属性 设置样式。 之前我们都是给同一层级的组件定义样式。而 .yourClassName是给组件中的组件（即子组件）设置样式。 比如：我们在index.js中使用 iconfont图标 时组件是span，这并不是我们自己定义的组件，所以想要修改iconfont图标的部分样式时，我们 可以在SearchWrapper的样式中加入.iconfont{样式们} 来设置。1234&lt;SearchWrapper&gt; &lt;NavSearch /&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe62d;&lt;/span&gt;&lt;/SearchWrapper&gt; 注意 同时调用多个样式名时，用空格分隔样式名。 &amp;表示当前元素 例如下面代码编译之后就是a.b{}（表示className为b的a组件），没有&amp;就成了a .b（中间有个空格，b这个class成了a的后代元素的了）。123a&#123; &amp;.b &#123;&#125;&#125; 使用iconfont嵌入头部图标需要借助iconfont官网完成以下操作。 新建项目打开iconfont官网-注册登录-“图标管理”-“我的项目”-（点击右边图标）新建项目（图标仓库）： 目前我们需要3个图标： 添加图标1.在顶部搜索框中搜索我们需要的图标-加入“购物车”： 2.点击右上角 购物车图标 -“添加至项目”： 3.修改羽毛颜色后，“下载至本地”： 4.得到压缩文件download，此时文件中demo_index.html教我们如何使用iconfont，真正有用的是下面5个文件： 5.将有用的6个文件添加至 src\\statics下新建的iconfont文件夹中。 使用图标修改iconfont.css为全局样式组件iconfont.css是iconfont主要的css文件。 改为相对路径1.我们需要给iconfont.css中每个url的路径前加./，将其改为相对路径(以data:开头的路径不需要加，他是base64的文件) 2.下面的几个class可以先删除： 改为全局样式组件因为我们整个项目都可能需要用到iconfont，所以iconfont.css 改为全局样式组件会更合适。 定义全局样式组件：将iconfont.css重命名为iconfont.js，在iconfont.js中，借助’styled-components’的createGlobalStyle定义全局样式组件GlobalIconFontStyle。 使用全局样式组件：在src-App.js中，引入并使用 全局样式组件GlobalIconFontStyle（注意引用路径和Globalstyle不同） iconfont.js中，定义全局样式组件GlobalIconFontStyle： 1234567891011121314151617181920import &#123; createGlobalStyle &#125; from 'styled-components'export const GlobalIconFontStyle = createGlobalStyle`@font-face &#123;font-family: \"iconfont\"; src: url('./iconfont.eot?t=1582706509034'); /* IE9 */ src: url('./iconfont.eot?t=1582706509034#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAARMAAsAAAAACGQAAAP/AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCDHAqEJINqATYCJAMQCwoABCAFhG0HQhtWB1GUL0qG7EtMRUbWKynSLdb02Bgu0Ffng0EHFQEAALwATC6AXxwQD1/7vZ67e9/PBphcJjYpjCdUBEa0sqo1hoyr8R3PqkLlx7XfvhgmfZh9bYj7ydv9/fPdsOahkgid6pFkmvDMQJ5WOIOSTiJe5+CkN90D/8yLK9Q8y/lsov5/rqmXzw8stm9nc4lqq6S2wwGOWwcW0VQgA96Abawbxq68iMMEBqyo5braPTiJgpIxKhBvqSKgYMoma6jQjL2Shdkfn3CdVj4QDvnofz/+iUeQoquMo64975JR60+llP4v9aiW4d6N5wFbRsURJImXpb7HPGHiiMeA0t3rFNI0hbHaqpBiL7pm/uVRhEr0GLohRJ5o64nJbY7CzziCn2wqxHN4Qz++4T8gl+6eqtLaNJAxNHosmZ12J8MzLSHdb/5QmHHE6yucA8MZiIFtp4z62/gyH58df3NDr81ZXOkc0HCBx0egqDeG+SCIFwwHWxrPQJK8FEXz6iHv7rKFGdCrq6+3k6eAMQ17Tq4Kdu8z6mV3o0fAMAgeyip29oFdQAOz58IEmJJB/nywJ8LMsvlY+KV3JzRErGege5pnwDfFfDDMoIe5hYBAD6aAvYNdD0+jbR5lLe9Fsf0XLd7ijV283ObhtBnz/jbOyLzSVcGTzZRT5LzjMoMAB9P6t8s+/JoP/M0v9VFKGHcnv4t4fUXsMsWu2DF1xtmdRfnuiQkCVOdjCbQRxrEY/R7oTRprza++OfHS2t/eamE/SxlebBNdv0nF6Rpw6d7CPELhQ6vrevmGPWwnOtzOhmm2iazIIGs+3lOAcH3XkSyVfnMwvxXtVUGBnhXanWzxxJn5XraZuV8epThC3gpPRaL9yaa5W7BZr1w7fW7evnoV0ghGCcuUXlKk5rtidwT4jSILwsV/p9Uf/t7javj/X6Wpvv/xg9z93H4ewm74tQFXHv6x6yBStdP7e/LW8t9sSYka5K9KVRr2TLlcbuJQuvgnBNN1g48oGDCAn5thwucY+ukZZG6gmY6h6LMMVbOFJnkEnUEn0NOcwYBDPcsHTWI8Ivtx4ABAGHMMxYjvUI25RZP8gM6Mf+gZCw8MuBPcGw7aCZpmwUDgIGNxC1PJNIjl5GlB7jgoa5rAkkqfngbm0DCOhaPZdA8YwMaY4qwrcc4JJszUcTc4DjTNxBYzUyDxcJJzqz4SIWUvCkumjtJcwQABB2SYaAtGSUwG4lbn0nKfHwcUazQCVsOriE4DjIN2jsWERVugPTqjFe9aujvWKeI4juBhBGPSYd3QAzQzYcKs8n4pQMKFJXvELPUiqBJpqwvPb9CfcA0MMG7PKFEjo1MuCSEnQTEoocACeWu6YIoUIQA=') format('woff2'), url('./iconfont.woff?t=1582706509034') format('woff'), url('./iconfont.ttf?t=1582706509034') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('./iconfont.svg?t=1582706509034#iconfont') format('svg'); /* iOS 4.1- */&#125;.iconfont &#123; font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;&#125;` App.js中，引入并使用 全局样式组件GlobalIconFontStyle: 123456789101112131415161718import React, &#123; Component,Fragment &#125; from 'react';import &#123; Globalstyle &#125; from './style';import Header from \"./common/header\";import &#123;GlobalIconFontStyle&#125; from \"./statics/iconfont/iconfont\"class App extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;Globalstyle /&gt; &lt;GlobalIconFontStyle /&gt; &lt;Header /&gt; &lt;/Fragment&gt; ); &#125;&#125;export default App; 控制台未报错，说明iconfont成功引入： 使用Aa图标根据demo的使用方法，使用&lt;span&gt;标签替换我们common-header-index.js中的Aa.注意：在react中使用className代替class 1.文件夹中的demo_index.html-Unicode拉到最下面有教我们使用方法：几年前是&lt;i&gt;标签用于引用字体图标，现在文档改为了&lt;span&gt;，其实你写&lt;div&gt;也可以,但最好和官方保持一致。 文档中的字体编码： 2.common-header-index.js中，使用&lt;span&gt;标签替换我们原本的字符串Aa: 123&lt;NavItem className=\"right\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe636;&lt;/span&gt; &lt;/NavItem&gt; 注意：在react中使用className代替class 使用羽毛笔图标common-header-index.js: 1234&lt;Button className=\"writting\"&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe6e5;&lt;/span&gt; 写文章&lt;/Button&gt; 使用搜索图标（.iconfont设置图标样式） 使用SearchWrapper组件：因为搜索框（input）内不能再放置组件，所以我们只能把搜索图标放在搜索框外，然后使用SearchWrapper组件（div）将他们包裹**起来。 使用子绝父相对图标进行定位：为了让图标出现在搜索框内，我们需要将它绝对定位以脱离文档流。为了布局方便，他的父元素SearchWrapper组件需要设置为相对定位。 注意：在包裹图标的 父组件样式 中添加.iconfont设置（子组件）图标的样式 回顾： 以前我们在定义组件样式时，使用过&amp;.yourClassName来给使用某个className的样式组件设置不同的样式（比如&lt;A className=&quot;aa&quot; /&gt;和&lt;A className=&quot;bb&quot; /&gt;就可以在样式上稍有不同）。 也使用过&amp;::placeholder给placeholder属性 设置样式。他们都是同一个组件中的内容。 而iconfont使用的span组件并不是我们自己定义的，所以他的样式要去父组件中给子组件（即span）设置，我们可以通过在父组件中增加.iconfont给组件中的组件（即子组件）设置样式。 common-header-style.js:复习：line-height设置 SearchWrapper组件需要左浮动：因为他前面的组件全都浮动了，浮动的组件脱离了文档流，所以她也需要浮动才能出现在我们希望的位置。 图标line-hight垂直居中：因为这个图标是&lt;span&gt;元素，所以可以使用line-hight实现垂直居中。【绝对定位使得元素成为inline-block，所以虽然表现为块状，但仍然可以使用行内元素的line-hight属性实现垂直居中】 图标text-align水平居中：因为这个图标是&lt;span&gt;元素，所以可以使用text-align水平居中。 1234567891011121314export const SearchWrapper = styled.div` position: relative; float:left; .iconfont&#123; position: absolute; right:5px; bottom:5px; width:30px; line-height:30px; text-align:center; border-radius:15px; background:green; &#125;`; common-header-index.js: 1234&lt;SearchWrapper&gt; &lt;NavSearch /&gt; &lt;span className=\"iconfont\"&gt;&amp;#xe62d;&lt;/span&gt;&lt;/SearchWrapper&gt; 搜索图标上的绿色背景是为点击以后的动态效果所保留的（具体效果可以从简书官网看到） 实现搜索框动画效果要实现的效果：点击搜索框时搜索框变长且搜索按钮变为灰底白字。 搜索框两种样式首先我们不考虑逻辑，只考虑如何做出两个样式。样式1：我们原本的搜索框样式（窄且按钮无底色）样式2：点击后显示的样式，搜索框长且按钮为灰底白字。 注意： react中我们尽量不操作DOM，我们使用数据的改变来让页面发生改变。 思路 在Header组件的index.js中创造一个构造函数，在state中保存一个变量focused表示搜索框是否被选中，选中则为true，未选中则为false。 在Header组件的style.js中，给搜索框的样式NavSearch增加&amp;.focused{}样式，设置搜索框宽度拉长。 在Header组件的style.js中，在.iconfont{}中添加&amp;.focused{}设置点击后背景变为灰色，图标变为白色。 在组件的className中结合 三目运算符实现：根据state中 focused变量 值 改变 样式名。 假设点击时focused为true，则搜索框的样式对应&amp;.focused{}，图标的样式对应.iconfont{}中添加&amp;.focused{} 假设未点击时focused为false，则搜索框的样式对应空（即使用NavSearch组件原本的样式），图标的样式对应 iconfont（即原定样式） 当然此时我们还没做逻辑判断，通过手动修改state中focused的值来看两种不同的效果。 注意：组件使用多个样式表时，使用 空格 分隔多个样式表名。 代码实现1.Header-index.js：在Header组件中创造一个构造函数，在state中保存一个变量focused表示搜索框是否被选中，选中则为true，未选中则为false： 123456constructor(props) &#123; super(props); this.state = &#123; focused: false &#125;&#125; 2.Header-style.js：给搜索框的样式NavSearch增加&amp;.focused{}样式，设置搜索框宽度拉长： 12345678910111213141516171819202122export const NavSearch = styled.input.attrs(&#123; placeholder: \"搜索\"&#125;)` width: 160px; height: 38px; padding: 0 30px 0 20px; margin-top:9px; margin-left:20px; box-sizing:border-box; border:none; outline:none; border-radius:19px; background: #eee; font-size: 14px; color: #666; &amp;::placeholder&#123; color: #999; &#125; &amp;.focused&#123; width:240px; &#125;`; 3.在.iconfont{}中添加&amp;.focused{}设置点击后背景变为灰色，图标变为白色：(注意：是在.iconfont{}中添加，由于iconfont不是我们定义的组件，所以想要给她设置样式则需要通过 在iconfont的父组件中设置子组件的样式 的方式) 1234567891011121314151617export const SearchWrapper = styled.div` position: relative; float:left; .iconfont&#123; position: absolute; right:5px; bottom:5px; width:30px; line-height:30px; text-align:center; border-radius:15px; &amp;.focused&#123; background: #777; color: #fff; &#125; &#125;`; 4.index.js:在组件的className中结合 三目运算符实现：根据state中 focused变量 值 改变 样式名： 123456&lt;SearchWrapper&gt; &lt;NavSearch className=&#123;this.state.focused ? \"focused\" : \"\"&#125; /&gt; &lt;span className=&#123;this.state.focused ? \"focused iconfont\" : \"iconfont\"&#125;&gt; &amp;#xe62d; &lt;/span&gt;&lt;/SearchWrapper&gt; 在上面的代码中，我们假设点击时focused为true，则搜索框的样式对应&amp;.focused{}，图标的样式对应.iconfont{}中添加&amp;.focused{}。假设未点击时focused为false，则搜索框的样式对应空（即使用NavSearch组件原本的样式），图标的样式对应 iconfont（即原定样式）。注意：组件使用多个样式表时，使用 空格 分隔多个样式表名。 5.效果展示当然此时我们还没做逻辑判断，可以通过手动修改state中focused的值来看两种不同的效果。 focused: false时： focused: true时： 实现逻辑判断实现效果：点击搜索框则修改state中的focused值为true，搜索框失去焦点时state中的focused值变为false。 思路 在Header组件中，给搜索框NavSearch绑定onFocus事件函数handleInputFocus(记得在构造函数中使用bind()绑定this指向) 创建handleInputFocus函数，在函数中调用setState()将focused值设为true。 给搜索框NavSearch绑定onBlur事件函数handleInputBlur(记得在构造函数中使用bind()绑定this指向) 创建handleInputBlur函数，在函数中调用setState()将focused值设为 false。 通过focused值的改变就能改变样式，但目前还没有动画效果。 代码实现Header-index.js给搜索框NavSearch绑定onFocus事件函数handleInputFocus，以及onBlur事件函数handleInputBlur： 12345&lt;NavSearch className=&#123;this.state.focused ? \"focused\" : \"\"&#125; onFocus=&#123;this.handleInputFocus&#125; onBlur=&#123;this.handleInputBlur&#125;/&gt; 记得在构造函数中使用bind()绑定this指向: 12345678constructor(props) &#123; super(props); this.state = &#123; focused: false &#125; this.handleInputFocus = this.handleInputFocus.bind(this); this.handleInputBlur = this.handleInputBlur.bind(this);&#125; 创建handleInputFocus函数，在函数中调用setState()将focused值设为true。创建handleInputBlur函数，在函数中调用setState()将focused值设为 false: 12345678910handleInputFocus() &#123; this.setState(&#123; focused: true &#125;)&#125;handleInputBlur() &#123; this.setState(&#123; focused: false &#125;)&#125; 实现动画效果要实现动画效果就需要用到之前笔记提到过的react-transition-group(可以在github上搜索到) 1.在项目中安装react-transition-group： 1yarn add react-transition-group 2.使用CSSTransition实现简单的过渡动画（可参考笔记）： header-index.js:（复习CSS transition属性）引入CSSTransition组件: 1import &#123; CSSTransition &#125; from 'react-transition-group'; 使用 CSSTransition组件 包裹 NavSearch组件： 1234567891011&lt;CSSTransition in=&#123;this.state.focused&#125; timeout=&#123;200&#125; classNames=\"slide\"&gt; &lt;NavSearch className=&#123;this.state.focused ? \"focused\" : \"\"&#125; onFocus=&#123;this.handleInputFocus&#125; onBlur=&#123;this.handleInputBlur&#125; /&gt;&lt;/CSSTransition&gt; 注意：classNames属性值决定了对应的样式前缀 style.js：由于CSSTransition依旧不是我们自定义的组件，所以想定义他的样式要通过去父组件中给子组件定义的方式来实现： 12345678910111213141516171819202122232425262728293031export const SearchWrapper = styled.div` position: relative; float:left; // 入场动画 .slide-enter&#123; transition: all .2s ease-out; &#125; .slide-enter-active&#123; width:240px; &#125; // 出场动画 .slide-exit&#123; transition: all .2s ease-out; &#125; .slide-exit-active&#123; width:160px; &#125; .iconfont&#123; position: absolute; right:5px; bottom:5px; width:30px; line-height:30px; text-align:center; border-radius:15px; &amp;.focused&#123; background: #777; color: #fff; &#125; &#125;`; 优化代码动画效果的样式是针对NavSearch组件的，可我们上面把他们放在了CSSTransition的父组件SearchWrapper的样式中，这样虽然执行没问题，但我们应该将它们放到NavSearch组件的样式中会更好： 123456789101112131415161718192021222324252627282930313233343536export const NavSearch = styled.input.attrs(&#123; placeholder: \"搜索\"&#125;)` width: 160px; height: 38px; padding: 0 30px 0 20px; margin-top:9px; margin-left:20px; box-sizing:border-box; border:none; outline:none; border-radius:19px; background: #eee; font-size: 14px; color: #666; &amp;::placeholder&#123; color: #999; &#125; &amp;.focused&#123; width:240px; &#125; // 入场动画 &amp;.slide-enter&#123; transition: all .2s ease-out; &#125; &amp;.slide-enter-active&#123; width:240px; &#125; // 出场动画 &amp;.slide-exit&#123; transition: all .2s ease-out; &#125; &amp;.slide-exit-active&#123; width:160px; &#125;`; 注意：在这里动画样式是针对NavSearch组件的，不再是针对子组件，所以要加上&amp;！表示当前组件的动画样式 复习：&amp;表示当前元素，例如： 123a&#123; &amp;.b &#123;&#125;&#125; 编译之后就是a.b{}没有&amp;就成了a .b（中间有个空格，b这个class成了a的后代元素的了）","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"简书Header组件开发（样式组件的className、属性的样式）","slug":"简书Header组件开发（样式组件的className、属性的样式）","date":"2020-01-24T14:40:52.000Z","updated":"2020-03-06T13:29:00.657Z","comments":true,"path":"2020/01/24/简书Header组件开发（样式组件的className、属性的样式）/","link":"","permalink":"http://yoursite.com/2020/01/24/简书Header组件开发（样式组件的className、属性的样式）/","excerpt":"总结样式组件的className 找到几个组件之间的共性后只需要生成一个样式组件 在style.js中定义该样式时添加&amp;.yourClassName{xxx:xxx} 在使用样式组件时添加专属的className即可","text":"总结样式组件的className 找到几个组件之间的共性后只需要生成一个样式组件 在style.js中定义该样式时添加&amp;.yourClassName{xxx:xxx} 在使用样式组件时添加专属的className即可 解释&amp;的含义&amp;表示当前元素，例如 123a&#123; &amp;.b &#123;&#125;&#125; 编译之后就是a.b{}没有&amp;就成了a .b（中间有个空格，b这个class成了a的后代元素的了） 使用场景 在style.js中我们会给大部分样式相同的元素创建一个组件A，并通过styled.div 写在模板字符串中的各种样式;来定义组件A的样式。 在index.js中直接使用&lt;A&gt;...&lt;/A&gt;即可调用组件。但有时候我们使用&lt;A&gt;...&lt;/A&gt;创建了几个组件，但希望这几个组件能拥有一些不同的样式，此时就可以在style.js的组件A的样式中再通过&amp;.yourClassName{各种样式}来定义这些有区别的样式。 在index.js中直接使用&lt;A className={yourClassName}&gt;...&lt;/A&gt;即可调用有不同样式的组件了。 样式组件的属性的样式 在style.js或index.js中给样式组件增添属性（比如placeholder） 在style.js中定义该样式时添加&amp;::属性名{xxx:xxx}（比如&amp;::placeholder{color: #999;}就是给placeholder的字体定义颜色） Header组件中间部分：导航栏（Nav组件）之前我们写了logo，现在来完成logo右边的导航部分： 在common-header文件夹中： 在style.js中定义Nav组件（div标签） 在index.js中引入并使用Nav组件 在style.js中定义4个NavItem组件（div标签） 可以注意到“首页”“下载App”是左浮动，而“Aa”“登录”是右浮动，但他们4个都是用的同一个样式组件。 此时就需要在定义NavItem样式时使用&amp;.left{float:left;}，代表当NavItem组件有定义className为left的时候就让该组件左浮动。 在index.js中引入并将4个NavItem放入Nav组件中，并给需要左浮动的NavItem组件加上className:left,给需要右浮动的NavItem组件加上className:right 定义导航栏（Nav组件）在style.js中定义Nav组件（div标签）： 123456export const Nav = styled.div` width:960px; height:100%; margin: 0 auto; background:green;` 引入并使用导航栏（Nav组件）在index.js中引入并使用Nav组件: 1234567891011121314151617181920import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper, Logo, Nav,&#125; from \"./style\";class Header extends Component &#123; render() &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt;&lt;/Nav&gt; &lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header; 可以看到导航栏的位置已经确定出来了： 定义4个NavItem组件同一组件实现左右浮动左右浮动的效果： &amp;.的使用（类似className的选择器） 可以注意到“首页”“下载App”是左浮动，而“Aa”“登录”是右浮动，但他们4个都是用的同一个样式组件。 此时就需要在定义NavItem样式时使用&amp;.left{float:left;}，代表当NavItem组件有定义className为left的时候就让该组件左浮动。 在style.js中定义4个NavItem组件（div标签）： 12345678export const NavItem = styled.div` &amp;.left&#123; float:left; &#125; &amp;.right&#123; float:right; &#125;` 使用NavItem组件(className的使用)在index.js中引入并将4个NavItem放入Nav组件中，并给需要左浮动的NavItem组件加上className:left,给需要右浮动的NavItem组件加上className:right: 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper, Logo, Nav, NavItem,&#125; from \"./style\";class Header extends Component &#123; render() &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt; &lt;NavItem className=\"left\"&gt;首页&lt;/NavItem&gt; &lt;NavItem className=\"left\"&gt;下载App&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;登录&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;Aa&lt;/NavItem&gt; &lt;/Nav&gt; &lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header; 多个className的使用实现效果： 我们要使“首页”颜色不同，就需要给它多加一个独特的样式，此时调用该组件时就需要设置多个className，多个className属性值之间用 空格 分隔。style.js: 12345678910111213141516export const NavItem = styled.div` line-height: 56px; padding: 0 15px; font-size: 17px; color: #333; &amp;.left&#123; float:left; &#125; &amp;.right&#123; float:right; color: #969696; &#125; &amp;.active&#123; color: #ea6f5a; &#125;` index.js: 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper, Logo, Nav, NavItem,&#125; from \"./style\";class Header extends Component &#123; render() &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt; &lt;NavItem className=\"left active\"&gt;首页&lt;/NavItem&gt; &lt;NavItem className=\"left\"&gt;下载App&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;登录&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;Aa&lt;/NavItem&gt; &lt;/Nav&gt; &lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header; 搜索框NavSearch组件还剩三个组件，我们先来完成搜索框。注意：定义样式组件时是styled.input,带一个placeholder属性，使用&amp;::placeholder定义 属性placeholder 的样式。 &amp;::placeholder定义 属性placeholder 的样式style.js: 123456789101112131415161718export const NavSearch = styled.input.attrs(&#123; placeholder: \"搜索\"&#125;)` width: 160px; height: 38px; padding: 0 20px; margin-top:9px; margin-left:20px; box-sizing:border-box; border:none; outline:none; border-radius:19px; background: #eee; font-size: 14px; &amp;::placeholder&#123; color: #999; &#125;` index.js: 12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper, Logo, Nav, NavItem, NavSearch,&#125; from \"./style\";class Header extends Component &#123; render() &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt; &lt;NavItem className=\"left active\"&gt;首页&lt;/NavItem&gt; &lt;NavItem className=\"left\"&gt;下载App&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;登录&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;Aa&lt;/NavItem&gt; &lt;NavSearch /&gt; &lt;/Nav&gt; &lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header; Header组件最右部分：Addition组件“注册”和“写文章”按钮 定义一个div的样式组件Addition，它是绝对定位的，相对&lt;HeaderWrapper&gt;进行定位，脱离文档流 悬浮在页面右上角。 我们将 注册和写文章按钮 绝对定位在Addition中。 定义div的样式组件Button,“注册”和“写文章”按钮就使用该组件。 注意：中间导航栏Nav与右边两个按钮重合，此时给Nav增加padding-right时还要设置为 替代盒模型box-sizing-border-box，这样才能保证width是我们可见的宽度。(标准盒模型 的宽度只是内容的宽度，不包括padding与border，所以我们一旦设置padding与border就应该设置替代盒模型，以确保我们设置的width就是我们看到的宽度) 1234567export const Nav = styled.div` width:960px; height:100%; margin: 0 auto; box-sizing:border-box; padding-right: 70px;` style.js: 123456789101112131415161718192021222324export const Addition = styled.div` position:absolute; right:0; top:0; height:56px;`export const Button = styled.div` float:right; margin-top:9px; margin-right:20px; padding:0 20px; line-height:38px; border-radius:19px; border:1px solid #ec6149; font-size:14px; &amp;.reg&#123; color:#ec6149; &#125; &amp;.writting&#123; color:#fff; background:#ec6149; &#125;` index.js: 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper, Logo, Nav, NavItem, NavSearch, Addition, Button,&#125; from \"./style\";class Header extends Component &#123; render() &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo /&gt; &lt;Nav&gt; &lt;NavItem className=\"left active\"&gt;首页&lt;/NavItem&gt; &lt;NavItem className=\"left\"&gt;下载App&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;登录&lt;/NavItem&gt; &lt;NavItem className=\"right\"&gt;Aa&lt;/NavItem&gt; &lt;NavSearch /&gt; &lt;/Nav&gt; &lt;Addition&gt; &lt;Button className=\"writting\"&gt;写文章&lt;/Button&gt; &lt;Button className=\"reg\"&gt;注册&lt;/Button&gt; &lt;/Addition&gt; &lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Node.js函数引用与解构赋值","slug":"Node.js函数引用与解构赋值","date":"2020-01-23T14:00:10.000Z","updated":"2020-01-27T08:05:28.277Z","comments":true,"path":"2020/01/23/Node.js函数引用与解构赋值/","link":"","permalink":"http://yoursite.com/2020/01/23/Node.js函数引用与解构赋值/","excerpt":"函数引用什么时候要使用{}进行解构赋值？什么时候引用外部js文件中的函数时要使用{}进行解构赋值？输出时使用了{}来包裹的在外部js文件中引用时需要使用{}将变量括起。（具体可看下面的事例）","text":"函数引用什么时候要使用{}进行解构赋值？什么时候引用外部js文件中的函数时要使用{}进行解构赋值？输出时使用了{}来包裹的在外部js文件中引用时需要使用{}将变量括起。（具体可看下面的事例） 我的理解是：输出的时候是以 对象的属性 的形式输出，那么引用时就要使用 解构赋值 的方法将这些 属性 都分解出来再赋给变量，自然就会用上 解构赋值 。而输出时就以变量形式输出的引用时就变量形式引用即可。 例子1在js文件顶部引用controller文件夹下blog.js文件内的getList函数时使用的是： 1const &#123; getList &#125; = require(\"../controller/blog\") 其实相当于： 1const getList = require(\"../controller/blog\").getList 之所以需要这样引用应该是输出的原因: 1234//接下来还会有函数需要输出，所以先使用对象的方式进行返回module.exports = &#123; getList&#125; 反观输出时采用module.exports = handleBlogRouter的引用时使用const handleBlogRouter = require(&quot;./src/router/blog&quot;)即可。 例子2在resModel.js中输出： 12345//输出module.exports = &#123; SuccessModel, ErrorModel&#125; 在blog.js中引用resModel.js中的SuccessModel、ErrorModel两个模块： 12//引入resModel.js中的两个模块const &#123; SuccessModel, ErrorModel &#125; = require(\"../model/resModel\") 例子3在blog.js中输出handleBlogRouter： 12/* 不要忘记输出函数 */module.exports = handleBlogRouter 在app.js中引用handleBlogRouter路由组件： 12// 引用路由组件const handleBlogRouter = require(\"./src/router/blog\")","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"简书Header组件开发（styled-components管理样式）","slug":"简书Header组件开发（styled-components管理样式）","date":"2020-01-23T13:44:55.000Z","updated":"2020-02-26T07:33:40.446Z","comments":true,"path":"2020/01/23/简书Header组件开发（styled-components管理样式）/","link":"","permalink":"http://yoursite.com/2020/01/23/简书Header组件开发（styled-components管理样式）/","excerpt":"新建react项目（create-react-app脚手架工具）可以参考：react官网-“get started”-Create React App的例子","text":"新建react项目（create-react-app脚手架工具）可以参考：react官网-“get started”-Create React App的例子 根据文档，安装create-react-app脚手架工具、创建react项目jianshu： 12npm install -g create-react-appcreate-react-app jianshu create-react-app这个脚手架工具会帮我们自动安装react的环境，并构建一个react项目。 运行react项目启动react项目： 12cd jianshunpm start 初始化完毕，弹出http://localhost:3000/： 删除暂时用不到的文件留下他们即可： app.js: 12345678910111213import React, &#123; Component &#125; from 'react'class App extends Component &#123; render()&#123; return ( &lt;div&gt; hi &lt;/div&gt; ); &#125;&#125;export default App; index.js: 123456import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); styled-components管理CSS样式在react项目中，只要我们在index.js中引入一次css，则所有组件中都不需要引入css则可使用样式。（例子在下方“使用index.css的效果”中）这就会造成混乱，所以建议使用第三方模块Styled-Components对样式进行管理。 （不建议）使用index.css的效果index.css中写样式： 123.dell&#123; background-color: red;&#125; index.js中引入index.css: 1import './index.css'; app.js: 123&lt;div className=\"dell\"&gt; hi&lt;/div&gt; 可以看到在index.js中引入的样式在全局组件中都能使用：这就会造成混乱，所以建议使用第三方模块Styled-Components对样式进行管理。 安装styled-components在项目中安装Styled-Components: 1yarn add styled-components 使用styled-components引入样式 将index.css重命名为style.js,此时样式时放在js文件中的。 在index.js中引入style.js。 书写样式 全局布局：使用‘styled-components’的createGlobalStyle来生成一个带样式的标签（组件）。 局部样式：使用“styled-components”的styled来生成带样式的标签（组件）。【例子在下方“设置Header组件的样式（styled局部样式组件）”中】 注意：全局样式组件和局部样式组件的使用有些不同，全局是自闭和标签&lt;xxx /&gt;。而局部可以当作普通组件使用，比如：通过styled.div生成的就是带样式的div组件，使用方法和div一样。** 全局样式(createGlobalStyle)createGlobalStyle官方文档 The injectGlobal API was removed and replaced by createGlobalStyle in styled-components v4.以前使用injectGlobal，但用官方的话来讲，就是这个API 从现在开始废除了，换成 createGlobalStyle （新的API） ，作为一个样式组件出现，按照样式组件思想，以一个标签形式被引入。（也就是说使用createGlobalStyle来生成一个带有样式的标签（组件）） 1.在style.js中，用createGlobalStyle定义全局样式： 12345678import &#123; createGlobalStyle &#125; from 'styled-components'// 样式组件Globalstyleexport const Globalstyle = createGlobalStyle` body&#123; margin: 0; padding: 0 &#125;` 然后引入样式组件Globalstyle即可。 在App.js中导入样式，以样式组件的方式当作标签引入1234567891011121314import React, &#123; Component,Fragment &#125; from 'react';import &#123; Globalstyle &#125; from './style';class App extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;Globalstyle /&gt; &lt;/Fragment&gt; ); &#125;&#125;export default App; Reset.css统一默认样式 做pc项目要在所有浏览器上保证默认样式的统一，我们借助Reset.css。 每个浏览器对元素的默认样式时不同的，为了保证我们的项目在不同浏览器上的效果是一样的，我们需要使用Reset.css。 使用Reset.css后，元素每个浏览器上的默认样式基本保持一致。 流程：百度搜索Reset.css-进入CSS Tools：Resct CSS-复制代码-粘贴到style.js中的全局样式Globalstyle中 style.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123; createGlobalStyle &#125; from 'styled-components'export const Globalstyle = createGlobalStyle` html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline; &#125; /* HTML5 display-role reset for older browsers */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125; body &#123; line-height: 1; &#125; ol, ul &#123; list-style: none; &#125; blockquote, q &#123; quotes: none; &#125; blockquote:before, blockquote:after, q:before, q:after &#123; content: ''; content: none; &#125; table &#123; border-collapse: collapse; border-spacing: 0; &#125;;` 统一成功: 使用styled-components完成Header组件布局（1） 在项目中新建common文件夹-》再新建header文件夹，在文件夹中新建index.js放置Header组件。（注意：自定义组件 首字母大写） 在src目录下的App.js中引入header组件并放到App组件中。 在header文件夹下新建style.js用于存放Header组件的样式。 新建Header组件common-header-index.js放置Header组件： 1234567891011import React, &#123; Component &#125; from 'react'class Header extends Component&#123; render()&#123; return( &lt;div&gt;你好呀&lt;/div&gt; ) &#125;&#125;export default Header; src-App.js引入header组件并放到App组件中： 123456789101112import React, &#123; Component &#125; from 'react'import Header from \"./common/header\"class App extends Component &#123; render() &#123; return ( &lt;Header /&gt; ); &#125;&#125;export default App; 设置Header组件的样式局部样式组件（styled-components的styled） 全局布局：‘styled-components’的createGlobalStyle来生成一个带样式的标签（组件）。 局部样式：“styled-components”的styled来生成带样式的标签（组件）。 注意：全局样式组件和局部样式组件的使用有些不同，全局是自闭和标签&lt;xxx /&gt;。而局部可以当作普通组件使用，比如：通过styled.div生成的就是带样式的div组件，使用方法和div一样。** common-header-style.js存放Header组件的局部样式组件HeaderWrapper（相当于带样式的div组件）（记得输出）: 1234567import styled from \"styled-components\";// 局部样式组件HeaderWrapper（带样式的div组件）export const HeaderWrapper = styled.div` height:56px; background:red;` commmon-header-index.js中直接调用HeaderWrapper组件 123456789101112131415import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper,&#125;from \"./style\";class Header extends Component&#123; render()&#123; return( &lt;HeaderWrapper&gt;你好呀&lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header; 模仿简书官网我们可以到简书官网去看Header中各个元素的宽高，将我们需要的Logo图片保存到src下新建的statics文件夹中： 使用局部样式定义图片组件错误示范将图片放到局部样式组件中进行定义，特别注意：不能在样式属性值中通过url(../../statics/logo)去找图片，因为项目打包的时候样式是作为字符串被识别的，并不会去找这个图片：可以看到到了页面上还向上去找，可是localhost地址向上根本找不到图片。 正确示范 定义带样式的图片组件：先引入图片LogoPic，再在url中通过${LogoPic}使用LogoPic。（相关语法可以参考ES6模板字符串） 注意：这里的图片其实是可以点击的，所以创建的是一个a标签（styled.a） 使用图片组件，显示图片。 注意：设置HeaderWrapper为相对定位，使其脱离文档流，悬浮在页面上。再将其中的子元素设置为绝对定位时（子绝父相），子元素就会相对HeaderWrapper进行定位，方便操作。 common-header-style.js定义带样式的图片组件: 1234567891011121314151617181920import styled from \"styled-components\";import LogoPic from \"../../statics/logo.png\";export const HeaderWrapper = styled.div` position:relative; height:56px; border-bottom:1px solid #f0f0f0;`export const Logo = styled.a` position:absolute; display:block; top:0; left:0; height:56px; width:100px; background:url($&#123;LogoPic&#125;); // contain：把x轴拉满，y轴够长的话会平铺重复显示图片 background-size:contain;` common-header-index.js引入并使用Logo组件 显示图片: 123456789101112131415161718import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper, Logo&#125;from \"./style\";class Header extends Component&#123; render()&#123; return( &lt;HeaderWrapper&gt; &lt;Logo/&gt; &lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header; 图片组件（a标签）的href属性实现功能：点击图片跳转首页。 方法1：写在index.js中，调用组件时&lt;Logo href=&quot;/&quot; /&gt;定义href属性。 方法2：写在style.js中，定义样式时使用styled.a.attrs({href:/})来定义href属性。 方法1：style.js中common-header-style.js： 123456789101112131415161718import React, &#123; Component &#125; from 'react'import &#123; HeaderWrapper, Logo&#125; from \"./style\";class Header extends Component &#123; render() &#123; return ( &lt;HeaderWrapper&gt; &lt;Logo href=\"/\" /&gt; &lt;/HeaderWrapper&gt; ) &#125;&#125;export default Header; 方法2：index.js中common-header-index.js： 12345678910111213141516171819202122import styled from \"styled-components\";import LogoPic from \"../../statics/logo.png\";export const HeaderWrapper = styled.div` position:relative; height:56px; border-bottom:1px solid #f0f0f0;`export const Logo = styled.a.attrs(&#123; href:\"/\"&#125;)` position:absolute; display:block; top:0; left:0; height:56px; width:100px; background:url($&#123;LogoPic&#125;); // contain：把x轴拉满，y轴够长的话会平铺重复显示图片 background-size:contain;`","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"在react-redux中使用connect()与componentDidMount()","slug":"在react-redux中使用connect()与componentDidMount()","date":"2020-01-22T06:04:42.000Z","updated":"2020-02-25T13:50:19.923Z","comments":true,"path":"2020/01/22/在react-redux中使用connect()与componentDidMount()/","link":"","permalink":"http://yoursite.com/2020/01/22/在react-redux中使用connect()与componentDidMount()/","excerpt":"背景描述在TodoList項目中，我原本使用react-redux的connect（）将store的state和dispatch通过两个参数包装在无状态组件TodoListUI上，使其成为聪明的容器组件。但我想使用componentDidMount()发送一个AJAX请求来获取list列表的初始数据，但此时 无状态组件 没有生命周期函数，所以我将 无状态组件 包裹在一个 容器组件TodoList 中，再对TodoList使用connect()连接上store。","text":"背景描述在TodoList項目中，我原本使用react-redux的connect（）将store的state和dispatch通过两个参数包装在无状态组件TodoListUI上，使其成为聪明的容器组件。但我想使用componentDidMount()发送一个AJAX请求来获取list列表的初始数据，但此时 无状态组件 没有生命周期函数，所以我将 无状态组件 包裹在一个 容器组件TodoList 中，再对TodoList使用connect()连接上store。 代码TodoList.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from \"react-redux\";import &#123; getChangeInputValue, getAddItem, getDeleteItem, getTodoList &#125; from \"./store/actionCreator\";// UI组件=&gt;无状态组件const TodoListUI = (props) =&gt; &#123; const &#123; inputValue, list, changeInputValue, handleClick, handleClickDelete &#125; = props; console.log(inputValue, list);//undefined undefined return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;inputValue&#125; onChange=&#123;changeInputValue&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125; onClick=&#123;() =&gt; (handleClickDelete(index))&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; )&#125;class TodoList extends Component &#123; render() &#123; return ( &lt;TodoListUI/&gt; ) &#125; // 生命周期函数 componentDidMount() &#123; this.props.initList(); &#125;&#125;// state指store中的数据，通过mapStateToProps()将state中的数据映射到props中const mapStateToProps = (state) =&gt; &#123; return &#123; // state中的inputValue映射到props的inputValue中 inputValue: state.inputValue, list: state.list &#125;&#125;// 将store的dispatch()传到组件的props中const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const action = getChangeInputValue(e); dispatch(action); &#125;, handleClick() &#123; const action = getAddItem(); dispatch(action); &#125;, handleClickDelete(index) &#123; const action = getDeleteItem(index); dispatch(action); &#125;, initList() &#123; // 将异步AJAX请求放到action中 const action = getTodoList(); // 因为thunk中间件，action可以是一个函数 dispatch(action); &#125; &#125;&#125;// connect让TodoList连接store，如何连接看mapStateToProps(),修改state看mapDispatchToProps()export default connect(mapStateToProps, mapDispatchToProps)(TodoList); 报错报错： 1Cannot read property 'map' of undefine 分析调用map的对象list 打印出来是 undefined，初始化第一次渲染的时候异步数据返回之前list是undefined。也就是说我们此时根本没有从store中获取到list数据 解决我们在无状态组件（子组件）中其实并没有拿到store中的数据，我们可以发现现在直接使用connect包裹的组件是父组件，所以父组件拿到了store中的数据，子组件并没有，所以我们需要在调用子组件的同时将相关数据/方法传过去，这样子组件才能调用我们使用connect的两个参数绑定的store相关的数据/方法。 123456789101112131415161718class TodoList extends Component &#123; render() &#123; const &#123; inputValue, list, changeInputValue, handleClick, handleClickDelete &#125; = this.props; return ( &lt;TodoListUI inputValue=&#123;inputValue&#125; list=&#123;list&#125; changeInputValue=&#123;changeInputValue&#125; handleClick=&#123;handleClick&#125; handleClickDelete=&#123;handleClickDelete&#125; /&gt; ) &#125; // 生命周期函数 componentDidMount() &#123; this.props.initList(); &#125;&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Redux进阶(3)React-Redux的使用","slug":"Redux进阶(3)React-Redux的使用","date":"2020-01-22T05:48:06.000Z","updated":"2020-03-06T14:43:38.508Z","comments":true,"path":"2020/01/22/Redux进阶(3)React-Redux的使用/","link":"","permalink":"http://yoursite.com/2020/01/22/Redux进阶(3)React-Redux的使用/","excerpt":"React-Redux 的使用 redux是数据框架。 React-Redux 是第三方模块，他可以让我们在react中更方便的使用redux。","text":"React-Redux 的使用 redux是数据框架。 React-Redux 是第三方模块，他可以让我们在react中更方便的使用redux。 安装React-Redux首先我们需要将之前的项目删除到只剩下src文件夹下的index.html。然后安装React-Redux ： 1yarn add react-redux （如果还未安装redux则需要先使用yarn add redux安装redux） 新建组件TodoList.js12345678910111213141516171819import React, &#123; Component &#125; from 'react'class TodoList extends Component&#123; render()&#123; return( &lt;div&gt; &lt;div&gt; &lt;input /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;Dell&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125; export default TodoList ; 新建store（使用redux）在react中，我们最好使用store来管理数据，那么我们就需要使用redux的createStore()创建一个store。 新建store文件夹并在其下新建index.js: 12345import &#123; createStore &#125; from \"redux\";const store = createStore();export default store; 新建reducer.js store需要借助 reducer 来处理action以改变state。所以我们需要新建reducer.js并在index.js中引入reducer。 reducer.js是纯函数，返回一个新的state给store，函数的参数1是store的state，参数2是action。 一般我们会定义一个state初始值。 新建reducer.js： 12345678const defaultState = &#123; inputValue: \"\", list: []&#125;export default (state = defaultState, action) =&gt; &#123; return state;&#125; 在index.js中引入reducercreateStore()创建一个store时我们就要引入reducer作为参数。 index.js： 123456import &#123; createStore &#125; from \"redux\";import reducer from \"./reducer\";const store = createStore(reducer);export default store; 在组件中使用store的数据原本的数据使用方法 在组件中引入store并创建constructor构造函数，在构造函数内使用store的getState()获取到store的state并赋值给组件的state。 在需要使用数据的元素上通过调用组件的state来使用store的state中的值。 （在reducer中给store的state一个inputValue的初始值为“你好呀”）12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import store from \"./store\";class TodoList extends Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); &#125; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.state.inputValue&#125; /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;Dell&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList; 使用react-redux之后的数据使用方法 在src的index.js中引入react-redux的 Provider组件和store，通过Provider组件使所有被其包裹的组件有能力与store连接。 在组件中引入react-redux的connect方法，在组件输出时通过connect方法连接store。 connect()的参数1（mapStateToProps()）定义store中的数据state与组件的props之间的映射关系。 在组件中通过this.props.数据名引用store中的数据。 connect()的参数2（回调函数）接收dispatch作为参数，在参数2（mapDispatchToProps()）内定义action并将其传给store。 总结： Provider组件让TodoList有能力连接上store connect()让TodoList连接store 如何连接看 mapStateToProps(),修改state看 mapDispatchToProps() Provider组件react-redux提供一个 Provider组件 ，该组件可以连接store，并且使得被包含在该组件下的所有组件都有能力连接store： 12345678910111213import React from 'react';import ReactDOM from 'react-dom';import TodoList from './TodoList';import &#123; Provider &#125; from \"react-redux\";import store from \"./store\";const App = ( &lt;Provider store=&#123;store&#125;&gt; &lt;TodoList /&gt; &lt;/Provider&gt;)ReactDOM.render(App, document.getElementById('root')); 原本我们在src目录下的index.html中只将TodoList组件渲染在了页面上。现在我们可以引入react-redux的 Provider组件，将其放在App组件(JSX语法)中，将我们所有需要用到store数据的组件都放在Provider组件中。最后页面只渲染App组件即可.【注意：这里渲染用的是App，不是&lt;App /&gt;】 connect方法 Provider组件 只是使得被包含的组件有能力连接store，但怎么连接就要依靠connect方法 connect方法让被 Provider组件 包裹的组件连接上store，从而可以直接使用store中的数据。 connect方法的参数1mapStateToProps（回调函数）：规定组件的props和store之间怎么做连接的规则。 注意：使用了connect方法后，使用this.props.xxx调用store中的数据。 connect方法的参数2mapDispatchToProps（回调函数）：将store的dispatch()传到组件的props中,使props中的函数可以调用dispatch()，所以可以在该函数中调用dispatch将action传给store。然后在reducer中修改state的值。【修改action的操作放在参数2中】 想让xx组件连接上store，则原本导出的是xx组件，现在我们导出的是 connect()生成的组件connect(mapStateToProps,mapDispatchToProps)(xx)。 总结 调用connect(mapStateToProps,mapDispatchToProps)()返回值是Connect组件（请注意大小写的区别）。 connect(mapStateToProps,mapDispatchToProps)(需要连接store的组件名)返回的是组件。 通俗点理解，使用connect可以把state和dispatch绑定到react组件，使得组件可以访问到redux的数据。 connect让TodoList连接store 如何连接看mapStateToProps(),修改state看mapDispatchToProps() 使输入框内实时显示输入的内容TodoList.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from \"react-redux\";class TodoList extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.props.inputValue&#125; onChange=&#123;this.props.changeInputValue&#125; /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;Dell&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;// state指store中的数据，通过mapStateToProps()将state中的数据映射到props中const mapStateToProps = (state) =&gt; &#123; return &#123; // state中的inputValue映射到props的inputValue中 inputValue: state.inputValue &#125;&#125;// 将store的dispatch()传到组件的props中const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e)&#123; const action=&#123; type:\"change_input_value\", value:e.target.value &#125; dispatch(action); &#125; &#125;&#125;// connect让TodoList连接store// 如何连接看mapStateToProps(),修改state看mapDispatchToProps()export default connect(mapStateToProps, mapDispatchToProps)(TodoList); reducer.js: 12345678910111213const defaultState = &#123; inputValue: \"你好呀\", list: []&#125;export default (state = defaultState, action) =&gt; &#123; if (action.type === \"change_input_value\") &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; &#125; return state;&#125; 使用React-redux完成TodoList功能好处：使用connect()连接组件和store后，每次store更新就会带动组件的state更新，页面渲染不需要通过store.subscribe()订阅store了。 点击“确认”增加list中itemTodoList.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from \"react-redux\";class TodoList extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;this.props.inputValue&#125; onChange=&#123;this.props.changeInputValue&#125; /&gt; &lt;button onClick=&#123;this.props.handleClick&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.props.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;// state指store中的数据，通过mapStateToProps()将state中的数据映射到props中const mapStateToProps = (state) =&gt; &#123; return &#123; // state中的inputValue映射到props的inputValue中 inputValue: state.inputValue, list: state.list &#125;&#125;// 将store的dispatch()传到组件的props中const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const action = &#123; type: \"change_input_value\", value: e.target.value &#125; dispatch(action); &#125;, handleClick() &#123; const action = &#123; type: \"add_item\" &#125; dispatch(action); &#125; &#125;&#125;// connect让TodoList连接store，如何连接看mapStateToProps(),修改state看mapDispatchToProps()export default connect(mapStateToProps, mapDispatchToProps)(TodoList); reducer.js: 12345678910111213141516171819const defaultState = &#123; inputValue: \"\", list: []&#125;export default (state = defaultState, action) =&gt; &#123; if (action.type === \"change_input_value\") &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; &#125; if (action.type === \"add_item\") &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list.push(newState.inputValue); newState.inputValue=\"\"; return newState; &#125; return state;&#125; 点击“提交”后页面list中item增加： 优化代码 TodoList是一个UI组件，所以我们可以将它变成一个无状态组件，依次提高性能。 在TodoList.js中我们输出的是经过connect()合成以后的 容器组件（加上参数1、2后 他是有逻辑的）。 所以使用了react-redux以后，我们将逻辑和页面写在了一个TodoList.js中，不像之前那样分为TodoList.js和TodoListUI.js。 优化步骤： TodoList 没有逻辑，他是一个UI组件，所以我们可以将TodoList组件优化为无状态组件。 无状态组件：使用常量const定义一个箭头函数，该函数接收一个参数props（来自父组件的变量、方法），返回原本render函数中的内容 使用了connect()的参数1、2后，store中state的数据都映射在props上，涉及dispatch传递action的函数也都在props上。所以我们可以使用ES6的解构赋值将所有this.props.xxx形式的变量/函数都简化为const {xxx,xxx} = props,接着调用时直接使用 变量/函数名 即可。 在解构赋值中，由于无状态组件接收一个参数props，所以此时this.props变成props。 TodoList.js: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import React from 'react';import &#123; connect &#125; from \"react-redux\";const TodoList = (props) =&gt; &#123; const &#123; inputValue, list, changeInputValue, handleClick &#125; = props; return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;inputValue&#125; onChange=&#123;changeInputValue&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; )&#125;// state指store中的数据，通过mapStateToProps()将state中的数据映射到props中const mapStateToProps = (state) =&gt; &#123; return &#123; // state中的inputValue映射到props的inputValue中 inputValue: state.inputValue, list: state.list &#125;&#125;// 将store的dispatch()传到组件的props中const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const action = &#123; type: \"change_input_value\", value: e.target.value &#125; dispatch(action); &#125;, handleClick() &#123; const action = &#123; type: \"add_item\" &#125; dispatch(action); &#125; &#125;&#125;// connect让TodoList连接store，如何连接看mapStateToProps(),修改state看mapDispatchToProps()export default connect(mapStateToProps, mapDispatchToProps)(TodoList); connect()与componentDidMount()原本，connect 将store的state和dispatch包装在无状态组件TodoList上，使其成为聪明的容器组件。 那么我们想要使用componentDidMount()时： 先将 无状态组件TodoListUI 包装在 容器组件TodoList 中 在该 容器组件 中使用componentDidMount() 最后使用connect包装该 容器组件，形成新的容器组件 注意无状态组件调用store相关的变量/方法 我们原本使用connect直接包裹 无状态组件 ，无状态组件中可以通过props拿到store中的变量/方法。 现在使用 容器组件TodoList 包裹 无状态组件TodoListUI ，那么无状态组件就没办法自己拿到store中的变量/方法。需要容器组件（父组件）在调用子组件（无状态组件TodoListUI）时通过属性的方式将容器组件拿到的store中的变量/方法 传给子组件（无状态组件TodoListUI），子组件才能调用store中的变量/方法。 点击删除功能和mock.js模拟数据接下来补全了actionTypes.js、actionCreator.js、mock-TodoListMock.js，并使用了redux-thunk中间件。 store文件夹-index.js 加入redux-thunk中间件： 1234567891011121314151617import &#123; createStore,applyMiddleware,compose &#125; from \"redux\";import reducer from \"./reducer\";import thunk from 'redux-thunk';// redux-devtools-extension中间件const composeEnhancers = //如果REDUX_DEVTOOLS_EXTENSION_COMPOSE存在就调用它，否则就调用compose函数 window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;//compose要从redux中引入// thunk中间件const enhancer = composeEnhancers( applyMiddleware(thunk),);const store = createStore(reducer,enhancer);export default store; store文件夹-actionTypes.js 规定action的type值为常量，防止书写错误不报错： 1234export const CHANGE_INPUT_VALUE = \"change_input_value\";export const ADD_ITEM = \"add_item\";export const DELETE_ITEM = \"delete_item\";export const INIT_LIST = \"init_list\"; store文件夹-actionCreator.js 统一创建action： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import &#123; CHANGE_INPUT_VALUE, ADD_ITEM, DELETE_ITEM,INIT_LIST &#125; from \"./actionTypes\"import axios from \"axios\";import \"../mock/TodoListMock\";export const getChangeInputValue = (e) =&gt; &#123; return ( &#123; type: CHANGE_INPUT_VALUE, value: e.target.value &#125; )&#125;export const getAddItem = () =&gt; &#123; return ( &#123; type: ADD_ITEM, &#125; )&#125;export const getDeleteItem = (index) =&gt; &#123; return ( &#123; type: DELETE_ITEM, index &#125; )&#125;export const initListAction = (data) =&gt; &#123; return ( &#123; type: INIT_LIST, data &#125; )&#125;export const getTodoList = ()=&gt;&#123; return(dispatch)=&gt;&#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 axios.get(\"/list.json\").then((res) =&gt; &#123; const data = res.data.list; // 通过initListAction()将data转为action对象 const action = initListAction(data); // 将action对象传给store dispatch(action); &#125;).catch(() =&gt; &#123; alert(\"失败\"); &#125;) &#125;&#125; store文件夹-reducer.js 处理action返回newState: 12345678910111213141516171819202122232425262728293031import &#123; CHANGE_INPUT_VALUE, ADD_ITEM, DELETE_ITEM, INIT_LIST &#125; from \"./actionTypes\"const defaultState = &#123; inputValue: \"\", list: []&#125;export default (state = defaultState, action) =&gt; &#123; if (action.type === CHANGE_INPUT_VALUE) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.inputValue = action.value; return newState; &#125; if (action.type === ADD_ITEM) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list.push(newState.inputValue); newState.inputValue = \"\"; return newState; &#125; if (action.type === DELETE_ITEM) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list.splice(action.index, 1); return newState; &#125; if (action.type === INIT_LIST) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list = action.data; return newState; &#125; return state;&#125; mock文件夹-TodoListMock.js 创建随机模拟数据： 123456import Mock from \"mockjs\"//引入Mockexport default Mock.mock(\"/list.json\",&#123; // 随机生成长度为3的数组，数组元素是3-10个字范围内的中文单词 \"list|3\":[\"@cword(3,10)\"]&#125;) TodoLisy.js: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import React, &#123; Component &#125; from 'react';import &#123; connect &#125; from \"react-redux\";import &#123; getChangeInputValue, getAddItem, getDeleteItem, getTodoList &#125; from \"./store/actionCreator\";// UI组件=&gt;无状态组件const TodoListUI = (props) =&gt; &#123; const &#123; inputValue, list, changeInputValue, handleClick, handleClickDelete &#125; = props; // console.log(inputValue, list);//undefined undefined return ( &lt;div&gt; &lt;div&gt; &lt;input value=&#123;inputValue&#125; onChange=&#123;changeInputValue&#125; /&gt; &lt;button onClick=&#123;handleClick&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125; onClick=&#123;() =&gt; (handleClickDelete(index))&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; )&#125;class TodoList extends Component &#123; render() &#123; const &#123; inputValue, list, changeInputValue, handleClick, handleClickDelete &#125; = this.props; return ( &lt;TodoListUI inputValue=&#123;inputValue&#125; list=&#123;list&#125; changeInputValue=&#123;changeInputValue&#125; handleClick=&#123;handleClick&#125; handleClickDelete=&#123;handleClickDelete&#125; /&gt; ) &#125; // 生命周期函数 componentDidMount() &#123; this.props.initList(); &#125;&#125;// state指store中的数据，通过mapStateToProps()将state中的数据映射到props中const mapStateToProps = (state) =&gt; &#123; return &#123; // state中的inputValue映射到props的inputValue中 inputValue: state.inputValue, list: state.list &#125;&#125;// 将store的dispatch()传到组件的props中const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; changeInputValue(e) &#123; const action = getChangeInputValue(e); dispatch(action); &#125;, handleClick() &#123; const action = getAddItem(); dispatch(action); &#125;, handleClickDelete(index) &#123; const action = getDeleteItem(index); dispatch(action); &#125;, initList() &#123; // 将异步AJAX请求放到action中 const action = getTodoList(); // 因为thunk中间件，action可以是一个函数 dispatch(action); &#125; &#125;&#125;// connect让TodoList连接store，如何连接看mapStateToProps(),修改state看mapDispatchToProps()export default connect(mapStateToProps, mapDispatchToProps)(TodoList);","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Redux进阶(2)Redux-thunk与Redux-saga中间件","slug":"Redux进阶(2)Redux-thunk与Redux-saga中间件","date":"2020-01-21T09:04:20.000Z","updated":"2020-02-25T13:49:19.414Z","comments":true,"path":"2020/01/21/Redux进阶(2)Redux-thunk与Redux-saga中间件/","link":"","permalink":"http://yoursite.com/2020/01/21/Redux进阶(2)Redux-thunk与Redux-saga中间件/","excerpt":"使用Redux-thunk中间件实现ajax数据请求 我们之前把异步请求放在TodoList组件的生命周期函数中，当我们放在组件中的逻辑过于复杂的时候就可以使用Redux-thunk将异步请求或者其他比较复杂的逻辑移到action中进行统一管理。 在这里我们先使用中间件，关于“什么是中间件”放到下面进行解释。","text":"使用Redux-thunk中间件实现ajax数据请求 我们之前把异步请求放在TodoList组件的生命周期函数中，当我们放在组件中的逻辑过于复杂的时候就可以使用Redux-thunk将异步请求或者其他比较复杂的逻辑移到action中进行统一管理。 在这里我们先使用中间件，关于“什么是中间件”放到下面进行解释。 流程总结 安装Redux-thunk中间件 在store文件夹下的index.html中创建store时，在参数2中使用Redux-thunk（使用方法参考github中的官方文档） 原本 创建store时 作为 参数2 的 开发者工具REDUX_DEVTOOLS_EXTENSION 我们可以根据github中的官方文档 换个地方放置。 原本写在TodoList.js的生命周期函数中的AJAX请求放到actionCreator.js的一个函数getTodoList返回的匿名函数中，在匿名函数中进行AJAX请求，并通过调用actionCreator.js的函数initListAction返回一个action对象，该匿名函数可以接收到dispatch（），可以将其产生的action对象传给store。（原本actionCreator.js中的函数必须返回的action是一个对象才能被dispatch(action)传递到store中，但通过thunk中间件，action可以是一个函数，当dispatch发现action是函数时就会自动执行该函数） 安装Redux-thunk中间件在github中搜索Redux-thunk可以获取他的安装和使用方法。 1yarn add redux-thunk 在创建store的文件中使用Redux-thunkstore文件夹下的index.html： 引入applyMiddleware,它使我们可以使用Redux-thunk中间件 从&#39;redux-thunk&#39;库中引入thunk 在创建store的createStore()中添加第二个参数applyMiddleware(thunk)来引入thunk中间件。 原本我们的在参数2的位置放了window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__()，其实REDUX_DEVTOOLS_EXTENSION也是一个中间件，现在需要将它换一个地方。 参考github中的官方文档: compose需要从redux中引入。 最终代码： 123456789101112131415161718import &#123; createStore, applyMiddleware, compose &#125; from \"redux\";import thunk from 'redux-thunk';import reducer from \"./reducer\";// redux-devtools-extension中间件const composeEnhancers = //如果REDUX_DEVTOOLS_EXTENSION_COMPOSE存在就调用它，否则就调用compose函数 window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;//compose要从redux中引入// thunk中间件const enhancer = composeEnhancers( applyMiddleware(thunk),);// 创建store,将reducers作为第一个参数传给storeconst store = createStore(reducer, enhancer);export default store; 注意：中间件是redux的，在创建store的时候使用。不是react的！ 通过action返回一个函数(进行AJAX请求)在actionCreators.js中，本来action返回的是一个对象，使用了中间件Redux-thunk后，action可以返回一个函数,在这个函数中可以进行异步操作。 中间件Redux-thunk的作用：本来store.dispatch(action);中action必须是一个 对象 ，它才能被传递给store。使用中间件Redux-thunk后，action可以是一个函数，当调用store.dispatch(action);时，它识别到action是一个函数，便会自动执行该函数。且dispatch()会被传递到函数中，在该函数中也可以使用dispatch()来给store传递数据，在该函数中使用dispatch(action)时，它识别到action是一个对象，便会自动传递给store。 中间件Redux-thunk的好处：把复杂的逻辑（异步操作）放到action中有利于后期自动化测试，比起放在生命周期函数中，放在action中比较方便自动化测试。 TodoList.js: 1234567// 生命周期函数componentDidMount() &#123; // 将异步AJAX请求放到action中 const action = getTodoList(); // 因为thunk中间件，action可以是一个函数 store.dispatch(action);&#125; actionCreator.js: 1234567891011121314export const getTodoList = ()=&gt;&#123; return(dispatch)=&gt;&#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 axios.get(\"/list.json\").then((res) =&gt; &#123; const data = res.data.list; // 通过initListAction()将data转为action对象 const action = initListAction(data); // 将action对象传给store dispatch(action); &#125;).catch(() =&gt; &#123; alert(\"失败\"); &#125;) &#125;&#125; 什么是Redux的中间件 中间件指的是action和store的中间。只有redux才有action和store，所以只有redux才有中间件！（不是react，区分清楚） 总的来说，redux中间件就是对dispatch()做了个升级。 比如：上面介绍的redux-thunk中间件，本来原始的dispatch()只能接收对象类型的action，接收以后直接传递给store。但经过redux-thunk中间件升级后，dispatch()可以接收 函数类型的 action，他会执行该函数。（在函数中就可以进行AJAX请求了） Redux-saga中间件使用入门 之前我们使用redux-thunk解决了异步代码的问题，通过redux-thunk将异步操作放到action函数中，方便了自动化测试和代码的拆分管理。 Redux-saga中间件 也是用于解决异步代码的问题的，完全可以使用Redux-saga中间件 代替 redux-thunk中间件。 目前主流的react项目中有关异步的问题基本都是使用这两个中间件去完成的。 流程总结 安装Redux-saga中间件 在store文件夹下新建sagas.js文件，在index.js中配置Redux-saga中间件 引入’redux-saga’的createSagaMiddleware()用于帮助创造中间件sagaMiddleware 和thunk中间件传入方式一样，通过applyMiddleware()将中间件sagaMiddleware放入enhancer中，再将enhancer传入createStore()作为参数2 引入存储异步操作的文件sagas.js,并通过sagaMiddleware.run()让文件sagas.js运行起来 在sagas.js文件的mySaga()中通过takeEvery()捕获组件中通过dispatch传递的action，捕获到参数1的type类型的action时就执行参数2的回调函数（在该回调函数中随便打印一串字符，运行项目，测试是否可以被捕获成功） sagas.js文件的takeEvery()参数2的回调函数中发起AJAX请求并将获取到的数据通过put()传递给store。注意这里使用yield替代Promise，使用try…catch代替then()/catch(),使用saga自带的put()代替store.dispatch。(sagas.js就在store文件夹中，他没有dispatch方法) 删除redux-thunk中间件的一系列操作在这之前我们使用了redux-thunk中间件，现在我们需要将代码还原到没有使用redux-thunk时的状态。 删除actionCreator.js中的getTodoList函数，将异步操作放回TodoList.js组件的生命周期函数中。记得在store文件夹的index.js中去除redux-thunk的引用。 安装Redux-saga中间件在github中搜索Redux-saga，安装: 1yarn add redux-saga 配置Redux-saga中间件官方案例 新建文件用于存放异步操作(参考官方案例中的sagas.js)在redux-saga中，我们会将异步操作放到一个文件中进行管理。所以我们需要在store文件夹下新建sagas.js： 12345function* mySaga() &#123; &#125;export default mySaga; 在这里我们先不管函数内容，先配置好Redux-saga中间件。 创建store时引入Redux-saga(参考官方案例中的main.js)我们需要在创建store的文件中引入Redux-saga，所以在store文件夹的index.js中： 123456789101112131415161718192021222324252627import &#123; createStore, applyMiddleware, compose &#125; from \"redux\";import reducer from \"./reducer\";// 1.createSagaMiddleware()用于帮助创造中间件import createSagaMiddleware from 'redux-saga'// 5.引入存储异步操作的文件sagas.jsimport todoSagas from \"./sagas\"// 2.创建redux-saga中间件sagaMiddlewareconst sagaMiddleware = createSagaMiddleware()// redux-devtools-extension中间件（开发者工具）const composeEnhancers = //如果REDUX_DEVTOOLS_EXTENSION_COMPOSE存在就调用它，否则就调用compose函数 window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose;//compose要从redux中引入// 3.和thunk中间件传入方式一样，通过applyMiddleware传入作为createStore的参数2const enhancer = composeEnhancers( applyMiddleware(sagaMiddleware),);// 4.创建store,将reducers作为第一个参数传给storeconst store = createStore(reducer, enhancer);// 6.通过sagaMiddleware.run()让文件sagas.js执行起来sagaMiddleware.run(todoSagas);export default store; 配置成功重新运行后不报错说明配置成功： 使用Redux-saga中间件的小案例首先我们需要在组件TodoList.js的生命周期函数中移除AJAX请求的操作，改成一个从actionCreator.js中返回的对象类型的action（这里我们没有使用thunk中间件了，action必须是对象） 1.actionCreator.js中的getInitList()不需要返回value，只需要返回一个action对象: 123export const getInitList = () =&gt; (&#123; type: GET_INIT_LIST&#125;) 2.组件TodoList.js中调用getInitList()将返回的action对象发给store: 12345// 生命周期函数componentDidMount() &#123; const action = getInitList(); store.dispatch(action);&#125; 3.(参考官方案例中的sagas.js)在store文件夹下的sagas.js中设置，当获取到type值为GET_INIT_LIST的action时就执行sagas.js中的getInitList（）（因为中间件所以sagas.js中的mySaga()也能接收到dispatch()传给store的action） 12345678910111213141516import &#123; takeEvery &#125; from 'redux-saga/effects'import &#123; GET_INIT_LIST &#125; from \"./actionTypes\"function* getInitList() &#123; yield console.log(\"abc\");&#125;// 这里的语法涉及ES6的generator函数function* mySaga() &#123; // takeEvery可捕获每次发出的action，并根据type值执行参数2的函数 //参数1为type值，参数2为对应会执行的函数 yield takeEvery(GET_INIT_LIST, getInitList);&#125;export default mySaga; 流程总结：因为在创建store时我们使用了redux-saga中间件，所以组件使用dispatch()将action传递给store时，不仅reducer.js可以接收到这个action，sagas.js中的mySaga()也能接收到这个action,而我们在mySaga()中通过takeEvery()声明：“当获取到type值为GET_INIT_LIST的action时就执行sagas.js中的getInitList（）”，所以最后会打印abc 使用Redux-saga中间件完成AJAX请求sagas.js中的mySaga()也能接收到dispatch()传递的action,并且通过takeEvery()设置 当获取到type值为 参数1 的action时就执行 参数2 的函数。所以我们可以将AJAX请求放在takeEvery()的参数2的回调函数中,AJAX请求获得的数据通过saga的put()传给store。 sagas.js: 12345678910111213141516171819202122232425262728import &#123; takeEvery, put &#125; from 'redux-saga/effects'import &#123; GET_INIT_LIST &#125; from \"./actionTypes\"import axios from \"axios\";import &#123; initListAction &#125; from \"./actionCreator\"function* getInitList() &#123; try &#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 // 在saga中使用yield代替promise，等待axios请求成功就赋值给res const res = yield axios.get(\"/list.json\"); // 通过initListAction()将list转为action对象 const action = initListAction(res.data.list); // 是用saga自带的put()替代store.dispatch(action); yield put(action); &#125; catch (e) &#123; console.log(\"list.json网络请求失败\"); &#125;&#125;// 这里的语法涉及ES6的generator函数function* mySaga() &#123; // takeEvery可捕获每次发出的action，并根据type值执行参数2的函数 //参数1为type值，参数2为对应会执行的函数 yield takeEvery(GET_INIT_LIST, getInitList);&#125;export default mySaga; 需要注意的是： 在saga中发送AJAX请求，使用yield代替promise，yield会等待axios请求成功就赋值给res。 没有了Promise的then()和catch(),在这里我们把错误判断放到try...catch中 在saga文件中并没有store，所以我们需要通过官方文档例子中的put方法将action传给store（替代store.dispatch()） 对比redux-thunk和redux-saga redux-thunk只是允许action为一个函数，我们可以将异步操作放在该函数中。 redux-saga是将异步操作直接分离到sagas.js文件中，当action被dispatch传递时，该sagas.js文件中的一个函数也可拦截action，并通过type值确定要执行sagas.js文件中的某个函数，在这个函数中就可进行异步操作。 redux-saga分离的更加彻底也更加复杂，更适合大型项目，接下来的简书项目会比较偏向使用redux-thunk。 redux-thunk优点： 学习成本低 把复杂的逻辑（异步操作）放到action中有利于后期自动化测试，比起放在生命周期函数中，放在action中比较方便自动化测试。 缺点： 一个异步请求的action代码过于复杂，且异步操作太分散，相对比saga就显得简单多了。 action形式不统一，thunk允许action为一个函数,而原本的action是一个对象。如果不一样的异步操作，就要写多个了。 redux-saga优点 saga将异步操作直接分离到sagas.js文件中,集中处理了所有的异步操作，异步接口部分一目了然(有提供自己的方法) action是普通对象，这跟redux同步的action一模一样({type:XXX}) 通过Effect，方便异步接口的测试 通过worker和watcher可以实现非阻塞异步调用，并且同时可以实现非阻塞调用下的事件监听 不再使用Promise进行异步操作，所以异步操作的流程是可以控制的，可以随时取消相应的异步操作。 缺点：学习成本高。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JSON方法","slug":"JSON方法","date":"2020-01-20T14:14:18.000Z","updated":"2020-11-05T02:22:08.590Z","comments":true,"path":"2020/01/20/JSON方法/","link":"","permalink":"http://yoursite.com/2020/01/20/JSON方法/","excerpt":"parse()将JSON字符串转换为 JS 对象（接受服务器数据）JSON 通常用于与服务端交换数据。在接收服务器数据时一般是JSON字符串（JSON字符串长的很像JS对象）。","text":"parse()将JSON字符串转换为 JS 对象（接受服务器数据）JSON 通常用于与服务端交换数据。在接收服务器数据时一般是JSON字符串（JSON字符串长的很像JS对象）。我们可以使用 JSON.parse() 方法将JSON字符串数据转换为 JavaScript 对象。 语法JSON.parse(text[, reviver])参数：text:必需， 一个有效的 JSON 字符串。（确保你的数据是标准的 JSON 格式，否则会解析出错）reviver: 可选，一个转换结果的函数， 将为对象的每个成员调用此函数。(例子在下面“JSON 不能存储 Date 对象的解决方法”中) 例子例如我们从服务器接收了这样的JSON字符串数据： 1&#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" &#125; 使用 JSON.parse() 方法处理以上数据，将其转换为 JavaScript 对象： 1var obj = JSON.parse('&#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":\"www.runoob.com\" &#125;'); 注意：解析前要确保你的数据是标准的 JSON 格式，否则会解析出错。可以使用在线工具检测：https://c.runoob.com/front-end/53。完整例子 从服务端接收 JSON 数据123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myObj = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myObj.name; &#125;&#125;;xmlhttp.open(\"GET\", \"/try/ajax/json_demo.txt\", true);xmlhttp.send(); 可以使用 AJAX 从服务器请求 JSON 数据，并解析为 JavaScript 对象。完整例子 从服务端接收数组的 JSON 数据123456789var xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange = function() &#123; if (this.readyState == 4 &amp;&amp; this.status == 200) &#123; myArr = JSON.parse(this.responseText); document.getElementById(\"demo\").innerHTML = myArr[1]; &#125;&#125;;xmlhttp.open(\"GET\", \"/try/ajax/json_demo_array.txt\", true);xmlhttp.send(); 完整例子 JSON 不能存储 Date 对象的解决方法JSON 不能存储 Date 对象。如果你需要存储 Date 对象，需要将其转换为字符串,之后再将字符串转换为 Date 对象。 例子（完整例子点击这里）： 12345var text = '&#123; \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"&#125;';var obj = JSON.parse(text);//将其转换为字符串obj.initDate = new Date(obj.initDate);//再将字符串转换为 Date 对象 document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期: \" + obj.initDate;//Runoob创建日期: Sat Dec 14 2013 08:00:00 GMT+0800 (中国标准时间) 可以启用 JSON.parse 的第二个参数 reviver，一个转换结果的函数，对象的每个成员调用此函数： 1234567891011var text = '&#123; \"name\":\"Runoob\", \"initDate\":\"2013-12-14\", \"site\":\"www.runoob.com\"&#125;';//将其转换为字符串var obj = JSON.parse(text, function (key, value) &#123;//每个对象都走一遍，遇到initDate时将字符串值转换为 Date 对象 if (key == \"initDate\") &#123; return new Date(value); &#125; else &#123; return value;&#125;&#125;); document.getElementById(\"demo\").innerHTML = obj.name + \"创建日期：\" + obj.initDate; （完整例子点击这里） JSON解析函数的方法首先，不建议在 JSON 中使用函数。JSON 不允许包含函数！！但你可以将函数作为字符串存储，之后再将字符串转换为函数： 12345var text = '&#123; \"name\":\"Runoob\", \"alexa\":\"function () &#123;return 10000;&#125;\", \"site\":\"www.runoob.com\"&#125;';var obj = JSON.parse(text);obj.alexa = eval(\"(\" + obj.alexa + \")\"); document.getElementById(\"demo\").innerHTML = obj.name + \" Alexa 排名：\" + obj.alexa(); eval() 函数计算 JavaScript 字符串，并把它作为脚本代码来执行。如果参数是一个表达式，eval()函数将执行表达式。如果参数是Javascript语句，eval()将执行 Javascript 语句。完整例子 stringify()将 JS 对象转换为JSON字符串(向服务器发送数据)JSON 通常用于与服务端交换数据。在向服务器发送数据时一般是JSON字符串。我们可以使用JSON.stringify() 方法将 JavaScript 对象转换为JSON字符串。 语法1JSON.stringify(value[, replacer[, space]]) value:必需， 要转换的 JavaScript 值（通常为对象或数组）。 replacer:可选。用于转换结果的函数或数组。如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值。使用返回值而不是原始值。如果此函数返回 undefined，则排除成员。根对象的键是一个空字符串：””。如果 replacer 是一个数组，则仅转换该数组中具有键值的成员。成员的转换顺序与键在数组中的顺序一样。当 value 参数也为数组时，将忽略 replacer 数组。 space:可选，文本添加缩进、空格和换行符，如果 space 是一个数字，则返回值文本在每个级别缩进指定数目的空格，如果 space 大于 10，则文本缩进 10 个空格。space 也可以使用非数字，如：\\t。 JavaScript 对象转换为JSON字符串例如我们向服务器发送以下JS对象数据： 1var obj = &#123; name:\"hlz\", alexa:10000, site:\"www.baidu.com\"&#125;; 使用 JSON.stringify() 方法处理以上JS对象，将其转换为字符串： 1var myJSON = JSON.stringify(obj); myJSON 为JSON字符串。 完整例子: 123var obj = &#123; name:\"hlz\", alexa:10000, site:\"www.baidu.com\"&#125;;var myJSON = JSON.stringify(obj);document.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"hlz\",\"alexa\":10000,\"site\":\"www.baidu.com\"&#125; JavaScript 数组转换为 JSON 字符串也可以将 JavaScript 数组转换为 JSON 字符串,myJSON 为JSON字符串： 123var arr = [ \"Google\", \"Runoob\", \"Taobao\", \"Facebook\" ];var myJSON = JSON.stringify(arr);document.getElementById(\"demo\").innerHTML = myJSON; (完整例子) JSON 不能存储 Date 对象的解决方法JSON 不能存储 Date 对象。可以使用 JSON.stringify() 将所有日期转换为JSON字符串myJSON： 123var obj = &#123; name:\"Runoob\", initDate:new Date(), site:\"www.runoob.com\"&#125;;//obj是一个JS对象var myJSON = JSON.stringify(obj);//将所有日期转换为JSON字符串myJSONdocument.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"Runoob\",\"initDate\":\"2020-01-20T14:04:12.438Z\",\"site\":\"www.runoob.com\"&#125; 之后可以再将JSON字符串myJSON转换为 Date 对象。（完整例子）。 解析函数的方法JSON 不允许包含函数,不建议在 JSON 中使用函数。JSON.stringify() 会删除 JavaScript 对象的函数，包括 key 和 value(完整例子): 1234var obj = &#123; name:\"Runoob\", alexa:function () &#123;return 10000;&#125;, site:\"www.runoob.com\"&#125;;var myJSON = JSON.stringify(obj); document.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"Runoob\",\"site\":\"www.runoob.com\"&#125; 可以在执行 JSON.stringify() 函数前将函数转换为字符串来避免以上问题的发生(完整例子)： 12345var obj = &#123; name:\"Runoob\", alexa:function () &#123;return 10000;&#125;, site:\"www.runoob.com\"&#125;;obj.alexa = obj.alexa.toString();var myJSON = JSON.stringify(obj); document.getElementById(\"demo\").innerHTML = myJSON;//&#123;\"name\":\"Runoob\",\"alexa\":\"function () &#123;return 10000;&#125;\",\"site\":\"www.runoob.com\"&#125;","categories":[{"name":"JSON学习","slug":"JSON学习","permalink":"http://yoursite.com/categories/JSON学习/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"JS Date 对象","slug":"JS_Date对象","date":"2020-01-20T13:38:57.000Z","updated":"2020-03-29T07:27:47.730Z","comments":true,"path":"2020/01/20/JS_Date对象/","link":"","permalink":"http://yoursite.com/2020/01/20/JS_Date对象/","excerpt":"Date 对象Date 对象用于处理日期与时间。创建 Date 对象：new Date()","text":"Date 对象Date 对象用于处理日期与时间。创建 Date 对象：new Date() 以下四种方法同样可以创建 Date 对象： 1234var d = new Date();var d = new Date(milliseconds);var d = new Date(dateString);var d = new Date(year, month, day, hours, minutes, seconds, milliseconds); 可参考 更多实例 方法getTime() 方法getTime() 方法可返回距 1970 年 1 月 1 日之间的毫秒数。 12var d = new Date();var n = d.getTime(); n 输出结果:1568630422651 其他方法 toUTCString() 将Date对象转换为字符串 toUTCString() 方法可根据世界时 (UTC) 把 Date 对象转换为字符串，并返回结果。 语法：dateObject.toUTCString() 返回值:dateObject 的字符串表示，用世界时表示。 例子：使用 toUTCString() 来把今天的日期转换为（根据 UTC）字符串： 123456&lt;script type=\"text/javascript\"&gt;var d = new Date()document.write (d.toUTCString())&lt;/script&gt; 输出： 1Tue, 24 Mar 2020 14:17:49 GMT 获取2017-06-10格式的日期 1-18 函数 formatDate 接受一个Date对象，返回一个格式化后的日期 2-4 为防止报错，如果没有传入参数，就新建一个Date对象作为参数dt 5 getFullYear()getFullYear()获取年份获取年份 6 getMonth()获取月份，由于获取到的是0-11，所以需要+1 7 getDate()获取日期 8-15 由于我们需要格式化的日期是两位数的，所以当month&lt;10的时候我们需要在前面添加0。日期也是同理。 这里涉及到之前讲的字符串拼接，字符串&quot;0&quot;和数字month拼接后相当于强制类型转换，month将成为字符串。 17 通过-连接，将数字拼接字符串 得到 字符串 19 新建一个Date对象dt 20 将dt传入函数formatDate，得到格式化后的日期formatDate 21 打印格式化后的日期formatDate 使用momentjs库 格式化日期 moment.js是一个轻量级的JavaScript时间库，它方便了日常开发中对时间的操作，提高了开发效率。日常开发中，通常会对时间进行下面这几个操作：比如获取时间，设置时间，格式化时间，比较时间等等。 momentjs中文网 安装 momentjs12npm install moment --save # npmyarn add moment # Yarn 引入 momentjs12345678// require 方式（nodejs）var moment = require('moment');// import 方式（react）import moment from 'moment'; // 原生js&lt;script src=\"moment.js\"&gt;&lt;/script&gt; 使用 momentjs 更多方式可查看官网 日期格式化12345moment().format('MMMM Do YYYY, h:mm:ss a'); // 三月 29日 2020, 3:18:12 下午moment().format('dddd'); // 星期日moment().format(\"MMM Do YY\"); // 3月 29日 20moment().format('YYYY [escaped] YYYY'); // 2020 escaped 2020moment().format(); // 2020-03-29T15:18:12+08:00 相对时间12345moment(\"20111031\", \"YYYYMMDD\").fromNow(); // 8 年前moment(\"20120620\", \"YYYYMMDD\").fromNow(); // 8 年前moment().startOf('day').fromNow(); // 15 小时前moment().endOf('day').fromNow(); // 9 小时内moment().startOf('hour').fromNow(); // 18 分钟前 日历时间12345678moment().subtract(10, 'days').calendar(); // 2020/03/19moment().subtract(6, 'days').calendar(); // 上星期一15:18moment().subtract(3, 'days').calendar(); // 上星期四15:18moment().subtract(1, 'days').calendar(); // 昨天15:18moment().calendar(); // 今天15:18moment().add(1, 'days').calendar(); // 明天15:18moment().add(3, 'days').calendar(); // 下星期三15:18moment().add(10, 'days').calendar(); // 2020/04/08 多语言支持1234567891011moment.locale(); // zh-cnmoment().format('LT'); // 15:18moment().format('LTS'); // 15:18:12moment().format('L'); // 2020/03/29moment().format('l'); // 2020/3/29moment().format('LL'); // 2020年3月29日moment().format('ll'); // 2020年3月29日moment().format('LLL'); // 2020年3月29日下午3点18分moment().format('lll'); // 2020年3月29日 15:18moment().format('LLLL'); // 2020年3月29日星期日下午3点18分moment().format('llll'); // 2020年3月29日星期日 15:18","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"react中使用mock.js模拟接口数据","slug":"react中使用mock.js模拟接口数据","date":"2020-01-20T12:16:06.000Z","updated":"2020-11-05T02:38:30.124Z","comments":true,"path":"2020/01/20/react中使用mock.js模拟接口数据/","link":"","permalink":"http://yoursite.com/2020/01/20/react中使用mock.js模拟接口数据/","excerpt":"原本从接口获取到数据的流程（完整例子在笔记“redux进阶（1）”中） 在组件中创建一个生命周期函数componentDidMount()。引用 axios 模块，在componentDidMount函数中借助 axios 模块发送ajax请求，使用axios.get(&quot;接口路径&quot;)来获取某个接口路径下的数据,请求成功后执行then()的回调函数（接收一个参数res表示接收到的数据），请求失败后执行catch()的回调函数 桌面创建list.json文件，并在其中放入一个数组 使用接口地址在Charles中模拟接口数据，使得发送请求到接口路径时调用我们桌面的list.json文件【使用Charles抓取localhost包需要注意更换url：需要使用http://localhost.charlesproxy.com:3000/访问】 then()的回调函数中打印出的res中的内容，可得到 res中的data是我们需要的数组，那么我们可以在ajax请求成功时通过then()获取data数据","text":"原本从接口获取到数据的流程（完整例子在笔记“redux进阶（1）”中） 在组件中创建一个生命周期函数componentDidMount()。引用 axios 模块，在componentDidMount函数中借助 axios 模块发送ajax请求，使用axios.get(&quot;接口路径&quot;)来获取某个接口路径下的数据,请求成功后执行then()的回调函数（接收一个参数res表示接收到的数据），请求失败后执行catch()的回调函数 桌面创建list.json文件，并在其中放入一个数组 使用接口地址在Charles中模拟接口数据，使得发送请求到接口路径时调用我们桌面的list.json文件【使用Charles抓取localhost包需要注意更换url：需要使用http://localhost.charlesproxy.com:3000/访问】 then()的回调函数中打印出的res中的内容，可得到 res中的data是我们需要的数组，那么我们可以在ajax请求成功时通过then()获取data数据 123456789101112// 生命周期函数componentDidMount() &#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 axios.get(\"/list.json\").then((res) =&gt; &#123; const data = res.data; const action=initListAction(data); // console.log(action); store.dispatch(action); &#125;).catch(() =&gt; &#123; alert(\"失败\"); &#125;)&#125; 使用mock.js后的流程 方法1是直接在react项目中使用的，优点是好理解，缺点是真正上线时删除起来比较麻烦。 方法2则是直接模拟了一个后端项目，上线时直接将设置的axios.defaults.baseURL改成真正的后端地址或者删掉即可。 方法1 在组件中创建一个生命周期函数componentDidMount()。引用 axios 模块，在componentDidMount函数中借助 axios 模块发送ajax请求，使用axios.get(&quot;接口路径&quot;)来获取某个接口路径下的数据,请求成功后执行then()的回调函数（接收一个参数res表示接收到的数据），请求失败后执行catch()的回调函数 在 src目录 下创建 mock文件夹 用于存放我们的 mock数据 的js文件，在TodoListMock.js中引入mockjs并写入我们的模拟数据。 在需要发出 AJAX请求 的文件中引入我们写好的mock组件，那么接下来只要正常书写AJAX请求即可，一旦对应的请求发出，Mock就会拦截并返回数据。 在项目中安装mock.js1npm install mockjs 创建mock文件夹在 src目录 下创建 mock文件夹 用于存放我们的 mock数据 的js文件。 写入mock数据TodoListMock.js: 123456import Mock from \"mockjs\"//引入Mockexport default Mock.mock(\"/list.json\",&#123; // 随机生成长度为3的list数组，数组元素是3-10个字范围内的中文单词 \"list|3\":[\"@cword(3,10)\"]&#125;) 引入mock文件模拟数据完成后，我们得在 需要发出AJAX请求的页面中 引入mock文件: 1import \"./mock/TodoListMock\"; 然后修改原代码，现在我们拿到的res.data中就会有list数组了： 123456789101112// 生命周期函数componentDidMount() &#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 axios.get(\"/list.json\").then((res) =&gt; &#123; const data = res.data.list; const action=initListAction(data); // console.log(action); store.dispatch(action); &#125;).catch(() =&gt; &#123; alert(\"失败\"); &#125;)&#125; 方法2 另外创建一个服务器专门用于放置mock文件夹，将模拟接口的数据都放在这个服务器内。 正常的后端服务器是接受到前端的ajax请求后返回处理后的数据，而mock服务器是接受到前端的ajax请求后返回模拟的数据。 假设创建mock服务器时设置的监听端口是8000，假设服务器是用node写的。 在react中发送ajax请求之前，先使用axios插件的baseURL来设置默认URL为mock服务器的地址：axios.defaults.baseURL = &#39;http://localhost:8000&#39;; 同时运行react项目和mock服务器，此时react项目中如果发送/list.json的ajax请求，那么实际上发送的是http://localhost:8000/list.json，那么mock服务器就会拦截到并返回模拟数据。（注意：react项目是3000端口的，不将axios.defaults.baseURL改成8000则不会请求到mock服务器） 总结 比起原本使用的Charles，使用Mock.js不仅可以省去我们书写模拟数据的麻烦，还可以解决Charles抓包中的麻烦。 方法1是直接在react项目中使用的，优点是好理解，缺点是真正上线时删除起来比较麻烦。 方法2则是直接模拟了一个后端项目，上线时直接将设置的axios.defaults.baseURL改成真正的后端地址或者删掉即可。 使用axios与jquery的区别在上一篇笔记中，我的例子是使用jquery发起AJAX请求的，那个时候拿到的数据是 字符串 ，如果想要方便后续操作就需要使用JSON.parse()将其转换为JS对象。但在react中，我们通过axios发起 AJAX请求 拿到的数据直接就是对象，不需要进行转换(后端传JSON对象到前端，通过axios也会直接获取到JS对象，不需额外转换)：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JSON基础","slug":"JSON基础","date":"2020-01-20T11:05:55.000Z","updated":"2020-02-15T12:50:46.586Z","comments":true,"path":"2020/01/20/JSON基础/","link":"","permalink":"http://yoursite.com/2020/01/20/JSON基础/","excerpt":"JSON (用于接收 web 服务端的数据) JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是存储和交换文本信息的语法。","text":"JSON (用于接收 web 服务端的数据) JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation） JSON 是存储和交换文本信息的语法。 JSON 类似 XML，但它比 XML 更小、更快、更易解析。 JSON 独立于语言：JSON 使用 Javascript语法来描述数据对象，但是 JSON 仍然独立于语言和平台。JSON 解析器和 JSON 库支持许多不同的编程语言。 目前非常多的动态（PHP，JSP，.NET）编程语言都支持JSON。 JSON 文件的文件类型是 “.json”。JSON 文本的 MIME 类型是 “application/json”。(http返回的请求中设置返回格式为json就实用了&quot;Content-type&quot;:&quot;application/json&quot;) JSON 与 XML 的异同JSON 和 XML 都用于接收 web 服务端的数据。 JSON 与 XML 的相同之处： JSON 和 XML 数据具有“自我描述性”，易于理解（人类可读） JSON 和 XML 数据具有层级结构（值中存在值） JSON 和 XML 数据可通过 JavaScript 进行解析，可以被大多数编程语言使用 JSON 和 XML 数据数据可使用 AJAX 进行传输 JSON 相比 XML 的不同之处： JSON 不需要结束标签 JSON 更短 JSON 读写的速度更快 JSON 能够使用内建的 JavaScript eval()方法进行解析 JSON 可以使用数组 JSON 不使用保留字 最大的不同：XML 需要使用 XML 解析器来解析，JSON 可以使用标准的 JavaScript 函数来解析：JSON.parse(): 将一个 JSON 字符串转换为 JavaScript 对象。JSON.stringify(): 于将 JavaScript 值转换为 JSON 字符串。 为什么使用 JSONXML 比 JSON 更难解析。JSON 可以直接使用现有的 JavaScript 对象解析。对于 AJAX 应用程序来说，JSON 比 XML 更快更易使用： 使用 XML 需要: 读取 XML 文档 使用 XML DOM 来循环遍历文档 读取值并存储在变量中 使用 JSON： 读取 JSON 字符串 JSON.Parse() 解析 JSON 字符串 JSON 语法JSON 语法是 JavaScript 语法的子集。JSON 属性必须加双引号,值不可以是 方法函数、undefined以及NAN 数据在名称/值对中 数据由逗号分隔 花括号保存对象 方括号保存数组 JSON 书写格式 JSON 数据的书写格式是：名称/值对，也就是 &quot;名称&quot;:值 注意JSON对象需要使用花括号比如：{&quot;name&quot; : &quot;我就是你想放进去的值呀&quot;}等价于这条 JavaScript 语句：name = &quot;我就是你想放进去的值呀&quot; JSON 值JSON 值可以是（注意JSON对象需要使用花括号）：数字（整数或浮点数）:{&quot;age&quot;:233}字符串（在双引号中）:&#39;{&quot;name&quot;:&quot;aaaaaa&quot;}&#39;【注意：由于属性必须使用双引号，所以字符串只能使用单引号】逻辑值（true 或 false）:{&quot;flag&quot;:true}数组（在中括号中）:例子在下面对象（在大括号中）:例子在下面null:{&quot;name&quot;:null} JSON 对象语法JSON 对象放在大括号{}中。对象可以包含多个 key/value（键/值）对，key 和 value 中使用冒号:分割。key 必须是字符串，value 可以是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。多个 key/value对 之间使用逗号,分割。 例子： 1234&#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125; 与之等价的 JavaScript 语句： 12name = \"菜鸟教程\"url = \"www.runoob.com\" 访问对象值(.或[])可以使用点号.来访问对象的值： 123var myObj, x;myObj = &#123; \"name\":\"hlz\", \"alexa\":10000, \"site\":null &#125;;x = myObj.name;//hlz 也可以使用中括号[]来访问对象的值(记住带上双引号)： 123var myObj, x;myObj = &#123; \"name\":\"hlz\", \"alexa\":10000, \"site\":null &#125;;x = myObj[\"name\"];//hlz 循环对象的属性与值( for-in )注意：在 for-in 循环对象的属性时，不能使用.来访问属性的值（循环不到）！需要使用中括号[]来访问属性的值。 使用 for-in 来循环对象的属性： 123456&lt;script&gt; var myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;; for (x in myObj) &#123; document.getElementById(\"demo\").innerHTML += x + \"&lt;br&gt;\";//name alexa site &#125;&lt;/script&gt; 在 for-in 循环对象的属性时，使用中括号[]来访问属性的值(注意不能使用.来访问属性的值)： 123456&lt;script&gt; var myObj = &#123; \"name\":\"runoob\", \"alexa\":10000, \"site\":null &#125;; for (x in myObj) &#123; document.getElementById(\"demo\").innerHTML += myObj[x] + \"&lt;br&gt;\";//runoob 10000 null &#125;&lt;/script&gt; 嵌套 JSON 对象JSON 对象中可以包含另外一个 JSON 对象： 123456789myObj = &#123; \"name\":\"hlz\", \"alexa\":10000, \"sites\": &#123; \"site1\":\"www.baidu.com\", \"site2\":\"m.baidu.com\", \"site3\":\"c.baidu.com\" &#125;&#125; 可以使用点号.或者中括号[]来访问嵌套的 JSON 对象: 1234x = myObj.sites.site1;//www.baidu.comx = myObj.sites[\"site1\"];//www.baidu.comx = myObj[\"sites\"][\"site1\"];//www.baidu.comx = myObj[\"sites\"].site1;//www.baidu.com 实际运行起来的例子 修改对象的值(.或[])使用点号.来修改 JSON 对象的值,比如修改myObj对象中的sites对象的site1属性值：myObj.sites.site1 = &quot;www.google.com&quot;;(例子)可以使用中括号[]来修改 JSON 对象的值：myObj.sites[&quot;site1&quot;] = &quot;www.google.com&quot;;(例子)(至于访问嵌套对象的值的多种方法可以看上面“嵌套 JSON 对象”) 删除对象属性(delete 关键字)可以使用 delete 关键字来删除 JSON 对象的属性。比如删除myObj对象中的sites对象的site1属性值（不同的调用属性值方法都是可以的）：delete myObj.sites.site1;(例子)或者delete myObj.sites[&quot;site1&quot;](例子) JSON 数组语法JSON 数组放在中括号中，数组值（数组元素）必须是合法的 JSON 数据类型（字符串, 数字, 对象, 数组, 布尔值或 null）。数组元素之间使用逗号分隔。(JSON文件中可以只放数组) JavaScript 中，数组值可以是以上的 JSON 数据类型，也可以是 JavaScript 的表达式，包括函数，日期，及 undefined。 例子：JSON文件中可以只放数组： 1[ \"Google\", \"Runoob\", \"Taobao\" ] JSON对象属性的值可以是一个数组： 12345&#123;\"name\":\"网站\",\"num\":3,\"sites\":[ \"Google\", \"Runoob\", \"Taobao\" ]&#125; 可以使用索引值来访问数组(完整例子)： 1x = myObj.sites[0];//Google 数组元素为对象的数组例子：JSON 数组放在中括号中，数组可包含多个对象,数据由逗号分隔： 1234567&#123; \"sites\": [ &#123; \"name\":\"菜鸟教程\" , \"url\":\"www.runoob.com\" &#125;, &#123; \"name\":\"google\" , \"url\":\"www.google.com\" &#125;, &#123; \"name\":\"微博\" , \"url\":\"www.weibo.com\" &#125; ]&#125; 在上面的例子中，对象 “sites”是包含三个对象的数组,每个对象代表一条关于某个网站（name、url）的记录。 循环数组（for-in或for 循环）可以使用 for-in 来访问数组(例子)： 123for (i in myObj.sites) &#123; x += myObj.sites[i] + \"&lt;br&gt;\";&#125; 也可以使用 for 循环(例子)： 123for (i = 0; i &lt; myObj.sites.length; i++) &#123; x += myObj.sites[i] + \"&lt;br&gt;\";&#125; 嵌套 JSON 对象中的数组JSON 对象中数组可以包含另外一个数组，或者另外一个 JSON 对象,但是记住了：JSON值可以是任意符合要求的（可以是另外一个数组/对象），但是JSON名称必须是字符串！ 例子： 123456789myObj = &#123; \"name\":\"网站\", \"num\":3, \"sites\": [ &#123; \"name\":\"Google\", \"info\":[ \"Android\", \"Google 搜索\", \"Google 翻译\" ] &#125;, &#123; \"name\":\"Runoob\", \"info\":[ \"菜鸟教程\", \"菜鸟工具\", \"菜鸟微信\" ] &#125;, &#123; \"name\":\"Taobao\", \"info\":[ \"淘宝\", \"网购\" ] &#125; ]&#125; 可以使用 for-in 来循环访问每个数组： 123456for (i in myObj.sites) &#123; x += \"&lt;h1&gt;\" + myObj.sites[i].name + \"&lt;/h1&gt;\"; for (j in myObj.sites[i].info) &#123; x += myObj.sites[i].info[j] + \"&lt;br&gt;\"; &#125;&#125; 完整例子 修改数组值可以使用索引值来修改数组值(完整例子)： 1myObj.sites[1] = \"Github\"; 删除数组元素可以使用 delete 关键字来删除数组元素(完整例子)： 1delete myObj.sites[1]; JSON 使用 JavaScript 语法JSON 文本格式在语法上与创建 JavaScript 对象的代码相同。由于这种相似性，无需解析器，JavaScript 程序能够使用内建的 eval() 函数，用 JSON 数据来生成原生的 JavaScript 对象。但使用 JSON 解析器将 JSON 转换为 JavaScript 对象是更安全的做法。在下面的章节，将学会如何把 JSON 文本转换为 JavaScript 对象。","categories":[{"name":"JSON学习","slug":"JSON学习","permalink":"http://yoursite.com/categories/JSON学习/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"http://yoursite.com/tags/JSON/"}]},{"title":"Mock.js的使用方法","slug":"Mock.js的使用方法","date":"2020-01-19T09:04:20.000Z","updated":"2020-02-25T13:51:14.926Z","comments":true,"path":"2020/01/19/Mock.js的使用方法/","link":"","permalink":"http://yoursite.com/2020/01/19/Mock.js的使用方法/","excerpt":"Mock.js 作用：生成随机数据，拦截 Ajax 请求 （并返回数据） 当后端还没开发好某个接口时，前端可以借助 Mock.js 拦截 Ajax 请求 并返回设置好的随机数据。当后端接口开发完成后，只需要改变 Ajax 请求 的接口路径即可。 我们写AJAX请求的时候，正常写，Mock.js会自动拦截的。 官方网站","text":"Mock.js 作用：生成随机数据，拦截 Ajax 请求 （并返回数据） 当后端还没开发好某个接口时，前端可以借助 Mock.js 拦截 Ajax 请求 并返回设置好的随机数据。当后端接口开发完成后，只需要改变 Ajax 请求 的接口路径即可。 我们写AJAX请求的时候，正常写，Mock.js会自动拦截的。 官方网站 安装Mock.js 可以参考官方文档 在html中可以通过BootCDN复制 &lt;script&gt;链接 ，直接进行引用。 语法规范具体可参考官方文档，我只记录使用到的部分。 数据模板定义规范数据模板中的每个属性由 3 部分构成：属性名、生成规则、属性值： 1234// 属性名 name// 生成规则 rule// 属性值 value'name|rule': value 属性名 和 生成规则 之间用竖线 | 分隔。 生成规则 是可选的。 生成规则 有 7 种格式： &#39;name|min-max&#39;: value &#39;name|count&#39;: value &#39;name|min-max.dmin-dmax&#39;: value &#39;name|min-max.dcount&#39;: value &#39;name|count.dmin-dmax&#39;: value &#39;name|count.dcount&#39;: value &#39;name|+step&#39;: value 生成规则 的 含义 需要依赖 属性值的类型 才能确定。(具体的含义可以回到官方文档中进行查看) 属性值 中可以含有 @占位符。 属性值 还指定了最终值的初始值和类型。 数据占位符定义规范占位符 只是在属性值字符串中占个位置，并不出现在最终的属性值中。 占位符 的格式为： 12@占位符@占位符(参数 [, 参数]) 用 @ 来标识其后的字符串是 占位符。 占位符 引用的是 Mock.Random 中的方法。 通过 Mock.Random.extend() 来扩展自定义占位符。 占位符 也可以引用 数据模板 中的属性。 占位符 会优先引用 数据模板 中的属性。 占位符 支持 相对路径 和 绝对路径。 1234567891011121314151617Mock.mock(&#123; name: &#123; first: '@FIRST', middle: '@FIRST', last: '@LAST', full: '@first @middle @last' &#125;&#125;)// =&gt;&#123; \"name\": &#123; \"first\": \"Charles\", \"middle\": \"Brenda\", \"last\": \"Lopez\", \"full\": \"Charles Brenda Lopez\" &#125;&#125; Mock.Random 具体可参考官方文档 Mock.Random 是一个工具类，用于生成各种随机数据。 Mock.Random 的方法在数据模板中称为『占位符』，书写格式为 @占位符(参数 [, 参数])。 注意：Mock.Random的方法 直接使用表示的是 JS变量 ，想要将其放入 属性值 中表示一个字符串则需要加上占位符 Mock.Random的方法（占位符） 各个方法（占位符）的具体含义可参考官方文档 注意： Mock.Random的方法表示的是一个JS变量，想要将其放在属性值中则需要加上占位符@将其转换为字符串。（例子在下面） Type Method Basic boolean, natural, integer, float, character, string, range, date, time, datetime, now Image image, dataImage Color color Text paragraph, sentence, word, title, cparagraph, csentence, cword, ctitle Name first, last, name, cfirst, clast, cname Web url, domain, email, ip, tld Address area, region Helper capitalize, upper, lower, pick, shuffle Miscellaneous guid, id 方法表示JS变量，加占位符表字符串Random.cname()随机生成一个常见的中文姓名： 12Random.cname()// =&gt; \"袁军\" 但是Mock.Random.cname()表示的是一个JS变量，如果你想要用到属性值中，则需要加上一个占位符@使其表示一个字符串（@cname）。 Mock.mock() Mock.mock( template ):根据 数据模板template 生成 模拟数据。 Mock.mock( rurl, template ):记录数据模板。当拦截到匹配 rurl 的 Ajax 请求时，将根据数据模板 template 生成模拟数据，并作为响应数据返回。 rurl(可选)表示需要拦截的 URL，可以是 URL 字符串或 URL 正则。例如 /\\/domain\\/list\\.json/、&#39;/domian/list.json&#39;。 template(可选)表示数据模板，可以是对象或字符串。例如 { &#39;data|1-10&#39;:[{}] }、&#39;@EMAIL&#39;。 更多使用方法可参考官方文档 例子通过BootCDN引入mock.jsBootCDN: 生成一个随机对象1234567891011&lt;body&gt; &lt;script src=\"https://cdn.bootcss.com/Mock.js/1.0.1-beta3/mock-min.js\"&gt;&lt;/script&gt; &lt;script&gt; var data = Mock.mock(&#123; \"id\": \"@id\", \"name\": \"@cname\", \"age\": \"@integer(20,30)\" &#125;) console.log(data); &lt;/script&gt;&lt;/body&gt; 可以看到刷新页面之后得到的数据是不同的： 生成一个随机对象组成的数组但是只得到一个随机对象还不够方便，我们可以借助数据模板定义规范中“属性值是数组 Array”时的 规则(&#39;name|count&#39;: array:通过重复属性值 array 生成一个新数组，重复次数为 count)来构成一个随机对象组成的数组： 123456789101112131415&lt;body&gt; &lt;script src=\"https://cdn.bootcss.com/Mock.js/1.0.1-beta3/mock-min.js\"&gt;&lt;/script&gt; &lt;script&gt; var data = Mock.mock(&#123; \"userList|20\": [ &#123; \"id\": \"@id\", \"name\": \"@cname\", \"age\": \"@integer(20,30)\" &#125; ] &#125;) console.log(data); &lt;/script&gt;&lt;/body&gt; 可以看到刷新页面之后得到的数据是20个随机对象组成的数组的： @id是随机生成的18位身份证号码，我们可以让属性id从1开始递增： 1\"id|+1\": 1, 拦截AJAX请求，返回mock数据在这之前我们已经明白如何生成mock数据了，那么我们接下来我们可以使用jquery来发送一个AJAX请求，首先到BootCDN中引入jquery。 123456789101112131415161718192021&lt;body&gt; &lt;script src=\"https://cdn.bootcss.com/Mock.js/1.0.1-beta3/mock-min.js\"&gt;&lt;/script&gt; &lt;script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js\"&gt;&lt;/script&gt; &lt;script&gt; //如果拦截到\"/userList\"的请求，就返回对应的mock数据 Mock.mock(\"/userList\", &#123; \"userList|20\": [ &#123; \"id|+1\": 1, \"name\": \"@cname\", \"age\": \"@integer(20,30)\" &#125; ] &#125;) //发送AJAX请求，获取\"/userList\"下的数据 $.get(\"/userList\", data =&gt; &#123; //直接拿到的data是字符串，我们需要将其转换为JS对象 console.log(JSON.parse(data)); &#125;) &lt;/script&gt;&lt;/body&gt; 直接拿到的mock数据是字符串，为了方便后续操作，需要通过JSON.parse()将其转换为 JS对象。原因：上面这个例子，如果我们想循环这个数组，得到数组中的某一项放在页面上，此时我们就需要对数组进行操作，如果我们拿到的数据是 字符串 ，那就很麻烦了。 项目中实际运用在项目中新建一个mock文件夹，在该文件夹下放专属的js文件用于 规定拦截到某个AJAX请求时传回相应的模拟数据。在需要用到这个接口下的数据的文件中，引入mock.js（通过BootCDN查找引入链接），再引入这个mock文件夹下的js文件，即可发出AJAX请求。 在react中使用mock.js注意：但在react中，我们通过axios发起 AJAX请求 拿到的数据直接就是对象，不需要进行转换： 使用流程： 在项目中安装mock.js：yarn add mockjs 在 src目录 下创建 mock文件夹 用于存放我们的 定义mock数据 的js文件，在TodoListMock.js中引入mockjs并写入我们的模拟数据。 import Mock from &quot;mockjs&quot;//引入Mock export default//记得输出mock组件 在需要发出 AJAX请求 的文件中引入我们写好的mock组件，那么接下来只要正常书写AJAX请求（通过axios）即可，一旦对应的请求发出，Mock就会拦截并返回数据。 import &quot;./mock/TodoListMock&quot;;//引入自定义的mock组件 正常发出 AJAX请求","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"开发博客项目之接口(2)","slug":"开发博客项目之接口(2)","date":"2020-01-18T14:00:10.000Z","updated":"2020-03-01T07:23:07.502Z","comments":true,"path":"2020/01/18/开发博客项目之接口(2)/","link":"","permalink":"http://yoursite.com/2020/01/18/开发博客项目之接口(2)/","excerpt":"4-5 搭建开发环境 从0开始搭建，不使用任何框架 使用nodemon监测文件变化，自动重启node（不需要像之前那样使用node xxx.js来手动重启node） 使用cross-env设置环境变量，兼容mac linux和windows","text":"4-5 搭建开发环境 从0开始搭建，不使用任何框架 使用nodemon监测文件变化，自动重启node（不需要像之前那样使用node xxx.js来手动重启node） 使用cross-env设置环境变量，兼容mac linux和windows 开始搭建根据上一篇笔记的“模块化规范”初始npm环境，并在package.json文件中继续以下步骤： nodemon安装nodemon：npm install nodemon --save或者npm i nodemon -D启动nodemon:nodemon app.js(用nodemon替换node去启动项目的入口文件将项目改变成自动重启服务器)当你看到每次保存以后终端都自动更新，说明自启动成功：后续启动项目：（package.json中的配置写在了下面）npm run dev cross-env安装cross-env：npm install cross-env --save-dev或者npm i cross-env -D 手动补齐package.json： 123456789101112131415161718&#123; \"name\": \"blog-1\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"bin/www.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"cross-env NODE_ENV=dev nodemon ./bin/www.js\", \"prd\": \"cross-env NODE_ENV=production nodemon ./bin/www.js\" &#125;, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\", \"devDependencies\": &#123; \"cross-env\": \"^6.0.3\", \"nodemon\": \"^2.0.2\" &#125;&#125; 在node中，process对象是全局变量，它提供当前node.js的有关信息，以及控制当前node.js的有关进程。因为是全局变量，它对于node应用程序是始终可用的，无需require()。 env是process的一个属性，这个属性返回包含用户环境信息的对象。在终端输入node后，在输入process.env可以看到打印出来的信息。 NODE_ENV不是process.env对象上原有的属性，它是我们自己添加上去的一个环境变量，用来确定当前所处的开发阶段。 一般 生产阶段 设为production，开发阶段 设为develop（在package.json中设置），然后在 脚本 中读取process.env.NODE_ENV即可知道现在是开发阶段还是生产阶段。 app.js: 123456789101112131415161718const serverHandle = (req, res) =&gt; &#123; //设置返回格式 JSON res.setHeader(\"Content-type\", \"application/json\") const resData = &#123; name: \"Hlz\", site: \"imooc\", //这里还是开发阶段, //所以NODE_ENV读到的是我们`package.json`中设置好的dev env: process.env.NODE_ENV &#125; res.end( JSON.stringify(resData) )&#125;module.exports = serverHandle ./bin/www.js: 1234567const http = require(\"http\")const PORT = 8000const serverHandle = require(\"../app\")const server = http.createServer(serverHandle)server.listen(PORT) 千万不要忘记终端执行npm run dev！！ 测试 4-6 初始化路由 开发接口初始化路由：根据之前技术方案的设计，做出路由返回假数据：将路由和数据处理分离，以符合设计原则 注意： 路由组件（函数）写好后需要通过module. exports输出出去，然后再在需要调用的js文件顶部通过require调用后才能使用。(app.js中的serverHandle不是路由组件，但是注意，函数都需要输出！不输出www.js中就用不了) 千万不要忘记在终端执行npm run dev！！(否则就不会去监听8000端口) 设置接口路径时前面前往不要忘记api前面的/! 思路我们先不管接口内容，去把各个接口跑通。blog.js和user.js中存放的是路由组件。app.js用来设置系统比较基础的功能（处理blog、user路由）或者参数（获取path、解析query）还有返回类型（JSON），还是不涉及业务逻辑的处理。在blog.js和user.js中通过判断以后返回的是对象，所以在app.js中得到的blogData也是一个对象，但res.end返回的需要是字符串，所以需要通过JSON.stringify（）来转换一下，此时注意需要return来结束。 复习：处理HTTP请求简单示例为了帮助理解下面被拆分的代码，我们需要先复习一下一个简单的示例。 调用 node的&#39;http&#39;模块 使用&#39;http&#39;模块的createServer()来创建一个server服务端 createServer()接收一个函数作为参数，该函数接收2个参数，分别是 浏览器向server服务端发送的请求req和 服务端返回给浏览器的响应res。 其中res.end()中需要返回字符串,该字符串会显示在页面上。 让server服务端监听8000端口，好让浏览器访问http://localhost:8000/时可以访问到服务端。 在下面的代码中，这一部分的“开启 Server,监听8000端口”写在www.js中，createServer()的回调函数（参数）被写在app.js中。 代码 www.js开启 Server,监听8000端口: 123456789const http = require(\"http\")const PORT = 8000const serverHandle = require(\"../app\")//通过createServer()调用app.js中的serverHandle，创建服务器serverconst server = http.createServer(serverHandle)//启动监听服务，监听8000端口server.listen(PORT) app.js处理逻辑: 1234567891011121314151617181920212223242526272829303132333435363738394041// 引用路由组件const handleBlogRouter = require(\"./src/router/blog\")const handleUserRouter = require(\"./src/router/user\")// serverHandle接收2个参数：浏览器的请求req，服务端的响应resconst serverHandle = (req, res) =&gt; &#123; //设置返回格式 JSON res.setHeader(\"Content-type\", \"application/json\") //处理blog路由，blogData是通过调用函数handleBlogRouter得到的对象 //将req和res传过去 const blogData = handleBlogRouter(req, res) if (blogData) &#123; res.end( //记住end是一句字符串，故必须把对象转换为字符串 JSON.stringify(blogData) ) //记住要使用return来结束 return &#125; //处理user路由(当路由命中handleUserRouter时) const userData = handleUserRouter(req, res) if (userData) &#123; res.end( //记住end是一句字符串，故必须把对象转换为字符串 JSON.stringify(userData) ) //记住要使用return来结束 return &#125; //未命中路由，返回404（这个了解即可，使用不多） res.writeHead(404, &#123; \"Content-type\": \"text/plain\" &#125;) res.write(\"404 Not Found\\n\") res.end()&#125;//函数也需要输出module.exports = serverHandle//process.env.NODE_ENV blog.js5个路由接口: 123456789101112131415161718192021222324252627282930313233343536373839404142434445//接收 浏览器的请求req，服务端的响应resconst handleBlogRouter = (req, res) =&gt; &#123; const method = req.method//GET POST const url = req.url const path = url.split(\"?\")[0] //获取博客列表,api前面千万不要漏掉 / !!! if (method === \"GET\" &amp;&amp; path === \"/api/blog/list\") &#123; return &#123; msg: \"这是获取博客列表的接口\" &#125; &#125; //获取博客详情 if (method === \"GET\" &amp;&amp; path === \"/api/blog/detail\") &#123; return &#123; msg: \"这是获取博客详情的接口\" &#125; &#125; //新建一篇博客 if (method === \"POST\" &amp;&amp; path === \"/api/blog/new\") &#123; return &#123; msg: \"这是新建一篇博客的接口\" &#125; &#125; //更新一篇博客 if (method === \"POST\" &amp;&amp; path === \"/api/blog/update\") &#123; return &#123; msg: \"这是更新一篇博客的接口\" &#125; &#125; //删除一篇博客 if (method === \"POST\" &amp;&amp; path === \"/api/blog/del\") &#123; return &#123; msg: \"这是删除一篇博客的接口\" &#125; &#125;&#125;/* 不要忘记输出函数 */module.exports = handleBlogRouter user.js一个登录接口： 12345678910111213const handleUserRouter = (req, res) =&gt; &#123; const method = req.method//GET POST const url = req.url const path = url.split(\"?\")[0] //登录 if (method === \"POST\" &amp;&amp; path === \"/api/user/login\") &#123; return &#123; msg: \"这是登陆的接口\" &#125; &#125;&#125;module.exports = handleUserRouter 测试结果直接输入http://localhost:8000/,未命中设定好的任何一个路由，触发设定好的404： 输入http://localhost:8000/api/blog/list?author=hlz&amp;keyword=hahaha,命中其中一个接口： 打开postman测试post请求，如下图所示：再测试一个user的登录接口： 简化把两个路由blog.js和user.js中都用得到的path参数放到app.js中一次性获取。（因为req和res都会传给路由组件，所以可以在app.js中获取path参数以后挂载在req/res上传给用的到的路由组件） 原始代码：简化后： 补充：constructor构造方法constructor 是一种用于创建和初始化class创建的对象的特殊方法。在一个构造方法中可以使用super关键字来调用一个父类的构造方法。MDN中关于constructor构造方法的解释和例子 补充：JSON.parse()JSON.parse() 方法用于将一个 JSON 字符串转换为对象。可参考笔记“JSON方法” 4-7 开发路由（博客列表路由）resModel.js建数据模型在src下新建model文件夹，在该文件夹下新建resModel.js文件，在该文件新建一个基类BaseModel。通过基类BaseModel 建两个模型SuccessModel和ErrorModel，希望通过这两个模型实现返回格式的统一。 resModel.js代码解析： 4 BaseModel中，constructor()传入的data是一个对象类型，message是一个字符串类型的消息。 6-13 兼容，使得constructor()可以只传一个字符串，也可以传一个对象和一个字符串。 假设传入的第一个参数data是字符串类型且没有传入第二个参数message，为使其兼容则需将参数data赋给BaseModel的message，且data和message都不要了。 注意：this.message才是BaseModel的message。data和message都只是传入的参数。(不清楚可以看MDN中的例子) 14-19 如果传入constructor()的是data对象，那就赋值给BaseModel的data(this.data)。message同理。 23 我们需要设立两个模型SuccessModel和ErrorModel（他们继承BaseModel），用于app.js中 的res.end。 26 使用super继承父类BaseModel的data和message。super相当于执行了BaseModel的constructor,统一将data和message传过去放在父类BaseModel中处理 最后记得输出两个模块（SuccessModel和ErrorModel）。 注意：BaseModel中的this指向使用SuccessModel/ErrorModel的对象 比如：router-blog.js-handleBlogRouter()里new了一个SuccessModel，那么this就指向在app.js中调用了handleBlogRouter()的，对象blogData。所以对象blogData中就会有SuccessModel中的data、message、errno。 接下来就可以通过new SuccessModel()或new ErrorModel()来new一个对象了。(数据等就可以通过参数传入)（可参考MDN理解） resModel.js: 1234567891011121314151617181920212223242526272829303132333435363738394041class BaseModel &#123; //constructor 是一种用于创建和初始化class创建的对象的特殊方法。 //要求传入的data为对象，message为字符串 constructor(data, message) &#123; //兼容，如果只传入了 字符串date，没有传入message if (typeof data === \"string\") &#123; // 则将传入的date赋值给BaseModel的message，并清空data、message this.message = data //注意，this.message才是BaseModel的message //data和message都只是传入的参数 data = null message = null &#125; if (data) &#123; this.data = data &#125; if (message) &#123; this.message = message &#125; &#125;&#125;class SuccessModel extends BaseModel &#123; constructor(data, message) &#123; //super相当于执行了BaseModel的constructor,统一将data和message传过去放在父类BaseModel中处理 super(data, message) this.errno = 0 &#125;&#125;class ErrorModel extends BaseModel &#123; constructor(data, message) &#123; super(data, message) this.errno = -1 &#125;&#125;//记得输出module.exports = &#123; SuccessModel, ErrorModel&#125; 借助这2个模型我们希望实现返回格式的统一（非实际使用，只是在app.js中做效果展示）： app.js解析公共参数所有公共的参数都放到app.js中进行解析(比如query的解析)：（req.query得到的效果可以参考这个例子） 1.app.js中顶部增添: 12//引用js原生模块querystringconst querystring = require(\"querystring\") 2.app.js的serverHandle中增添: 12//解析query,parse方法用于将一个 JSON 字符串转换为对象req.query = querystring.parse(url.split(\"?\")[1]) 新建controller文件夹 在src下新建controller文件夹，在该文件夹下新建blog.js文件。 controller文件夹中的js文件类似于router中的文件。 blog.js文件中先返回假数据（格式是正确的），此时虽然author和keyword没有使用，但我们假装他使用了并返回了很多的元素（博客）。 没连接数据库，先返回假数据 由于接下来还要建很多个函数，所以返回（输出）的是对象（方便增加返回的函数）。 controller文件夹内的blog.js: 12345678910111213141516171819202122232425const getList = (author, keyword) =&gt; &#123; //虽然author,keyword没有使用，但先返回假数据（格式是正确的） //返回的是数组，数组元素为博客文章 return [ &#123; id: 1, title: \"标题A\", content: \"内容A\", createTime: 1579421639661, author: \"hlz\" &#125;, &#123; id: 2, title: \"标题B\", content: \"内容B\", createTime: 1579421789492, author: \"lv\" &#125; ]&#125;//接下来还会有函数需要输出，所以先使用对象的方式进行返回module.exports = &#123; getList&#125; 其中，createTime可以在网页上获取一个来使用： router中引用controller 可以在router文件夹内的blog.js文件中通过解构赋值的方式引用在controller文件夹内的blog.js文件中定义的getList函数。（至于为什么使用解构赋值可参考笔记“Node.js函数引用与解构赋值”） 想要调用getList就必须传入参数author, keyword，而author, keyword是从queryString中来的，所以我们可以在app.js中统一获取到req.query里 注意：req.query得到的是一个JSON对象，如果我们访问http://localhost:8000/api/blog/list?author=hlz&amp;keyword=hahaha，则这个对象中有author属性和keyword属性，可参考这个例子。 通过getList()拿到的数据listData 作为参数data 传入SuccessModel。 SuccessModel中的this指向blogData对象。经过SuccessModel相当于给blogData对象添加属性data以及属性值listData和属性errno。 注意：BaseModel中的this指向使用SuccessModel/ErrorModel的对象 也就是说：router-blog.js-handleBlogRouter()里new了一个SuccessModel对象，那么this就指向在app.js中调用了handleBlogRouter()的对象blogData 。所以对象blogData中就会有SuccessModel中的data、message、errno。 通过SuccessModel合成后的数据在app.js中作为blogData对象的属性 通过res.end()显示在页面上。 router文件夹内的blog.js顶部： 1234//通过解构赋值的方式引用controller/blog.js中的getList函数const &#123; getList &#125; = require(\"../controller/blog\")//引入resModel.js中的两个模块const &#123; SuccessModel, ErrorModel &#125; = require(\"../model/resModel\") 将router文件夹内的blog.js中“获取博客列表”的部分进行修改： 123456789101112//获取博客列表,api前面千万不要漏掉 / !!!if (method === \"GET\" &amp;&amp; req.path === \"/api/blog/list\") &#123; //从app.js中解析的query中读取author、keyword，没有则空 const author = req.query.author || \" \" const keyword = req.query.keyword || \" \" //将读取到的author, keyword传到controller/blog.js中的getList函数， //获取返回的博客列表数据listData const listData = getList(author, keyword) //将博客列表数据listData传入SuccessModel， //此时我们只传入了data参数，没有传入message参数 return new SuccessModel(listData)&#125; 测试获取博客列表的接口通过假数据显示已经跑通了： 捋清思路（系统架构设计的四层）系统架构设计的四层抽象：第一层： www.js [开启 Server]第二层：app.js [通信设置层]第三层：router文件夹 [业务逻辑层]第四层：controller文件夹 [数据层] 一开始进入项目执行的是bin文件夹下的www.js,这里面只是createServer的逻辑，端口连通什么的，和我们的业务逻辑没有关系。第二层：app.js ，用来设置系统比较基础的功能（处理blog、user路由）或者参数（获取path、解析query）还有返回类型（JSON），还是不涉及业务逻辑的处理。第三层：router文件夹下的两个路由文件 blog.js、user.js，稍微涉及逻辑层，但只管路由。匹配到路由（接口）以后会去处理一些数据，然后（通过SuccessModel）会给你返回一个正确的格式。至于这些数据是怎么去匹配的，怎么去筛选的，是正确的还是错误的他不管，他只管和路由（接口）有关的。第四层：controller.js 是最关心数据的层次，他没有res、req、path、query这些东西，只是对传入的数据进行计算处理再返回。（我们目前还没有计算，接下来会有）。至于数据返回后是怎么处理的controller.js是不管的。 一层层拆分是一个由最基础的http服务向逻辑层转变的过程。 我们一开始先在www.js上创建服务器server并监听8000端口，这个服务器做的事情放到app.js的serverHandle中。然后在app.js中将HTTP请求req和响应res传到路由组件（router文件夹），并设置一些 公共参数 通过req/res传给路由组件以供使用。在router文件夹下的路由组件blog.js、user.js中，根据app.js传过来的req、res匹配对应的接口并将从controller.js中得到的数据进行一些格式的处理。最终返回显示在页面上。在controller.js中对数据进行计算处理再返回。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Redux进阶(1)UI组件、容器组件、无状态组件","slug":"Redux进阶(1)UI组件、容器组件、无状态组件","date":"2020-01-18T09:04:20.000Z","updated":"2020-11-06T05:02:28.672Z","comments":true,"path":"2020/01/18/Redux进阶(1)UI组件、容器组件、无状态组件/","link":"","permalink":"http://yoursite.com/2020/01/18/Redux进阶(1)UI组件、容器组件、无状态组件/","excerpt":"UI组件和容器组件 我们让 UI组件 负责页面的渲染，让 容器组件 负责页面的逻辑 当然有时候让 UI组件 负责一点点逻辑也是可以的。 当 UI组件 只负责页面渲染时，它实际只有一个render函数，那么此时我们可以使用无状态组件代替它以提高性能。","text":"UI组件和容器组件 我们让 UI组件 负责页面的渲染，让 容器组件 负责页面的逻辑 当然有时候让 UI组件 负责一点点逻辑也是可以的。 当 UI组件 只负责页面渲染时，它实际只有一个render函数，那么此时我们可以使用无状态组件代替它以提高性能。 分离UI组件TodoListUI在src下新建TodoListUI.js文件,将TodoList.js的render函数内页面渲染相关的内容都剪切过去，放在组件TodoListUI中。将父组件TodoList.js中有关页面渲染的引用都剪切到子组件TodoListUI.js中进行引用： 12345678910111213141516171819202122232425262728import React, &#123; Component &#125; from 'react'//imcrimport &#123; Input, Button, List &#125; from 'antd';class TodoListUI extends Component&#123; render()&#123; return( &lt;div style=&#123;&#123; marginTop: \"10px\", marginLeft: \"10px\" &#125;&#125;&gt; &lt;div&gt; &lt;Input value=&#123;this.props.inputValue&#125; placeholder=\"Todo info\" style=&#123;&#123; width: \"300px\", marginRight: \"10px\" &#125;&#125; onChange=&#123;this.props.handleInputChange&#125; /&gt; &lt;Button type=\"primary\" onClick=&#123;this.props.handleButtonClick&#125;&gt;提交&lt;/Button&gt; &lt;/div&gt; &lt;List style=&#123;&#123; marginTop: \"10px\", width: \"300px\" &#125;&#125; bordered dataSource=&#123;this.props.list&#125; renderItem=&#123;(item, index) =&gt; &lt;List.Item onClick=&#123;()=&gt;&#123;this.props.handleItemDelete(index)&#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;&#125; /&gt; &lt;/div &gt; ) &#125;&#125;export default TodoListUI; 在 父组件TodoList.js 的render函数中调用 子组件TodoListUI ，并将子组件需要的state相关数据和父组件方法都通过子组件属性的方式传递过去 ，页面的渲染就交给子组件：构造函数中：this.handleItemDelete = this.handleItemDelete.bind(this); 1234567891011render() &#123; return ( &lt;TodoListUI inputValue=&#123;this.state.inputValue&#125; list=&#123;this.state.list&#125; handleInputChange=&#123;this.handleInputChange&#125; handleButtonClick=&#123;this.handleButtonClick&#125; handleItemDelete=&#123;this.handleItemDelete&#125; /&gt; )&#125; 注意：子组件事件绑定函数传参原本父组件中有一个事件绑定函数handleItemDelete在bind（）绑定this指向的同时进行了传参，现在改为在父组件中bind（）绑定this指向，在子组件中传参： 原本的：在React这个例子中使用bind绑定事件函数 handleItemDelete 的this指向时还要将参数index传入函数，那么我们可以在绑定时传入： 1&lt;List.Item onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/List.Item&gt; 现在：但如果事件函数和bind绑定都在父组件中，而函数的调用和传参在子组件，就可以这样传参： 在父组件的构造函数中使用bind绑定this.handleItemDelete=this.handleItemDelete.bind(); 我们知道bind()返回的还是一个函数，所以在子组件中，我们通过箭头函数在每次调用handleItemDelete()时传入参数index：1&lt;List.Item onClick=&#123;()=&gt;&#123;this.props.handleItemDelete(index)&#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt; 注意： 在这里不能直接使用handleItemDelete(index)传参是因为handleItemDelete(index)直接执行了函数，而onClick需要绑定的事件函数是不能立即执行的，所以需要新建一个箭头函数让他不立即执行。 箭头函数是JS表达式，在JSX中需要使用{}，调用的父组件的函数也是JS表达式，同样中需要使用{}。 容器组件（父组件TodoList）那么分离以后的父组件TodoList也就成为了容器组件 无状态组件（性能优化） 当一个组件中只有render函数时，我们可以使用 无状态组件 替换 它。 无状态组件：使用常量const定义一个箭头函数，该函数接收一个参数props（来自父组件的变量、方法），返回原本render函数中的内容（记得输出） 好处相对普通组件，无状态组件性能高：因为无状态组件实际上只是一个函数，而普通组件是JS的class（类），类生成的对象里还会有一些 生命周期函数，所以普通组件既要执行生命周期函数又要执行render函数，性能就比不上 无状态组件。 例子：TodoListUI组件将TodoListUI组件替换成TodoListUI组件：使用常量const定义无状态组件，它是一个函数，接收一个参数props（来自父组件的变量、方法），返回原本render函数中的内容。（此时原本使用this.props.xx来调用的父组件变量/方法 改为 使用props.xx来调用）： 1234567891011121314151617181920212223242526import React from 'react'//imcrimport &#123; Input, Button, List &#125; from 'antd';const TodoListUI = (props) =&gt; &#123; return ( &lt;div style=&#123;&#123; marginTop: \"10px\", marginLeft: \"10px\" &#125;&#125;&gt; &lt;div&gt; &lt;Input value=&#123;props.inputValue&#125; placeholder=\"Todo info\" style=&#123;&#123; width: \"300px\", marginRight: \"10px\" &#125;&#125; onChange=&#123;props.handleInputChange&#125; /&gt; &lt;Button type=\"primary\" onClick=&#123; props.handleButtonClick&#125;&gt;提交&lt;/Button&gt; &lt;/div&gt; &lt;List style=&#123;&#123; marginTop: \"10px\", width: \"300px\" &#125;&#125; bordered dataSource=&#123; props.list&#125; renderItem=&#123;(item, index) =&gt; &lt;List.Item onClick=&#123;() =&gt; &#123; props.handleItemDelete(index) &#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;&#125; /&gt; &lt;/div &gt; )&#125;export default TodoListUI; 复习：第三方模块axios（发送AJAX）在React高级内容（3）中我们提到，React并不像jquery那样封装了AJAX发送的内置功能，所以我们需要借助 第三方模块axios来使用AJAX。 Redux 中发送异步请求获取数据 实现功能：我们希望发送一个AJAX请求来获取数据放入列表中。 其实在React高级内容（3）中我们实现过同样的功能，唯一的不同是现在我们通过redux的store管理state数据，所以我们需要走redux的工作流程进行数据修改。 总流程先“从接口获取到数据的流程”，然后将获取到的数据通过“redux工作流程”显示在页面上。 从接口获取到数据的流程 在组件中创建一个生命周期函数componentDidMount()。引用 axios 模块，在componentDidMount函数中借助 axios 模块发送ajax请求，使用axios.get(&quot;接口路径&quot;)来获取某个接口路径下的数据,请求成功后执行then()的回调函数（接收一个参数res表示接收到的数据），请求失败后执行catch()的回调函数 桌面创建list.json文件，并在其中放入一个数组 使用接口地址在Charles中模拟接口数据，使得发送请求到接口路径时调用我们桌面的list.json文件【使用Charles抓取localhost包需要注意更换url：需要使用http://localhost.charlesproxy.com:3000/访问】 then()的回调函数中打印出的res中的内容，可得到 res中的data是我们需要的数组，那么我们可以在ajax请求成功时通过then()获取data数据 redux工作流程 在actionTypes.js中创建type,然后在actionCreator.js中,创建action方法 在组件TodoList.js中,引用该方法获取action，并将从接口获取到的数据data传入action，并通过store.dispatch(action)将action发送给store store自动将action和state传给reducer.js reducer.js根据action的type处理相关action后返回newState给store store拿到newState后自动将其替换掉自己原本的state 组件通过store.subscirbe(this.handleStoreChange)监听到store的数据变化时执行回调函数this.handleStoreChange进行自身state数据的更新，页面重新渲染 实例1.在组件中创建一个生命周期函数componentDidMount()。引用 axios 模块，在componentDidMount函数中借助 axios 模块发送ajax请求，使用axios.get(&quot;接口路径&quot;)来获取某个接口路径下的数据,请求成功后执行then()的回调函数（接收一个参数res表示接收到的数据），请求失败后执行catch()的回调函数: 1import axios from \"axios\"; 12345678910// 生命周期函数componentDidMount() &#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 axios.get(\"/list.json\").then((res) =&gt; &#123; console.log(res); alert(\"成功\"); &#125;).catch(() =&gt; &#123; alert(\"失败\"); &#125;)&#125; 2.桌面创建list.json文件，并在其中放入一个数组： 1[\"你好呀\",\"可以通过点击删除我\",\"今天也要加油哦\"] 3.使用接口地址在Charles中模拟接口数据，使得发送请求到接口路径时调用我们桌面的list.json文件【使用Charles抓取localhost包需要注意更换url】，使用http://localhost.charlesproxy.com:3000/访问： 4.then()的回调函数中打印出的res中的内容，可得到 res中的data是我们需要的数组，那么我们可以在ajax请求成功时通过then()获取data数据： 123456789// 生命周期函数componentDidMount() &#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 axios.get(\"/list.json\").then((res) =&gt; &#123; const data = res.data; &#125;).catch(() =&gt; &#123; alert(\"失败\"); &#125;)&#125; 5.在actionTypes.js中创建type,然后在actionCreator.js中,创建action方法： 1export const INIT_LIST_ACTION=\"init_list_action\"; 1234export const initListAction = (data) =&gt; (&#123; type: INIT_LIST_ACTION, data&#125;) 6.在组件TodoList.js中,引用该方法获取action，并将从接口获取到的数据data传入action，并通过store.dispatch(action)将action发送给store: 1234567891011// 生命周期函数componentDidMount() &#123; // 借助 `axios` 模块发送`ajax`请求,通过`get()`获取接口路径下的数据 axios.get(\"/list.json\").then((res) =&gt; &#123; const data = res.data; const action=initListAction(data); store.dispatch(action); &#125;).catch(() =&gt; &#123; alert(\"失败\"); &#125;)&#125; 7.store自动将action和state传给reducer.js8.reducer.js根据action的type处理相关action后返回newState给store: 12345if (action.type === INIT_LIST_ACTION) &#123; const newState = JSON.parse(JSON.stringify(state)); newState.list = action.data; return newState;&#125; 【reducer中list没拿到数据】 9.store拿到newState后自动将其替换掉自己原本的state10.组件通过store.subscirbe(this.handleStoreChange)监听到store的数据变化时执行回调函数this.handleStoreChange进行自身state数据的更新，页面重新渲染:","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JS笔试遇到的知识点（3）","slug":"JS笔试题遇到的知识点（3）","date":"2020-01-18T04:08:59.000Z","updated":"2020-02-09T11:25:32.331Z","comments":true,"path":"2020/01/18/JS笔试题遇到的知识点（3）/","link":"","permalink":"http://yoursite.com/2020/01/18/JS笔试题遇到的知识点（3）/","excerpt":"运算符优先级参考MDN的运算符优先级中的“汇总表”","text":"运算符优先级参考MDN的运算符优先级中的“汇总表” 逻辑运算符&amp;&amp;和||的规律可参考MDN的逻辑运算符 明确：&amp;&amp;和||返回的是表达式，!返回的是布尔值！ 会被转换为 false 的表达式有：null； NaN； 0； 空字符串（&quot;&quot; or &#39;&#39; or ``）； undefined。 帮助理解返回表达式的原则：从前往后判断，只要到了能判断出 整个表达式的真假 的位置我们就停下来返回这个位置的部分表达式。 &amp;&amp;：前后都为真才是真，只要有一个是假的就是假。所以只要有第一个表达式是假的我们就不用继续判断了，返回第一个表达式。如果第一个表达式是真的我们就继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。 ||：只要有一个是真就是真。所以只要有第一个表达式是真的就可以判断整个表达式都是真的，故返回第一个表达式。如果第一个表达式是假的那我们就要继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。 例子12345//10可被强转为true，0则是false，有一个错的就返回错的表达式console.log(10 &amp;&amp; 0);//0//\"\"可被强转为false，\"abc\"可被强转为true，有一个是真的就返回真的表达式console.log(\"\" || \"abc\");//\"abc\"console.log(!window.abc);//true。`window.abc`是undefined，强转为false 题目问题：1 &amp;&amp; 2&gt;1返回的布尔值？答案：true解析：&gt;的优先级排在前，所以先判断右边的表达式，2&gt;1 结果为true。得到1&amp;&amp;true，1可被强转为true，所以返回的结果是 运算符后面的表达式 ，也就是true。 改一下问题：console.log(2 &gt; 1 &amp;&amp; 1);答案：1解析：2&gt;1 结果为true，所以返回 运算符后面的表达式，也就是1. cookie的生命期cookie的有效时间默认为-1，如果不进行设置的话，就会默认在浏览器会话关闭时结束。可以通过setMaxAge()方法设置cookie的生命期。当setMaxAge(0)表示立刻删除该浏览器上指定的cookie。 Ajax技术的工作原理（XMLHttpRequest）可参考笔记AJAX异步更新 Ajax技术核心就是XMLHttpRequest对象。 Ajax技术的工作原理(可以分成3步): 123456789101112131415161718//1. 创建XMLHttpRequest对象：var xhr = new XMLHttpRequest();//2. xhr 发送请求：xhr.open('get','test.html','true');xhr.send();//3. xhr获取响应：xhr.onreadystatechange = function()&#123; if(xhr.readystate == 4)&#123;//请求的状态码 /* 0:请求还没有建立（open执行前） 1：请求建立了还没发送（执行了open） 2：请求正式发送（执行了send） 3：请求已受理，有部分数据可以用，但还没有处理完成 4：请求完全处理完成 */ alert(xhr.responseText);//返回的数据 &#125;&#125; 可以看到，send()前是open() 在笔记“AJAX异步更新的向服务器发送请求”中也提到： 解释型语言的特性:非独立、效率低非独立：JavaScript语言依赖执行环境，对于客户端来说是浏览器，对于服务端来说是node。效率低：执行前不需要编译，执行时才编译，因此效率低。 解释性语言和编译性语言计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。 解释性语言的定义解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。 编译性语言的定义编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。 动态语言与静态语言JavaScript是动态语言。 静态语言（强类型语言）静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 例如：C++、Java、Delphi、C#、Objective-C等。 动态语言（弱类型语言）动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。例如：PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。 区别 字符串字面量 和 String对象首先注意：typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。准确判断可以从构造函数（instanceof）、原型链（prototype.isPrototypeOf）上下手，具体可以看笔记 JS数据类型 JS 中值的类型分为原始值类型和对象类型。原始值类型包括 number, string, boolean, null 和 undefined；（记忆：纳尼USB）对象类型即 object。首先明确原始值类型不是对象。 另外，要注意 &quot;hello&quot; 和 new String(&#39;hello&#39;) 的区别，前者是字符串字面值，属于原始类型，而后者是对象。用 typeof 运算符返回的值也是完全不一样的： 1212 typeof 'hello';// 'string'typeof new String('hello');// 'object' 很多人分不清字符串字面值和 String 对象，是因为 JS 的语法中的“装箱”：当执行 &#39;hello&#39;.length 时，返回 5，很多人就觉得 &#39;hello&#39; 就是 String 对象，不然它怎么会有 String 对象的属性。其实，这是由于 JS 在执行到这条语句的时候，内部将 &#39;hello&#39; 包装成了一个 String 对象，执行完后，再把这个对象丢弃了，这种语法叫做 “装箱”，在其他面向对象语言里也有（如 C#）。不要认为 JS 帮你装箱了，你就可以在写代码的时候不分箱里箱外了！【题目可看20200205第十题】 #","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"牛客网题目","slug":"牛客网题目","permalink":"http://yoursite.com/categories/牛客网题目/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS笔试遇到的知识点（2）","slug":"JS笔试遇到的知识点（2）","date":"2020-01-18T04:08:59.000Z","updated":"2020-04-12T11:50:52.269Z","comments":true,"path":"2020/01/18/JS笔试遇到的知识点（2）/","link":"","permalink":"http://yoursite.com/2020/01/18/JS笔试遇到的知识点（2）/","excerpt":"js中同名函数后面会覆盖前面的js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。","text":"js中同名函数后面会覆盖前面的js里面没有函数重载的概念，在其他语言中（如java）java中，可以存在同名函数，只要传入的参数数量或者类型不同即可。 在js中，定义了两个同名函数后，后面的函数会覆盖前面定义的函数。也就是说，前面定义的函数内容会被后面的函数内容覆盖，当你以为自己执行的是前面的函数内容时，其实执行的是后面的函数内容。 例子： 1234567891011&lt;script&gt; var m= 1, j = k = 0; function add(n) &#123; return n = n+1; &#125; y = add(m); function add(n) &#123; return n = n + 3; &#125; z = add(m); &lt;/script&gt; 例子结果：y和z的最终结果为:4,4例子分析：由于函数声明提升，所以函数声明会提前，由于存在同名函数，后面的add函数将覆盖第一个add函数，所以两次调用add()返回的值是相同的。 void关键词 void是一元运算符，它出现在操作数之前，操作数可以是任意类型，操作数会照常计算，但会忽略计算结果并返回undefined。由于void会忽略操作数的值，因此在操作数具有副作用的时候使用void来让程序更具语义。 void 作为运算符后面接的是表达式，void expression。而void(0)也是被当做void 0。如果直接void()，那么我觉得应该是把void当做函数使用了，但是void() 是关键词，并不能作为函数使用,所以void ();会报SyntaxError，即“语法错误”。。1234567void 0; //undefinedvoid (0);//undefinedvoid (); //SyntaxError 语法错误typeof 1; //'number'typeof (1);//'number'typeof (); //SyntaxError 语法错误 按位与运算&amp;&amp;:位运算符 比较两个数字的二进制的数位，按位与运算中 相等为1，否则为0。例子：1&amp;2返回的是0计算过程：（注意是针对二进制的数位进行对比是否相等！！）1＝0001 ，2＝0010，运算以后＝0000， 转换为数字结果为0，故返回0。 返回值和输出值不一样注意：返回值和输出值不是一种东西！任何函数执行完一次，如果没有 return 返回值和声明变量接受返回值，都会立即消失，永远找不到值！（undefined）也就是说，没有写return语句的函数都会默认返回undefined。 先立即执行匿名函数，输出Hello World！ 匿名函数没有写return语句默认返回undefined，则输出未定义 定义函数的三种方法在Javascript定义一个函数一般有如下三种方式： 函数关键字(function)语句： function fnMethodName(x){alert(x);} (最常用的方法) 函数字面量(Function Literals)： var fnMethodName = function(x){alert(x);} Function()构造函数： var fnMethodName = new Function(‘x’,’alert(x);’)后两种都是把一个函数赋值给变量fnMethodName，而这个函数是没有名字的，即匿名函数（拉达姆函数）。类似于 var foo = function bar(){...} 这样的统一按第2种方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。 注意，Function()构造函数没有{} 几个常见的事件的方法preventDefault() 取消事件默认行为（不是阻止事件冒泡），如阻止点击提交按钮时对表单的提交（click没有默认行为）stopImmediatePropagation() 取消事件冒泡同时阻止当前节点上的事件处理程序被调用，影响当前的事件stopPropagation() 取消事件冒泡，不影响事件cancelBubbe() 取消事件冒泡returnValue() 取消事件默认行为 thisIIFE(立即执行函数表达式)中的this指向window null与undefinednull和undefined是不同的，但它们都表示“值的空缺”，判断相等运算符“==”认为两者是相等的（使用严格相等运算符“===”来区分它们则不等） 运算符instanceof、===、== instanceof运算符希望左操作数是一个对象，右操作数表示对象的类（初始化对象的构造函数）。如果左侧的对象是右侧对象的实例，返回true，否则返回false。例如：计算o instanceof f首先计算f.prototype，然后在原型链中查找o，找到返回true ===严格相等运算符：首先计算其操作数的值，然后比较这两个值，比较过程中没有任何类型转换 ==相等运算符：如果两个操作数不是同一类型，那么会尝试进行一些类型转换，然后进行比较（1）尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换，因此==运算符认为两者是相等的（2）NaN表示非数字值，特殊之处：它和任何值都不相等，包括自身。判断NaN的方法：x!=x返回true JS继承方式JavaScript实现继承共6种方式：原型链继承、借用构造函数继承、组合继承、原型式继承、寄生式继承、寄生组合式继承。 转换为布尔值0、“ ”、null、undefined转换为布尔型是false，其余都是true。 运算符优先级+加号运算符优先级大于?:三目运算符。（具体可看20200109第六题） ES6中promise的三种状态 一个 promise 可能有三种状态：等待（pending）、已完成（Resolved，又称fulfilled）、已拒绝（rejected） 一个promise的状态只可能从“等待”转到“完成”态或者“拒绝”态，不能逆向转换，同时“完成”态和“拒绝”态不能相互转换。 promise必须实现then方法（可以说，then就是promise的核心），而且then必须返回一个promise，同一个promise的then可以调用多次，并且回调的执行顺序跟它们被定义时的顺序一致 then方法接受两个参数，第一个参数是成功时的回调，在promise由“等待”态转换到“完成”态时调用，另一个是失败时的回调，在promise由“等待”态转换到“拒绝”态时调用。同时，then可以接受另一个promise传入，也接受一个“类then”的对象或方法，即thenable对象。 数组js中，数组会自动根据最大下标延长一位，既下标为n，则数组的长度为n+1。没有填值默认为undefinded。 分母为0isNaN(1/0) 任何 数值除以0 都会导致错误而终止程序执行。但是在 JavaScript 中，会返回出特殊的值，因此不会影响程序的执行。 比0大的数除以0，则会得到无穷大，所以 js 用 Infinity （无穷）来显示。 也就是1/0得到的是Infinity。isNaN(1/0)返回的是false。但是isNaN(0/0)返回的就是true。 in操作符（可参考MDN的in运算符） 如果指定的 属性 在指定的对象或其原型链中，则in 运算符返回true。 如果指定的 数组索引 在数组中，则in 运算符返回true。 1 in [1]并不是表示数字1在不在数组里。而是表示数组中含不含有1这个索引index值。 数组长度为1，所以只含有的index值为0，1 in [1]返回fasle。 for…in 和 for…of for…in还是for…of语句都是遍历一些东西。它们之间的主要区别在于它们的迭代方式。 for…in 语句以任意顺序遍历对象的可枚举属性，更适合用于遍历对象属性。（但要注意：需要使用hasOwnProperty()筛选是否为继承自原型的属性,数组/对象/字符串都会继承原型属性） MDN for…in for…of 语句按顺序遍历可迭代对象的数据，更适合用于遍历 数组元素/字符串 等拥有 迭代器 对象的集合。 MDN for…of 但是for…of不能遍历对象,因为对象没有迭代器。 与forEach()不同的是，for…of可以正确响应break、continue和return语句。 以下示例显示了与Array一起使用时，for…of循环和for…in循环之间的区别：12345678910111213141516171819Object.prototype.objCustom = function() &#123;&#125;; Array.prototype.arrCustom = function() &#123;&#125;;let iterable = [3, 5, 7];iterable.foo = 'hello';for (let i in iterable) &#123; console.log(i); // logs 0, 1, 2, \"foo\", \"arrCustom\", \"objCustom\"&#125;for (let i in iterable) &#123; if (iterable.hasOwnProperty(i)) &#123; console.log(i); // logs 0, 1, 2, \"foo\" &#125;&#125;for (let i of iterable) &#123; console.log(i); // logs 3, 5, 7&#125;","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"牛客网题目","slug":"牛客网题目","permalink":"http://yoursite.com/categories/牛客网题目/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Redux的reducer为什么不能有异步操作","slug":"Redux的reducer为什么不能有异步操作","date":"2020-01-17T03:24:22.000Z","updated":"2020-02-25T13:53:04.037Z","comments":true,"path":"2020/01/17/Redux的reducer为什么不能有异步操作/","link":"","permalink":"http://yoursite.com/2020/01/17/Redux的reducer为什么不能有异步操作/","excerpt":"回顾Redux设计和使用的三大基本原则可参考笔记Redux入门（2）： 单一数据源，也就是store中的state是唯一的 state 是只读，Redux并没有暴露出直接修改state的接口，必须通过action来触发修改(即：只有store能改变自己的state) reducer必须是纯函数","text":"回顾Redux设计和使用的三大基本原则可参考笔记Redux入门（2）： 单一数据源，也就是store中的state是唯一的 state 是只读，Redux并没有暴露出直接修改state的接口，必须通过action来触发修改(即：只有store能改变自己的state) reducer必须是纯函数 Redux的设计初衷先从Redux的设计层面来解释为什么Reducer必须是纯函数。 Redux的设计参考了Flux的模式，作者希望以此来实现时间旅行，保存应用的历史状态，实现应用状态的可预测。所以整个Redux都是函数式编程的范式，要求reducer是纯函数也是自然而然的事情，使用纯函数才能保证相同的输入得到相同的输入，保证状态的可预测。 不是纯函数的例子可以参考Redux入门（2）中的例子。 Redux的源码那么reducer到底干了件什么事，在Redux的源码中只用了一行来表示： 1currentState = currentReducer(currentState, action) 这一行简单粗暴的在代码层面解释了为什么currentReducer必须是纯函数。currentReducer就是我们的reducer（至于为什么会加个current有兴趣的可以自己去看源码），reducer通过store传入的state和action进行处理后需要返回的是一个新的state，store拿到这个新的state后就会修改自身的state。reducer是用来计算state的，所以它的返回值必须是state，也就是我们整个应用的状态，而不能是promise之类的。 要在reducer中加入异步的操作，如果你只是单纯想执行异步操作，不会等待异步的返回，那么在reducer中执行的意义是什么。如果想把异步操作的结果反应在state中，首先整个应用的状态将变的不可预测，违背Redux的设计原则，其次，此时的currentState将会是promise之类而不是我们想要的应用状态（state），根本是行不通的。 其实这个问题应该是Redux中为什么不能有副作用的操作更合适。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Redux入门（2）","slug":"Redux入门（2）","date":"2020-01-16T07:00:33.000Z","updated":"2020-02-25T13:56:38.514Z","comments":true,"path":"2020/01/16/Redux入门（2）/","link":"","permalink":"http://yoursite.com/2020/01/16/Redux入门（2）/","excerpt":"使用redux完成TodoList列表功能实现效果：继续上一篇笔记的例子，我们希望在点击 “提交”按钮 后，input框中的 数据value 存到store中的list中，并清空input框。","text":"使用redux完成TodoList列表功能实现效果：继续上一篇笔记的例子，我们希望在点击 “提交”按钮 后，input框中的 数据value 存到store中的list中，并清空input框。 1.首先给button绑定一个onClick事件函数handleButtonClick（记得绑定this作用域，JS表达式在JSX中使用{}）: 1&lt;Button type=\"primary\" onClick=&#123;this.handleButtonClick&#125;&gt;提交&lt;/Button&gt; 2.在事件函数handleButtonClick中添加action，写好type属性。（注意：这里不需要value属性去传值，action传给store以后store会把之前的state数据和action一起传给reducer） 1234567handleButtonClick()&#123; const action=&#123; type:\"add_todo_item\", &#125; store.dispatch(action) // 传给store以后store会把之前的state数据和action一起传给reducer&#125; (我们到时候在reducer中使用reducer的state中的inputValue的数据即可.) 3.store收到action后会自动把之前的state数据和action一起传给reducer4.在reducer中，一样先深拷贝state，然后通过newState.list.push(newState.inputValue);将input框中的值加入到list数组中。（记得返回newState给store）,并清空输入框: 12345678if(action.type === \"add_todo_item\")&#123; const newState=JSON.parse(JSON.stringify(state)); // newState.list= [...newState.list,newState.inputValue];效果一样 newState.list.push(newState.inputValue); // 清空输入框 newState.inputValue=\"\"; return newState;&#125; 5.store接收到newState后会替换掉原本的state，而我们之前在组件上使用store.subscribe(this.handleStoreChange);监听了store，在该函数中我们使用this.setState(store.getState());获取了store中的state来改变 组件的state，组件的state发生改变后，页面数据自然重新渲染： 使用Redux完成TodoList删除功能1.在reducer中清空input框的内容和list列表的数据： 1234const defaultState = &#123; inputValue: \"\", list: []&#125;; 那么我们希望点击“111”后他会消失 2.在组件TodoList中，我们的列表子项是通过&lt;List.Item&gt;进行渲染的，所以我们可以给&lt;List.Item&gt;绑定一个 事件函数handleItemDelete ,增加一个参数index传入&lt;List.Item&gt;，并通过bind()的第二个参数将index传入函数handleItemDelete： 1renderItem=&#123;(item, index) =&gt; &lt;List.Item onClick=&#123;this.handleItemDelete.bind(this,index)&#125;&gt;&#123;item&#125;&lt;/List.Item&gt;&#125; 3.在事件函数handleItemDelete中书写action,将type和index一起传给store: 12345678handleItemDelete(index)&#123; const action=&#123; type:\"delete_todo_item\", // index相当于index:index index &#125; store.dispatch(action)&#125; 4.store接收到type和index后就自动带上原本的state一起打包发给reducer。5.在reducer中通过数组的splice方法删除index子项： 1234567if(action.type === \"delete_todo_item\")&#123; const newState=JSON.parse(JSON.stringify(state)); // 删除list数组中index项 newState.list.splice(action.index,1); return newState;&#125;return state; 实现效果： actionTypes拆分type属性值注意： 在actionType.js中输出的是各个常量名，在别的文件也是使用对象的方式引用多个常量名再进行使用。（常量名的引用没有引号，区分于字符串） 常量的输出不能使用export default,只能使用export.仅允许表达式、函数或类作为“默认”导出: Parsing error: Only expressions, functions or classes are allowed as the default export. 原因我们之前在action中都是使用字符串作为属性值（type: &quot;add_todo_item&quot;），在reducer.js中（if(action.type === &quot;add_todo_item&quot;){}）也都是调用的字符串。假设一旦字符串中有一个字母输错了，页面不会报错，但功能无法实现，所以我们需要把这个 字符串 保存在另一个js文件的常量（const）中，在需要使用他们的时候再进行文件和常量的引用。这样一来，一旦 常量书写错误，页面就会进行相应的报错。 拆分过程我们应该把所有action中的 type属性值 拆分出来写在store文件夹下的actionType.js中,然后再在组件TodoList.js和reducer.js中分别引用actionType.js中对应 type属性值的各个 常量（const）。 例子1.在store文件夹下新建actionType.js用于存放所有action中的 type属性值，记得把这些常量输出： 1234// 记得输出才能在别的文件引用export const CHANGE_INPUT_VALUE = \"change_input_value\";export const ADD_DOTO_ITEM = \"add_todo_item\";export const DELETE_TODO_ITEM = \"delete_todo_item\"; 2.在TodoList.js中引入： 1import &#123; CHANGE_INPUT_VALUE, ADD_DOTO_ITEM, DELETE_TODO_ITEM &#125; from \"./store/actionTypes\" 3.将TodoList.js中的所有action中的type属性值从字符串修改为常量名 （注意：常量名的引用不需要引号）：type: CHANGE_INPUT_VALUE,、type: ADD_DOTO_ITEM,、type: DELETE_TODO_ITEM,4.在reducer.js中引入(注意路径的改变)： 1import &#123; CHANGE_INPUT_VALUE, ADD_DOTO_ITEM, DELETE_TODO_ITEM &#125; from \"./actionTypes\" 5.将reducer.js中的所有action中的type属性值从字符串修改为常量名 （注意：常量名的引用不需要引号）：if (action.type === CHANGE_INPUT_VALUE) {}、if(action.type === ADD_DOTO_ITEM){}、if(action.type === DELETE_TODO_ITEM){} 测试将reducer.js中的DELETE_TODO_ITEM写错： 1if(action.type === DELET_TODO_ITEM)&#123;&#125; 会告诉你“DELET_TODO_ITEM没有被定义”也就是说DELET_TODO_ITEM没被声明，它不是一个变量，那我们就很容易发现错误了。 actionCreator统一创建action好处 方便管理，提高代码的可维护性。 前端有自动化测试工具，把action统一写在actionCreator.js文件中将方便测试。 拆分过程在store文件夹下创建actionCreator.js文件并引入action的type属性值，将action的创建都都写在actionCreator.js的不同常量定义的方法中，在组件中直接引用方法即可。（需要由组件传递到action中的方法通过函数进行传递） 例子修改第一个action1.在store文件夹下创建actionCreator.js文件，引入type常量并写入一个新函数（记得输出）： 12345678910import &#123; CHANGE_INPUT_VALUE &#125; from \"./actionTypes\";// 使用const创建一个箭头函数// return后只返回一个对象可将`return&#123;&#125;`省略为`()`export const getInputChangeAction = (value) =&gt; (&#123; // value接收了TodoList中传过来的e.target.value type: CHANGE_INPUT_VALUE, // value相当于value:value value&#125;) 2.在TodoList.js中引入actionCreator.js中的getInputChangeAction方法: 1import &#123; getInputChangeAction &#125; from \"./store/actionCreator\"; 3.修改TodoList.js中action,调用getInputChangeAction方法时将e.target.value传过去，getInputChangeAction方法收到后就将它作为value返回: 修改剩下的action1.将剩余会使用的type值都引入到actionCreator.js中，创建剩余的action: 1import &#123; CHANGE_INPUT_VALUE,ADD_DOTO_ITEM, DELETE_TODO_ITEM &#125; from \"./actionTypes\"; 12345678export const getButtonClickAction = () =&gt; (&#123; type: ADD_DOTO_ITEM,&#125;)export const getItemDeleteAction = (index) =&gt; (&#123; type: DELETE_TODO_ITEM, index&#125;) 2.在TodoList.js中 引入 并 使用 剩余两个获取actin的方法： 1import &#123; getInputChangeAction,getButtonClickAction,getItemDeleteAction &#125; from \"./store/actionCreator\"; const action =getButtonClickAction();和const action = getItemDeleteAction(index); 3.删除TodoList.js中无用的引用:import { CHANGE_INPUT_VALUE, ADD_DOTO_ITEM, DELETE_TODO_ITEM } from &quot;./store/actionTypes&quot;; 重新归纳redux的工作流程使用actionCreator以后，工作流程变更为：在组件中调用actionCreator创建action方法，然后store使用dispatch()将action传给store 获取store中数据 创建store：在store文件夹下的index.js中，通过引用自react的createStore（）创建store。（记得输出store） 创建reducers：在store文件夹下的reducers.js中，需要输出一个参数为state和action的函数，reducer中的state就是store的state。所以我们可以通过设置state的默认值defaultState并在函数中返回，将默认state的值返回给store store连接reducers：将reducers.js中的reducers作为createStore（）的第一个参数传给 store。store从reducers获取到初始state值，然后store将其替换掉自身的state. 组件TodoList连接store获取数据:在组件的构造函数中通过store.subscribe();监听一个函数，在被监听的函数中把store的state赋值给 组件的state，这样第一次渲染页面时，组件的state的就会获取到store中的state值。 改变store中数据 通过actionCreator创建 获取action对象的方法：通过actionCreator.js创建组件需要的 action对象 存储在不同的 方法 中，这些方法会返回 action对象 （记得输出） 在actionTypes.js中将type属性值转为常量：在actionTypes.js中将action对象的type属性值统一由字符串赋值给常量。 在组件中调用actionCreator的方法获取action对象并传给store：在组件中引用actionCreator.js并调用actionCreator.js中的方法获取action,通过store.dispatch()将action传送给store store自动将收到的action和自己的state数据打包传送给reducer reducer处理action并返回newState值给store：reducer根据action中不同的type属性值做出不同的处理并返回新的newState值给store store获取到newState后自动替换state 组件中state由于监听函数，更新后页面重新渲染：组件中之前通过store.subscribe();监听的函数会在store的state改变时将store的state赋值给 组件的state，组件自然重新渲染。 Redux设计和使用的三大基本原则store是唯一的只有store能改变自己的内容 reducer从store拿到之前的state数据，深拷贝为一个新的newState，修改newState后返回给store，store拿到newState后自己把state替换掉，所以最后其实是store自己改变了自己的内容。 reducer中的state就是store的state,这也就是为什么我们需要深拷贝一个newState出来用而不能直接修改reducer中的state。 reducer必须是纯函数 纯函数指的是：给定固定的输入，就一定会有固定的输出，且不能对传入的参数进行修改。 纯函数不能涉及 异步 或者是关于 时间 的操作，一旦函数中涉及 AJAX请求、new Date()、setTimeout() ,他就 不是纯函数。 例子纯函数:也就是说state和action确定时，返回的newState就是确定的。 非纯函数：state和action确定时，返回的newState是不固定的，他会收到当前时间的影响。 Redux中的核心api redux的createStore（）可以帮助我们创建store store.dispatch()帮助我们将action传给store store.getState()帮助我们获取store中的所有数据 store.subscribe()帮助我们订阅store的改变，只要store发生改变，store.subscribe()接收的回调函数就会执行","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"JS笔试遇到的知识点（1）","slug":"JS笔试遇到的知识点（1）","date":"2020-01-16T03:29:40.000Z","updated":"2020-11-04T08:42:16.582Z","comments":true,"path":"2020/01/16/JS笔试遇到的知识点（1）/","link":"","permalink":"http://yoursite.com/2020/01/16/JS笔试遇到的知识点（1）/","excerpt":"四种touch事件1234touchstart: //手指放到屏幕上时触发touchmove: //手指在屏幕上滑动式触发touchend: //手指离开屏幕时触发touchcancel: //系统取消touch事件的时候触发，这个好像比较少用","text":"四种touch事件1234touchstart: //手指放到屏幕上时触发touchmove: //手指在屏幕上滑动式触发touchend: //手指离开屏幕时触发touchcancel: //系统取消touch事件的时候触发，这个好像比较少用 跨域关于跨域 javascript中实现跨域的方式总结第一种方式：jsonp请求jsonp的原理是利用&lt;script&gt;标签的跨域特性，可以不受限制地从其他域中加载资源，类似的标签还有&lt;img&gt;.第二种方式：document.domain这种方式用在主域名相同子域名不同的跨域访问中第三种方式：window.namewindow的name属性有个特征：在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。第四种方式：window.postMessagewindow.postMessages是html5中实现跨域访问的一种新方式，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源。第五种方式：CORSCORS背后的基本思想，就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是应该失败。第六种方式：Web Socketsweb sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。 Math 对象Math 对象用于执行数学任务。注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。 Math.round(）方法 返回最接近的整数Math.round(）函数返回一个数字四舍五入后最接近的整数如果参数的小数部分大于0.5，四舍五入到相邻的绝对值更大的整数如果参数的小数部分小于0.5，四舍五入到相邻的绝对值更小的整数如果参数的小数部分等于0.5，四舍五入到相邻的在正无穷（+∞）方向上的整数。 例： 1234x=Math.round(2019.49) ; //2019x=Math.round(2019.5); //2020x=Math.round(-2019.5); //-2019x=Math.round(-2019.51); //-2020 Math.abs() 方法 返回数的绝对值 定义：abs() 方法可返回数的绝对值。 语法：Math.abs(x) 参数：必需。必须是一个数值。 基本（原始）、复杂与全局数据类型 基本数据类型（原始值）（记忆：NNUSB=&gt;纳尼USB）Number，Null，Undefined，String，Boolean。es6添加了一种新的原始数据类型：Symbol。所以现在 js的原始数据类型有6种。 复杂数据类型（对象值）：Object，Array，Function，RegExp，Date，Error 全局数据类型：Math 原始值和引用值ECMAScript中，变量可以存放两种类型的值，即原始值和引用值。原始值是存储在栈中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。(基本（原始）数据类型的值)引用值是存储在堆中的对象，也就是说，存储在变量处的值是一个指针，指向存储对象的内存处。（比如对象、数组） RegExp正则表达式JavaScript RegExp 对象有3个方法：test()、exec()、compile()test()：检测一个字符串是否匹配某个正则表达式，如果匹配成功，则返回true，否则返回false；exec()：检索字符串中与正则表达式匹配的值，返回一个数组，存放匹配的结果；如果未找到，返回null；compile():可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。注：match是支持正则表达式的String对象的方法. Array 对象方法concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串,元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素 .push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素unshift() 向数组的开头添加一个或更多元素，并返回新的长度。slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行 升序/降序排序(请注意，数组在原数组上进行排序，不生成副本。)，参数决定排序的顺序（参数为空则按照字符编码的顺序进行排序，参数也可为比较函数）。splice() 删除元素，并向数组添加新元素。(删除，插入，替换；得到的数组都是被删去的）toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。valueOf() 返回数组对象的原始值 不会更改原有数组的方法concat()连接两个或更多的数组，得到新数组。map()循环数组 会更改原有数组的方法splice()【删除，插入，替换；得到的数组都是被删去的】sort()【数组在原数组上进行排序，不生成副本。】 ++前后之区别前置自增：++在前，先+1，再取值，表达式的值即为自增后的值后置自增：++在后，先取值，再+1，表达式的值即为自增前的值 对象={属性：值}1var car = &#123;type=\"porsche\",color=\"white\"&#125; Number类的toFixed（）与toPrecision（） 两个方法返回的数字都是字符串形式。 toFixed（）把数字四舍五入转换为由参数指定小数位数的数字。（不采用科学记数法） toPrecision（） 规定Number对象的值超出参数指定的有效数字的位数时将其有效长度格式化为参数指定的长度。 当参数规定的有效数字的位数能包住Number对象时 注意：参数规定的有效数字的位数是从数字第一个不为0的数(包括整数部分和小数部分)开始计算的位数。 Number对象的值 &gt; 参数指定的有效数字的位数 时，采用定点记数法（使用小数点）【比如参数为5时，312=312.00;参数为2时，要求有效位数2位，0.8=0.80】 Number对象的值 &lt;= 参数指定的有效数字的位数 时，采用科学记数法。【比如参数为2时，1234.1234 = 12.341234*10^2 = 12.341234e10+2】 AngularJS1数据绑定的占位符AngularJS1中页面中用于数据绑定的占位符是{{ }} jquery获取当前窗口的宽度值在jquery中，如果想要获取当前窗口的宽度值,使用width() 在jquery中: width()方法设置或返回元素的宽度（不包括内边距padding、边框border或外边距margin）。 height()方法设置或返回元素的高度（不包括内边距padding、边框border或外边距margin）。 innerWidth()方法返回元素的宽度（包括内边距padding）。 innerHeight() 方法返回元素的高度（包括内边距padding）。 outerWidth()方法返回元素的宽度（包括内边距padding和边框border）。 outerHeight() 方法返回元素的高度（包括内边距padding和边框border）。 outerWidth(true) 方法返回元素的宽度（包括内边距padding、边框border和外边距margin）。 outerHeight(true) 方法返回元素的高度（包括内边距padding、边框border和外边距margin）。 12345678alert($(window).height()); //浏览器当前窗口可视区域高度 alert($(document).height()); //浏览器当前窗口文档的高度 alert($(document.body).height());//浏览器当前窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器当前窗口可视区域宽度 alert($(document).width());//浏览器当前窗口文档对象宽度 alert($(document.body).width());//浏览器当前窗口文档body的宽度 alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin 注意：区分jquery的innerheight（）与window的innerheight属性。window.innerheight 返回浏览器窗口的视口（viewport）高度（以像素为单位）；如果有水平滚动条，也包括滚动条高度。window.outerHeight属性设置或返回一个窗口的外部高度，包括所有界面元素（如工具栏/滚动条）。 变量与函数提升 变量声明会被提升，赋值语句不提升。使用 函数声明 时函数也会被提升，但使用 函数表达式 时不存在提升。（注意：函数表达式就是带等号的。函数在ES5中是整个函数被提升，在ES6中是只提升函数的声明（也就是只提升函数名），函数内容（变量初始化的值）是不会被提升的，他们将被留在原来的位置。） 变量声明、函数声明都会被提升到作用域顶处，且 函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被变量赋值后覆盖。 补充：当出现多个同名变量与同名函数时，调用该变量名时的优先级为：变量声明&lt; 函数声明 &lt; 变量赋值（具体参考20191215第7题、20200205第4题） 闭包 闭包内变量执行后不会被清除，要到整个闭包被清除的时候才会清除，比如局部变量要等到函数执行完之后。 自调用函数（立即执行函数）理论上是一个闭包。闭包可以访问其他函数内部变量的函数，而立即执行函数传参，相当于父级变量；闭包需要手动执行，不能自主释放内存；而立即执行函数相当于做了一次函数执行，最后释放内存。逻辑上立即执行函数可以理解为：声明闭包函数-执行-释放内存 &lt;link&gt;与&lt;script&gt; &lt;link&gt; 和href配合 加载css，hypertext reference超文本引用，页面加载到href时不会停下来。 &lt;script&gt;和src配合 加载script文件，source资源，页面会停下来等待资源加载完毕（并执行完），所以一般js放在body的最下面。 数组长度不包括数组的方法（函数） 首先要明确：数组也是对象 对象不能用length返回其拥有的属性数量 12345var arr = 0; arr[0] = 0; arr[1] = 1; arr.foo = 'C'; console.loa(arr.lenath);//2 这里要理解所谓‘数组’其实是array类型对象的一个特殊作用，就是：我们可以对它进行一种模式的数据存储，但除此之外，它依然是一个对象 var arr = [‘1’，‘2’] //这本质上是一系列操作：得到一个数组对象；调用了它的数组方法存入了一些数据，arr.length根据存入数据的数目被修改 arr.length，对arr对象的length属性进行一个访问 arr.foo = &#39;hello&#39; 对arr对象创建一个属性，所以.foo 跟.length地位是并列的：就是arr的一个属性**，同时arr的数组方法跟这些属性是毫不相关的。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"牛客网题目","slug":"牛客网题目","permalink":"http://yoursite.com/categories/牛客网题目/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"开发博客项目之接口(1)","slug":"Node.js开发博客项目之接口(1)","date":"2020-01-15T03:41:14.000Z","updated":"2020-02-16T12:05:45.331Z","comments":true,"path":"2020/01/15/Node.js开发博客项目之接口(1)/","link":"","permalink":"http://yoursite.com/2020/01/15/Node.js开发博客项目之接口(1)/","excerpt":"http-概述开发接口（不用任何框架）nodejs处理http请求搭建开发环境开发接口（暂不连接数据库，暂不考虑登录）","text":"http-概述开发接口（不用任何框架）nodejs处理http请求搭建开发环境开发接口（暂不连接数据库，暂不考虑登录） HTTP请求概述（从输入url到页面显示都经历了什么） 客户端（浏览器）： DNS解析：通过输入的域名解析到一个IP地址；建立TCP连接（三次握手）；发送http请求。 服务端： server接收到http请求，处理，并返回。（处理过程在下面“nodejs处理HTTP请求”中）（res返回的都是字符串，只是形式不同，通过content-type来决定，比如html或者json） 客户端（浏览器）： 接收到服务端返回的数据，处理数据（如渲染页面，执行js）。 实例演示 客户端（浏览器）进行DNS解析：浏览器或者操作系统本身是有缓存的，如果是缓存过期或者没有缓存又或者是第一次访问，浏览器或者操作系统就会去域名工程商去通过域名去DNS服务器换取IP地址。（更多详情需要复习 计算机网络 ） server端就是这个IP地址的服务器！！（百度比较大，全国各地使用人数多，看到的IP地址不一样是正常的，就算是自己今天看到的和昨天看到的不一样也是很正常的） 客户端找到IP地址之后就会和这个IP地址的服务器（server端）进行TCP连接（三次握手） 握手 作用 第1次 客户端（浏览器）询问服务器（server端）：“你是否可以使用？” 第2次 服务器（server端）回答客户端（浏览器）：“我可以用。” 第3次 客户端（浏览器）告诉服务器（server端）：“我知道啦，接下来我会访问你哦。” 客户端（浏览器）发送http请求：客户端（浏览器）通过url使用get方法向服务端发送http请求，头部包含了请求信息，他们告诉了服务端这个客户端（浏览器）是什么样子的以及有什么要求。 （注意：请求req都是客户端发起的，而回复res都是服务端做的。） 我们已经清楚：server端就是这个IP地址的服务器。 server端会通过Response Headers 告诉客户端：我反回的是html代码而不是纯文本： 客户端（浏览器）接收到server端返回的数据后就会解析这些html代码，解析完之后就会去渲染，渲染完后就会显示页面，页面显示之后就会加载图片、加载js、加载jquery、加载css等，这些又是另外的HTTP请求。（可能会通过一个网页产生很多的HTTP请求，当然请求越少性能越好） nodejs处理HTTP请求nodejs作为server端处理HTTP请求，这也是“从输入url到页面显示都经历了什么”中的第二个步骤。 主要讲解： get请求和querystring（客户端要向server端获取（索取）数据） post请求和postdata（客户端要向服务端传递数据） 路由（接口地址） 总结：无论是GET还是POST，nodejs处理HTTP请求的最基本思路就是我们（客户端）向服务端传递一些信息（我想向你获取/传递数据），然后服务端进行处理以后再返回给我们。 概括HTTP请求的代码流程 所有的HTTP请求都需要在开头引用node自带的http模块(const http = require(&quot;http&quot;)) 在中间通过http.createServer()创建一个服务器，http.createServer()的参数为一个函数，该函数通过 request, response 2个参数来接收和响应数据（参数名可自定义）。 最后在结尾监听端口（服务器名.listen(8000)）. request（req）和response（res）的属性/方法 创建服务器的http.createServer()的参数（回调函数）拥有两个参数：request和response（参数名可自定义，第一参数为请求，第二参数为响应） request 对象表示 HTTP 请求，包含了请求查询字符串，参数，内容，HTTP 头部等属性。 response 对象表示 HTTP 响应，即在接收到请求时向客户端（浏览器）发送的 HTTP 响应数据。 有不了解的属性可到nodejs文档中查询。 用到的request 对象的属性： request.method：客户端是用什么方法请求的(GET/POST)。 request.url:获取完整的url request.headers:客户端（浏览器）向服务端发送的请求中的头中的信息。request.headers[&quot;content-type&quot;]：请求的数据类型是什么（比如JSON）。 request.setHeader(name, value):为请求头对象设置单个请求头的值。 （例子） 用到的response 对象的属性： response.end()中要返回一个字符串：【必须在每个响应上调用response.end()】此方法向服务器发出信号，表明已发送所有响应头和主体，该服务器应该视为此消息已完成。用于让响应的代码结束。（文档解释） response.setHeader(name, value):设置单个响应头的值。假设我们通过response.setHeader(&#39;Content-Type&#39;, &#39;application/json&#39;); 将响应头的内容类型设置为JSON了，那么response.end()返回的虽然还是一个字符串，但这个字符串是JSON类型的（比如&#39;{&quot;name&quot;:&quot;shily&quot;,&quot;sex&quot;:&quot;女&quot;,&quot;age&quot;:&quot;23&quot;}&#39;;//json字符串）。（文档解释） 复习：string的split()将字符串转换为数组 split()可把一个字符串分割成字符串数组 stringObject.split(separator) separator:必需,分隔符.（分隔符可以使字符串） 在下面“处理get请求”例子中有所应用。 node自带的querystring模块 querystring和http一样也是node自带的一个模块。 a=querystring.parse()可将()中的字符串转换为对象后赋值给a 在下面“处理get请求”例子中有所应用。 处理get请求 get请求，即客户端要向server端获取（索取）数据，如查询博客列表 客户端通过querystring来向服务端传递数据(也就是url参数)，如a.html？a=100&amp;b=200也就是把a=100&amp;b=200传给了服务端，服务端收到后进行处理再返回相应的数据给到客户端。 浏览器直接访问，发送的就是get请求（像上面的“实例演示”中访问百度就是get请求） 例子新建文件夹“http-test”，在vscode中打开，因为不知道接下来会不会需要加载其他包，所以可以在终端先npm init -y初始化npm环境，初始化后会得到package.json，将首页改为app.js后新建主页： 123456789101112131415161718192021const http = require(\"http\")//querystring也是node自带的一个模块const querystring = require (\"querystring\")const server = http.createServer((req,res)=&gt;&#123; //GET，req.method：客户端是用什么方法请求的 console.log(\"method:\",req.method) const url = req.url console.log(\"url:\",url) //split()把 字符串 分割成 字符串数组,取第2个数组元素（`?`后的字符串） // 使用querystring.parse()可将（）中的字符串转换为对象后赋值给req.query req.query = querystring.parse(url.split(\"?\")[1]) console.log(\"query:\",req.query) //`end()`中要返回一个字符串,使用`stringify()`将JSON对象转换为字符串 res.end( JSON.stringify(req.query) )&#125;)//使用8000端口监听server对象server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 在终端测试,输入node app.js后得到OK说明监听成功：打开http://localhost:8000/得到的是一个空对象，这是因为query就是一个对象，而我们没有往里面放东西:输入http://localhost:8000/api/blog/list?author=hlz&amp;keyword=hahaha,也就是通过url参数(?后即url参数)往query里面放东西以后：可以看到终端返回的内容也有所变化：补充：终端中的url: /favicon.ico是浏览器默认的请求，主要是向服务端请求一个页面标志： 处理post请求post请求，即客户端要向服务端传递数据，如新建博客也就是客户端通过post data向服务端传递数据，服务端接收以后会进行处理。浏览器无法直接模拟，需要手写js，或者使用postman（不能像上面get请求一样直接通过浏览器访问某个页面来模拟） 安装postmanpostman可用于调试、发送HTTP请求。以前可以进入Google搜索postman chrome，或者可以点击这个链接进行postman插件的添加。现在只能直接去官网下载postman app。 数据流（获取数据的方式） nodejs中获取由客户端post请求发送过来的数据是采取数据流的方法，并不是传完再获取，是一边传一遍获取（可以想象为一根水管连着木桶） 三种处理数据流的方法on()有三个可选的第一个参数：data, end,error 在下面“POST请求的例子”中有所使用。 例子：假设readerStream是我们要读取的一大段数据： 1234567891011121314151617// 处理流事件 --&gt; data, end, and error//当接受到一点数据时就执行一次data（传入一次chunk），逐次累加在 allData 上let allData = \"\";readerStream.on('data', function(chunk) &#123; allData += chunk;&#125;);//数据传输结束，执行endreaderStream.on('end',function()&#123; console.log(allData);&#125;);readerStream.on('error', function(err)&#123; console.log(err.stack);&#125;);console.log(\"程序执行完毕\"); 可参考菜鸟教程 post请求的例子注意：每次修改nodejs代码内容后都需要在终端输入node app.js来重启node。 1234567891011121314151617181920212223const http = require(\"http\")const server = http.createServer((req, res) =&gt; &#123; if (req.method === \"POST\") &#123; //req 数据类型，目前只处理JSON，比较方便 console.log(\"req content-type\", req.headers[\"content-type\"]) //接收数据 let postData = \"\" //on()可参考上面“数据流”笔记 //每接受一点数据就执行一次data，chunk为接受的数据 req.on(\"data\", chunk =&gt; &#123; postData += chunk.toString() &#125;) //接收完毕执行end req.on(\"end\", () =&gt; &#123; console.log(\"postData:\", postData) res.end(\"hello world!\") &#125;) &#125;&#125;)//监听8000端口server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 在postman上的操作流程：postman接收到了hello world！说明服务端接收到了返回（res）。回到vscode终端可以看到（记得修改nodejs代码内容后需要在终端输入node app.js）：说明我们通过postman发送的数据真正到了node文件中，并且他是一个post请求，且它被我们通过data、on、end的方式被接收到了。 nodejs处理路由路由：代表了url资源唯一的标识。以github为例讲解一下路由： 例子123456789const http = require(\"http\")const server = http.createServer((req, res) =&gt; &#123; const url = req.url const path = url.split(\"?\")[0] res.end(path);//返回路由&#125;);server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 访问http://localhost:8000/api/blog/list?author=hlz&amp;keyword=hahaha 处理http请求的综合示例总结：无论是GET还是POST，nodejs处理HTTP请求的最基本思路就是我们向服务端传递了什么，然后服务端进行处理以后再返回给我们。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const http = require(\"http\")const querystring = require(\"querystring\")const server = http.createServer((req, res) =&gt; &#123; const method = req.method const url = req.url const path = url.split(\"?\")[0] const query = querystring.parse(url.split(\"?\")[1]) //设置返回的字符串格式为JSON res.setHeader(\"Content-type\", \"application/json\") //返回的数据 const resData = &#123; method, url, path, query &#125; //返回 if (method === \"GET\") &#123; res.end( //res.end()返回的一定是字符串，而上面设置的Content-type返回类型为json JSON.stringify(resData) ) &#125; if (method === \"POST\") &#123; let postData = \"\" req.on(\"data\", chunk =&gt; &#123; //把post过来的数据都放进postData中 postData += chunk.toString() &#125;) req.on(\"end\", () =&gt; &#123; //postData中的数据必须返回才能显示，所以放入resData中 resData.postData = postData //返回 res.end( JSON.stringify(resData) ) &#125;) &#125;&#125;)server.listen(8000)console.log(\"OK\")//返回一个OK证明监听成功 测试GET直接在网页测试GET请求，客户端通过querystring向服务端传递？后的query数据（也就是url参数），然后服务端将它们通过res返回到客户端，也就显示在页面上了： 测试POST在postman中进行POST请求的测试，客户端通过 postData 向服务端传递了两条数据（博客标题、博客内容），我们写的nodejs给予的处理是将 postData 放入 resData 中通过 res 返回到页面上，如图所示：","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"export和export default 的区别","slug":"export和export default的区别","date":"2020-01-15T02:06:51.000Z","updated":"2020-02-25T13:54:56.575Z","comments":true,"path":"2020/01/15/export和export default的区别/","link":"","permalink":"http://yoursite.com/2020/01/15/export和export default的区别/","excerpt":"export，export default,import是什么 ES6模块主要有两个功能：export和import export用于规定 对外输出本模块（一个文件可以理解为一个模块）变量的接口 而export default则是用于规定模块的默认对外接口，很显然默认对外接口只能有一个，所以 export default 在同一个模块中只能出现一次 import用于在一个模块中加载引用另一个含有export接口的模块。 也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。","text":"export，export default,import是什么 ES6模块主要有两个功能：export和import export用于规定 对外输出本模块（一个文件可以理解为一个模块）变量的接口 而export default则是用于规定模块的默认对外接口，很显然默认对外接口只能有一个，所以 export default 在同一个模块中只能出现一次 import用于在一个模块中加载引用另一个含有export接口的模块。 也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。 export 和 export default 区别1.export导出多个对象，export default只能导出一个对象。2.export导出对象需要用{ }，export default不需要{ }，如： 12export &#123;A,B,C&#125;;export default A; 3.仅允许表达式、函数或类作为export default导出,你想使用{ }导出对象时只能使用default。4.在其他文件引用export default导出的对象时不一定使用导出时的名字。因为这种方式实际上是将该导出对象设置为 默认导出对象，如：假设文件A、B在同级目录，实现文件B引入文件A的导出对象deObject。文件A导出：export default deObject;文件B引用：import deObject from &#39;./A&#39;或者import newDeObject from &#39;./A&#39;5.性能上export会略微好一些，建议使用export.","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"Redux入门（1）","slug":"Redux入门（1）","date":"2020-01-14T08:08:08.000Z","updated":"2020-07-22T04:09:51.709Z","comments":true,"path":"2020/01/14/Redux入门（1）/","link":"","permalink":"http://yoursite.com/2020/01/14/Redux入门（1）/","excerpt":"Redux概念简述 Redux 是全球范围内比较推荐的 和React进行搭配的 数据层框架。 无论程序多么复杂，都不需要我们手动传值了，数据传递的过程都是：组件数据改变-&gt; Store改变 -&gt; 其他组件取值 Redux=Reducer+Flux（Flux是FaceBook公司最早配合React推出的数据层框架，但是它问题很多，所以作者Dan引入Reducer的概念创造了Redux）","text":"Redux概念简述 Redux 是全球范围内比较推荐的 和React进行搭配的 数据层框架。 无论程序多么复杂，都不需要我们手动传值了，数据传递的过程都是：组件数据改变-&gt; Store改变 -&gt; 其他组件取值 Redux=Reducer+Flux（Flux是FaceBook公司最早配合React推出的数据层框架，但是它问题很多，所以作者Dan引入Reducer的概念创造了Redux） 复习：React视图层框架 在React的文档首页就说明了“A JavaScript library for building user interfaces”，也就是“React是一个用于创建用户接口的JavaScript库”。 React是轻量型的视图层框架，只能处理简单的数据关系（父子组件中的传值）多几层就只能一层一层传，具体可看笔记围绕 React 衍生出的思考或者下面的例子。 例子假设 绿色组件 想给很多灰色的组件 传值：如果我们改变了 绿色子组件 的数据，只使用React就需要先调用 绿色子组件的父组件的方法 改变 父组件中的相关值（第一次子组件向父组件传值），然后使用 同样的方法 层层传递，直到最顶端。如果我们想要方便的进行传值就需要搭配 数据层框架 结合使用。 使用Redux继续上面的例子当我们使用Redux时， 所有组件的数据都不放在自身，而是放在公共存储区域Store。 当绿色组件放在Store中的数据发生改变时，其他灰色组件就会感知到Store中的数据发生变化，自动到Store中获取改变的绿色组件的数据。 这样一来绿色组件的数据就很轻松的传给了其他灰色的组件。（实际上不需要有传递这一步） 使用Antd实现TodoList页面布局 Antd：React的UI框架（React的UI组件库）。 Antd（Ant Design of React）的官网 antd可以非常方便快捷的完成一个后端的页面布局，但是由于我们接下来做的是用户端，所以可能并不会用到特别多antd。 接下来的例子会使用React和Redux重新编写TodoList的页面布局。 安装Antd（React的UI组件库）在官网中提到，使用 npm 或 yarn 安装： 1yarn add antd 安装完成后重启服务器： 1npm start 使用Antd引入样式： 1import 'antd/dist/antd.css'; // or 'antd/dist/antd.less' 需要什么组件就引入什么组件，比如我想放入一个&lt;input&gt;框，就可以到官网搜索得到：选择一个喜欢的，查看他的代码，使用即可： 完整例子： 123456789101112131415161718import React, &#123; Component &#125; from 'react'import 'antd/dist/antd.css';import &#123; Input &#125; from 'antd';class TodoList extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;div&gt; &lt;Input placeholder=\"Todo info\" style=&#123;&#123; width: \"300px\" &#125;&#125; /&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125;export default TodoList; 选一个按钮button： 12345678910111213141516171819import React, &#123; Component &#125; from 'react'import 'antd/dist/antd.css';import &#123; Input, Button &#125; from 'antd';class TodoList extends Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: \"10px\", marginLeft: \"10px\" &#125;&#125;&gt; &lt;div&gt; &lt;Input placeholder=\"Todo info\" style=&#123;&#123; width: \"300px\", marginRight: \"10px\" &#125;&#125; /&gt; &lt;Button type=\"primary\"&gt;提交&lt;/Button&gt; &lt;/div&gt; &lt;/div &gt; ) &#125;&#125;export default TodoList; 加入列表list： 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'import 'antd/dist/antd.css';import &#123; Input, Button, List &#125; from 'antd';// 列表数据放在外部（全局）const data = [ 'Racing car sprays burning fuel into crowd.', 'Japanese princess to wed commoner.', 'Australian walks 100km after outback crash.', 'Man charged over missing wedding girl.', 'Los Angeles battles huge wildfires.',];class TodoList extends Component &#123; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: \"10px\", marginLeft: \"10px\" &#125;&#125;&gt; &lt;div&gt; &lt;Input placeholder=\"Todo info\" style=&#123;&#123; width: \"300px\", marginRight: \"10px\" &#125;&#125; /&gt; &lt;Button type=\"primary\"&gt;提交&lt;/Button&gt; &lt;/div&gt; &lt;List style=&#123;&#123; marginTop: \"10px\", width: \"300px\" &#125;&#125; bordered dataSource=&#123;data&#125; renderItem=&#123;item =&gt; &lt;List.Item&gt;&#123;item&#125;&lt;/List.Item&gt;&#125; /&gt; &lt;/div &gt; ) &#125;&#125;export default TodoList; Redux的工作流程 注意获取store中数据时： Redux中store是最重要的，首先就要编写数据存储的仓库（store）。 但是光创建 store 是没用的，这个“图书管理员”什么都不知道，还需要同时创建“管理员的记录本”Reducers然后给到这个“图书管理员”store。 reducer返回（输出）的是一个函数,函数中的 参数state 就是整个store中存储的数据(参数action在后面”改变store中数据”中讲)。 现在store里已经有数据了，reducer也创建好了，那么组件就可以连接store去里面取数据然后显示出来了。 改变store中数据时： 想要改变store中的数据就需要在 组件 中创建一个action。（在react中，action是一个对象的形式，type属性 描述要做的事情，value属性 为需要传的值。）【注意：value属性名是自定义的，根据你需要传的值的名字来定】 store提供了一个dispatch方法,可使用store.dispatch(action)将action传给store。 store将自动将 接收到的数据 和action一起传给reducer，reducer返回的函数中的state就是 上次传过来的数据，action就是组件想要修改state的那句话。 reducer会根据store传来的 上一次的数据（state） 和action整合起来后进行处理，给store返回一个新数据newState。 reducer处理过程：reducer 可以接受state，但是决不能修改state。所以我们需要对store传进来的state进行深拷贝成newState，然后再进行action的处理，最后返回newState给store 此时页面和store数据并未同步，需要使用在 组件的构造函数 中使用store.subscribe(this.handleStoreChange);让组件订阅store，那么只要store发生改变，handleStoreChange函数 就会被执行一次。 在handleStoreChange函数中，使用getState（）获取store中的数据 替换 组件中的state数据，组件的state发生改变后，页面自然重新渲染。 流程总结获取store数据： 创建Redux中的store（src-store-index.js） 创建Reducer(src-store-reducer.js)并将state中 默认数据 设置好 在store中引入Reducer并在创建store时将Reducer 作为第一个参数传给store，以便获取 默认state数据（defaultState） 组件TodoList.js去连接store，获取数据然后显示在页面上 改变store数据： 点击输入框时，在组件中创建 对象action，type属性 描述要做的事情，value属性 为需要传的值。（TodoList.js-handleInputChange（）） 使用store.dispatch(action)将action传给store。（TodoList.js-handleInputChange（）） store自动将 接收到的数据（state） 和action一起传给reducer reducer会根据store传来的 上一次的数据（state） 和action整合起来后进行处理，给store返回一个新数据newState（reducer.js中输出的函数中） reducer处理过程：对store传进来的state进行深拷贝成newState，然后再进行action希望的处理，最后返回newState给store 在 组件的构造函数 中使用store.subscribe(this.handleStoreChange);让组件订阅store，那么只要store发生改变，handleStoreChange函数 就会被执行一次。 在handleStoreChange函数中，使用getState（）获取store中的数据 替换 组件中的state数据。那么组件的数据一更新页面自然重新渲染。 使用redux获取store数据(state)首先需要在项目中添加redux，执行: 1yarn add redux 创建Redux中的store创建store在src下创建 文件夹store，在此文件夹下创建index.js用于创建store: 12345678// 引入`redux`库的`createStore`模块import &#123; createStore &#125; from \"redux\";// 使用`createStore()`创建storeconst store = createStore();// 记得输出export default store; 创建reducer在文件夹store下创建reducers.js用于创建reducer(state就是整个store中存储的数据)【reducer返回（输出）的是一个函数】: 123456const defaultState = &#123;&#125;;// 默认state为空对象：默认store上什么数据都没有export default (state = defaultState, action) =&gt; &#123; return state;&#125; state就是整个store中存储的数据，defaultState是我们定义的默认数据，也就是一开始放在store中存储的数据。我们知道实际上TodoList需要存储的是两个数据：inputValue和list，所以我们可以将它们放在默认数据defaultState中： 1234const defaultState = &#123; inputValue: \"请输入一些待办事项\", list: [\"吃饭\",\"睡觉\"]&#125;; stroe中引入reducer在stroe(index.js)中引入reducer:在index.js中引入reducers（图书管理员拿到记录本）,并且在创建store时将reducers作为第一个参数传给store： 1234567import &#123; createStore &#125; from \"redux\";import reducer from \"./reducer\";// 创建store,将reducers作为第一个参数传给storeconst store = createStore(reducer);export default store; 现在store里已经有数据了，reducer也创建好了，那么组件就可以连接store去里面取数据然后显示出来了。 组件TodoList连接store获取数据注意： 组件引入时，./store相当于./store/index.js，因为会默认到index.js中去寻找组件。 组件store提供了getState（）用于获取store中存储的数据。 在TodoList.js中删除我们原本列表写死的数据。引入store。使用getState（）获取store中存储的数据并保存在组件TodoList的state中。将state中的数据用于input框的value值（输入框默认显示）与list列表的datasource(列表的数据来源)： 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from 'react'import 'antd/dist/antd.css';import &#123; Input, Button, List &#125; from 'antd';// `./store`相当于`./store/index.js`import store from \"./store\";class TodoList extends Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); &#125; render() &#123; return ( &lt;div style=&#123;&#123; marginTop: \"10px\", marginLeft: \"10px\" &#125;&#125;&gt; &lt;div&gt; &lt;Input value=&#123;this.state.inputValue&#125; placeholder=\"Todo info\" style=&#123;&#123; width: \"300px\", marginRight: \"10px\" &#125;&#125; /&gt; &lt;Button type=\"primary\"&gt;提交&lt;/Button&gt; &lt;/div&gt; &lt;List style=&#123;&#123; marginTop: \"10px\", width: \"300px\" &#125;&#125; bordered dataSource=&#123;this.state.list&#125; renderItem=&#123;item =&gt; &lt;List.Item&gt;&#123;item&#125;&lt;/List.Item&gt;&#125; /&gt; &lt;/div &gt; ) &#125;&#125;export default TodoList; 安装chrome插件Redux DevTools Redux DevTools可以帮助我们进行redux的调试。 “扩展程序” - 打开 Cent Browser 网上应用商店 - 搜索Redux DevTools - 添加 ：显示“找不到store，需要跟着指南做配置”。 配置过程首先需要我们在store文件夹下的index.js中创建store时传入第二个参数： 12345678910import &#123; createStore &#125; from \"redux\";import reducer from \"./reducer\";// 创建store,将reducers作为第一个参数传给storeconst store = createStore( reducer, window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; window.__REDUX_DEVTOOLS_EXTENSION__());export default store; 该参数的意思是“如果window下安装了__REDUX_DEVTOOLS_EXTENSION__这个扩展程序就在页面上使用__REDUX_DEVTOOLS_EXTENSION__这个工具”。 此时点开控制面板就可以看到state里面的数据： 使用redux改变store中数据(action)input框内数据改变时改变store中的值首先我们希望input框内数据改变时，state中的inputValue也跟着变。 在TodoList.js的render函数中，给input框 绑定onChange事件函数handleInputChange（）： 123456&lt;Input value=&#123;this.state.inputValue&#125; placeholder=\"Todo info\" style=&#123;&#123; width: \"300px\", marginRight: \"10px\" &#125;&#125; onChange=&#123;this.handleInputChange&#125;/&gt; 在TodoList.js的构造函数中，绑定this指向：【注意：这里的store是顶部import store from &quot;./store&quot;;已经引用的store】 12345constructor(props) &#123; super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this);&#125; 在事件函数handleInputChange（）中通过打印测试是否能在 input框 中发生改变时获取到 input框 中的 value值： 123handleInputChange(e) &#123; console.log(e.target.value);&#125; 那么接下来就要告诉store,我想让store中的state的inputValue改成e.target.value。 创建action传给store那么我们就需要创建一个action,在react中，action是一个对象的形式，type属性 描述要做的事情，value属性 为需要传的(现在的)值。store提供了一个dispatch方法,可使用该方法将action传给store：【注意：这里的store是顶部import store from &quot;./store&quot;;已经引用的store】 12345678910handleInputChange(e) &#123; // `action`是一个对象的形式 const action = &#123; // `type`描述要做的事情，`value`为需要传的(现在的)值 type: \"change_input_value\", value: e.target.value &#125; // 用`store`的`dispatch`方法将`action`传给`store` store.dispatch(action)&#125; 此时数据已经传递给了store,可是这个“管理员”不知道怎么处理数据，就去查阅“小手册”，所以store会自动将 接收到的数据 和action一起传给“小手册”reducer。（reducer返回的函数中的state就是 上次传过来的数据，action就是组件想要修改state的那句话）接下来，reducer会根据store传来的 （上一次的）数据 和action整合起来后，进行处理，给store返回一个新数据newState。 reducer处理并返回newStatereducer处理过程：reducer 可以接受state，但是决不能修改state。所以我们需要对store传进来的state进行深拷贝成newState，然后再进行action的处理，最后返回newState给store： 12345678910111213// state为store中上一次数据，action由组件发出// reducer 可以接受state，但是决不能修改stateexport default (state = defaultState, action) =&gt; &#123; if (action.type === \"change_input_value\") &#123; // 不能修改state，故先深拷贝为newState const newState = JSON.parse(JSON.stringify(state)); // action处理 newState.inputValue=action.value; // 把newState返回给store return newState; &#125; return state;&#125; 此时输入“aaa”已经可以在改变store中的state，但页面显示效果还没变。 组件与store数据同步(订阅store)在组件TodoList.js中，使用store.subscribe()订阅store。只要store发生改变，subscribe（）内作为参数的函数就会被执行一次:【注意：这里的store是顶部import store from &quot;./store&quot;;已经引用的store】 12345678constructor(props) &#123; super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); // 只要`store`发生改变，handleStoreChange函数就会被执行一次 store.subscribe(this.handleStoreChange);&#125; 当感知到store发生改变时，函数handleStoreChange（）就会被执行，函数中将使用getState（）获取store中的数据后，使用setatate()来改变 组件 中的state(组件 中的state改变，页面自然重新渲染): 1234handleStoreChange() &#123; // 使用`getState（）`获取`store`中的数据 替换 组件中的`state` this.setState(store.getState());&#125; 此时页面效果就和store中的数据同步了。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"DOM 元素的 children 与 childNodes 属性","slug":"children","date":"2020-01-13T11:21:07.000Z","updated":"2020-08-04T09:26:32.852Z","comments":true,"path":"2020/01/13/children/","link":"","permalink":"http://yoursite.com/2020/01/13/children/","excerpt":"children 与 childNodes 的区别childNodes 属性返回所有的节点，包括文本节点、注释节点。children 属性只返回元素节点。","text":"children 与 childNodes 的区别childNodes 属性返回所有的节点，包括文本节点、注释节点。children 属性只返回元素节点。 HTML DOM children 属性(子元素) children 属性返回元素的子元素的集合，是一个 HTMLCollection 对象（类似数组，有length属性，可使用index访问对应元素）。 根据子元素在元素中出现的先后顺序进行排序，可以使用序列号(index，起始值为0)访问每个子元素。 可以使用 HTMLCollection对象 的 length属性获取子元素的数量 HTML DOM childNodes 属性（所有节点） childNodes 属性返回包含被选节点的子节点的 NodeList。 空格和换行都会被看做一个文本节点。 例子 相关题目题目分析下面代码，对于该段代码分析说法正确的是（ ） 123456789101112131415161718192021222324&lt;html&gt;&lt;body&gt; &lt;div id=\"ele\" class=\"div\"&gt; &lt;span id=\"s1\" class=\"sp\" lang=\"zh-cn\"&gt; &lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\"&gt; function exct() &#123; var oEle = document.getElementById(\"ele\"); var child = oEle.children; console.log(\"ele.children的执行结果是:\"); for(i = 0; i &lt; child.length; i++)&#123; console.log(child[i].tagName); &#125; child = oEle.childNodes; console.log(\"ele.childNodes的执行结果是:\"); for(i = 0; i &lt; child.length; i++)&#123; console.log(child[i].tagName); &#125; &#125; exct (); &lt;/script&gt;&lt;/html&gt; 答案其运行结果是： 123456div1.children的执行结果是:SPANdiv1.childNodes的执行结果是:undefinedSPANundefined 对于DOM元素，children是指DOM Object类型的子对象，不包括tag之间隐形存在的TextNode，而childNodes包括tag之间隐形存在的TextNode对象。 解释div元素下虽然只有一个span元素，但有3个子节点。因为childNodes获取子节点没有类型限制，span是一个元素节点，还有两个文本节点：空格和换行都被看做一个文本节点。所以，3个子节点 = 两个文本节点 + 一个元素节点。tagName用来获取元素的标签名，文本节点没有标签名，所以也就为undefined了。 参考链接 HTML DOM children 属性 HTML DOM childNodes 属性","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"react-transition-group实现多元素之间的动画","slug":"react-transition-group实现多元素之间的动画","date":"2020-01-13T03:47:18.000Z","updated":"2020-07-21T15:09:59.990Z","comments":true,"path":"2020/01/13/react-transition-group实现多元素之间的动画/","link":"","permalink":"http://yoursite.com/2020/01/13/react-transition-group实现多元素之间的动画/","excerpt":"TransitionGroup配合CSSTransition 回到文档中,我们可以看到有react-transition-group有四个组件：Transition、CSSTransition、SwitchTransition、TransitionGroup。 上一篇笔记我们学习了使用CSSTransition实现单个元素的动画效果。 如果我们想实现多个元素之间的动画效果，就要使用TransitionGroup配合CSSTransition：TransitionGroup写在 所有被控制的 DOM元素/组件 的外部,管理所有；CSSTransition写在 具体（单个） DOM元素/组件 的外部，管理单个动画效果。 TransitionGroup文档和例子","text":"TransitionGroup配合CSSTransition 回到文档中,我们可以看到有react-transition-group有四个组件：Transition、CSSTransition、SwitchTransition、TransitionGroup。 上一篇笔记我们学习了使用CSSTransition实现单个元素的动画效果。 如果我们想实现多个元素之间的动画效果，就要使用TransitionGroup配合CSSTransition：TransitionGroup写在 所有被控制的 DOM元素/组件 的外部,管理所有；CSSTransition写在 具体（单个） DOM元素/组件 的外部，管理单个动画效果。 TransitionGroup文档和例子 注意： 实现多个元素之间的动画效果时，不再需要CSSTransition标签中的属性in={this.state.show}， key值加载循环的单个组件的最外层标签上。（当我们使用CSSTransition标签包裹 其他标签 来控制动画效果时，这个 被控制标签 的key值就要放到CSSTransition标签内。） setState()有一个参数prevState表示上一次的state数据。 JS变量/表达式 写在 JSX语法中，需要使用{}包裹。 例子实现效果：每一次点击按钮就会在页面上添加一个div显示“hello world”,并在所有div元素上都显示出动画效果（入场动画（执行的是fade-enter前缀的三个样式））。 先实现点击按钮添加item在App.js中，暂时隐藏App.js中的CSSTransition标签，，删去div标签和handleToggle函数，给按钮绑定点击事件函数handleAddItem,每次点击按钮就在页面上添加一个div标签“item”。 1&lt;button onClick=&#123;this.handleAddItem&#125;&gt;toggle&lt;/button&gt; 将state中的 布尔值show 换成 数组list，用于存放每次点击后添加的div标签（“item”）的数据。并绑定事件函数的this指向: 1234567constructor(props) &#123; super(props); this.state = &#123; list: [] &#125; this.handleAddItem = this.handleAddItem.bind(this);&#125; 在按钮的事件绑定函数handleAddItem中，每次点击后都使用setState()把新的item存到list数组中（记住setState有一个参数prevState表示上一次的state数据），使用return返回一个对象： 1234567handleAddItem() &#123; this.setState((prevState) =&gt; &#123; return &#123; list: [...prevState.list, \"item\"] &#125; &#125;)&#125; 在render函数的return中，使用map()循环展示list中的每一项item,并将其放到div标签中返回（注意：JS变量/表达式 写在 JSX语法中，需要使用{}包裹）：【注意：这里返回的是使用map产生的数组，不能用forEach。在jsx渲染中,如果这个变量是一个数组，则会展开这个数组的所有成员】 1234567&#123; this.state.list.map((item,index) =&gt; &#123; return ( &lt;div key=&#123;index&#125;&gt;&#123;item&#125;&lt;/div&gt; ) &#125;)&#125; 此时每点击一次按钮就能在页面上添加一个“item”，但还没有动画效果： 添加动画效果在App.js中引入组件TransitionGroup（相关文档）: 1import &#123; CSSTransition,TransitionGroup &#125; from 'react-transition-group'; 使用TransitionGroup配合CSSTransition：TransitionGroup写在 所有被控制的 DOM元素/组件 的外部,管理所有；CSSTransition写在 具体（单个） DOM元素/组件 的外部，管理单个动画效果: 123456789101112131415161718&lt;TransitionGroup&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;CSSTransition timeout=&#123;1000&#125; classNames=\"fade\" unmountOnExit onEntered=&#123;(el) =&gt; &#123; el.style.color = \"blue\" &#125;&#125; appear=&#123;true&#125; key=&#123;index&#125; &gt; &lt;div&gt;&#123;item&#125;&lt;/div&gt; &lt;/CSSTransition&gt; ) &#125;) &#125;&lt;/TransitionGroup&gt; (（key值加载循环的单个组件的最外层标签上。（当我们使用CSSTransition标签包裹 div标签 来控制动画效果时，这个 div标签 的key值就要放到CSSTransition标签内。） 结果此时每一次点击的按钮都会有入场动画（执行的是fade-enter前缀的三个样式）：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"使用react-transition-group实现动画","slug":"使用react-transition-group实现动画","date":"2020-01-12T04:25:00.000Z","updated":"2020-03-06T13:16:11.784Z","comments":true,"path":"2020/01/12/使用react-transition-group实现动画/","link":"","permalink":"http://yoursite.com/2020/01/12/使用react-transition-group实现动画/","excerpt":"复习：三目运算符b?x:y对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。","text":"复习：三目运算符b?x:y对于条件表达式b ? x : y，先计算条件b，然后进行判断。如果b的值为true，计算x的值，运算结果为x的值；否则，计算y的值，运算结果为y的值。 React中实现CSS过渡动画 实现功能：点击button实现hello的显示或隐藏。 注意：render函数中只能return一个父标签，可以借助react的Fragment占位符，它并不会被渲染成任何一个标签。（Fragment在react库中，需引用才能使用） CSS中： opacity属性 为1时显示，为0时隐藏。transition属性 可实现过渡效果。【opacity 不透明；transition 过渡】 例子：1.将TodoList文件夹中src文件夹下删为仅剩一个index.js文件。在index.js中引入并挂载 组件APP 到 root节点 上: 123import App from './App';ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 2.新建APP.js编写 组件APP 的 render函数 ，写出页面上的两个元素div和button： 12345678render() &#123; return ( &lt;Fragment&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;button&gt;toggle&lt;/button&gt; &lt;/Fragment&gt; );&#125; 注意，Fragment需要先引用才能使用： 1import React, &#123; Component, Fragment &#125; from 'react'; 3.补充APP.js中的 constructor构造函数 ，将 div 显示与否 的 决定属性show 存在state中，使用show的值给div加上一个className属性，给button绑定一个 onclick事件函数 handleToggle，点击时让show在false与true之间进行变换（记得绑定函数handleToggle的this指向）： 123456789101112131415161718192021222324252627282930import React, &#123; Component, Fragment &#125; from 'react';class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; show: true &#125; this.handleToggle = this.handleToggle.bind(this); &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div className=&#123;this.state.show ? \"show\" : \"hide\"&#125;&gt;hello world&lt;/div&gt; &lt;button onClick=&#123;this.handleToggle&#125;&gt;toggle&lt;/button&gt; &lt;/Fragment&gt; ); &#125; handleToggle() &#123; this.setState(() =&gt; &#123; return (&#123; show: this.state.show ? false : true &#125;) &#125;) &#125;&#125;export default App; 结果：虽然点击按钮看不到效果变化，但实际className还是发生了改变，所以接下来我们就去设置CSS。 4.设置CSS.js并在 APP.js 中使用import &quot;./style.css&quot;;进行引用,CSS.js: 123456.show&#123; opacity: 1;&#125;.hide&#123; opacity: 0;&#125; 结果：此时点击按钮可使“hello”消失/显示，但没有过渡效果，我们可以加上 transition属性 实现过渡效果： 12345678.show&#123; opacity: 1; transition: all 1s ease-in;&#125;.hide&#123; opacity: 0; transition: all 1s ease-in;&#125; React中使用CSS动画效果 实现功能：点击按钮时，hello经过红色、绿色、蓝色过渡，最后显示/消失。 什么叫CSS动画效果：通过 @keyframes 定义一些CSS动画，然后在选择器中通过 animation属性 进行动画的调用。 CSS3中 animation属性 有 forwards属性值 :可以使动画结束后保留最后一个效果的样式. 例子：修改style.css，通过 @keyframes 定义一些CSS动画，然后在选择器中通过 animation属性 进行动画的调用。（使用 animation属性 代替 opacity属性）: 12345678910111213141516171819202122.show&#123; opacity: 1; transition: all 1s ease-in;&#125;.hide&#123; animation: hide-item 2s ease-in; transition: all 1s ease-in;&#125;@keyframes hide-item&#123; 0%&#123; opacity: 1; color: red; &#125; 50%&#123; opacity: 0.5; color: green; &#125; 100%&#123; opacity: 0; color: blue; &#125;&#125; 结果：此时可以发现动画效果已实现，但是蓝色以后hello又回到黑色，并未消失，这是因为动画执行结束后，最后一个效果不会被保持下来。CSS3中有 forwards属性值 ，它可以使动画结束后保留最后一个效果的样式： 1234.hide&#123; animation: hide-item 2s ease-in forwards; transition: all 1s ease-in;&#125; 结果：可以发现动画效果后hello消失。 给 显示 也设置动画效果： 123456789101112131415161718192021222324252627282930313233343536.show&#123; animation: show-item 2s ease-in forwards; transition: all 1s ease-in;&#125;.hide&#123; animation: hide-item 2s ease-in forwards; transition: all 1s ease-in;&#125;@keyframes show-item&#123; 0%&#123; opacity: 0; color: red; &#125; 50%&#123; opacity: 0.5; color: green; &#125; 100%&#123; opacity: 1; color: blue; &#125;&#125;@keyframes hide-item&#123; 0%&#123; opacity: 1; color: red; &#125; 50%&#123; opacity: 0.5; color: green; &#125; 100%&#123; opacity: 0; color: blue; &#125;&#125; 使用react-transition-group实现动画react-transition-group：react动画的第三方模块上面我们讲解的 CSS动画 比较局限，涉及到 JS动画 的部分就无法处理。借助 react-transition-group 这个第三方模块 ，我们可以更加方便的做一些动画效果。 安装react-transition-group模块进入github - 搜索react-transition-group - 选择星标最多的 - 下拉点击Main documentation(主文档) - 安装提示，在命令行中输入： 12# yarnyarn add react-transition-group 重新启动项目： 1npm start 接着回到文档可以看到下面有 四个 动画组件 ： 学习CSSTransition组件 我们主要讲解CSSTransition。 Transition组件 是比CSSTransition组件更低层的存在，当我们利用CSSTransition组件无法实现一些效果时，可以到Transition组件中去找。 官方文档的 Example 中可以看到 &lt;CSSTransition&gt; 有以下属性（/JS钩子）： 12345678&lt;CSSTransition in=&#123;showMessage&#125; timeout=&#123;300&#125; classNames=\"alert\" unmountOnExit onEnter=&#123;() =&gt; setShowButton(false)&#125; onExited=&#123;() =&gt; setShowButton(true)&#125;&gt; in属性in属性 告诉CSSTransition 被控制元素的 入场/出场状态 ，CSSTransition需要给 被控制的元素 增加/删除 一些样式，而 in属性 就是告诉了CSSTransition 属性值 false-&gt;true时 入场，true-&gt;false时 出场。 timeout属性动画持续的毫秒数（1000毫秒=1秒） classNames属性 注意有个s，属性值为 自动挂载的样式 的前缀。（也就是说它决定了该组件的样式都有哪些） classNames属性值可以使官方文档中给定的，也可以是自定义的字符串，属性值决定了 自动挂载的样式 的前缀。 比如下面的样式fade-appear的前缀就是fade，那么我们就要设置classNames=&#39;fade&#39;，这样对应的样式才会生效。 unmountOnExit属性该属性不需要属性值，添加该属性后，被控制的元素完成出场动画后将直接消失在页面（不会留下一个空白位置）。 JS钩子 钩子 相当于 生命周期函数，他们都是某一时刻会自动执行的函数。 属性值就是个JS钩子（函数）。 该函数可以接收一个自命名参数，该参数 指 被CSSTransition控制的元素。 onEnter、onEntering、onEntered onEnter：当入场动画执行的第一个时刻，onEnter钩子（函数）就会被自动执行。 onEntering：当入场动画执行第二帧时，onEntering钩子（函数）就会被自动执行。 onEntered：当入场动画执行完成后，onEntered钩子（函数）就会被自动执行。 onExit、onExiting、onExiting onExit：当出场动画执行的第一个时刻，onExit钩子（函数）就会被自动执行。 onExiting：当出场动画执行第二帧时，onExiting钩子（函数）就会被自动执行。 onExiting：当出场动画执行完成后，onExited钩子（函数）就会被自动执行。 自动挂载的样式(classNames) 官方文档中 Example 下给出了很多自动挂载的样式(classNames)，比如fade-appear, fade-appear-active, fade-appear-done,fade-enter, fade-enter-active, fade-enter-done, fade-exit,fade-exit-active, fade-exit-done. 注意：这些样式的前提是CSSTransition组件的classNames=&quot;fade&quot;classNames属性值是自定义的字符串，属性值决定了样式的前缀 使用方法：.fade-appear{color: red;} 需要先设置CSSTransition标签的属性classNames=&quot;fade&quot;才能使用这些fade前缀的样式。 需要先设置CSSTransition标签的属性appear={true}，才能使用fade-appear, fade-appear-active, fade-appear-done。 入场动画相关的样式 入场动画相关的样式：fade-enter、fade-enter-active、fade-enter-done fade-enter：入场动画执行的第一个时刻，CSSTransition会往 被控制的元素上 增加fade-enter样式。 fade-enter-active：入场动画执行的第二个时刻到入场动画执行完成之前，此时 被控制的元素上 会一直有fade-enter-active样式。 fade-enter-done：整个入场动画执行完成之后，fade-enter-done样式会被增加并保持在 被控制的元素上。 出场动画相关的样式 出场动画相关有：fade-exit、fade-exit-active、fade-exit-done。 fade-exit：出场动画执行的第一个时刻，CSSTransition会往 被控制的元素上 增加fade-exit样式。 fade-exit-active：出场动画执行的第二个时刻到出场动画执行完成之前，此时 被控制的元素上 会一直有fade-exit-active样式。 fade-exit-done：整个入场动画执行完成之后，fade-exit-done样式会被增加并保持在 被控制的元素上。 刷新页面执行的动画相关样式 刷新页面执行的动画相关样式有：fade-appear、fade-appear-active、fade-appear-done 在页面刷新，DOM元素的第一次渲染时的动画效果就由这些样式来决定。 注意：需要先设置CSSTransition标签的属性appear={true}，才能使用fade-appear, fade-appear-active, fade-appear-done。 fade-appear-done不设置时，页面显示默认的状态作为动画效果的最后一个状态保持。 CSSTransition例子之前我们是自己在state中设置一个show值用于改变div的 className（样式名字），达到 div元素显示/删除 的工作，现在CSSTransition会帮我们完成一些 样式名字 的 添加/删除 工作，只需要使用&lt;CSSTransition&gt;标签包裹需要被控制的元素（div）并进行属性设置即可。 在App.js中引用CSSTransition组件： 1import &#123; CSSTransition &#125; from 'react-transition-group'; 使用CSSTransition标签包裹需要被控制的div标签： 1234567&lt;CSSTransition in=&#123;this.state.show&#125; timeout=&#123;1000&#125; classNames=\"fade\"&gt; &lt;div&gt;hello world&lt;/div&gt;&lt;/CSSTransition&gt; 将原本的style.css删除掉，改为: 12345678910.fade-enter&#123; opacity: 0;&#125;.fade-enter-active&#123; opacity: 1; transition: opacity 1s ease-in;&#125;.fade-enter-done&#123; opacity: 1;&#125; 结果：在页面上可以看到点击按钮，show值由false-&gt;true时，页面有动画效果（入场效果）。接下来增加 出场动画 ： 12345678910.fade-exit&#123; opacity: 1;&#125;.fade-exit-active&#123; opacity: 0; transition: opacity 1s ease-in;&#125;.fade-exit-done&#123; opacity: 0;&#125; 效果：做到这里完成的效果与上一个例子效果一样，看起来似乎并没有简化，但是下面增加的就是CSSTransition带来的简化。 使用unmountOnExit属性在CSSTransition标签内增加unmountOnExit属性，该属性不需要属性值。添加该属性后，被控制的元素完成出场动画后将直接消失在页面（不会留下一个空白位置）。 使用JS钩子onEntered实现效果：hello显示完成后变为红色。实现方法：我们可以在CSS中通过改变.fade-enter-done选择器内的color实现，也可以通过 JS钩子onEnter 实现。 在CSSTransition标签内增加: 1onEntered=&#123;(el) =&gt; &#123; el.style.color = \"blue\" &#125;&#125; appear属性与对应的样式做到这儿可以发现一个小问题：页面刚刷新时并不会显示动画效果，如果我们希望元素首次挂载在页面上就显示动画效果，可以使用appear属性，但appear属性对应的CSS样式并不是.fade-enter那几个，是fade-appear前缀的三个样式。 在App.js中添加CSSTransition标签的appear属性： 1appear=&#123;true&#125; 在style.css中增加.fade-appear和.fade-appear-active: 1234567.fade-enter,.fade-appear&#123; opacity: 0;&#125;.fade-enter-active,.fade-appear-active&#123; opacity: 1; transition: opacity 1s ease-in;&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"关于setState()","slug":"关于setState()","date":"2020-01-11T08:08:55.000Z","updated":"2020-02-25T14:01:51.934Z","comments":true,"path":"2020/01/11/关于setState()/","link":"","permalink":"http://yoursite.com/2020/01/11/关于setState()/","excerpt":"setState()是异步的setState是一个异步方法，可以集中执行多数据的更新，从而减少虚拟DOM比对次数，提升性能。","text":"setState()是异步的setState是一个异步方法，可以集中执行多数据的更新，从而减少虚拟DOM比对次数，提升性能。 不推荐在setState()中直接修改state数据不推荐直接修改state中的数据，如： 1234this.state.list.splice(xxx)this.setState(&#123; list:this.state.list &#125;) 这样做确实可以生效，但应该遵循immutable的原则而尽量避免直接修改state中的数据，应改为（注意：一维数组可以这样，但是如果数组元素有引用对象就要注意深拷贝）： 12345const list = [...this.state.list]list.splice(xxx)this.setState(&#123; list&#125;) 推荐使用setState()返回函数setState()可以返回一个函数，也推荐大家尽量使用函数式setstate()，如： 123456handleInputChange(e)&#123; const value = e.target.value this.setState(()=&gt;(&#123; inputValue: value &#125;))&#125; 注意:不能直接inputValue:e.target.value，而要先在setState()外做一份拷贝保存一下，再在setState()内使用，否则会由于异步的问题报错。 setState()的回调函数接收两个参数函数式setState()的回调函数可以接受两个参数：prevState, props 123this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment &#125;)) 第一个参数是原始state，等同于this.state，第二个参数是父组件传递的属性。 setState()的第二个参数（回调函数）setState()接收的第一个参数是异步的，而setState()本身还可以接收第二个参数（回调函数），这个函数解决由于setState是异步的，有些事件我们需要等setState更新完才触发的问题。如: 1234567this.setState(()=&gt;&#123; return &#123; inputValue: value &#125;&#125;, ()=&gt;&#123; console.log(\"this is a callback\")&#125;) 注意：该回调函数会在componentDidUpdate之后执行。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"Charles代理Chrome抓取localhost的包","slug":"Charles代理Chrome抓取localhost的包","date":"2020-01-09T07:44:55.000Z","updated":"2020-02-25T14:00:40.075Z","comments":true,"path":"2020/01/09/Charles代理Chrome抓取localhost的包/","link":"","permalink":"http://yoursite.com/2020/01/09/Charles代理Chrome抓取localhost的包/","excerpt":"慕课实战遇到的问题在React中想使用Charles实现接口数据模拟。发现两个问题： Charles无法代理Chrome，所以一开始没抓到chrome的包。 Charles无法抓localhost的包，导致无法实现接口模拟。","text":"慕课实战遇到的问题在React中想使用Charles实现接口数据模拟。发现两个问题： Charles无法代理Chrome，所以一开始没抓到chrome的包。 Charles无法抓localhost的包，导致无法实现接口模拟。 解决：Charles代理ChromeCharles在Windows下，默认只代理IE浏览器，对 Chrome 需要设置后才能抓包。SwitchySharp工具下载地址Chrome设置教程 解决：Charles抓localhost的包弄好之后可以发现确实可以抓取chrome的包，但并不能抓取localhost的包。 官方解释Charles官方对不能捕获localhost本地网页的说明，以及解决方法。全文大致意思如下： Localhost流量不会出现在Charles中某些系统被硬编码为不使用代理进行本地主机流量，因此当您连接到http：// localhost /时，它不会显示在Charles中。解决方法是连接到http://localhost.charlesproxy.com/。这指向IP地址127.0.0.1，因此它应该与localhost完全相同，但它的优势在于它将通过Charles。无论Charles是在跑还是你在使用Charles，这都会有效。如果您使用其他端口，例如8080，只需像往常一样添加它，例如localhost.charlesproxy.com:8080。您还可以在该域前放置任何内容，例如myapp.localhost.charlesproxy.com，它也将始终解析为127.0.0.1。或者，您可以尝试添加.在localhost之后，或用本机名称替换localhost，或使用本地链接IP地址（例如192.168.1.2）。如果Charles正在运行并且您使用Charles作为代理，那么您也可以使用local.charles作为localhost的替代方案。请注意，这仅在您使用Charles作为代理时才有效，因此上述方法是首选方法，除非您特别希望请求在不使用Charles时失败。 解决方法原本想抓取的网址：http://localhost:3000/现在换成：http://localhost.charlesproxy.com:3000/成功抓包（例子可看下方） 接口模拟例子桌面右键新建文件todolist.json并放入数据（这就是接口的模拟数据）: 1[\"你好呀\",\"你叫什么名字？\",\"我是胡萝卜\"] 在http://localhost.charlesproxy.com:3000/中我们可以看到在父组件TodoList.js中设置的**AJAX请求的接口地址**： 希望在 TodoList.js组件中发送AJAX请求时将桌面上的todolist.json文件内的数据返回过来，则需要借助 Charles 进行设置。打开 Charles,进行设置，抓取到请求的接口地址是“http://localhost.charlesproxy.com:3000/api/todolist”时就返回`todolist.json`文件的数据： 发送的AJAX请求 数据获取成功： 可以看到获取到的数据：","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React 高级内容（3）","slug":"React高级内容（3）","date":"2020-01-08T13:27:03.000Z","updated":"2020-11-05T02:36:11.982Z","comments":true,"path":"2020/01/08/React高级内容（3）/","link":"","permalink":"http://yoursite.com/2020/01/08/React高级内容（3）/","excerpt":"render函数必须存在所有的生命周期函数都可以没有，但render函数必须存在，否则报错。原因：组件时继承自react的Component的，其中内置了其他所有的生命周期函数，唯独没有render函数。所以我们的render函数是必须自己定义的。","text":"render函数必须存在所有的生命周期函数都可以没有，但render函数必须存在，否则报错。原因：组件时继承自react的Component的，其中内置了其他所有的生命周期函数，唯独没有render函数。所以我们的render函数是必须自己定义的。 React生命周期函数的使用场景在http://localhost:3000/中**设置 highlight，那么页面上被 重新渲染的 组件 就会被框起来：可以发现输入input框时不仅父组件被渲染，子组件也被渲染** ： 利用它做性能优化需优化原因需优化原因：父组件数据更新 子组件render也被执行 例子：子组件TodoItem在子组件TodoItem的render函数中加一个打印语句： 1console.log(\"child render\"); 提交11时第一次执行Todoltem的render函数,在父组件的输入框中输入9个数字时不仅执行父组件的render函数9次，还执行了子组件Todoltem的render函数9次： 这就是我们之前讲的“当父组件的render函数被运行时，它的子组件的render都将被重新运行一次”。可实际上并不需要执行子组件的render，所以我们可以使用生命周期函数来做性能优化。 使用shouldComponentUpdate注意： shouldComponentUpdate 应该需要自带两个参数(nextProps, nextState)，他们代表即将更新的两个数据。 在上一篇笔记 React高级内容（2） 的“React的生命周期函数”中我们提到过，不管state还是props更新都要先通过shouldComponentUpdate来判断是否需要更新。 在子组件TodoItem中使用 shouldComponentUpdate 做性能优化，避免content无变化时被父组件更新带动执行子组件render： 1234567shouldComponentUpdate(nextProps, nextState) &#123; if (nextProps.content !== this.props.content) &#123; return true; &#125; else &#123; return false; &#125;&#125; 可以看到子组件的render仅在提交1时执行了一次，后面父组件的10次改动都并未执行子组件的render： 总结：我们使用 shouldComponentUpdate 函数减少了虚拟DOM的比对，实现了性能优化。 发生 AJAX请求 列表数据如果我们希望通过AJAX请求得到输入框下面的 列表数据 ，我们需要明确：首先，不能把AJAX请求放在render函数中，因为数据更新时render会被再次执行。所以我们需要放在组件中一个 只会被执行一次的函数 中，那么我们可以在父组件中添加 componentDidMount 函数，在页面渲染好（render函数执行后）触发 AJAX请求。 使用componentDidMount函数为什么 我们需要放在组件中一个 只会被执行一次的函数 中。 componentWillMount函数 也只执行一次，但是到了react native或者更深的时候放在componentWillMount函数中就会报错，所以我们默认将AJAX请求 放在 componentDidMount里。 虽然constructor构造函数也只执行一次，但还是建议将AJAX请求 放在 componentDidMount里。 例子：TodoList中发送AJAX请求借助axios模块 注意：axios可自动转换 JSON 数据，从后端获取的JSON数据并不需要通过JSON方法去转换为JS对象，直接就可使用JS对象。 React并不像jquery那样封装了AJAX发送的内置功能，所以我们需要借助 第三方模块axios。 客户端支持防御 XSRF 安装第三方模块axios：在程序终端输入yarn add axios（npm与yarn的区别）,加载完成后输入npm start重启服务器: 在父组件TodoList中引用axios： 1import axios from \"axios\"; 通过axios发送AJAX请求获取接口内容： 12345678// render执行后发生AJAX请求componentDidMount() &#123; // 通过axios发送AJAX请求获取接口内容 axios.get(\"/api/todolist\") // 请求成功则执行then，失败执行catch .then(() =&gt; &#123; alert(\"成功\"); &#125;) .catch(() =&gt; &#123; alert('失败'); &#125;)&#125; （AJAX是用JavaScript执行异步网络请求。Promise实例 里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果，Promise实例拥有then()和catch()。） 当然并没有这个接口，所以最后会显示： 但是我们点开network可以发现确实发送了一个 http://localhost:3000/api/todolist 的请求，只不过404了： 回顾学过的性能优化（面试） 在constructor函数里绑定 事件函数 的 this指向（bind），而不是在事件函数内绑定，这样可以保证整个程序里只绑定一次，且可以避免 子组件 的无谓渲染。（后面会细讲） React的底层内置的setState是异步的，可以把多次的数据改变结合成一次来做，降低了 虚拟DOM 的比对频率。 React的底层用了虚拟DOM的概念，替代了之前的 真实的DOM（JS对象）。 React的 diff算法： 同层比对、key值的运用 来提升 虚拟DOM 比对的速度。 借助生命周期函数shouldComponentUpdate来提高组件性能，避免不必要的子组件render函数的渲染更新。 使用Charles实现本地接口数据mock在上面我们调用接口获取数据时因为接口不存在所以爆出404，但是前端开发和后端是分离的，所以我们就需要在没有接口的情况下 使用 Charles 进行接口数据模拟 。 Charles 是一个抓包工具，他可以抓住我们的浏览器向外发送的请求并进行处理。 工作原理：我们可以在tools里的map local中进行设置，Charles抓取到“map from”中的地址请求就会返回“map to”中选择的文件的数据。Charles就是一个中间代理服务器。 比如：他看到我们请求的接口地址是“http://http://localhost.charlesproxy.com:3000/api/todolist”，那么通过Charles我们可以设置 当接收这个地址的请求时就返回我们桌面的todolist.json文件内的数据，这也就起到了接口模拟数据的作用。 下载安装 Charles 下载地址：https://www.charlesproxy.com/latest-release/download.do 安装：一路next，然后选择路径。 破解：https://www.zzzmode.com/mytools/charles/（替换本地lib中的jar包） 重启，就不会显示需要破解的相关信息了 Charles代理ChromeCharles在Windows下，默认只代理IE浏览器，对 Chrome 需要设置后才能抓包。SwitchySharp工具下载地址Chrome设置教程 Charles抓localhost的包弄好之后可以发现确实可以抓取chrome的包，但并不能抓取localhost的包，Charles官方对不能捕获localhost本地网页的说明，以及解决方法。全文大致意思如下： Localhost流量不会出现在Charles中某些系统被硬编码为不使用代理进行本地主机流量，因此当您连接到http：// localhost /时，它不会显示在Charles中。解决方法是连接到http://localhost.charlesproxy.com/。这指向IP地址127.0.0.1，因此它应该与localhost完全相同，但它的优势在于它将通过Charles。无论Charles是在跑还是你在使用Charles，这都会有效。如果您使用其他端口，例如8080，只需像往常一样添加它，例如localhost.charlesproxy.com:8080。您还可以在该域前放置任何内容，例如myapp.localhost.charlesproxy.com，它也将始终解析为127.0.0.1。或者，您可以尝试添加.在localhost之后，或用本机名称替换localhost，或使用本地链接IP地址（例如192.168.1.2）。如果Charles正在运行并且您使用Charles作为代理，那么您也可以使用local.charles作为localhost的替代方案。请注意，这仅在您使用Charles作为代理时才有效，因此上述方法是首选方法，除非您特别希望请求在不使用Charles时失败。 解决方法：原本的网址：http://localhost:3000/现在换成：http://localhost.charlesproxy.com:3000/成功抓包（例子可看下方） 例子（TodoList）需要实现的功能：在TodoList中发送的AJAX请求（接口）获取到桌面上todolist.json文件内的内容并显示在输入框下作为默认的无序列表。 获取到todolist.json内数据桌面右键新建文件todolist.json并放入数据（这就是接口的模拟数据）: 1[\"你好呀\",\"你叫什么名字？\",\"我是胡萝卜\"] 在http://localhost.charlesproxy.com:3000/中我们可以看到**AJAX请求的接口地址**： 希望在 TodoList.js组件中发送AJAX请求时将桌面上的todolist.json文件内的数据返回过来，则需要借助 Charles 进行设置。打开 Charles,进行设置，抓取到请求的接口地址是“http://localhost.charlesproxy.com:3000/api/todolist”时就返回`todolist.json`文件的数据： 发送的AJAX请求 数据获取成功： 可以看到获取到的数据： 显示在页面上我们先修改TodoList.js的代码，打印看看成功接收到的数据res： 123456789componentDidMount() &#123; // 通过axios发送AJAX请求获取接口内容 axios.get(\"/api/todolist\") // 请求成功则执行then，失败执行catch .then((res) =&gt; &#123; console.log(res); &#125;) .catch(() =&gt; &#123; alert('失败'); &#125;)&#125; 可以注意到res里面有一个 数组data 包含我们想要的数据： 修改then函数中的打印语句： 1console.log(res.data); 可以看到data就是我们想要显示在页面上的数据： 我们知道，在React中，修改state数据页面就会重新渲染，而state中的列表是保存在list: []中的，所以我们可以使用setState改变state中的list数据使data数组成为无序列表显示在输入框下。复习：setState（）中最好传入一个函数作为参数，记得return： 12345678910111213componentDidMount() &#123; // 通过axios发送AJAX请求获取接口内容 axios.get(\"/api/todolist\") // 请求成功则执行then，失败执行catch .then((res) =&gt; &#123; this.setState(() =&gt; &#123; return &#123; list: res.data &#125; &#125;); &#125;) .catch(() =&gt; &#123; alert('获取失败'); &#125;)&#125; 结果：todolist.json文件中的内容显示在输入框下面，并且可以实现点击删除，也可以提交新的数据 思路：state中的list更新后， 父组件TodoList 就会重新执行 render函数 ，那么 render函数 中的 getTodoItem函数 也会被重新执行，在getTodoItem函数中会遍历list中的每一个数据并把他们依次传入 子组件TodoItem 中，在 子组件TodoItem 中每一项都会实现 点击删除 的功能，返回的子组件们就会在父组件的ul标签中形成无序列表。 优化代码当函数中返回的代码只有一句时，我们可以使用()包裹代码从而代替函数的{}return:（相关原因可看笔记”函数相关知识点补充“中的 箭头函数） 我们之前把data放到list中list: res.data，但最好使用扩展运算符将其复制到list中： list: [...res.data]，以免因为数据的改动产生不好的影响。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React 高级内容（2）","slug":"React高级内容（2）","date":"2020-01-08T11:39:11.000Z","updated":"2020-03-17T03:18:03.509Z","comments":true,"path":"2020/01/08/React高级内容（2）/","link":"","permalink":"http://yoursite.com/2020/01/08/React高级内容（2）/","excerpt":"React中ref的使用（尽量不用）ref-&gt;reference 引用在React中我们可以使用ref来直接完成DOM的引用。","text":"React中ref的使用（尽量不用）ref-&gt;reference 引用在React中我们可以使用ref来直接完成DOM的引用。 但是尽量不要使用ref来获取页面上的DOM，要时刻记得我们要减少去操作DOM，我们在React中应该直接去操作state数据，十分复杂的情况下可使用（比如动画）。 有时候同时使用ref和setState时数据的获取会有延迟，是因为setState是异步的，他并不是马上处理的，所以会停留在上一次的数据。此时可以 将获取DOM的这段代码放在setState的第二个参数的函数里，那么她就会在页面完全渲染好以后再进行DOM元素的获取。 使用e.target引用对应的DOM元素TodoList中: 123456&lt;input id=\"inserArea\" className=\"input\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125;/&gt; 我们可以通过e.target来获取元素对应的DOM，也可以通过ref来获取元素对应的DOM。 使用ref引用对应的DOM元素 在react16的语法中，ref等于一个函数，这个函数自动接收一个参数（即对应的DOM元素），参数名可以自定义 ref={(input) =&gt; { this.input = input }} 我们给获取到的对应DOM元素取名input，将它赋值给this.input，则接下来在组件中可以通过this.input来操作这个DOM元素。 可改写 TodoList，render函数中: 12345678&lt;input id=\"inserArea\" className=\"input\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; //`this.input` 指input对应的DOM元素 ref=&#123;(refInput) =&gt; &#123; this.input = refInput &#125;&#125;/&gt; 同时修改TodoList中的handleInputChange： 1234567handleInputChange() &#123; // this.input相当于e.target const value = this.input.value; this.setState(() =&gt; (&#123; inputValue: value &#125;));&#125; 效果和上面使用e.target是一样的，但其实并不推荐使用ref。【原代码改回e.target再继续下一节课的学习】 同时使用ref和setState时的问题与解决有时候同时使用ref和setState时数据的获取会有延迟，是因为setState是异步的，他并不是马上处理的，所以会停留在上一次的数据。此时可以 将获取DOM的这段代码放在setState的第二个参数的函数里，那么她就会在页面完全渲染好以后再进行DOM元素的获取。 例子在TodoList的render中，我们给&lt;ul&gt;增加一个ref去获取对应的DOM节点（也就是ul元素）： 1234//this.ul指向对应的ul元素，refUl是自定义的&lt;ul ref=&#123;(refUl) =&gt; &#123; this.ul = refUl &#125;&#125;&gt; &#123;this.getTodoItem()&#125;&lt;/ul&gt; 然后在点击“提交”按钮的绑定事件函数 handleBtnClick 中增加一个打印语句，打印ul元素下的所有div标签的长度。 12345678910handleBtnClick() &#123; // prevState：修改数据前的那一次的数据，相当于this.state，但更靠谱 this.setState((prevState) =&gt; (&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...prevState.list, prevState.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;)); console.log(this.ul.querySelectorAll(\"div\").length);&#125; handleBtnClick函数主要作用就是把输入框中的内容加到列表中*（state的list中）并清空输入框，按理说每输入一次div标签就会增加一个。那么输入1时长度应该是1，再次输入2时长度应该是2，可结果明显是DOM元素的获取有延迟：这是因为setState是异步的，并不会马上执行，所以获取的数据有所延迟，此时可以 将获取DOM的这段代码放在setState的第二个参数的函数里，那么她就会在页面完全渲染好以后再进行DOM元素的获取： 1234567891011handleBtnClick() &#123; // prevState：修改数据前的那一次的数据，相当于this.state，但更靠谱 this.setState((prevState) =&gt; (&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...prevState.list, prevState.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;), () =&gt; &#123; console.log(this.ul.querySelectorAll(\"div\").length); &#125;);&#125; 结果： React 的 生命周期函数 生命周期函数指在某一时刻组件会自动调用执行的函数。 React 的 生命周期函数 非常重要，建议每天回顾记忆。 React生命周期函数以及关于17.0版本生命周期函数的改变 例子： “当props或state发生改变时，组件自动调用render函数进行页面挂载。”那么render函数其实就是生命周期函数。 “当组件被创建时，会自动调用 constructor函数 （构造函数）。”所以你也可以认为 constructor函数 是生命周期函数，但是 constructor函数 并不是React独有的，他是ES6自带的，所以我们不把 constructor函数 归类为 生命周期函数 ，但实际上没区别。 组件/DOM第一次挂载的流程（mounting）理解：mount 挂载 -&gt; 将组件放到页面上 -&gt; 渲染页面（第一次） 组件第一次挂载的流程：UNSAFE_componentWillMount函数 -&gt; render函数 -&gt;componentDidMount函数 被React弃用并需要替代的函数们使用componentWillMount时报出警告: 1Warning: componentWillMount has been renamed, and is not recommended for use. React 宣布 生命周期方法重命名为： componentWillMount → UNSAFE_componentWillMount componentWillReceiveProps → UNSAFE_componentWillReceiveProps componentWillUpdate → UNSAFE_componentWillUpdate UNSAFE_componentWillMount函数该函数只在页面即将被挂载时执行，也就是只在第一次将组件放（渲染）到页面上之前才会执行，后续在输入框内输入任何数据都不涉及组件挂载，也就不会执行该函数了。 例子：在TodoList.js中添加： render函数（进行页面挂载）当props或state发生改变时，组件自动调用render函数进行页面挂载，将页面渲染出来。 componentDidMount函数在render函数下方添加componentDidMount函数： 123componentDidMount() &#123; console.log(\"componentDidMount\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 可以看到执行顺序是：UNSAFE_componentWillMount函数 -&gt; render函数 -&gt;componentDidMount函数 清空console框，再次输入数据，此时只有render函数被执行。说明只在组件第一次挂载时才执行UNSAFE_componentWillMount函数 和 componentDidMount函数： 组件更新的流程更新state数据的流程：shouldComponentUpdate函数 判断是否需要更新，不需要（false）则不再执行下面的函数，需要则顺序执行UNSAFE_componentWillUpdate函数 -&gt; componentDidUpdate函数 。 更新props数据的流程：比起更新state数据的流程要在最前方多出一个函数：componentWillReceiveProps函数 当一个组件他自己是顶层组件，没有父组件的情况下，他没有接收到props参数，那么就不会执行 函数，比如TodoList中就没有props参数。 shouldComponentUpdate函数在组件更新之前会被运行，该函数要求返回一个布尔值。“我的组件需要被更改吗？”返回的布尔值相当于给他一个回答，当返回false时不论你怎么修改state数据，组件都在执行该函数后明白你不需要更新，那么render函数就不会被执行，页面也就不会产生任何的反馈。 注意：shouldComponentUpdate函数其实应该自带两个参数（nextProps，nextState）表示即将更新的state和props，具体可看笔记“React高级内容（3）”中的（使用shouldComponentUpdate做性能优化） 例子：【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 一样在TodoList中做演示：当我们鼠标一点进input框就会执行该函数：如果将返回值设为false，则不论你怎么修改state数据，组件都在执行该函数后明白你不需要更新，那么render函数就不会被执行，页面也就不会产生任何的反馈： UNSAFE_componentWillUpdate函数componentWillUpdate函数被弃用，使用会报警告，应使用UNSAFE_componentWillUpdate函数替代: 1react-dom.development.js:12449 Warning: componentWillUpdate has been renamed, and is not recommended for use. 组件被更新之前，他会自动执行，但是他在shouldComponentUpdate之后执行 如果shouldComponentUpdate返回true他才执行 如果返回false，这个函数就不会被执行了 在TodoList中添加： 123UNSAFE_componentWillUpdate() &#123; console.log(\"UNSAFE_componentWillUpdate\");&#125; componentDidUpdate函数组件更新完成后，他会被执行 在TodoList中添加： 123componentDidUpdate() &#123; console.log(\"componentDidUpdate\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 shouldComponentUpdate函数返回值为true时的流程： shouldComponentUpdate函数返回值为false时的流程： UNSAFE_componentWillReceiveProps函数componentWillReceiveProps函数已经被React弃用， 我们需要使用UNSAFE_componentWillReceiveProps函数代替他。 执行条件：一个组件要从父组件接受参数如果这个组件是第一次存在于父组件中，则该函数不会被执行如果这个组件之前已经存在于父组件中，该函数就会执行 在TodoList中添加该函数： 123UNSAFE_componentWillReceiveProps()&#123; console.log(\"UNSAFE_componentWillReceiveProps\");&#125; 然而并无反应，因为TodoList就是顶层函数，他没有父组件，也就不会接受props参数，自然也不存在props更新。 在TodoItem中添加该函数： 123UNSAFE_componentWillReceiveProps()&#123; console.log(\"child UNSAFE_componentWillReceiveProps\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 首先我们要明确，TodoItem这个子组件控制的是输入框下面的ul列表。 当我们输入1并提交，第一次往TodoItem中放入数据时，UNSAFE_componentWillReceiveProps函数并没被执行，这是因为 这个组件必须之前已经存在于父组件中，该函数才会执行：当我们再次输入2并点击提交时，完美符合执行条件，该函数被执行： 把组件从页面去除的流程（unmounting）当这个组件即将从页面中剔除时，该生命周期函数会被执行。 componentWillUnmount函数在TodoItem中添加该函数： 123componentWillUnmount() &#123; console.log(\"child componentWillUnmount\");&#125; 结果【我们在每个生命周期函数内添加了对应的打印语句来观察结果】 输入并提交1以后删除无序列表中的“你好呀-1”： 依次输入并提交1、2，再删除无序列表中的“你好呀-2”： 结果2的原因：TodoList中放在ul标签中的getTodoItem告诉我们，遍历list列表后数组中的每一项都会返回一个子组件TodoItem，所以该无序列表中的每一项都是一个子组件！","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React中的虚拟DOM","slug":"React中的虚拟DOM","date":"2020-01-07T11:40:02.000Z","updated":"2020-03-17T03:16:10.961Z","comments":true,"path":"2020/01/07/React中的虚拟DOM/","link":"","permalink":"http://yoursite.com/2020/01/07/React中的虚拟DOM/","excerpt":"面试： 虚拟DOM 是什么，有什么用总结： 虚拟DOM 就是一个JS对象，用它来描述 真实的DOM。 使用 虚拟DOM 有助于极大提升性能：React对性能的提升在于减少了 真实DOM对象 的生成与比较，取而代之的是使用 虚拟DOM(JS对象) 来完成数据改变后的生成与比较。而用JS形成一个 JS对象 性能损耗非常小，生成一个 DOM元素 性能损耗大，涉及DOM的操作都很耗性能。（具体可看下面 例子 的“第二次优化”） 有了 虚拟DOM 使得跨端应用（React Native）得以实现。（因为像是Android、ios、React Native这些原生应用里是没有 真实DOM 的 ）","text":"面试： 虚拟DOM 是什么，有什么用总结： 虚拟DOM 就是一个JS对象，用它来描述 真实的DOM。 使用 虚拟DOM 有助于极大提升性能：React对性能的提升在于减少了 真实DOM对象 的生成与比较，取而代之的是使用 虚拟DOM(JS对象) 来完成数据改变后的生成与比较。而用JS形成一个 JS对象 性能损耗非常小，生成一个 DOM元素 性能损耗大，涉及DOM的操作都很耗性能。（具体可看下面 例子 的“第二次优化”） 有了 虚拟DOM 使得跨端应用（React Native）得以实现。（因为像是Android、ios、React Native这些原生应用里是没有 真实DOM 的 ） 例子我们通过假设没有 React 来渲染来一步步梳理优化来看看React在背后做了哪些工作。 假设没有 React 来渲染，我们需要做的是： state 数据 JSX 模版 数据 + 模版 结合，生成 真实的DOM ，来挂载在页面上 state 数据 发生改变 数据 + 模版 结合，生成 真实的DOM ，替换 原始的DOM 缺陷：第一次生成了一个完整的DOM片段第二次又生成了一个完整的DOM片段第二次的DOM替换第一次的DOM，非常耗性能 第一次优化 state 数据 JSX 模版 数据 + 模版 结合，生成 真实的DOM ，来挂载在页面上 state 数据 发生改变 数据 + 模版 结合，生成 新的 真实的DOM ，并不替换 原始的DOM 新的DOM（实际上是JS上的DocumentFragment（文档碎片））和 原始的DOM 做比对，找差异 找出只有input框发生了变化 只用 新的DOM中的input元素 替换 原始的DOM中的input元素 缺陷：性能提升并不明显 第二次优化（注意这并不是React完全正确的顺序，请看下面的“深入了解 虚拟DOM”） state 数据 JSX 模版 数据 + 模版 结合，生成 真实的DOM ，来挂载在页面上&lt;div id=&quot;abc&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; 生成 虚拟的DOM (虚拟DOM就是一个JS对象，用它来描述 真实的DOM)[&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;hello world&quot;]]（可以理解为一个 数组结构的对象 ） 【损耗了一点性能：用JS形成一个 JS对象 性能损耗非常小，生成一个 DOM元素 性能损耗大】 state 数据 发生改变 数据 + 模版 结合，生成 新的 虚拟的DOM [&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;bye bye&quot;]] 【极大的提升了性能：因为上一次优化在数据改变后生成的是新的DOM元素，而现在我们让他生成的虚拟DOM实际上是JS对象。】 比较 原始虚拟DOM 和 新的虚拟DOM 的区别，找到区别是 span中的内容 【上一次优化是将两个DOM做对比，而涉及DOM的操作就很耗性能。在这里我们对比的是虚拟DOM（JS对象），提升了性能】 直接操作DOM，改变span中的内容 补充：数组类型的对象对象数组 就是数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋给数组就行了。 注意： 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。（具体可以看笔记“js对象 学习笔记（1）”） 数组中每一项都可以存放不同类型的数据。 深入了解 虚拟DOM 只有页面需要渲染的时候才会生成真实的DOM。 在这里我们明白了render函数中的标签其实并不是页面上的DOM元素，他们是步骤中的 JSX 模版。 render函数第一次执行的时候会将渲染的数据在内存中保存一份，当第二次数据发生了改变后，render会将这次的虚拟DOM与缓存中的虚拟DOM进行对比 这种对比叫做DIFF算法 只要this.state/this.props发生了改变那么render函数就会执行 第三次优化【注意和之前的“真实DOM”“虚拟DOM”顺序相反】 state 数据 JSX 模版 数据 + 模版 结合，生成 虚拟的DOM （保存在内存中）[&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;hello world&quot;]] 用 虚拟的DOM 的结构 生成 真实的DOM ，显示在页面上&lt;div id=&quot;abc&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; state 数据 发生改变 数据 + 模版 结合，生成 新的 虚拟的DOM [&quot;div&quot;,{id:&quot;abc&quot;},[&quot;span&quot;,{},&quot;bye bye&quot;]] 比较 原始虚拟DOM 和 新的虚拟DOM 的区别，找到区别是 span中的内容 直接操作有区别的DOM，改变span中的内容 优点： 性能提升了，如果不使用虚拟DOM，则需要生成所有的真实DOM进行替换，使用虚拟DOM则只需要生成有区别的真实DOM进行替换即可。 有了 虚拟DOM 使得跨端应用（React Native）得以实现。（因为像是Android、ios、React Native这些原生应用里是没有 真实DOM 的 ） React真实的操作顺序JSX -&gt; createElement -&gt; JS 对象（虚拟DOM） -&gt; 真实DOM帮助理解：下面两个return返回的内容其实是一样的： 1234render（）&#123; return &lt;div&gt;item&lt;/div&gt; return React.createElement(\"div\",&#123;&#125;,\"item\");&#125; 虚拟DOM中的Diff算法在上面第7步中我们说去 “当state数据发生改变时，比较 原始虚拟DOM 和 新的虚拟DOM 的区别”， 这里的“比较”采用的就是Diff算法，（Diff-&gt;difference-&gt;找不同）。Diff算法大大提升了两个虚拟DOM之间进行比对的性能。 下面的同层比较 和 key值匹配 就是 Diff算法 的一部分。 答之前的问题：为什么setState是异步的（关于什么是异步可参考笔记“JS中的同步与异步”）setState之所以是异步，是因为要提高React底层的性能。提高性能主要靠减少比对次数：如果不是异步的，短时间内修改3次state，则react需要进行3次 虚拟DOM 的比对，而异步则可以把3次比对合并，react只需要进行1次 虚拟DOM 的比对。 异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。我的理解：也就是说如果短时间内多次修改，他会等你停止修改以后才通知主线程可以对我进行比对啦。 同层比较React的 虚拟DOM 采用的是 同层比较 的算法。逐层比对，如果第一层就不同，react就不会往下比对，而是直接使用 新的虚拟DOM 去生成真实的DOM。虽然可能会造成DOM节点渲染的浪费，但同层比对的算法简单，效率快，大大减少了两个虚拟DOM之间比对的性能消耗。 答之前的问题：为什么index不能作为key值key值需要是稳定的，可变的key值也就失去了它存在的意义。 原理在React中我们会根据key值给 虚拟DOM 命名，数据修改后 新的 虚拟DOM 就会根据key值和 原始的 虚拟DOM 进行快速比对，多出来的就是修改的DOM。这会大大提升性能。 之前的 TodoList 的例子如果我们使用数组下标index作为key值，我们就没办法保证 新的 虚拟DOM 和 原始的 虚拟DOM 的 名字（key值）一致，也就没办法快速匹配了。所以使用一个稳定的内容作为key值才是稳妥的做法，数组下标index是会因为列表的变化而发生改变的，他是不稳定的。 结合我们之前的 TodoList 的例子，我们将数组下标index作为key值：当我们在页面上依次输入“a,b,c”时，他们对应的key分别是“0 a,1 b,2 c”,而当我们点击a时，a被从list中删除掉，bc对应的key分别是“0 b,1 c”,可以发现如果我们将index作为key则key是可变的。但我们必须保证 新的 虚拟DOM 到了与 原始DOM 比对的树上时它的名字（key值）是没有变的，否则无法快速匹配。可变的key值也就失去了它存在的意义。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"数组结构的对象（对象数组）","slug":"数组结构的对象","date":"2020-01-06T05:52:22.000Z","updated":"2020-02-25T14:05:53.212Z","comments":true,"path":"2020/01/06/数组结构的对象/","link":"","permalink":"http://yoursite.com/2020/01/06/数组结构的对象/","excerpt":"数组类型的对象对象数组 就是数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋给数组就行了。","text":"数组类型的对象对象数组 就是数组里的每个元素都是类的对象，赋值时先定义对象，然后将对象直接赋给数组就行了。 注意 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。（具体可以看笔记“js对象 学习笔记（1）”） 数组中每一项都可以存放不同类型的数据。（具体可以看笔记“JS对象之数组(1)”） 例子在React.js中，我们说“ 虚拟DOM 就是一个 JS对象 ，用它来描述 真实的DOM。”(其中的 JS对象 可以理解为一个 数组类型的对象) 我们假设真实的DOM是： 1&lt;div id=\"abc&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt; 那么对应的虚拟DOM就是（数组类型的对象）： 1[\"div\",&#123;id:\"abc\"&#125;,[\"span\",&#123;&#125;,\"hello world\"]]","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"React 高级内容（1）","slug":"React高级内容(1)","date":"2020-01-05T13:54:06.000Z","updated":"2020-02-25T14:06:54.089Z","comments":true,"path":"2020/01/05/React高级内容(1)/","link":"","permalink":"http://yoursite.com/2020/01/05/React高级内容(1)/","excerpt":"安装React开发调试工具（React Developer Tools）安装步骤（需要科学上网）：","text":"安装React开发调试工具（React Developer Tools）安装步骤（需要科学上网）： 安装成功：在通过React开发并处于本地开发的页面上图标会显示为红色，说明安装成功： 通过React开发并处于线上版本的网页，图标会显示为黑色： 非React开发的页面上图标会显示为灰色： React Developer Tools 的好处 方便进行 组件结构 的查询、 在组件传值调试时不需要反复通过 console.log 来打印信息，直接看 开发者工具 右侧 state 中是否有相关信息即可。 使用React Developer Tools进入原始页面，打开 开发者工具 ，可以看到新增的 Component ：在输入框内依次输入a b，可以看到右方 state 实时产生变化： 可以很方便的进行 组件结构 查询： PropTypes与DefaultProps的应用PropTypes 强校验子组件在接受父组件传过来的值（即 属性 ）时进行强校验。他可以要求父组件给子组件传的值是什么类型的。如若不是也并不会报错，只会在 开发者工具 中给出警告。 使用步骤 脚手架工具中已经有 prop-types 的包，所以我们可以直接在 子组件 中顶部引入 PropTypes ： 1import PropTypes from 'prop-types'; 在 子组件 export default 顶上使用 propTypes （注意是小写）限制父组件传过来的值的类型（更多值的类型可以看下面”PropTypes不同的验证函数“）： 1234567// 使用propTypes限制父组件传过来的值的类型TodoItem.propTypes = &#123; // 注意PropTypes大小写，上面必须小写，下面是import中自定义的名字 content: PropTypes.string, deleteItem: PropTypes.func, index: PropTypes.number&#125; 如果将 index 的 PropTypes要求 改为 string ，则一旦提交输入内容后就会给出 警告 ，告诉我们子组件接收 index 时希望得到的是 string 类型的而不是 number ： isRequired强制传值总结： 当父组件没有向子组件传某个值时，某个值对应的propTypes是不生效的。 使用isRequired可以强制要求父组件向子组件传递某个值，如果父组件并未传值就会报出 警告 。 例子1：子组件上增加 test （实际上父组件并未传 test ）：对子组件上 test 进行强校验：然而到页面上输入时并未报出警告，也就是说test: PropTypes.string是没有生效的。 例子2：在 propTypes 中使用isRequired强制要求父组件向子组件传递test值:父组件并未传值，报出 警告： DefaultProps 设置默认值当父组件没有向子组件传递某个值，而子组件使用了该值时，可以在子组件中设置DefaultProps来规定该值的默认值。 注意：上面强校验时引入了PropTypes是因为需要使用PropTypes内的类型（string、func、number等），而DefaultProps不需要另外引入别的包。 有时候你使用isRequired强制要求父组件传过来的值实际上没办法传，这时候就需要用到默认值来解决报错问题，结合上面的例子，我们在子组件中给test一个默认值： 官网深入学习 打开英文官网https://reactjs.org/。（中文官网较为滞后，推荐英文官网） Docs（文档）=&gt; ADVANCED GUIDES（高级指南）=&gt; typechecking-with-proptypes PropTypes 直接拉到中间看 PropTypes使用方法的 demo： 再往下看可以看到 PropTypes 可以使用的各种值： 还可以 使用instanceOf来判断接收的值是不是Message的一个实例 等，PropTypes可以做非常丰富的代码检测： 假设我们希望例子中的content可以是number或者string类型，我们可以使用文档中给出的oneOfType来完成“或者”的语法：12345// content 可以是number或者string类型content: PropTypes.oneOfType([ PropTypes.number, PropTypes.string]), PropTypes不同的验证函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import PropTypes from 'prop-types';MyComponent.propTypes = &#123; // 你可以声明一个道具是一个特定的JS类型。默认情况下，这些都是可选的。 optionalArray: PropTypes.array, optionalBool: PropTypes.bool, optionalFunc: PropTypes.func, optionalNumber: PropTypes.number, optionalObject: PropTypes.object, optionalString: PropTypes.string, optionalSymbol: PropTypes.symbol, // 任何可以渲染的东西：数字，字符串，元素或数组（或片段）。 optionalNode: PropTypes.node, // React元素 optionalElement: PropTypes.element, // 一个React元素类型(即MyComponent)。 optionalElementType: PropTypes.elementType, // 你也可以声明prop是某个类的实例。 内部使用的是JS的instanceof运算符。 //使用instanceOf来判断接收的值是不是Message的一个实例 optionalMessage: PropTypes.instanceOf(Message), // 你可以通过将它作为枚举来确保你的prop值仅限于特定的值。 optionalEnum: PropTypes.oneOf(['News', 'Photos']), // 可以是许多类型之一的对象 optionalUnion: PropTypes.oneOfType([ PropTypes.string, PropTypes.number, PropTypes.instanceOf(Message) ]), // 某种特定类型的数组(数组元素为number的数组) optionalArrayOf: React.PropTypes.arrayOf(PropTypes.number), // 具有某种特定类型的属性值的对象 optionalObjectOf: PropTypes.objectOf(PropTypes.number), // 采取特定样式的对象 optionalObjectWithShape: PropTypes.shape(&#123; color: PropTypes.string, fontSize: PropTypes.number &#125;), // 你可以用`isRequired`来连接到上面的任何一个类型，以确保如果没有提供该props的话会显示一个警告。 requiredFunc: PropTypes.func.isRequired, // 任何数据类型 requiredAny: PropTypes.any.isRequired, // 您还可以指定自定义验证器。如果验证失败，它应该返回一个Error对象。 不要`console.warn`或`throw`，因为这在`oneOfType`中不起作用。 customProp: function(props, propName, componentName) &#123; if (!/matchme/.test(props[propName])) &#123; return new Error( 'Invalid prop `' + propName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;, // 您还可以为`arrayOf`和`objectOf`提供自定义类型检查器。 如果检查失败，它应该返回一个Error对象。 // 检查器将为数组或对象中的每个键调用验证函数。 // 检查器有两个参数，第一个参数是数组或对象本身，第二个是当前项的键。 customArrayProp: React.PropTypes.arrayOf(function(propValue, key, componentName, location, propFullName) &#123; if (!/matchme/.test(propValue[key])) &#123; return new Error( 'Invalid prop `' + propFullName + '` supplied to' + ' `' + componentName + '`. Validation failed.' ); &#125; &#125;)&#125;; defaultPropsdefaultProps 使用方法的 demo： 123456789101112131415161718class Greeting extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt; ); &#125;&#125;// 指定name的默认值:StrangerGreeting.defaultProps = &#123; name: 'Stranger'&#125;;// 显示 “你好,陌生人”:ReactDOM.render( &lt;Greeting /&gt;, document.getElementById('example')); props，state与render函数的关系之所以state中的数据一变页面就会自动发生变化是因为页面是通过render函数渲染出来的，而每当组件的state或者props发生改变时，render函数就会重新执行。（props发生改变，归根到底还是父组件的state发生了变化，所以我们也可以理解为state或者props发生改变时父子组件的render函数都会重新执行）当父组件的render函数被运行时，它的子组件的render都将被重新运行一次。 state与render函数的关系：每当组件的state内数据发生改变时，render函数就会重新执行。可以看TodoList.js来帮助理解。 props与render函数的关系：每当组件的props内的数据发生改变时，render函数就会重新执行。总结：当父组件的render函数被运行时，它的子组件的render都将被重新运行一次。 例子 在父组件中引入子组件Test：import Test from &quot;./Test&quot; 在父组件中将子组件Test放在无序列表下方位置并将state中的inputValue传过去，每当父组件的render函数被运行时就会打印”render”： 新建一个子组件Test.js，每当子组件的render函数被运行时就会打印”Test render”并在页面上显示父组件传过来的content（即state中的inputValue值）:123456789101112import React, &#123; Component &#125; from 'react'//imrcclass Test extends Component &#123; render() &#123; console.log(\"Test render\"); return ( &lt;div&gt;&#123;this.props.content&#125;&lt;/div&gt; ) &#125;&#125;export default Test; 结果： 解释： 最初的时候父组件需要渲染，子组件也需要渲染，所以 开发者工具 中显示了“render”和“Test render”。 输入1后，inputValue发生改变，父组件的state发生改变，所以父组件render函数重新运行，多打出来一行“render”。 输入1后inputValue一变content就会变（因为父组件传值&lt;Test content={this.state.inputValue} /&gt;），content一变props就变了（因为子组件中&lt;div&gt;{this.props.content}&lt;/div&gt;），props发生改变时，render函数就会重新执行，所以显示“Test render”。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"围绕 React 衍生出的思考","slug":"围绕 React 衍生出的思考","date":"2020-01-04T09:57:35.000Z","updated":"2020-02-25T14:07:51.743Z","comments":true,"path":"2020/01/04/围绕 React 衍生出的思考/","link":"","permalink":"http://yoursite.com/2020/01/04/围绕 React 衍生出的思考/","excerpt":"声名式开发不同于原生 JS 的 命令式开发 ， React 是声名式开发。 命令式开发 更关注 DOM 的每一步挂载，而 声名式开发 更在意数据的改变，只操作 数据，不关心 具体要如何 操作 DOM，改变数据以后 React 会自动帮你完成 DOM 挂载等步骤。","text":"声名式开发不同于原生 JS 的 命令式开发 ， React 是声名式开发。 命令式开发 更关注 DOM 的每一步挂载，而 声名式开发 更在意数据的改变，只操作 数据，不关心 具体要如何 操作 DOM，改变数据以后 React 会自动帮你完成 DOM 挂载等步骤。 帮助理解命令式：操作 DOM 使用 JS 去找到需要操作的 DOM 节点，然后 操作它。声明式：编码好 数据 与 界面的 关系，只操作 数据，不关心 具体要如何 操作 DOM ,把 DOM 都交给 React。 可以与其他框架并存React可以与其他框架并存，也就是说public文件夹下index.html内的不同节点可以被不同的库所管理。（vue、jQuery等）每一个库只管理自己对应的DOM，只要不影响外部DOM节点即可。 例子在src文件夹下的index.js中我们将一个 由React管理的组件 挂载在index.html的DOM节点root上： 在public文件夹下的index.html中我们可以放入由不同库进行管理的DOM节点： 组件化使用class定义一个组件名继承自react的Component来自定义组件。自定义组件命名以大写字母开头，调用形式类似h5标签（比如&lt;TodoItem /&gt;）。父子组件的通信： 父组件通过（子组件的）属性向子组件传值（数据或方法）。 子组件想修改父组件数据的步骤：首先需要父组件向子组件传递一个方法，然后子组件通过调用该方法间接的操作父组件的数据。 面试常问：React中如何做父子组件的通信父组件向子组件传值（数据或方法）:父组件通过在子组件上添加属性的方式将数据（或方法）传给子组件（属性名是自定义的，属性值为需要传递的数据）子组件内使用父组件数据：在子组件内需要使用父组件传递过来的数据的位置通过{this.props.属性名}来接受对应属性值（数据）。 子组件内修改父组件的数据（子组件向父组件传值）：首先需要父组件向子组件传递一个方法，然后子组件通过调用该方法间接的操作父组件的数据。（子组件向父组件传的值可以通过调用父组件传过来的方法的参数传回去） 更多细节和注意事项以及例子可以看详细笔记 单向数据流在React中只允许父组件向子组件传值，在子组件可以使用父组件传过来的值，但不能在子组件中直接去修改父组件传过来的值。但是子组件可以通过调用父组件穿过来的方法间接的操作父组件的数据。 好处：对代码调试很友好，一旦父组件的某个数据出现问题，所有对该数据的操作都是集中在父组件的某个方法中的，不会涉及到多个子组件身上。 例子完整例子 删除功能实际上就是想办法在子组件中修改父组件的list数据：正确的思路是 父组件是将item和index以及删除的方法handleItemDelete（在父组件的handleItemDelete（）中进行list数据的删除）传给子组件TodoItem，然后子组件通过调用父组件的方法对list数据进行删除： 错误的思路：在父组件中将list数据传到子组件中并在子组件中直接进行修改： 视图层框架React并未把自己定位为大型框架，它只是一个视图层框架，只帮助我们解决数据和渲染之间的问题，至于组件之间怎么传值它并不负责。在小型项目中光是依靠React来进行传值也是可以的（比如之前的TodoList，只有两层组件）。但在大型项目时，光用 React 是不够的，必须结合一些数据层框架（比如redux），解决复杂传值的问题。 例子在一个大型项目中，组件之间呈树状分布，如果React去负责组件之间的传值将非常困难，假设我们紫色的组件想传值给最顶上的组件，就需要层层传递，非常复杂： 函数式编程例子：在React中我们使用的是一块一块的函数，比如TodoList.js中的constructor构造函数、render函数、getTodoItem函数等等： 好处：给前端自动化测试带来很大便捷性。只需要给函数一个输入值，看看函数输出的时候符合预期即可。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"TodoList代码优化","slug":"TodoList代码优化","date":"2020-01-03T10:20:02.000Z","updated":"2020-02-25T14:09:29.471Z","comments":true,"path":"2020/01/03/TodoList代码优化/","link":"","permalink":"http://yoursite.com/2020/01/03/TodoList代码优化/","excerpt":"使用ES6的解构赋值进行优化TodoItem.js中第一处代码优化调用 父组件传递过来的数据 时可以进行代码优化，使用ES6的解构赋值：","text":"使用ES6的解构赋值进行优化TodoItem.js中第一处代码优化调用 父组件传递过来的数据 时可以进行代码优化，使用ES6的解构赋值： 解释 父组件传递到子组件的数据是存放在属性中的，而众属性是放在props中的。假设this.props={AA:&#39;AA值&#39;,BB:&#39;BB值&#39;,CC:&#39;CC值&#39;,..};使用ES6的解构赋值,可以一次性赋值多个变量:1const &#123;AA,BB,CC,...&#125;=this.props; 在此基础上，接下来需要调用属性时直接使用AA即可。 const { content } = this.props;相当于const content = this.props.content; 在return()中属性名content被{}包裹是因为JSX语法中调用JS变量需要使用{}。 TodoItem.js中第二处代码优化原本的代码： 123handelClick() &#123; this.props.deleteItem(this.props.index)&#125; 同样进行优化后： 12345handelClick() &#123; // index也是父组件传过来的，可以一起解构赋值 const &#123; deleteItem, index &#125; = this.props; deleteItem(index);&#125; 引用顺序的优化TodoList.js中第一处代码优化原本的代码： 123import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */import \"./style.css\"import TodoItem from \"./TodoItem\" 一般我们将组件的引用放在前面，样式的引用放在后面，进行优化后： 123import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */import TodoItem from \"./TodoItem\"import \"./style.css\" 在构造函数中绑定this指向（bind）TodoList.js中第二处代码优化原本在return()中绑定事件函数的this指向： 但是为了性能优化我们应该在构造函数constructor中绑定this指向： 附加：属性内容较长时可分行 TodoList.js中第三处代码优化将父组件的handleItemDelete方法传给子组件前我们需要绑定this指向，防止传过去以后this指向子组件以至于找不到该方法而报错： 同样的，我们可以将绑定这个动作放到构造函数中完成， 在构造函数中绑定this指向 ： JSX语法JSX语法实际上是写一些页面上显示的东西用的，但是在TodoList.js中出现了一些逻辑代码： TodoList.js中第四处代码优化我们另外写一个getTodoItem()来存放这些逻辑代码，然后在原本需要逻辑代码的位置使用JS表达式调用getTodoItem()即可（注意JS表达式需要{}包裹）：注意：getTodoItem()中需要另外写一个return用于将函数结果返回，否则调用函数以后是没有结果的。 setState（）中参数改为函数新版的React中，setState（）参数 可以是一个 函数 而不是 对象 ，而这个函数最终返回（return）一个对象。 TodoList.js中第五处代码优化原本的代码： 12345handleInputChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;)&#125; 解释：target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue，react中改变状态中的数据需要调用组件的setState方法 优化后： 1234567handleInputChange(e) &#123; this.setState(() =&gt; &#123; return &#123; inputValue: e.target.value &#125; &#125;)&#125; 结合ES6 return 简写，再次优化： 12345handleInputChange(e) &#123; this.setState(()=&gt;(&#123; inputValue: e.target.value &#125;));&#125; 会发现报错TypeError: Cannot read property &#39;value&#39; of null：原因：这是因为setState方法如果传一个函数，它实际上是异步的写法，在后面讲“虚拟DOM”时将会讲解，主要是为了提升性能。解决方案：此时需要将e.target.value放在setState（）的外部保存一下，再在内部进行调用： 123456handleInputChange(e) &#123; const value = e.target.value; this.setState(() =&gt; (&#123; inputValue: value &#125;));&#125; 注意：箭头函数返回对象时若想省略return则需要用()包裹对象。（具体可参考笔记“函数相关知识点补充”中箭头函数部分） 使用 prevState 代替 this.state我们像上面一样优化TodoList.js中的handleBtnClick（）：运行起来没问题，但其实有更加靠谱的优化方法（如下）。 TodoList.js中第六处代码优化setState（）中参数改为函数后，该参数内的函数可传入一个参数prevState。prevState指的是你修改数据前的那一次是怎么样的，相当于this.state，使用prevState可以避免你不小心改变state的状态： 123456789handleBtnClick() &#123; // prevState相当于this.state，但更靠谱 this.setState((prevState)=&gt;(&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...prevState.list, prevState.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;));&#125; TodoList.js中第七处代码优化原本的代码: 1234567handleItemDelete(index) &#123; const list = [...this.state.list] list.splice(index, 1); this.setState(&#123; list: list &#125;)&#125; setState（）中参数改为函数，第一次优化后： 1234567handleItemDelete(index) &#123; const list = [...this.state.list] list.splice(index, 1); this.setState(() =&gt; &#123; return &#123; list: list &#125; &#125;)&#125; 使用prevState代替this.state,第二次优化后： 1234567handleItemDelete(index) &#123; this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1); return &#123; list: list &#125;; &#125;);&#125; 其中，按照ES6的语法，list:list可简写为list（笔记“ES6对象简写”中有详细解释）： 1234567handleItemDelete(index) &#123; this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1); return &#123; list &#125;; &#125;);&#125; 解决key值问题涉及到循环时每一项都应该有自己独立的key值，没有不会报错，但会警告。 key值需要加在被循环的子项最外层上需要注意：index作为key值时不靠谱的，暂且用着，后期再改。 key值需要加在被循环的子项最外层上，所以有&lt;div&gt;时需要放在&lt;div&gt;上： 删去div写在 子组件TodoItem 也可以： 12345678910111213getTodoItem() &#123; return this.state.list.map((item, index) =&gt; &#123; return ( /* 注意return中只能有一个父元素，注释也会被当成子元素 */ &lt;TodoItem key=&#123;index&#125; content=&#123;item&#125; index=&#123;index&#125; deleteItem=&#123;this.handleItemDelete&#125; /&gt; ) &#125;)&#125;","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React.js基础精讲(2)","slug":"React.js基础精讲（2）","date":"2020-01-02T08:39:57.000Z","updated":"2020-02-25T14:10:06.585Z","comments":true,"path":"2020/01/02/React.js基础精讲（2）/","link":"","permalink":"http://yoursite.com/2020/01/02/React.js基础精讲（2）/","excerpt":"JSX语法细节补充注释语句在JSX中写注释相当于写js语句，所以一样需要{}将注释括起来。第一种注释语法很好理解，但是第二种注释语法需要注意：必须换行，否则结尾的花括号会被注释以至于无法包裹注释语句。","text":"JSX语法细节补充注释语句在JSX中写注释相当于写js语句，所以一样需要{}将注释括起来。第一种注释语法很好理解，但是第二种注释语法需要注意：必须换行，否则结尾的花括号会被注释以至于无法包裹注释语句。 第一种注释语法： 1&#123;/*注释语句*/&#125; 第二种注释语法：必须换行，否则结尾的花括号会被注释以至于无法包裹注释语句。 123&#123;//注释语句&#125; 外联CSS样式表及其注意事项引入外联样式表的方法 在src下新建样式表style.css并给input设置红色边框的样式 在组件页面TodoList.js顶部引入样式表import &quot;./style.css&quot;即可 使用className代替classreact中会混淆 标签样式定义类class 与 组件class TodoList extends Component{}中的class，给标签定义样式类名时使用class虽然不会报错，但控制台会提示警告: 12345&lt;inputclass=\"input\"value=&#123;this.state.inputValue&#125;onChange=&#123;this.handleInputChange.bind(this)&#125;/&gt; 所以我们在定义样式表class名称时需要使用className代替class: 12345&lt;inputclassName=\"input\"value=&#123;this.state.inputValue&#125;onChange=&#123;this.handleInputChange.bind(this)&#125;/&gt; dangerouslySetInnerHTML使JSX中部分内容不转译 如果在JSX中不希望内容被转译可使用 dangerouslySetInnerHTML(也就是希望输入框中输入的html标签可以被识别使用) 虽然这样做存在被XSS攻击的可能，但有时候也需要这样不转译的设置页面内容的情况。 例子： 原代码： 123456&lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt; &#123;item&#125;&lt;/li&gt; 使用 dangerouslySetInnerHTML 后: 123456&lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125; dangerouslySetInnerHTML=&#123;&#123;__html:item&#125;&#125;&gt;&lt;/li&gt; __html属性设置的是需要不转译显示在页面上的内容，这里设置为当前item，则li标签中间的{item}key省去（外层{}是代表里面写的是js表达式，内层{}代表是个js对象） 使用htmlFor代替属性for在react中，会混淆 元素标签的for属性 与 for循环，使用 for属性 会报出警告提示，所以我们需要属性for时应使用htmlFor代替属性for。比如：在&lt;label&gt;中使用 for属性 使点击 “输入内容” 时鼠标自动聚焦于输入框内时，使用 for属性 : 1234567&lt;label for=\"inserArea\"&gt;输入内容&lt;/label&gt;&lt;input id=\"inserArea\" className=\"input\" value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125;/&gt; 使用htmlFor代替属性for：&lt;label htmlFor=&quot;inserArea&quot;&gt;输入内容&lt;/label&gt; 组件拆分 与 组件之间的传值总结： 在render函数的return（）括号中只允许存在1个最外层标签，否则报错。（也就是说所有标签都必须包含在1个父元素下）return（）中的注释也会被当成一个子元素！（可以看：“父组件向子组件传递数据”的例子） 自定义组件名首字母大写。 定义组件后不要忘记在js文件最后export default 组件名;,一定要导出组件它才能在外部被引用。 组件的使用方式和JSX元素标签的使用方式类似。比如自定义子组件为TodoItem,在父组件TodoList的return（）中通过&lt;TodoItem /&gt;来引用。（不要忘记在父组件TodoList顶部引入子组件） 在JSX中想要使用变量或者js表达式时必须用{}括起来，参数与属性名则不需要。（比如：“父组件向子组件传递数据”的例子中TodoList.js中的&lt;TodoItem content={item} /&gt;,item就是变量，必须用{}括起来） 绑定事件函数要记得到组件的构造函数中使用bind()绑定this指向，否则绑定事件函数的方法内部的this会丢失指向。（参考另一篇笔记的传送门） 在父组件内通过在子组件标签上添加属性的方式将数据或者方法传给子组件。属性名是自定义的，属性值为需要传递的数据或者方法，注意 数据变量 与 方法 都需要{}括起来， 方法 不要忘记this.方法名。 子组件如果想要调用父组件的方法，在父组件中通过属性传递该方法时必须先通过bind()绑定该方法的this永远指向父组件,否则报错。因为通过this.方法名传过去后this变为子组件，而子组件中并无该方法。（可参考下方“子组件向父组件传递数据”中例子） 组件拆分网页可拆分为多个不同的父组件与子组件，子组件又可以嵌套其他的子组件形成树形结构。 组件之间的传值原本我们把列表的 增加 和 删除 功能都写在 TodoList.js 中，现在我们把列表中的子项放在 子组件TodoItem.js 中，增加 和 删除 功能的逻辑写在 子组件TodoItem.js 中，最后再在 TodoList.js 中调用 子组件TodoItem.js 。 往列表中增加数据： 父组件TodoList通过标签的形式引用子组件并以属性的方式将数据item传给子组件TodoItem（&lt;TodoItem content={item}&gt;） 子组件内通过{this.props.属性名}来获取从父组件传递过来的数据（对应属性值）。 点击子项后删除子项：原本是写在TodoList.js的&lt;li&gt;标签上的onClick事件绑定函数handleItemDelete上的，现在组件化后去掉了&lt;li&gt;标签，但我们可以让子组件调用父组件的handleItemDelete方法来实现改功能。 在父组件中通过 子组件属性 的方式将 数据item 、 数组下标index 、方法handleItemDelete 都传递到子组件中 子组件中，点击子组件时触动onClick事件绑定的函数handelClick，在函数handelClick内 将父组件传递过来的index值作为参数 通过属性名的方式调用父组件的deleteItem方法（即父组件的handleItemDelete方法）完成点击数据即删除的功能。 父组件向子组件传递数据（或方法） 父组件通过类似html标签的方式引用子组件，同时使用在子组件标签上添加属性的方式将数据传给子组件（属性名是自定义的，属性值为需要传递的数据）注意数据变量与方法都需要{}括起来（也就是属性值需要{}括起来），方法不要忘记this.方法名。 在子组件内需要使用父组件传递过来的数据的位置通过{this.props.属性名}来接受对应属性值（数据）。 注意：父组件向子组件传递方法时，必须在父组件中通过属性传递该方法的同时通过bind()绑定该方法的this永远指向父组件,否则报错。因为通过this.方法名传过去后this变为子组件，而子组件中并无该方法。在父组件中通过属性传递该方法时必须先通过bind()绑定该方法的this永远指向父组件,否则报错。因为通过this.方法名传过去后this变为子组件，而子组件中并无该方法。（可参考下方“子组件向父组件传递数据”中例子） 例子：点击按钮以后希望列表中显示输入框中内容则需要父组件将数据传给子组件，也就是 父组件TodoList 将输入框中得到的 item数据 传给 子组件TodoItem： 定义子组件并导出： 在父组件中引入子组件： 父组件向子组件传递数据： 子组件内通过{this.props.属性名}来获取从父组件传递过来的数据（对应属性值）： 子组件向父组件传递数据（子组件如何调用父组件的方法修改父组件的数据） 在父组件中通过属性的方式将 数据item 、 数组下标index 、方法handleItemDelete 都传递到子组件中： 注意：在父组件中将handleItemDelete传给子组件之前必须使用bind绑定this永远指向父组件，否则在子组件中调用this.props.deleteItem时实际上相当于调用this.handleItemDelete,但在子组件中this指向子组件，子组件中并没有handleItemDelete函数，因此报错。 子组件中，点击子组件时触动onClick事件绑定的函数handelClick，在函数handelClick内 将父组件传递过来的index值作为参数 通过属性名调用父组件的deleteItem方法（即父组件的handleItemDelete方法）完成点击数据即删除的功能： 需要修改state数据的方法可以保留在父组件中，在子组件中通过调用父组件方法来修改数据。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"正则表达式","slug":"JS正则表达式","date":"2020-01-02T08:01:23.000Z","updated":"2020-10-21T13:40:40.853Z","comments":true,"path":"2020/01/02/JS正则表达式/","link":"","permalink":"http://yoursite.com/2020/01/02/JS正则表达式/","excerpt":"JS中生成RegExp对象的两种方法 RegExp 对象表示正则表达式。 修饰符包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。","text":"JS中生成RegExp对象的两种方法 RegExp 对象表示正则表达式。 修饰符包含属性 “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配。 方法1：使用直接量的方式规则用//包裹起来，修饰符跟在后面： 1const regexp1=/规则/修饰符; 例子： 12//^表示开头，g表示全局匹配。即：开头为a的字符串就满足这个正则表达式const regexp1=/^a/g; 方法2：使用构造函数RegExp的方式规则和修饰符都用引号包裹起来： 1const regexp2=new RegExp('规则','修饰符'); 例子： 1const regexp2=new RegExp('^a','g'); 或者 1const regexp2=new RegExp(/规则/修饰符); 例子： 1const regexp3=new RegExp(/^a/g); 正则方法 字符串的正则方法有：match()、replace()、search()、split() 正则对象的方法有：exec()、test() 注意区分match()和exec()，他们都是返回匹配结果的数组，但区别如下表： match() exec() 字符串的正则方法，使用字符串对象进行调用 正则对象的方法，使用RegExp对象进行调用 返回的是匹配完成后完整的数组 每调用一次返回单次对应的匹配结果并用数组的方式显示 区分match()和exec()的例子：12345678910const r1 = /imooc/g;const str = \"imoocimooc_imooc\";console.log(r1.exec(str));//[\"imooc\", index: 0, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 5, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 11, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//nullconsole.log(str.match(r1));//[\"imooc\", \"imooc\", \"imooc\"] match() 方法 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值(数组)，而不是字符串的位置。 返回值:存放匹配结果的数组。 语法：12stringObject.match(searchvalue)stringObject.match(regexp) 参数 描述 searchvalue 必需。规定要检索的字符串值。 regexp 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 例子：在下面正则表达式完整例子中使用。 exec()方法 exec() 方法用于使用正则表达式，检索字符串中的正则表达式的匹配。 语法：RegExpObject.exec(要检索的字符串) 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 与match()类似，他们都是返回匹配结果的数组，但match()是字符串的正则方法（是使用字符串对象进行调用），exec()是正则对象的方法（使用RegExp对象进行调用）。 例子：在下面y粘连修饰符的例子*中使用。 test()方法 test()方法用于检测一个字符串是否匹配某个模式. 返回值：布尔型。如果字符串中有匹配的值返回 true ，否则返回 false。 注意：和match()类似，不过他返回的是布尔值而不是匹配值构成的数组。 语法：RegExp对象.test(要检测的字符串) 例子：在下面u修饰符的例子中使用。 正则表达式完整例子123456789101112131415//^表示开头，g表示全局匹配。即：开头为\"你\"的字符串就满足这个正则表达式const regexp1 = /^你/g;console.log(\"你好呀你好呀你好呀\".match(regexp1));//[\"你\"]const regexp2 = new RegExp(\"^你好\", \"g\");//不要漏掉g的引号console.log(\"你好呀你好呀你好呀\".match(regexp2));//[\"你好\"]const regexp3 = new RegExp(/^我/g);console.log(\"你好呀你好呀你好呀\".match(regexp3));//null，不符合规则const regexp4 = /你/g;//去掉^console.log(\"你好呀你好呀你好呀\".match(regexp4));//[\"你\", \"你\", \"你\"]const regexp5 = /你/;//去掉g,不再全局搜索console.log(\"你好呀你好呀你好呀\".match(regexp5));//[\"你\"] 正则表达式构造函数RegExp的变化不管有多少个“原来的修饰符”，都会被“新增的修饰符”覆盖，注意：新增的修饰符需要引号 1const regexp = new RegExp(/规则/原来的修饰符,\"新增的修饰符\"); 例子： 1const regexp = new RegExp(/^你/igm,\"i\");//最后生效的是i 定位符 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 ^用于定位/否定 用于定位：/^[0-9]/g表示全局匹配一个0-9开头的 用于表示否定：这个字符出现在一个字符集合模式的第一个字符时，他用于表示否定。/[^0-9]/ig表示表示全局匹配所有非数字字符（不区分大小写） 元字符 [a-z]字符范围。匹配指定范围内的任意一个字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 \\d匹配一个数字字符。等价于 [0-9]。 x|y匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz]字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 \\w匹配字母、数字或者下划线,等价于[A-Za-z0-9_] /g全局匹配 非打印字符 非打印字符也可以是正则表达式的组成部分。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 特殊字符 \\将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， n匹配字符 n。\\n匹配换行符。序列 \\\\匹配 \\，而 \\(则匹配 (。 限定符 +匹配前面一个表达式 1 次或者多次,要匹配 + 字符，请使用 \\+。 *匹配前一个表达式 0 次或多次，要匹配 * 字符，请使用 \\*。 ？问号代表前面的字符最多只可以出现一次（0次或1次）【例子：colou?r 可以匹配 color 或者 colour】或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 |指明两项之间的一个选择。要匹配 |，请使用 \\|。（^\\s+|\\s+$表示：匹配以一个或多个空格开始（^\\s+），或者(|)以一个或多个空格结束(\\s+$)的字符串。） {n}n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,}n 是一个非负整数。至少匹配n 次。例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。o{1,} 等价于 o+。’o{0,}’ 则等价于 o*。 {n,m}m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 o?。请注意在逗号和两个数之间不能有空格。 关于+和*可以看下面“match相关题目1”理解其用法。 运算符优先级相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序： 相关题目身份证相关题目15位身份证（第一代）15位号码各位的含义 1-2位省、自治区、直辖市代码； 3-4位地级市、盟、自治州代码； 5-6位县、县级市、区代码； 7-12位出生年月日,比如670401代表1967年4月1日（这是与18位的第一个区别）； 13-15位为顺序号，其中15位男为单数，女为双数； 举例介绍130503 670401 001的含义: 13为河北，05为邢台，03为桥西区，出生日期为1967年4月1日，顺序号为001。 正则表达式 18位身份证（第二代）要注意最后一位！ match相关题目1正则方法match()可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配，返回指定的值(数组)。(更多相关知识可查阅“ES6扩展 正则扩展”中的“match() 方法”)因为+和*都是贪婪匹配，它们会尽可能多地匹配字符，所以\\d+匹配”75”，\\w*匹配”team2017”，而/g就没有表演的机会了。最后选C。关于&amp;quot:属于html中的特殊字符的转义，选项中为双引号。 match相关题目2需要明确： 关于//的含义请到笔记顶部看“JS中生成RegExp对象的两种方法”的“方法1” 正则表达式里： 出现0次或多次. [0,+∞] 出现1次或多次 [1,+∞] g是全局匹配 /b+/ 也就是b出现1次或多次，/b*/ 是b出现0次或多次，/b{1,4}/ 是b至少出现1次，至多出现4次，/b{1,5}/ 是b至少出现1次，至多出现5次。 匹配整数的题目A正负整数，B正整数，C负整数，D正整数或者0 需要知道的？问号代表前面的字符最多只可以出现一次 匹配前面的子表达式零次或多次[a-z]字符范围。匹配指定范围内的任意一个字符.\\d 匹配一个数字字符。等价于 [0-9]。 各选项解析A.(-?[1-9]\\d*)|0 -号出现0次或1次，然后匹配一个1-9之间的数字字符0次或多次。或者匹配0。即 整数或者0。B.[1-9]\\d* 匹配一个1-9之间的数字字符0次或多次，即 正整数。C.-[1-9]\\d* 匹配一个-（1-9）之间的数字字符0次或多次，即 负整数。D.[1-9]\\d*|0 匹配一个1-9之间的数字字符0次或多次，或者匹配0，即 正整数或者0。 删除字符串头尾空格如果你的浏览器不支持 trim() 方法，你可以使用正则表达式来实现: 12345678function myTrim(x) &#123; return x.replace(/^\\s+|\\s+$/gm,'');&#125; function myFunction() &#123; var str = myTrim(\" Runoob \"); alert(str);&#125; (完整例子) 生成正则表达式对象：const regexp1=/规则/修饰符; 修饰符：g表示全局匹配，m表示多行匹配。 规则： 定位符：^ 输入字符串开始的位置，$ 输入字符串结尾的位置。 \\s匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 |指明两项之间的一个选择。要匹配 |，请使用 \\|。 +匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+等价于 {1,}。 总结：也就是说，如果x以一个或多个空格开始，替换全部空格为空（^\\s+）；或者(|)，如果x以一个或多个空格结束(\\s+$)，替换全部空格为空。 特别注意|的用法和思路！！^\\s+|\\s+$表示：匹配以一个或多个空格开始（^\\s+），或者(|)以一个或多个空格结束(\\s+$)的字符串。 更多可参考廖雪峰的相关解释 正则表达式 - 元字符 参考 正则表达式 - 语法参考","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"nodejs介绍","slug":"nodejs介绍","date":"2019-12-31T13:10:44.000Z","updated":"2020-02-18T13:29:13.843Z","comments":true,"path":"2019/12/31/nodejs介绍/","link":"","permalink":"http://yoursite.com/2019/12/31/nodejs介绍/","excerpt":"ES，js和nodejs区别 ES是语法规范，没有api只靠它自己什么也做不了（ES文档看阮一峰的书） js是ES+web API,可以完成浏览器端操作 nodejs是ES+node API，可以完成server端操作nodejs的API文档 在nodejs中尽量使用ES6的语法。","text":"ES，js和nodejs区别 ES是语法规范，没有api只靠它自己什么也做不了（ES文档看阮一峰的书） js是ES+web API,可以完成浏览器端操作 nodejs是ES+node API，可以完成server端操作nodejs的API文档 在nodejs中尽量使用ES6的语法。 commonjs模块化规范使用模块化的好处：可以对代码进行拆分，将功能相似的代码放在一起，在不同的地方都可以进行直接调用。（类似react.js中的组件） 步骤： 在vscode中打开工作文件夹，在vscode终端输入npm init -y用于初始化npm环境 再输入npm i lodash --save用于安装lodash库（其中，lodash是node中常用的数据库） 在根目录中会出现package.json文件，文件内有：（其中，lodash就是依赖的名字） 123\"dependencies\": &#123; \"lodash\": \"^4.17.15\" &#125; 在js文件中引用const _=require(&#39;lodash&#39;)(其中，lodash为package.json里面的依赖名字) 一般使用_代替lodash，所以在需要这个库的js文件顶部调用const _ = require(&#39;lodash&#39;)即可 想要使用该工具库的方法时只需调用_.方法名即可，比如： 12const arr = _.concat([1,2],3)console.log('arr1',arr)//arr1[1,2,3] 注意：可以直接使用require调用node自带的库，不需要另外安装或编写代码、输出，比如const http = require(&#39;http&#39;) debugge推荐使用vscode这个IDE作为debug的工具。 新建一个目录，然后在该目录下在vscode终端输入npm init -y用于初始化npm环境 在该目录下会出现一个package.json文件，该文件内有&quot;main&quot;:&quot;index.js&quot;,也就说明主页面是index.js，那么你需要保证你的目录下有这个文件，或者可以修改页面名称。 在vscode中目录左侧有个虫子图标就是用来debug的，注意点击图标以后出现在目录上方位置的绿色箭头代表“开始debug” 注意打断点，可以通过点击来删除断点，删除后可以点击红色方框停止debug。 server端和前端的区别服务稳定性server端可能会遭受各种恶意攻击和误操作，单个客户端（前端）可以意外挂掉，但是服务端不能。 CPU和内存的优化、扩展前端（客户端）独占一个浏览器，内存和CPU都不是问题，但server端要承载很多请求，CPU和内存都是稀缺资源。 优化：使用stream写日志扩展：使用redis存session（后面会详细讲解） 日志记录前端也会参与写日志，但只是日志的发起方，不关心后续。而server端要记录日志、存储日志、分析日志，前端不关心 安全server端要随时准备接收各种恶意攻击，前端则少很多。如：越权操作（比如用户想删除别的用户的博客），数据库攻击等。后面会讲解登录验证，预防XSS攻击和sql注入（XSS攻击前端也有一部分责任） 集群和服务拆分产品发展速度快，流量可能会迅速增加。server端需要考虑如何通过扩展机器和服务拆分来承载大流量。 module.exports 与 exports强烈建议使用module.exports = xxx的方式来输出模块变量，它可以应对任何情况。具体原因可以参考廖雪峰的博客 区分export、export default和module.exports、exports 相同点：文件、变量、函数等导出 不同点：module.exports、exports是Common.Js规范；而export、export default是es6规范。 module.exports、exports node.js遵循Common.Js规范。 推荐使用modules.exports。使用exports可能会有意料之外的错误。 export、export default React遵循es6规范。 一个js文件可以有很多个export，但只能拥有一个export default`。 在React.js中，输出可以使用export或者export default，建议使用export。","categories":[{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"Number类及其方法","slug":"JS_Number","date":"2019-12-15T12:37:00.000Z","updated":"2019-12-16T07:24:11.961Z","comments":true,"path":"2019/12/15/JS_Number/","link":"","permalink":"http://yoursite.com/2019/12/15/JS_Number/","excerpt":"Number Number ：表示整数和浮点数 NaN ：即非数值（ Not a Number ）是一个特殊的数值","text":"Number Number ：表示整数和浮点数 NaN ：即非数值（ Not a Number ）是一个特殊的数值 面试常考！说明： 任何涉及NaN的操作（例如NaN/10 ）都会返回NaN。 NaN与任何值都==不相等==，包括NaN本身。 如果typeof一个NaN，你会在F12中看到number，因为==NaN是特殊的number== toFixed() 方法指定小数位数 toFixed()方法可把 Number类对象的值 四舍五入为指定小数位数的数字（注意是字符串形式的数字）。(通过参数规定小数的位数) 语法：NumberObject.toFixed(num) 参数num:必需。规定小数的位数，是 0 ~ 20 之间的值，包括 0 和 20，有些实现可以支持更大的数值范围。如果省略了该参数，将用 0 代替。 返回值：返回 NumberObject 的字符串表示，不采用指数计数法，小数点后有固定的 num 位数字。如果必要，该数字会被舍入，也可以用 0 补足，以便它达到指定的长度。如果 num 大于 le+21，则该方法只调用 NumberObject.toString()，返回采用指数计数法表示的字符串。 抛出异常：当 num 太小或太大时抛出异常 RangeError。0 ~ 20 之间的值不会引发该异常。有些实现支持更大范围或更小范围内的值。当调用该方法的对象不是 Number 时抛出 TypeError 异常。 toPrecision() 方法指定数字总长度 toPrecision() 方法可在Number对象的值超出参数指定的位数时将其有效长度转换为指数计数法（科学记数法）。（把Number对象的值格式化为参数指定的长度，注意是总位数不是小数位数） 语法：NumberObject.toPrecision(num) 参数num：必需。规定必须被转换为指数计数法的最小位数。该参数是 1 ~ 21 之间（且包括 1 和 21）的值。有效实现允许有选择地支持更大或更小的 num。如果省略了该参数，则调用方法 toString()，而不是把数字转换成十进制的值。 返回值： 返回 NumberObject 的字符串表示，包含 num 个有效数字。 参数 num &gt;= NumberObject 整数部分的所有数字时返回的字符串将采用定点计数法。 否则，采用指数计数法（科学记数法），即小数点前有一位数字，小数点后有 num-1 位数字。必要时，该数字会被舍入或用 0 补足。 抛出异常：当 num 太小或太大时抛出异常 RangeError。1 ~ 21 之间的值不会引发该异常。有些实现支持更大范围或更小范围内的值。当调用该方法的对象不是 Number 时抛出 TypeError 异常。 参数规定的有效数字的位数是从数字第一个不为0的数(包括整数部分和小数部分)开始计算的位数。 在指数记数法（科学记数法）中，E是指数的意思，在java中e代表10的幂次,5.62e+5 = 5.62*10^5; 同样的,5.62e-5 = 5.62*10^(-5) 例子： 12345678910111213141516171819202122232425//toPrecision()会进行四舍五入var num = 423.536;// 调用的是toString()方法document.writeln( num.toPrecision() ); // 423.536num = 562345.12456;// 由于整数部分有6位，要求只有3位有效数字，必须采用指数计数法才能表示。document.writeln( num.toPrecision( 3 ) ); // 5.62e+5num = -2651.10;// 整数部分有4位，要求的有效数字为4位，采用定点表示法document.writeln( num.toPrecision( 4 ) ); // -2651num = 4564561.12457;// 整数部分有7位，要求有效数字为1位，采用指数计数法document.writeln( num.toPrecision( 1 ) ); // 5e+6num = 231;// 整数部分有3位，要求有效数字为5位，采用定点表示法，并在小数部分填充两个0document.writeln( num.toPrecision( 5 ) ); // 231.00num = 0.8;// 整数部分有1位，要求有效数字为1位，采用定点表示法document.writeln( num.toPrecision( 1 ) ); // 0.8 区别toFixed() 方法和toPrecision() 方法 两者都是返回字符串形式的数字。 toFixed() 方法没有触发要求，参数直接规定小数位数，不采用科学记数法。（0 &lt;= 参数 &lt;= 20） toPrecision() 方法由参数规定整个数字的总位数。（1 &lt;= 参数 &lt;= 21）当 参数 &gt;= Number对象的值的整数位数 时采用定点记数法（也就是小数点）（比如：参数为1时，0.8 = 0.8）。否则采用科学记数法（比如：参数为3时，562345.12456 = 5.62*10^5 = 5.62e+5）","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS布局（2）浮动 inline-block 响应式","slug":"CSS布局（2）浮动 inline-block 响应式","date":"2019-12-11T03:15:37.000Z","updated":"2020-08-10T03:47:15.306Z","comments":true,"path":"2019/12/11/CSS布局（2）浮动 inline-block 响应式/","link":"","permalink":"http://yoursite.com/2019/12/11/CSS布局（2）浮动 inline-block 响应式/","excerpt":"浮动：两列布局方法1 设置左左浮动，或设置左右浮动（需要设置父元素的宽度）如果父级元素没有设置高度，则需要设置overflow:hidden避免父元素“高度坍塌”。","text":"浮动：两列布局方法1 设置左左浮动，或设置左右浮动（需要设置父元素的宽度）如果父级元素没有设置高度，则需要设置overflow:hidden避免父元素“高度坍塌”。 可参考笔记CSS布局 方法2只设置一个左浮动元素（红色），然后给右边蓝色列设置与红色浮动等宽的margin-left使得两列不重合。 如果右边蓝色列不设置与红色浮动等宽的margin-left，那么红蓝有一部分是重叠的，虽然不影响蓝色列文字的显示，但是后续文字padding的设置会很麻烦： 例子： 浮动：三列布局（3种方法）方法1 【3个浮动元素】：（可参考笔记三列布局（浮动或子绝父相））首先设置父级元素的宽度（width: 100%;overflow: hidden;） 可以左左右设置浮动,然后中间设置margin调整间距。 也可以都设置成左浮动，设置margin，调整间距。同样注意清除浮动！ 由于都是浮动元素，所以可以控制自己的宽高，也不用担心没脱离普通元素的文本流所引发的问题。（方法2就要注意这个问题） 方法2 【1、3列浮动，中间margin留位置】：设置第1、3列为浮动，中间使用margin将空间留出来给普通元素。为防止第三列浮动元素受到中间普通元素文本的影响，需要在HTML中将最左和最右两个浮动写在一起，中间的普通元素放在最后。 方法3 【1、3列绝对定位，中间margin留位置】：使用子绝父相，将父元素设置为相对定位（position：relative），使用position：absolute将第1、3列设置为绝对定位，中间使用margin将空间留出来给普通元素。（但我们很少这么做，因为绝对定位是完全脱离文档流的，缺少适应性方面的特性） 方法2 错误示范左列左浮动，中间使用margin-left和margin-right预留出左右两列的宽度，第三列右浮动：可以看到蓝色列顶部是在中间列下面的，三列并未对齐：原因：第三列是浮动，不会脱离文本流，所以他会给中间的普通元素的文本留出位置。 方法2 正确示范在HTML中将最左和最右两个浮动写在一起，中间的普通元素放在最后。那么浮动元素：此时，左边浮动尽量往上靠，右边浮动尽量往上靠，最后中间元素再进去看有没有空间： inline-block布局 思路：像文本一样排block元素 优点：不需要处理清除浮动等问题 缺点：需要处理两个inline-block元素之间的间隙 错误示范（间隙）效果：可以看到中间有一条缝，这是因为inline-block就像文字一样，两个文字中间一定是有间隙的 间隙的处理方法解决方法：首先将父元素的font-size设为0（字体大小都为0了，间隙也就为0了，但同时他的子元素的文字也会消失），然后分别设置inline-block子元素的font-size使子元素中文字可以显示出来。 父元素：解决代码：效果： 什么时候使用浮动/inline-block布局 使用inline-block布局比浮动布局要简单，但是处理一些自适应会比较麻烦，浮动布局会更加方便。 处理定宽的问题时使用inline-block布局。 响应式设计和布局 响应式设计： 在不同设备上正常使用，一般主要处理屏幕大小问题。 主要方法： 隐藏+折行+自适应空间 rem/viewport/media query rem代替px：1rem 等于 HTML 中的根元素的字体大小，可参考笔记CSS文本 viewport：使网页页面的宽度和设备屏幕的宽度进行匹配&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0&quot;&gt; width=device-width：将页面宽度width设为 屏幕区域大小device-width（注意区分 页面 和 屏幕 ，device-width只和设备有关系）,使页面和屏幕的宽度进行匹配。（如果不加这个，那么很多手机上网页的默认宽度使980px，然而手机只有这么大却要显示980个像素，看起来页面就被缩小了很多。） initial-scale：表示初始的缩放比例 media query： 根据不同设备的特性匹配不同样式。 viewport案例（适配移动端） viewport 是用户网页的可视区域。 viewport 翻译为中文可以叫做”视区”。 手机浏览器是把页面放在一个虚拟的”窗口”（viewport）中，通常这个虚拟的”窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。 没有使用viewport的效果： 加上viewport： 加上viewport之后的效果： media query案例隐藏给上一个例子加上media query，规定左边红色列只有在屏幕宽度大于640px的情况下显示，小于时隐藏左边红色列：一般移动端都是小于640px的，所以移动端就会隐藏左边红色列： 适配移动端 实现效果：让文字大小适配屏幕大小（等比例） 实现方法： 使用@media判断为移动端设备时，设置元素居中并改为块级元素：居中使其左右不留空位（滑动条），块级使其独占一行 将所有文字单位调整成rem，然后使用@media来设置不同屏幕大小时font-size的大小 注意：@media规则中max-width小的放在下面，以此保证识别顺序。并且注意预留空间，因为rem精准性不高，当font-size与之相除产生小数点时将取近似数，要求精准时请勿使用rem","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"BFC与浮动","slug":"BFC与浮动","date":"2019-12-10T09:20:06.000Z","updated":"2020-03-10T09:20:58.335Z","comments":true,"path":"2019/12/10/BFC与浮动/","link":"","permalink":"http://yoursite.com/2019/12/10/BFC与浮动/","excerpt":"BFC BFC即块格式化上下文（Block Formatting Context）。 特点： BFC会包含创建它的元素内部的所有内容，也就是在父元素中添加相应的属性来创建BFC则子元素就不会溢出（始终能被包含在父元素内部）。","text":"BFC BFC即块格式化上下文（Block Formatting Context）。 特点： BFC会包含创建它的元素内部的所有内容，也就是在父元素中添加相应的属性来创建BFC则子元素就不会溢出（始终能被包含在父元素内部）。 不理解的话可以先看下面“创建BFC包含浮动元素解决塌陷”的例子帮助理解。 创建BFC元素的方法可以通过给元素添加下面的属性，使元素变为BFC： 根元素(&lt;html&gt;) 浮动元素（元素的 float属性值 不是 none时） 绝对定位元素（元素的 position 为 absolute 或 fixed） 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） overflow 值不为 visible 的块元素（有副作用，建议使用display:flow-root） display 值为 flow-root 的元素 contain 值为 layout、content或 paint 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 注意：块级元素不算BFC！！ BFC布局规则 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 解决方法：在其中一个Box元素外面再罩一个BFC元素，两个BFC元素之间就不会发生外边距重叠了 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 BFC与浮动 BFC对浮动定位（float）与清除浮动（clear）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。 浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。 外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。 浮动元素的高度塌陷（通过高度塌陷这一问题帮助理解BFC的作用） 在使用float时我们遇到过高度塌陷的问题:浮动元素存在于正常的文档流之外，所以他们在父元素中所占的面积的有效高度为0（高度塌陷）。由于浮动的元素比它旁边的元素高，所以浮动元素溢出了，父元素并没能包含它。 1234&lt;div class=\"box\"&gt; &lt;div class=\"float\"&gt;I am a floated box!&lt;/div&gt; &lt;p&gt;I am content inside the container.&lt;/p&gt;&lt;/div&gt; 12345678910111213.box &#123; background-color: rgb(224, 206, 247); border: 5px solid rebeccapurple;&#125;.float &#123; float: left; width: 200px; height: 150px; background-color: white; border:1px solid black; padding: 10px;&#125; 创建BFC包含浮动元素解决塌陷方法1：使用overflow属性创建BFC创建一个会包含这个浮动的BFC，通常的做法是设置父元素 overflow: auto 或者设置其他的非默认的 overflow: visible 的值。 比如，给父元素box的样式添加overflow: auto; 设置 overflow: auto =&gt; 创建一个新的BFC来包含所有子元素（包括浮动） =&gt; 父元素&lt;div&gt;变成布局中的迷你布局,则任何子元素都会被包含进去（包括浮动元素）。 overflow副作用当使用overflow属性只是为了创建BFC的时候，可能会发现一些不想要的问题，比如滚动条或者一些剪切的阴影。另外，对于后续的开发，可能不是很清楚当时为什么使用overflow。所以你最好添加一些注释来解释为什么这样做。 方法2：使用display:flow-root创建BFC flow-root是一个新的 display 属性值，它可以创建无副作用的BFC。 在父级元素中使用 display: flow-root 即可创建新的BFC。 比如，给父元素box的样式添加display: flow-root;给 &lt;div&gt; display: flow-root 属性后，&lt;div&gt; 中的所有内容都会参与BFC，浮动的元素自然不会从底部溢出。 外边距塌陷/合并在百度前端技术学院 第五天学习笔记（CSS盒模型）中提到过“(块之间的)外边距margin折叠”的问题。 解决方法：创建新的BFC包裹其中一个box元素，两个BFC元素之间不存在外边距重叠，即可避免两个相邻box元素之间的 外边距合并 问题。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS布局（1）常用布局方法和浮动布局","slug":"CSS布局（1）常用布局方法和浮动布局","date":"2019-12-09T13:01:40.000Z","updated":"2020-06-30T03:39:13.296Z","comments":true,"path":"2019/12/09/CSS布局（1）常用布局方法和浮动布局/","link":"","permalink":"http://yoursite.com/2019/12/09/CSS布局（1）常用布局方法和浮动布局/","excerpt":"CSS布局 CSS布局是CSS知识体系的重中之重 早期以table为主（简单） 后来以技巧性布局为主（难） 现在又flexbox/grid（偏简单） 响应式布局是必备知识（适配移动端）","text":"CSS布局 CSS布局是CSS知识体系的重中之重 早期以table为主（简单） 后来以技巧性布局为主（难） 现在又flexbox/grid（偏简单） 响应式布局是必备知识（适配移动端） 常用布局方法 table 表格布局 float 浮动 + margin inline-block 布局 flexbox 布局 table 表格布局以前的表格布局不推荐使用，但是遇到实在解决不了的问题可以使用红框内的方法来实现“表格”布局：（可以通过在.table-cell中添加vertical-align：middle使表格内部文字垂直居中） 布局属性盒模型可参考笔记CSS盒模型 display、position属性 可参考笔记display属性值 可参考笔记position属性/) flexbox 布局 完整笔记可参考CSS flexbox flexbox,即 弹性盒子。这些盒子本来就是并列的，不需要特殊设置，只需要指定宽度即可。 但兼容性不好，需要写很多兼容的代码。 flexbox 父容器 display:flex;定义flexbox父容器。 flexbox子项 flex:1，flex为简写属性，但一般只需要将 flex 设置为 auto，initial，none，或一个无单位正数 即可。如果写多个flex属性值，那他是有顺序要求的！（CSS flexbox） 想让子项固定大小可设置flex为none然后给定width。 float 布局 完整笔记可参考CSS 浮动 float属性值有left、right。 特性 拥有 float属性 的元素脱离文档流但不脱离文本流。 float属性 会使元素形成“块”，能使内联元素也可设置宽高（给span元素添加float属性后可以设置宽高）【也就是改变元素的display属性值为inline-block】 float属性对自身的影响：元素位置会尽量靠上，然后再根据属性值尽量靠左/右.（具体体现在三列浮动中） float属性对兄弟元素的影响： 元素脱离文档流但不脱离文本流 使用float属性后，元素会脱离文档流（像绝对定位那样，不会对其他元素造成影响，文档中不会为他预留位置（他会和别的元素重叠并位于上方）），但不脱离文本流，也就是说他会影响其他元素的文本（会占据其他元素文本的空间）。 这个特性是float本身创造出来的作用，它可以帮助我们实现文字环绕图片的效果。 例子：绿色是靠左浮动，红色是普通div。可以看到绿色浮动元素并未占据文档中的位置，他和红色元素重叠了。但是绿色浮动元素占据了红色普通div中文字的空间，文字部分并未重叠。 float属性 使元素形成“块”【也就是改变元素的display属性值为inline-block】 给span元素添加float属性后可以设置宽高： float属性对自身元素的影响 float属性的元素位置会尽量靠上，然后再根据属性值尽量靠左/右. 注意：如果是三列浮动，前面两列最好指定left，第三列指定right。如果第二列和第三列都指定right，那么第二列会显示在最右边，而第三列会显示在中间。因为第二列源代码顺序上比第三列等级要高 (DOM上第二列先出现并声明了float: right;) ，所以在浮动顺序上也会比第三列等级要高。又因为两者同时像右浮动，所以第二列就会更加地靠右。 例子：可以看到第一个float尽量靠上显示了，第二个float由于必须要把span中的元素显示出来的关系，他只能挨着span尽量靠上，然后再靠左边。 float的元素时尽量靠上，那么当我们的float宽度太大的时候，没办法靠着红色span也就只能向下走了。 float属性对兄弟元素的影响 上面贴非float元素 旁边贴float元素 不影响其他块级元素位置 影响其他块级元素内部文本 以上影响都可以从上一个例子体现出来。 float属性对父级元素的影响 float元素会从布局上“消失” 父级元素高度塌陷（假设一个float元素是100px的高度，那么他会希望父级元素能撑开100px的高度，但是因为float元素脱硫文档流，所以如果父级里没有其他元素能撑起100px的高度，那么父级高度就会变成0） 解决父级元素高度塌陷通过overflow属性控制父元素宽高我们可以让父元素能控制自己的宽高。给父级元素设置overflow:auto，则父级元素会关注内部的元素，当内部元素超出时进行滚动。（当然overflow:hidden也可以） 在float元素后清除浮动可参考笔记清除浮动( clear 属性) 通过给float元素使用::after 伪元素来清除浮动： 12345678.clearfix::after &#123; content:\".\"; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; ::after的意思是在.clearfix内部的最后加入伪元素::after 首先要显示伪元素，所以display:block(display默认inline) 然后为伪元素加入空内容，以便伪元素中不会有内容显示在页面中，所以， content:&quot;&quot;；(.也可以，只要加上visibility:hidden;) 其次，为使伪元素不影响页面布局，将伪元素高度设置为0，所以， height:0 最后，要清除浮动，所以，clear:both。 after伪元素其实是通过 content 在元素的后面生成了内容为一个点的块级元素。这样一来只要设置这两个非浮动元素之间的距离就行了。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS非布局样式 知识点汇总","slug":"CSS非布局样式 知识点汇总","date":"2019-12-08T07:27:14.000Z","updated":"2020-10-30T03:41:18.893Z","comments":true,"path":"2019/12/08/CSS非布局样式 知识点汇总/","link":"","permalink":"http://yoursite.com/2019/12/08/CSS非布局样式 知识点汇总/","excerpt":"CSS是如何工作的CSS是如何工作的 CSS基础（非布局样式）","text":"CSS是如何工作的CSS是如何工作的 CSS基础（非布局样式） img是行内元素，为什么可以设置框高？（题目来自魅族一面）尽管img是行内元素，但同时它也是置换元素，置换元素一般内置宽高属性，因此可以设置其宽高。 引申问题：那么什么又是“置换元素”呢？ 置换元素就是会根据标签属性来显示的元素。反之就是非置换元素了。 比如img根据src属性来显示，input根据value属性来显示，因此可知道img和input是置换元素。 当然同理button、textarea、select也是置换元素。 img图片下方有空隙是为什么，怎么去除原因： 因为img实际上也是一个行内元素，而行内元素的属性vertical-align默认值为baseline，所以他是默认基于基线（baseline）对齐的，但baseline和底线之间是有偏差的。 图片偏差的大小是由同一行的文字大小决定的，如果文字是12px的，那么图片下方空隙就是3px左右。 解决方法： 通过设置vertical-align: bottom;将img设置为底线对齐。 通过设置display:block;将img改为块，也就不会基于底线对齐了。（当然也无法同一行显示了） 如何让一个很长的文本不换行？设置该文本的white-space属性为nowrap。 如何使用背景来实现网格（或波浪形）使用线性渐变网格例子，135deg:从左上角到右下角进行渐变。transparent：透明的。从0到49.5%是透明的，从49.5%到50.5%是绿色的，50.5%到100%继续回到绿色： 123body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) no-repeat;&#125; background-size不仅可以设置背景图片的大小，也可以设置渐变的大小，此时可以加上它并让他在x轴上重复（注意：简写属性中background-size必须紧随在background-position后并以/字符分隔）： 123body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px;&#125; 此时还可以加上一个背景进行多背景叠加（两个属性值之间使用,分隔）： 1234body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px, linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px;;&#125; 我们还可以去掉x轴重复并给div一个高度然后形成一片网格： 12345#id &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) center/30px 30px, linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%) center/30px 30px; height: 100px;&#125; 使用重复线性渐变没办法做两个颜色间隔不同的效果（这个可以去上面看重复的倍数关系） 1234#hi &#123; height: 100px; background-image: repeating-linear-gradient(135deg, transparent 0,transparent 5px, green 5px, green 10px);&#125; 注意：如果绿色的宽度和透明的宽度不是倍数关系就会不均匀（这个可以去上面看重复的倍数关系）: 1234#id &#123; height: 100px; background-image: repeating-linear-gradient(135deg, transparent 0,transparent 5px, green 5px, green 6px );&#125; CSS如何优化页面（雪碧图） 使用雪碧图，将多个图标放在一张图上加载，通过background-position定位来显示相对应的图片。 所有小图标集中在一个图片上，这样就可以减少http请求，提高页面访问速度。 有些情况下可以减少图片大小 自定义字体的使用场景及原理原理：使用网络字体然后在CSS中定义。 使用场景 当字体用：宣传/品牌/banner等固定文案（自定义中，中文字体占内存太大，只能放在固定文案上） 当图标用：字体图标(将图标设置成对应文字，使用时直接输入文字即可) 网络字体、本地自定义字体 从 远程/本地 引用字体。 CSS3 @font-face 规则(可以参考菜鸟教程)来引用 远程/本地 字体。 如果字体文件不在工程文件夹下的位置，请使用完整的URL：src: url(&#39;http://www.w3cschool.css/css3/Sansation_Light.ttf&#39;) 也可以直接连接别的网站的css样式表然后使用font-family属性进行网络字体的引用。（例子2） 如果远程的字体有问题，可能是跨域的问题。如果跨域，必须要求对方服务器出具cors的头，允许跨域。 例子1： 可以参考菜鸟教程 如果字体文件不在工程文件夹下的位置，请使用完整的URL：src: url(&#39;http://www.w3cschool.css/css3/Sansation_Light.ttf&#39;) 例子2： 也可以直接连接别的css样式表然后使用font-family属性进行网络字体的引用。 样式表中已经有对字体的定义，也就可以直接使用了。 iconfont 字体做图标 可以在“阿里巴巴矢量图标库：https://www.iconfont.cn/”找到各种图标。 加入购物车 - 统一 “添加至项目” - 得到一套图标 下载好后里面会有 使用demo： 本质上，这些图标都是字体，使用的是标签&lt;i&gt;，但实际上我们调用的是加到CSS中的伪元素::before： base64的使用普通的背景图中url()中是路径，而 base64 是一串文本。 用于减少HTTP请求（但会增大解码的开销，如果拿到的是图片，那只需要解码显示；如果拿到的是base64，就需要先把他转化为一个图片数据，然后再做后面的操作，在移动端有明显影响。） 适用于小图片 base64的体积约为原图的4/3 详细笔记 单行文字垂直居中line-height属性：&lt;span&gt;元素中文字的背景高度由文字大小撑起，当 line-height &gt; 文字高度 时，多余的空间就会分布在上下两端。所以可以通过设置line-height实现单行文字垂直居中。直接设置line-height就可以实现单行文字垂直居中，不需要额外给div设置height。 如何使用CSS做三角形/扇形 使用边框实现三角形/扇形 例子： 当我们分别设置border-bottom和border-right时可以发现，两个边框衔接处是斜线： 通过设置右边框为透明的（border-color属性值设为transparent）可以得到“直角梯形”： 同样设置左边框，得到等腰梯形： 只要去掉“上底边”我们就能得到三角形，而 底部边框 的上面试盒子区域，所以我们可以将盒子的宽度缩小至0，则上底边消失： 三角形的宽度是由左右两边框的粗细决定的，所以我们可以通过缩小左右两边框的的宽度使三角形成为锐角三角形： 扇形：添加border-radius属性（圆角）（笔记可参考这里） 如何处理浏览器兼容问题（hack） hack虽然不是最好的方案，但是确实是最快最有效的CSS 兼容性解决方案。 现在浏览器兼容性越来越好，已经越来越不需要hack了，但如果需要兼容IE7/8，CSS hack就很重要。 hack 即“不合法但生效的写法”，是比较偏门的写法，只在部分浏览器中生效。 作用：主要用于区分不同的浏览器。 缺点：难理解、难维护、易失效 替代方案1：特性检测 替代方案2：针对性加class 使用注意当我们使用hack时一定要将 标准属性 放在前面，hack放到后面。否则假设hack在前，标准在后，IE对第一个属性也生效，第二个属性也生效，最后成立的还是第二个属性，就体现不出区别了。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"setTimeout()与setInterval()","slug":"setTimeout与setInterval","date":"2019-12-08T06:43:12.000Z","updated":"2020-02-27T07:38:38.997Z","comments":true,"path":"2019/12/08/setTimeout与setInterval/","link":"","permalink":"http://yoursite.com/2019/12/08/setTimeout与setInterval/","excerpt":"setTimeout()与 setInterval() setTimeout()只执行一次回调函数，而setInterval() 会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 提示： 1000 毫秒= 1 秒。 setTimeout()与 setInterval() 都是异步的。","text":"setTimeout()与 setInterval() setTimeout()只执行一次回调函数，而setInterval() 会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。 提示： 1000 毫秒= 1 秒。 setTimeout()与 setInterval() 都是异步的。 定时器使用过后必须清除 如果是setTimeout这种定时器，不清理就会在线程空闲后立即执行一次。 如果是setInterval这种，不清理，就一直按照间隔不断的执行下去。 setTimeout() setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。 可以使用 clearTimeout() 方法来阻止函数的执行。(clearTimeout()使用方法) setTimeout()例子 语法： 12setTimeout(code, milliseconds, param1, param2, ...)setTimeout(function, milliseconds, param1, param2, ...) 返回值:返回一个 ID（数字），可以将这个ID传递给 clearTimeout() 来取消执行。 参数 描述 code/function 必需。要调用一个代码串/函数 milliseconds 可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0 param1, param2, … 可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数） setInterval() setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。 setInterval() 方法会不停地执行回调函数，直到 clearInterval() 被调用或窗口被关闭。由 setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。（clearInterval()使用方法） setInterval()例子 语法： 12setInterval(code, milliseconds);setInterval(function, milliseconds, param1, param2, ...) 返回值:返回一个 ID（数字），可以将这个ID传递给 clearInterval() 来取消执行。 参数 描述 code/function 必需。要调用一个代码串/函数 milliseconds 必须。周期性执行或调用 code/function 之间的时间间隔，以毫秒计 param1, param2, … 可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS hack和使用选择器美化checkbox","slug":"CSS hack和使用选择器美化checkbox","date":"2019-12-08T06:27:14.000Z","updated":"2020-02-24T05:24:33.625Z","comments":true,"path":"2019/12/08/CSS hack和使用选择器美化checkbox/","link":"","permalink":"http://yoursite.com/2019/12/08/CSS hack和使用选择器美化checkbox/","excerpt":"CSS hack 现在浏览器兼容性越来越好，已经越来越不需要hack了，但如果需要兼容IE7/8，CSS hack就很重要。 hack 即不合法但生效的写法，是比较偏门的写法，只在部分浏览器中生效。","text":"CSS hack 现在浏览器兼容性越来越好，已经越来越不需要hack了，但如果需要兼容IE7/8，CSS hack就很重要。 hack 即不合法但生效的写法，是比较偏门的写法，只在部分浏览器中生效。 作用：主要用于区分不同的浏览器。 缺点：难理解、难维护、易失效 替代方案1：特性检测 替代方案2：针对性加class 使用注意当我们使用hack时一定要将 标准属性 放在前面，hack放到后面。否则假设hack在前，标准在后，IE对第一个属性也生效，第二个属性也生效，最后成立的还是第二个属性，就体现不出区别了。 面试题：如何处理浏览器兼容问题hack虽然不是最好的方案，但是确实是最快最有效的CSS 兼容性解决方案。 美化checkbox【重点是 伪类选择器:checked和 兄弟选择器+的运用】效果： 实现过程 首先我们有一个checkbox和一个label,绑定以后点击label就相当于点击了 checkbox: 隐藏checkbox，此时可以通过点击label来代替点击checkbox 样式都写在label上（包括图标），图标是通过改变背景来实现的，:checked状态是CSS给的，利用它和 兄弟选择器+ 来实现背景（图标）的改变： 可参考笔记关于:checked 同方法美化单选框radio同样的方法也可以用于美化 单选框radio 类似方法其他案例同样使用 伪类选择器:checked和 兄弟选择器+： 设置三个单选框radio作为三个选项卡按钮，radio后面跟一个&lt;label&gt;放置选项卡内容 选中radio后状态改为:checked，通过:checked + label设置显示的选项卡内容。 面试题CSS样式（选择器）的优先级 计算权重确定（计算不会进位）【参考笔记1/参考笔记2】 !important最优先【参考笔记】 内联样式较为优先 如果权重一样，那么后写的优先级高【参考笔记】 可参考笔记选择器/选择器的优先级 雪碧图的作用 使用雪碧图，将多个图标放在一张图上加载，通过background-position定位来显示相对应的图片。 所有小图标集中在一个图片上，这样就可以减少http请求，提高页面访问速度。 有些情况下可以减少图片大小 自定义字体的使用场景及原理原理：使用网络字体然后在CSS中定义。 使用场景 当字体用：宣传/品牌/banner等固定文案（自定义中，中文字体占内存太大，只能放在固定文案上） 当图标用：字体图标(将图标设置成对应文字，使用时直接输入文字即可) 网络字体、本地自定义字体 从 远程/本地 引用字体。 CSS3 @font-face 规则(可以参考菜鸟教程)来引用 远程/本地 字体。 如果字体文件不在工程文件夹下的位置，请使用完整的URL：src: url(&#39;http://www.w3cschool.css/css3/Sansation_Light.ttf&#39;) 也可以直接连接别的网站的css样式表然后使用font-family属性进行网络字体的引用。（例子2） 如果远程的字体有问题，可能是跨域的问题。如果跨域，必须要求对方服务器出具cors的头，允许跨域。 例子1： 可以参考菜鸟教程 如果字体文件不在工程文件夹下的位置，请使用完整的URL：src: url(&#39;http://www.w3cschool.css/css3/Sansation_Light.ttf&#39;) 例子2： 也可以直接连接别的css样式表然后使用font-family属性进行网络字体的引用。 样式表中已经有对字体的定义，也就可以直接使用了。 iconfont 字体做图标 可以在“阿里巴巴矢量图标库：https://www.iconfont.cn/”找到各种图标。 加入购物车 - 统一 “添加至项目” - 得到一套图标 下载好后里面会有 使用demo： 本质上，这些图标都是字体，使用的是标签&lt;i&gt;，但实际上我们调用的是加到CSS中的伪元素::before： base64的使用普通的背景图中url()中是路径，而 base64 是一串文本。 用于减少HTTP请求（但会增大解码的开销，如果拿到的是图片，那只需要解码显示；如果拿到的是base64，就需要先把他转化为一个图片数据，然后再做后面的操作，在移动端有明显影响。） 适用于小图片 base64的体积约为原图的4/3 详细笔记 伪类和伪元素的区别 伪元素选择器：不会出现在HTML中，也不会出现在DOM树中，但它是真实存在的元素，它可以在页面上显示内容、设置样式等等。 伪类选择器：是已有元素的一种状态下的样式，它不是真实存在的元素（和伪元素要区分开） 前者单冒号，后者双冒号（但因为历史遗留问题，有的浏览器中后者也只能使用单冒号） 补充：很久以前 伪元素选择器 刚出现时也是和 伪类选择器 一样使用单冒号的，所以去兼容一些老旧的IE时也有可能需要使用单冒号来写伪元素选择器，否则可能显示不出来，这是历史遗留问题。 可参考笔记伪类和伪元素 如何美化checkbox(如何使用纯CSS实现checkbox)【重点是 伪类选择器:checked和 兄弟选择器+的运用】 效果： 实现过程 首先我们有一个checkbox和一个label,绑定以后点击label就相当于点击了 checkbox: 隐藏checkbox，此时可以通过点击label来代替点击checkbox 样式都写在label上（包括图标），图标是通过改变背景来实现的，:checked状态是CSS给的，利用它和 兄弟选择器+ 来实现背景（图标）的改变： 可参考笔记关于:checked 同方法美化单选框radio同样的方法也可以用于美化 单选框radio 类似方法其他案例同样使用 伪类选择器:checked和 兄弟选择器+： 设置三个单选框radio作为三个选项卡按钮，radio后面跟一个&lt;label&gt;放置选项卡内容 选中radio后状态改为:checked，通过:checked + label设置显示的选项卡内容。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"ES6 Promise（3）","slug":"ES6 Promise（3）","date":"2019-12-08T04:22:25.000Z","updated":"2020-02-18T04:27:50.324Z","comments":true,"path":"2019/12/08/ES6 Promise（3）/","link":"","permalink":"http://yoursite.com/2019/12/08/ES6 Promise（3）/","excerpt":"同步异步执行顺序注意：在Promise构造函数的内部，执行顺序是同步的。等内部执行完成后，再选择调用then或catch方法，then方法执行是异步的。","text":"同步异步执行顺序注意：在Promise构造函数的内部，执行顺序是同步的。等内部执行完成后，再选择调用then或catch方法，then方法执行是异步的。 53：打印155：注意：Promise构造函数的回调函数（参数）是同步执行的，它的then()是异步任务56:打印257：resolve()相当于调用了63-65，p.then()是异步任务，所以在本轮事件循环中所有同步任务执行完以后才会执行，所以5在最后打印。58：打印361：打印467：打印663-65：打印5 把同步任务转为异步任务72-74：创建一个函数createAsyncTask（）用于将传入的同步任务syncTask转换为已经决议为成功的Promise实例，由于已成功的状态，该实例会立即调用then()的第一个回调函数：把syncTask传给syncTask()并立即执行syncTask()。那么最后被返回出去的就是Promise实例syncTask()。76-81：调用这个函数createAsyncTask（），往里传入一个thenable对象作为参数。那么这个参数就会使用Promise.resolve()将自己变成 Promise实例，这个Promise实例执行完后返回2并成为已成功的状态，所以就会触发then()的第一个回调函数，该回调函数接收Promise实例返回的2作为参数： 小案例可以看到3张图片的加载时间是不同的，而是在最后一张图片加载完成后页面才显示出图片： 注意事件函数绑定时不能使用img.onload = resolve(img);这样图片还没加载完成，在赋值阶段函数resolve(img)就直接被调用了。 检验错误可以增加一个检验错误，多往数组中放入一个src：结果就会返回我们在loadImg()中的onerror()中返回的错误对象e： 总结 Promise 改善了传统回调造成的代码难维护、控制反转的问题。 Promise是异步的，但Promise构造函数中代码的执行时同步的。 如果Promise.all()接收的是空数组，那么马上会被决议为成功。 如果Promise.race()接收的是空数组，那么会永远挂起。 catch()返回的Promise实例，可以无线捕获错误问题（链式）。 Promise.resolve方法的传参 如果 resolve() 接收的是普通的值，就会立即被决议为成功，直接传递这个值。 如果 resolve() 接收的是一个Promise实例，则返回这个Promise实例。 如果 resolve() 接收的是一个thenable对象，则会把该对象包装成Promise实例，并立即执行该thenable对象的then() Promise.reject方法的传参Promise.reject()会产生一个决议失败的Promise实例，并直接传递接收到的参数。（不会有任何处理，假设参数是thenable对象，那么thenable对象也会被直接作为错误信息传递例子）","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS3 transform、transform-origin属性","slug":"CSS3 transform属性","date":"2019-12-07T08:43:32.000Z","updated":"2020-03-10T07:09:46.247Z","comments":true,"path":"2019/12/07/CSS3 transform属性/","link":"","permalink":"http://yoursite.com/2019/12/07/CSS3 transform属性/","excerpt":"transform属性 CSS3 transform属性 应用于元素的2D或3D转换,允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。","text":"transform属性 CSS3 transform属性 应用于元素的2D或3D转换,允许你旋转，缩放，倾斜或平移给定元素。这是通过修改CSS视觉格式化模型的坐标空间来实现的。 它只能转换由盒模型定位的元素。所以元素必须具有display: block。 MDN 属性值 一个或多个CSS变换函数 或 关键字值none 。 变换函数按从左到右的顺序相乘，这意味着复合变换按从右到左的顺序有效地应用。 MDN 属性值详解 属性值：rotate的例子 translate(x,y)平移 rotate(x turn/deg)旋转 参数单位： turn：转，0.5 turn = 180 deg deg：角度，1 deg = 1度 transform-origin 属性 transform-origin CSS属性让你更改一个元素变形的原点。 例子可参考MDN 属性值：可以是1/2/3个，其中每个值都表示一个偏移量，没有明确定义的偏移将重置为其对应的初始值。 1个值：表示水平偏移量,必须是&lt;length&gt;，&lt;percentage&gt;，或 left, center, right, top, bottom关键字中的一个。 2个值:值1表示水平偏移量，值2表示垂直偏移量,2个都必须是&lt;length&gt;，&lt;percentage&gt;，或left, center, right关键字中的一个。 3个值：前两个值和只有两个值时的用法相同。第3个值必须是&lt;length&gt;,它始终代表Z轴偏移量。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"ES6 Promise（2）","slug":"ES6 Promise（2）","date":"2019-12-07T07:43:26.000Z","updated":"2020-02-18T04:22:05.254Z","comments":true,"path":"2019/12/07/ES6 Promise（2）/","link":"","permalink":"http://yoursite.com/2019/12/07/ES6 Promise（2）/","excerpt":"信任问题结合笔记“ES6 Promise（1）”中“回调函数和promise实现平移动画”的例子来看。使用Promise不仅是解决了回调函数层层嵌套的问题，更多的是解决了“信任问题”，不交由第三方库，直接自己控制流程。","text":"信任问题结合笔记“ES6 Promise（1）”中“回调函数和promise实现平移动画”的例子来看。使用Promise不仅是解决了回调函数层层嵌套的问题，更多的是解决了“信任问题”，不交由第三方库，直接自己控制流程。 回调函数：假设我们将回调函数cb传给第三方库method，那么由于种种原因我们并不能保证这个第三方库安装我们的预想去执行回调，它有可能 快了一些/慢了一些/因为bug执行了两次cb函数。 使用Promise： Promise状态一旦改变为 成功/失败 就不能再被改变，所以传进去的函数不会被重复执行： 控制反转回调函数：控制权已经在第三方库而不在自己手上了，第三方库有可能会在执行回调函数的时候“添油加醋”干些别的。 使用Promise： 在resolve()中的代码都是自己写的，很大程度上改善了“控制反转”的问题： Promise.all()获取多个Promise实例的参数 Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 使用Promise.all()得到的一定是Promise 实例，如果参数数组中有不是 Promise实例 的存在，那么他会自动通过Promise.resolve()将其转换为 Promise实例 。 新的Promise 实例的状态判断： 数组中各个 Promise实例 的状态都是 fulfilled，新的Promise实例 的状态才是fulfilled。 一旦有一个数组中的Promise实例状态为rejected，新的Promise实例 的状态就会变成rejected。 注意：参数为空数组时会直接决定新的Promise实例的状态为 已成功。 使用Promise.all()传参： 新的Promise实例 的状态为fulfilled时，参数数组中各个 Promise 实例的返回值组成一个数组，传递给 新的Promise实例 的回调函数。 新的Promise实例 的状态为rejected时，第一个被reject的Promise实例的返回值，会传递给 新的Promise实例 的回调函数。 参数 参数可以是一个数组，各数组元素必须是Promise 实例（如果不是Promise 实例，就会先调用下面讲到的Promise.resolve方法将其转换为Promise 实例） Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 状态（fulfilled/rejected）和传参1const p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all()方法接受一个数组作为参数，p1、p2、p3都是 Promise 实例。如果不是Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 p的状态由p1、p2、p3决定，分成两种情况: 只有p1、p2、p3的状态都变成 fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成 rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 例子：p状态为fulfilled 例子：p状态为rejected将getData4()的状态改为reject并传参data4 err:此时p的then()第一参数将不被执行，第二参数返回data4 err：异步操作还是会执行，但是参数不会被传递。 例子：参数为空数组参数为空数组时会直接决定新的Promise实例的状态为 已成功：结果会打印’dfsafd’ Promise.race()（race 竞赛，所以可以理解为参数数组中各个Promise实例在竞赛，谁的状态先改变就影响新的Promise实例的状态） Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 使用Promise.race()得到的一定是Promise 实例，如果参数数组中有不是 Promise实例 的存在，那么他会自动通过Promise.resolve()将其转换为 Promise实例 。 但新的 Promise 实例的状态的判断方法不同，只要参数中的 Promise实例 中有一个实例率先改变状态，新的 Promise 实例 的状态就跟着改变。 传参：率先改变的那个 Promise 实例的返回值，就传递给 新的Promise 实例 的回调函数。 和Promise.all()的区别 Promise.all()中参数为空数组时会直接决定新的Promise实例的状态为 已成功。 在Promise.race()中参数为空数组时会直接挂起，什么反应也没有。 参数 和all()参数一样，可以是一个数组，各数组元素必须是Promise 实例（如果不是Promise 实例，就会先调用下面讲到的Promise.resolve方法将其转换为Promise 实例） Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 状态（fulfilled/rejected）和传参1const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.resolve() Promise.resolve()可以将现有对象转为 Promise 对象，可以不带参数调用它迅速得到一个resolved状态的 Promise 对象。 注意:立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时(具体可看下面“不带参数”的例子) 传参参数可以是 普通的值/Promise实例/thenable对象。 例子：参数为普通的值 例子：参数为Promise实例如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例： 例子：参数为thenable对象 thenable对象：和类数组的概念相似，类数组看着像是数组，那么就可以当作数组转换。thenable对象指具有then()的对象，它看起来像是Promise对象。 Promise.resolve方法会将这个thenable对象转为 Promise 对象，然后由于已成功的状态，就会立即执行thenable对象的then方法。 例子：不带有任何参数Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象，所以如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法: 12345const p = Promise.resolve();p.then(function () &#123; // ...&#125;); 上面代码的变量p就是一个 Promise 对象。 注意:立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时: 12345678910111213setTimeout(function () &#123; console.log('three');&#125;, 0);Promise.resolve().then(function () &#123; console.log('two');&#125;);console.log('one');// one// two// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(‘one’)则是立即执行，因此最先输出。 Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 注意：与Promise.resolve方法不一样。Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。（可以参考下面“例子：参数为thenable对象”） 传参例子：参数为普通的值下面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 12345678const p = Promise.reject('出错了');// 等同于const p = new Promise((resolve, reject) =&gt; reject('出错了'))p.then(null, function (s) &#123; console.log(s)&#125;);// 出错了 例子：参数为thenable对象下面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象: 1234567891011const thenable = &#123; then(resolve, reject) &#123; reject('出错了'); &#125;&#125;;Promise.reject(thenable).catch(e =&gt; &#123; console.log(e === thenable)&#125;)// true","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS非布局样式：边框、滚动、文本折行、装饰性属性","slug":"CSS非布局样式：边框、滚动、文本折行、装饰性属性","date":"2019-12-07T07:27:14.000Z","updated":"2020-02-24T05:15:47.526Z","comments":true,"path":"2019/12/07/CSS非布局样式：边框、滚动、文本折行、装饰性属性/","link":"","permalink":"http://yoursite.com/2019/12/07/CSS非布局样式：边框、滚动、文本折行、装饰性属性/","excerpt":"边框边框的属性border可参考笔记CSS边框、列表","text":"边框边框的属性border可参考笔记CSS边框、列表 CSS3边框背景图属性border-image border-image属性允许在元素的边框上绘制图像。这使得绘制复杂的外观组件更加简单，也不用在某些情况下使用九宫格了。使用 border-image 时，其将会替换掉 border-style 属性所设置的边框样式。 border-image属性是速记属性,用于设置 border-image-source, border-image-slice, border-image-width, border-image-outset 和border-image-repeat 的值。 省略的值设置为它们的默认值。 需要配合属性border一起使用。 JavaScript 语法: object.style.borderImage=&quot;url(border.png) 30 30 round&quot; 点击可看完整例子 可参考MDN、菜鸟教程 如何使用CSS实现 三角形/扇形使用边框实现三角形/扇形 例子：当我们分别设置border-bottom和border-right时可以发现，两个边框衔接处是斜线： 通过设置右边框为透明的（transparent）可以得到“直角梯形”： 同样设置左边框，得到等腰梯形： 只要去掉“上底边”我们就能得到三角形，而 底部边框 的上面试盒子区域，所以我们可以将盒子的宽度缩小至0，则上底边消失： 三角形的宽度是由左右两边框的粗细决定的，所以我们可以通过缩小左右两边框的的宽度使三角形成为锐角三角形： 扇形：添加border-radius属性（圆角）（笔记可参考这里） 滚动（overflow属性） CSS属性 overflow 定义当一个元素的内容太大而无法适应 块级格式化上下文 时该做什么。 它是 overflow-x 和overflow-y的 简写属性 。 可参考MDN 属性值 含义 visible 默认值。内容不会被修剪，会呈现在元素框之外 hidden 内容会被修剪，并且其余内容不可见 scroll 内容会被修剪，浏览器会显示滚动条以便查看其余内容 auto 由浏览器定夺，如果内容被修剪，就会显示滚动条 inherit 规定从父元素继承overflow属性的值 例子： 文本折行(CSS3属性)当我们遇到文字在一行放不下时会有一系列问题：是否换行，什么时候换行，在哪里换行，针对什么东西换行？ 在CSS3中这些主要就是下面3个属性决定的。（这三个属性可以组合使用） overflow-wrap(word-wrap)属性 通用换行控制 overflow-wrap属性 即 word-wrap属性（但是overflow-wrap有时候兼容性不好，所以大多使用word-wrap） overflow-wrap(word-wrap)属性决定换行时是否保留单词完整（即：当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行） 默认属性值normal:保留单词完整 可参考MDN 属性值 含义 normal （默认）保留单词完整 break-word （打断单词）如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行（但在这种情况下任然会尽量保证单词的完整性,希望去除单词完整性则需要使用word-break属性） 例子：默认值时，超出范围的超长单词被保留：属性值为break-word时，超出范围的超长单词被折断：但在这种情况下任然会尽量保证 单词的完整性（可以看到and没有被折断）,希望去除 单词完整性 则需要使用word-break属性。 word-break属性 针对多字节文字 word-break属性设置换行时的保留单位是否是单词 注意：此时 中文句子 也会被识别为 单词。 word-break属性指定非CJK脚本的断行规则。（CJK脚本是中国，日本和韩国（”中日韩”）脚本） 默认属性值是： 属性值 含义 normal （默认）使用浏览器默认的换行规则 break-all （打断所有的单词）允许在单词内换行 keep-all 只能在半角空格或连字符处换行（让所有的单词/中文句子都保持完整）【兼容性不好】 例子：默认下是：修改属性值为break-all后，打断所有的，不管是不是一个单词，所以and也被折行了：修改属性值为keep-all后，让所有的单词/中文句子都保持完整： white-space属性 空白处是否换行 white-space属性指定元素内的空白怎样处理（是否换行）。 空白处默认会被浏览器忽略， 属性值 含义 normal (默认)空白会被浏览器忽略。 pre 空白会被浏览器保留。其行为方式类似 HTML 中的&lt;pre&gt;标签。 nowrap 文本不会换行，文本会在在同一行上继续，直到遇到&lt;br&gt; 标签为止。 pre-wrap 保留空白符序列，但是正常地进行换行。 pre-line 合并空白符序列，但是保留换行符。 inherit 规定应该从父元素继承 white-space 属性的值。 例子：默认下是：修改属性值为nowrap后，文本不会换行: 面试题问题：如何让一个很长的文本不换行？答案设置该文本的white-space属性为nowrap。 装饰性属性字重（粗体）font-weight属性可参考笔记CSS文本 斜体 font-style属性 font-style属性默认值为normal,斜体font-style：itatic itatic记忆方法：意大利写斜体字。 可参考笔记CSS文本 下划线 text-decoration属性可参考笔记CSS文本 指针 cursor属性 常见的point属性值就是“手型”。 可参考笔记CSS文本","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"类数组","slug":"类数组","date":"2019-12-07T06:59:46.000Z","updated":"2020-03-31T04:23:28.669Z","comments":true,"path":"2019/12/07/类数组/","link":"","permalink":"http://yoursite.com/2019/12/07/类数组/","excerpt":"类数组常见的类数组有: 函数的参数 arguments, DOM 对象列表(比如通过 document.querySelectorAll 得到的列表), jQuery 对象 (比如 $(“div”)). 区分类数组和真实数组类数组是一个普通对象，而真实的数组是Array类型。","text":"类数组常见的类数组有: 函数的参数 arguments, DOM 对象列表(比如通过 document.querySelectorAll 得到的列表), jQuery 对象 (比如 $(“div”)). 区分类数组和真实数组类数组是一个普通对象，而真实的数组是Array类型。 类数组的特点 拥有length属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）; 不具有数组所具有的方法。 arguments对象 arguments 是一个对应于传递给函数的参数的类数组对象。arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。 此对象包含传递给函数的每个参数，第一个参数在索引0处。[]语法可访问它的每一个元素: 123arguments[0]arguments[1]arguments[2] 参数也可以被设置： 1arguments[1] = 'new value'; arguments对象不是一个 Array实例 ，它类似于Array。 但除了length属性和索引元素之外没有任何Array属性（length属性确定传递参数的个数）。例如，它没有 pop 方法。 但是它可以被转换为一个真正的Array(下面4种方法都可以将类数组转换为数组) MDN更多参考信息 类数组转换为数组结合剩余参数...区分剩余参数与扩展运算符：剩余参数... 是做聚合的，而 扩展运算符... 是做展开的，符号都是...,但含义不同。 下面这个例子中...表示剩余参数而不是扩展运算符，sum函数通过将所有的剩余参数1,2,3,4,&quot;ddd&quot;传进args做一个聚合将他们组转换为数组： 1234function sum(...args)&#123;//将传进来的类数组匹配到的剩余参数都放到args中组成数组 console.log(args);//[1, 2, 3, 4, \"ddd\"]&#125;sum(1,2,3,4,\"ddd\");//传入一个类数组,通过剩余参数可以转换为数组 在[1,2,...[1,2,3]];中...就表示扩展运算符，意为将[1,2,3]展开来放入另一个数组中。 注意：无论...表示 剩余参数 还是 扩展运算符，当它作为参数时它都必须在最后一个: 12345function op(type, ...nums) &#123; console.log(type);//sum console.log(nums);//[1, 2, 3, 4, 5]&#125;op(\"sum\", 1, 2, 3, 4, 5); 通过call()和slice()slice()可参考笔记JS对象之数组（1） 1Array.prototype.slice.call(arrayLike); 或者直接使用数组字面量[]即可少写Array.prototype: 1[].slice.call(arrayLike); 通过扩展运算符(2种方法)任何定义了遍历器（Iterator）接口的对象，都可以用扩展运算符转为真正的数组: 123456function sum() &#123; let args = [...arguments]; // let [...args] = arguments; console.log(args);//[1, 2, 3, 4, \"ddd\"]&#125;sum(1, 2, 3, 4, \"ddd\");//传入一个类数组,通过剩余参数可以转换为数组 通过Array.from()1Array.from(arrayLike); Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象。 可参考笔记数组扩展中的“将类数组转换为数组”","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"CSS非布局样式：背景","slug":"CSS非布局样式：背景","date":"2019-12-06T12:57:23.000Z","updated":"2020-02-24T05:14:44.588Z","comments":true,"path":"2019/12/06/CSS非布局样式：背景/","link":"","permalink":"http://yoursite.com/2019/12/06/CSS非布局样式：背景/","excerpt":"背景 background属性（其中包含了很多属性，这里具体补充 笔记CSS背景 中没有的渐变部分，其他参考笔记CSS背景） 多分辨率适配：图标需要适配移动端的时候可以将background-size调小，那么移动端上看到就会更加清晰。（大图调小一倍也就是“两倍图”/“高清屏”）","text":"背景 background属性（其中包含了很多属性，这里具体补充 笔记CSS背景 中没有的渐变部分，其他参考笔记CSS背景） 多分辨率适配：图标需要适配移动端的时候可以将background-size调小，那么移动端上看到就会更加清晰。（大图调小一倍也就是“两倍图”/“高清屏”） 背景颜色background属性值： 直接使用颜色名：red等 十六进制：#f9f9f5等 hsl(230 , 50%,50%)或hsla(230,50%,50%,.3)：h：扇形角度。s：饱和度（%）。l:亮度（%）。a：透明度（小数，0透明，1全黑） rgb（255,255,255）或rgba（0,0,0,.3）:红、绿、蓝、透明度 背景图url(链接) 渐变色背景 可参考MDN CSS 渐变可以在任何使用 &lt;image&gt; 的地方使用,例如背景。 线性渐变linear-gradient()、径向渐变radial-gradient（）和圆锥渐变conic-gradient()。 还可以使用 repeating-linear-gradient（） 和 repeating-radial-gradient（） 函数创建重复渐变，注意属性是background-image。 线性渐变linear-gradient()线性渐变由 linear-gradient 函数创建)，至少指定两个颜色（色标），也可以指定任意数量： 123.simple-linear &#123; background: linear-gradient(blue, pink) no-repeat;&#125; 改变渐变中心点 默认情况下，渐变会平滑地从一种颜色过渡到另一种颜色。 你可以通过设置一个值来将渐变的中心点移动到指定位置。 在如下示例中, 我们将渐变的中心点由50%设为10%：123.color-hint &#123; background: linear-gradient(blue, 10%, pink) no-repeat;&#125; 改变渐变方向 默认情况下，线性渐变的方向是从上到下 你可以指定一个值来改变渐变的方向：123.horizontal-linear &#123; background: linear-gradient(to right,blue, pink) no-repeat;&#125; 对角线渐变 你甚至可以设置渐变方向为从一个对角到另一个对角 比如左上角到右下角：123.diagonal-gradient &#123; background: linear-gradient(to bottom right,blue, pink) no-repeat;&#125; 设置渐变角度 如果你想要更精确地控制渐变的方向，你可以给渐变设置一个具体的角度 deg：degree 度 0deg 代表渐变方向为从下到上, 90deg 代表渐变方向为从左到右，诸如此类 正角度 都属于 顺时针 方向。 而 负角度 意味着 逆时针 方向。123.angled-gradient &#123; background: linear-gradient(90deg,blue, pink) no-repeat;&#125; 使用多种颜色想使用多少种颜色都可以，默认情况下，所设置颜色会均匀分布在渐变路径中。 123.simple-linear &#123; background: linear-gradient(90deg,blue, pink) no-repeat;&#125; 设置颜色终止位置 你不需要让你设置的颜色在默认位置终止。 你可以通过给每个颜色设置0，1%或者2%或者其他的 绝对数值 来调整它们的位置。 如果你将位置设置为百分数， 0% 表示起始点, 而100%表示终点，但是如果需要的话你也可以设置这个范围之外的其他值来达到你想要的效果。 如果有些位置你没有明确设置，那么它将会被自动计算，第一种颜色会在0%处停止，而最后一种颜色是100%，至于其他颜色则是在它邻近的两种颜色的中间停止。 例子：一个有趣的例子，135deg:从左上角到右下角进行渐变。transparent：透明的。从0到49.5%是透明的，从49.5%到50.5%是绿色的，50.5%到100%继续回到绿色： 123body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) no-repeat;&#125; background-size不仅可以设置背景图片的大小，也可以设置渐变的大小，此时可以加上它并让他在x轴上重复（注意：简写属性中background-size必须紧随在background-position后并以/字符分隔）： 123body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px;&#125; 此时还可以加上一个背景进行多背景叠加（两个属性值之间使用,分隔）： 1234body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px, linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px;;&#125; 我们还可以去掉x轴重复并给div一个高度然后形成一片网格： 12345#id &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) center/30px 30px, linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%) center/30px 30px; height: 100px;&#125; repeating-linear-gradient（）重复渐变 注意：repeating-linear-gradient（）是background-image的属性值。 CSS函数 repeating-linear-gradient（） 创建一个由重复线性渐变组成的&lt;image&gt;， 这是一个类似 linear-gradient 的函数，并且采用相同的参数，但是它会在所有方向上重复渐变以覆盖其整个容器 每次重复时，色标位置的偏移量都是基准渐变长度（最后一个色标和第一个之间的距离）的倍数。因此，最后色标的色值应该与第一个色标的色值保持一致；如果不一致的话，会导致非常突兀的渐变效果。 例子 1234#hi &#123; height: 100px; background-image: repeating-linear-gradient(135deg, transparent 0,transparent 5px, green 5px, green 10px);&#125; 注意：如果绿色的宽度和透明的宽度不是倍数关系就会不均匀: 1234#id &#123; height: 100px; background-image: repeating-linear-gradient(135deg, transparent 0,transparent 5px, green 5px, green 6px );&#125; 面试：如何使用背景来实现网格（或波浪形）使用线性渐变网格例子，135deg:从左上角到右下角进行渐变。transparent：透明的。从0到49.5%是透明的，从49.5%到50.5%是绿色的，50.5%到100%继续回到绿色： 123body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) no-repeat;&#125; background-size不仅可以设置背景图片的大小，也可以设置渐变的大小，此时可以加上它并让他在x轴上重复（注意：简写属性中background-size必须紧随在background-position后并以/字符分隔）： 123body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px;&#125; 此时还可以加上一个背景进行多背景叠加（两个属性值之间使用,分隔）： 1234body &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px, linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%) repeat-x center/30px 30px;;&#125; 我们还可以去掉x轴重复并给div一个高度然后形成一片网格： 12345#id &#123; background: linear-gradient(135deg, transparent 0, transparent 49.5%, green 49.5%, green 50.5%, transparent 50.5%, transparent 100%) center/30px 30px, linear-gradient(45deg, transparent 0, transparent 49.5%, red 49.5%, red 50.5%, transparent 50.5%, transparent 100%) center/30px 30px; height: 100px;&#125; 使用重复线性渐变没办法做两个颜色间隔不同的效果（这个可以去上面看重复的倍数关系） 1234#hi &#123; height: 100px; background-image: repeating-linear-gradient(135deg, transparent 0,transparent 5px, green 5px, green 10px);&#125; 注意：如果绿色的宽度和透明的宽度不是倍数关系就会不均匀（这个可以去上面看重复的倍数关系）: 1234#id &#123; height: 100px; background-image: repeating-linear-gradient(135deg, transparent 0,transparent 5px, green 5px, green 6px );&#125; 多背景叠加 通过使用 CSS3，你可以向元素应用多个背景。这些背景相互堆叠，第一个背景放在最上面，最后一个背景放在最下面。 仅最后一个背景允许拥有背景色。 可以使用简写属性 background 来设置多个背景，也可以使用除background-color 外的独立属性来设置多个背景。即下面的属性可以用属性列表来设置每一个背景： background，background-attachment，background-clip, background-image，background-origin，background-position， background-repeat， background-size。123.myclass &#123; background: background1, background 2, ..., backgroundN;&#125; 雪碧图 雪碧图将多个图标放在一张图上加载，通过background-position定位来显示相对应的图片。所有小图标集中在一个图片上，这样就可以减少http请求，提高页面访问速度。 目的：有时为了美观，我们会使用一张图片来代替一些小图标，但是一个网页可能有很多很多的小图标，浏览器在显示页面的时候，就需要像服务器发送很多次访问请求，这样一来，一是造成资源浪费，二是会导致访问速度变慢。这时候，把很多小图片（需要使用的小图标）放在一张图片上，按照一定的距离隔开，就解决了上述的两个问题。 例子：这是一张放了两个图标的图片：两个图标其实是取自同一张图片的两个不同位置：网页效果： 面试：CSS如何优化页面 使用雪碧图，将多个图标放在一张图上加载，通过background-position定位来显示相对应的图片。 所有小图标集中在一个图片上，这样就可以减少http请求，提高页面访问速度。 base64和性能优化 base64一般用在少量的小图标上去减少HTTP请求。 普通的背景图中url()中是路径，而 base64 是一串文本。 注意：在真正的工程项目中不可能通过例子中的方法去使用base64，这样后面维护的人会不知道都是哪些图，写的时候还是正常url，后面打包时会通过别的方法进行转码到base64。 缺点： 图片转成base64后，体积增大1/3(变为原来的4/3)，文件体积增大，本来图片是单独的文件，现在相当于将其放到了CSS文件中，这会导致CSS文件本身变得很大。 增大解码的开销，如果拿到的是图片，那只需要解码显示；如果拿到的是base64，就需要先把他转化为一个图片数据，然后再做后面的操作，在移动端有明显影响。 优点：节省HTTP请求。 例子：我们可以使用在线工具将一张本地图片转为base64： 使用base64： 123body&#123; background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAOAAAABbCAYAAABqIIlXAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AAASySURBVHic7d09TyJrHIfh3xJFsgTUnKjJQkO2oDg2VvSUJDYWhoZiO1q/gIVfwHa7LWwMhY2JJb0VjY3FyTZgsmxOzGo4EXTlFMOwvMwAo45/dr2vCoIMmHD7vMwQ33W73a4AmIhYvwHgLSNAwBABAoYIEDBEgIAhAgQMESBgiAABQwQIGCJAwBABAoYIEDBEgIAhAgQMESBgiAABQwQIGCJAwBABAoYIEDBEgIAhAgQMLYT9ArvH9bBfAng1lWL6RY/HCAgYIkDAEAEChggQMESAgCECBAwRIGCIAAFDBAgYIkDAEAEChggQMESAgKHQvw3xdiS0v7Oszei9qsff9Dnw81d1WIwrddPS7tn10CPb+Q8qrUsXtSsdXPofoVxIK58M/MLDfF//54Tfq/e7q62jk+86feZbeEsIcF7kokpJavx7PfJAQlsrEanTVm1CfH0djwhyG6pkNOUPgxsRXhMBzonyX4tSp63qud9ItqRSMa2Sx3NbzR/6VL31OfKqDjOL0k1bjaykWSLGqyHAeZBdUy4ptZp3zsh1Vu+PVLNOP70ltL8TV0qSkksqbaVV2hr/qcbXuvbOn/H+8WQEOAe2U4uK615Vj1EsFQsw/RxRLixrMyrPdV1/zal7XRKfGQI0t6r8ekTST8/HsklJNw8BNzYGN4Q6yhbj+pJ/GJim/opv9g2jReWLaeUn/ozXNPmpm1JvAwG+uGkf1OEPZLnQmyL273us/5JxVYrxCa/5qIvalZru3dz74d3Y2oK+bC2rshPTUSOiUmZx7H1MR0hhIMAXF+CDml1TLvmoxo2U6kX3eWD958Q4+/HKH3s3zr9pd3Baefldn1Y2VMksqZSR904pTBCgmYT2/16Smj9UVUKlsV1Pd/rZecao4041Hc5mizM9daeKk3dQETYCNLOgVbV1Ur2V8onxh7MLWpHUunsIfOStQroX9L2qx3XtDT16q4MTNzgnxkpxWa1mS199jpeK+a1R8VwEaOZaeyfOrW2vh1ciikvSuhOIv/Epau2sroP+PXdDxrk3POKNxjjp/c6yCSOfHVf4IcB5NbqOG+GcH4yo1fxvyhR1MDJnXekE/Rjs3OLUdePwdBezIcDfkBufbloT1m+DI9+vUXJwk2c2Ca3HJN0FPRWCWRDgnCoX0srHvK/rdOObPNUbGPlyG6qMTh9nnSpmY8pEpUaDaWUYCHAuJdT4p66j1IfebmVvBMttqJJxrhk9CrLOGpvOupsv8am7oO5VOudcLRMKApxLtzq9lHR5pVP1ppzuCPYi5/CG14W+smvaWY+o1bzlBHxICDCA/tprotl2C4OcfzutOiE6J+aXtJNP6NTvuVH/b03M5M694ZynjHfaOuI8YWgIMAA3BCvOBsqqDovLqhQWvNdwTx4hR74PmHuvzeijLmpcMROmd91utxvmC/D/AfEn4f8DAn8QAgQMESBgiAABQwQIGCJAwBABAoYIEDBEgIAhAgQMESBgiAABQ6FfjA3AHyMgYIgAAUMECBgiQMAQAQKGCBAwRICAIQIEDBEgYIgAAUMECBgiQMAQAQKGCBAwRICAIQIEDBEgYIgAAUMECBgiQMAQAQKGCBAw9D9TZ5jL6D/UAwAAAABJRU5ErkJggg==);&#125;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"ES6 Promise（1）","slug":"ES6 Promise（1）","date":"2019-12-06T04:29:23.000Z","updated":"2020-06-28T13:25:19.803Z","comments":true,"path":"2019/12/06/ES6 Promise（1）/","link":"","permalink":"http://yoursite.com/2019/12/06/ES6 Promise（1）/","excerpt":"复习：同步与异步 同步任务会阻塞程序执行（alert、for、…） 异步任务不会阻塞程序执行（setTimeout、fs.readFile、…） 可参考笔记[异步和单线程]中的例子来帮助理解。","text":"复习：同步与异步 同步任务会阻塞程序执行（alert、for、…） 异步任务不会阻塞程序执行（setTimeout、fs.readFile、…） 可参考笔记[异步和单线程]中的例子来帮助理解。 Promise对象 Promise对象用于表示一个异步操作的最终状态（完成或失败）以及其返回的值。–MDN Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。 Promise对象三种状态和特点 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。(后面的resolved统一只指fulfilled状态，不包含rejected状态。) 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled 或 从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 缺点： Promise 新建后就会立即执行，无法中途取消。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部 当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 更多资料可参考阮一峰《ES6入门》中关于“promise”的描述、MDN“使用promise” Promise()构造函数 ES6 规定，Promise()是一个构造函数，用来生成Promise实例。 Promise()的参数是一个回调函数，一般我们在这个回调函数中放置异步任务，这个回调函数又接收两个回调函数（resolve和reject）作为参数，当异步任务成功时执行回调函数resolve，当异步任务失败是执行回调函数reject。 Promise（）新建后就会立即执行。 then方法的参数（回调函数）将在当前脚本所有同步任务执行完才会执行 注意，调用resolve()或reject()并不会终结 Promise 的参数函数的执行。 注意：在Promise构造函数的内部，执行顺序是同步的。等内部执行完成后，再选择调用then或catch方法，then方法执行是异步的。在事件循环中要注意执行顺序。（可以参考笔记[ES6 Promise（3）]） 参数resolve和reject Promise构造函数接收一个函数作为参数，该函数的两个参数 分别是resolve和reject，它们 也是两个函数 ，由 JavaScript 引擎提供，不用自己部署。 【参数名可自定义，resolve和reject是约定俗成的参数名】 resolve()或reject()总是晚于本轮循环的同步任务。 resolve()使Promise对象的状态从 pending 变为 resolved。而reject()使Promise对象的状态从 pending 变为 rejected。状态一旦改变就不可逆转。 可以通过resolve()或reject()传参给then()或catch（）。 （异步操作放在Promise的参数函数中） 当Promise的参数函数中保存的异步操作成功，则可以调用resolve()将获取到的数据通过参数传递给then()的第一个参数函数。 如果异步操作失败，则可以调用reject()将错误信息通过参数传递给then()的第二个参数函数/catch()的参数函数。 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then或catch方法里面，而不应该直接写在resolve或reject的后面。所以，最好在resolve或reject前面加上return语句，这样函数就结束了，后面语句自然也就不会执行了（return resolve();）。 帮助理解resolve()和reject() 调用resolve()或reject()并不会终结 Promise 的参数函数的执行。 但是调用resolve()时会将 Promise 对象的状态（即Promise的参数函数中的异步操作）会从“未完成”变为“成功”（即从 pending 变为 resolved），那么then()方法的第一参数（函数）就会执行。 调用resolve()时可将异步操作获取到的数据通过传参给then()方法的第一参数函数。 而调用reject()时会将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），那么then()方法的第二参数（函数）或者catch()就会执行。 调用reject()将错误信息通过参数传递给then()的第二个参数函数/catch()的参数函数。 也就是说，调用resolve()或reject()不会终结 Promise 的参数函数的执行,但它可以告诉我们接下来运行then()还是catch()，所以为了防止resolve()或reject()后面的函数还继续执行，最好在resolve或reject前面加上return语句，这样函数就结束了，后面语句自然也就不会执行了（return resolve();）。 resolve函数： 在异步操作成功时调用，并将 异步操作的结果 作为 参数 传递出去。 作用：是将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved）。 可传参，通过resolve()传递的参数会在then()的第一个参数（函数）中接收到。（但只能传递一个参数） reject函数： 在异步操作失败时调用，并将 异步操作报出的错误 作为 参数 传递出去。 作用：将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected）。 可传参，通过 reject()传递的参数会在then()的第二个参数（函数）/catch()中接收到。（但只能传递一个参数） 例子下面代码创造了一个Promise实例: 123456789const promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 加上then方法Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数: 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 例子:Promise新建后立即执行Promise新建后就会立即执行: 1234567891011121314let promise = new Promise(function(resolve, reject) &#123; console.log('Promise'); resolve();&#125;);promise.then(function() &#123; console.log('resolved.');&#125;);console.log('Hi!');// Promise// Hi!// resolved 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法的参数（回调函数）将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 例子:Promise对象的then()下面是一个Promise对象的简单例子: 1234567891011function timeout(ms) &#123; return new Promise((resolve, reject) =&gt; &#123; //ms毫秒之后调用resolve函数并将参数`\"done\"`传给`resolve`函数 setTimeout(resolve, ms, 'done'); &#125;);&#125;//then的第一个参数是`Promise`对象的状态变为`resolved`时调用的回调函数（即promise执行函数成功执行以后会调用的函数），这里省略了第二个参数timeout(100).then((value) =&gt; &#123; console.log(value);&#125;); timeout(100)：调用timeout方法时传入ms为100，然后timeout方法返回一个Promise实例，表示ms(也就是100)毫秒之后调用resolve函数并将参数&quot;done&quot;传给resolve函数。过了100毫秒（ms参数）以后，Promise实例的状态变为resolved，接着触发then方法绑定的回调函数,打印value。【then()的第一个参数是Promise对象的状态变为resolved时调用的回调函数（即promise执行函数成功执行以后会调用的函数），这里省略了第二个参数】。 例子:异步加载图片复习：DOM事件onload会等到图片加载完成后立即执行（参考笔记）。 12345678910111213141516function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); //onload:图片加载完成后立即执行 image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125; 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 例子:resolve()参数是Promise对象resolve()的参数是另一个Promise对象的情况： 12345678const p1 = new Promise(function (resolve, reject) &#123; // ...&#125;);const p2 = new Promise(function (resolve, reject) &#123; // ... resolve(p1);&#125;) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 Promise.prototype.then()与 链式操作 每个Promise实例都拥有then()，then()根据调用它的promise对象的状态决定使用哪个参数（回调函数）。 then()为 Promise 实例 添加状态改变时的 回调函数。 then方法的 第一个参数 是 resolved状态的回调函数 ，第二个参数（可选）是 rejected状态的回调函数。 then()中的参数（回调函数）获取到的参数是由调用它的Promise对象在决议为成功/失败的同时返回的数据。 then方法的参数（回调函数）将在当前脚本所有同步任务执行完才会执行 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 注意： then确实会返回一个promise，但是如果不手动return Promise，那么默认返回的promise状态就是resolved，值看你return的是啥了，不写return的话，值是undefined。return非promise则值就是这个非promise。而手动return Promise，那返回的promise状态就不一定是resolved了，因此就可以改变下一个then/catch调用的结果了。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function (comments) &#123; console.log(\"resolved: \", comments);&#125;, function (err)&#123; console.log(\"rejected: \", err);&#125;); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。 resolve()/reject()传参then()中的参数（回调函数）获取到的参数是由调用它的Promise对象在决议为成功/失败的同时返回的数据。 通过resolve()传递的参数可在then()第一个参数（回调函数）中通过data获取，通过reject()传递的参数可在then()第二个参数（回调函数）中通过e获取： 注意：回调函数只能传一个参数，传两个参数时是获取不到第二个参数的： Promise.prototype.catch()处理失败 catch() 方法同样返回一个Promise实例，并且处理拒绝的情况。它的行为与调用Promise.prototype.then()第二个参数（回调函数） 相同。 由于catch()中处理错误以后返回的还是Promise实例，所以还可以继续调用then()。 一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 promise是异步的，then()也是异步的，对异步来说try...catch是没有用的。 结合上一个例子：在第二个then()中并没有对错误的处理，所以会继续往下执行，直到遇到catch()。如果catch()前面有then()对错误进行处理，则catch()不执行： 例子： 123456789101112const p1 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)const p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p1), 1000)&#125;)p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error))// Error: fail 上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。 注意，调用resolve或reject并不会终结 Promise 的参数函数的执行。 Promise.prototype.finally()一定执行不论Promise对象的异步操作结果成功还是失败，finally中的内容一定会执行。 例子： 比较传统的 回调函数 与 promise 使用 回调函数 和 promise 分别实现同样的功能，进行对比。 使用回调函数写出来的函数像一个“箭头”，层层嵌套，后期修改十分麻烦。 使用promise方法来写是链式写法，后期修改管理都很方便，直接复制粘贴即可。 复习逻辑与&amp;&amp;&amp;&amp;：前后都为真才是真，只要有一个是假的就是假。所以只要有第一个表达式是假的我们就不用继续判断了，返回第一个表达式。如果第一个表达式是真的我们就继续判断第二个表达式，（但由于一定要返回一个表达式，所以）此时无论真假都得返回第二个表达式。 明确：&amp;&amp;和||返回的是表达式，!返回的是布尔值！ 会被转换为 false 的表达式有：null； NaN； 0； 空字符串（”” or ‘’ or ``）； undefined。 所以在下面“回调方法用于请求数据（模拟）”的例子中，cb &amp;&amp; cb()表示“如果存在cb就调用cb()” 回调方法用于请求数据（模拟） 回调函数：将函数b作为参数传到函数a里，当函数a执行完之后，再执行传进去的函数b，这个过程就叫做回调，回调的就是作为参数的函数b。 使用回调函数用于请求数据的例子： 注意：调用回调函数时是不需要()的，直接使用函数名！ 实现功能：分别间隔一秒打印1,2,3,4 可以看到回调函数的形式来写是一层层嵌套的金字塔形，不方便后期的修改：123456789101112131415161718192021222324//回调函数就是放在参数里调用的函数，cb就是回调函数//写一个函数f()用于请求数据function f(cb) &#123; setTimeout(function () &#123; cb &amp;&amp; cb();//如果存在cb就调用cb(),注意cb必须是函数 &#125;, 1000);&#125;//调用f(),其中cb为匿名函数，间隔一秒打印1,2,3,4f(function () &#123; console.log(1); //在匿名函数中再嵌套一个f() f(function () &#123; console.log(2); //再嵌套一个f() f(function () &#123; console.log(3); //再嵌套一个f() f(function () &#123; console.log(4); &#125;) &#125;) &#125;)&#125;) promise方法用于请求数据（模拟） 实现同样的功能，使用promise方法来写则是链式写法（有关then()和链式操作可参考上面的相关笔记） 后期修改只需要复制粘贴，十分方便。 在例子中，f()返回一个Promise实例，规定了Promise执行成功时执行的函数（1秒后执行resolve()），then()中使用的是第一个参数（回调函数），相当于Promise（）中的resolve函数。12345678910111213141516171819202122232425function f() &#123; return new Promise(resolve =&gt; &#123; setTimeout(function () &#123; resolve(); &#125;, 1000); &#125;)&#125;f() .then(function () &#123; console.log(1); return f(); &#125;) .then(function () &#123; console.log(2); return f(); &#125;) .then(function () &#123; console.log(3); return f(); &#125;) .then(function () &#123; console.log(4); return f(); &#125;) 实例对比回调与Promise的流程控制实现效果：点击 按钮 后 绿色方块“哦” 分别间隔一秒进行几次平移后回到原始位置。 index.html: 回调函数实现平移动画(模板字符串相关知识可参考笔记ES6扩展 字符串扩展) main.js: 使用Promise实现平移动画main.js:（.then()中也可以不用return然后继续.then()并在其中调用moveTo()）","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS选择器 知识点汇总","slug":"CSS选择器 知识点汇总","date":"2019-12-05T07:00:18.000Z","updated":"2020-02-28T14:03:02.067Z","comments":true,"path":"2019/12/05/CSS选择器 知识点汇总/","link":"","permalink":"http://yoursite.com/2019/12/05/CSS选择器 知识点汇总/","excerpt":"选择器伪类选择器和伪元素选择器的区别 伪类选择器：是已有元素的一种状态下的样式，它不是真实存在的元素（和伪元素要区分开）【比如:checked表示某些特定的元素被选中(参考笔记)】 伪元素选择器：不会出现在HTML中，也不会出现在DOM树中，但它是真实存在的元素，它可以在页面上显示内容、设置样式等等。 伪类单冒号，伪元素双冒号（但因为历史遗留问题，有的浏览器中伪元素也只能使用单冒号）【比如：h1::before可以在h1元素的内容前面插入新元素。】 补充：很久以前 伪元素选择器 刚出现时也是和 伪类选择器 一样使用单冒号的，所以去兼容一些老旧的IE时也有可能需要使用单冒号来写伪元素选择器，否则可能显示不出来，这是历史遗留问题。 可参考笔记伪类和伪元素","text":"选择器伪类选择器和伪元素选择器的区别 伪类选择器：是已有元素的一种状态下的样式，它不是真实存在的元素（和伪元素要区分开）【比如:checked表示某些特定的元素被选中(参考笔记)】 伪元素选择器：不会出现在HTML中，也不会出现在DOM树中，但它是真实存在的元素，它可以在页面上显示内容、设置样式等等。 伪类单冒号，伪元素双冒号（但因为历史遗留问题，有的浏览器中伪元素也只能使用单冒号）【比如：h1::before可以在h1元素的内容前面插入新元素。】 补充：很久以前 伪元素选择器 刚出现时也是和 伪类选择器 一样使用单冒号的，所以去兼容一些老旧的IE时也有可能需要使用单冒号来写伪元素选择器，否则可能显示不出来，这是历史遗留问题。 可参考笔记伪类和伪元素 浏览器如何解析CSS浏览器的解析方式是从右往左的，这样比较节省性能浏览器的解析方式是从右往左的，浏览器看到.body div .hello这个选择器后会先去找.hello,找到这个标签后再去进行验证，看看他有没有一个祖先是&lt;div&gt;,再去看有没有一个class是body。原因:这样比较节省性能,可以减少很多工作。这样可以，加快浏览器对CSS的解析速度，可以更快匹配到对应元素。 如何美化checkbox(如何使用纯CSS实现checkbox)【重点是 伪类选择器:checked和 兄弟选择器+的运用】 效果： 实现过程 首先我们有一个checkbox和一个label,绑定以后点击label就相当于点击了 checkbox: 隐藏checkbox，此时可以通过点击label来代替点击checkbox 样式都写在label上（包括图标），图标是通过改变背景来实现的，:checked状态是CSS给的，利用它和 兄弟选择器+ 来实现背景（图标）的改变： 可参考笔记关于:checked 同方法美化单选框radio同样的方法也可以用于美化 单选框radio 类似方法其他案例同样使用 伪类选择器:checked和 兄弟选择器+： 设置三个单选框radio作为三个选项卡按钮，radio后面跟一个&lt;label&gt;放置选项卡内容 选中radio后状态改为:checked，通过:checked + label设置显示的选项卡内容。 CSS样式（选择器）的优先级 计算权重确定（计算不会进位）【参考笔记1/参考笔记2】 !important最优先【参考笔记】 内联样式较为优先 如果权重一样，那么后写的优先级高【参考笔记】 可参考笔记选择器/选择器的优先级","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS选择器与非布局样式：字体、行高","slug":"CSS选择器与非布局样式：字体、行高","date":"2019-12-04T09:01:40.000Z","updated":"2020-02-26T15:32:48.772Z","comments":true,"path":"2019/12/04/CSS选择器与非布局样式：字体、行高/","link":"","permalink":"http://yoursite.com/2019/12/04/CSS选择器与非布局样式：字体、行高/","excerpt":"基本规则1234选择器&#123; 属性：值； 属性：值；&#125; 这里的;并不是 语句结束符号 ，只是 分隔符。 选择器可参考笔记CSS选择器、派生选择器、伪类选择器、伪元素、组合选择器、选择器的优先级、概览","text":"基本规则1234选择器&#123; 属性：值； 属性：值；&#125; 这里的;并不是 语句结束符号 ，只是 分隔符。 选择器可参考笔记CSS选择器、派生选择器、伪类选择器、伪元素、组合选择器、选择器的优先级、概览 用于匹配HTML元素 有不同的匹配规则 多个选择器可叠加 分类和权重(不进位计算)要知道 选择器分类 元素选择器：div{}指定元素的名字 伪元素选择器：::before{}不会出现在HTML中，也不会出现在DOM树中，但它是真实存在的元素，它可以在页面上显示内容、设置样式等等。 类选择器：.className{}class 属性选择器：[type=radio]{}根据HTML元素的属性进行选择 伪类选择器：:hover{}是已有元素的一种状态下的样式，它不是真实存在的元素（和伪元素要区分开） ID选择器：#idName{} 组合选择器：[type=checkbox]+label{}有很多组合方法，例子是属性选择器的兄弟元素label 否定选择器:not(.className){}用()将选择器括起来再在前面加上not表示括起来的都不要 通用选择器:*{} 选择器权重更详细可参考笔记 特异性 分值 范围 100 ID选择器：#idName{} 10 类选择器：.className{}、属性选择器：[type=radio]{}、伪类选择器：:hover{} 1 元素选择器：div{}、伪元素选择器：::before{} 0 其他选择器 注意： 选择器权重的计算是不进位的（可看下面的例子，特别注意例子2：十位到了11个还是不进位！） 只有选择器才计算权重，如果样式的声明位于元素的style属性内，这样的声明没有选择器，所以 内联样式 始终是1000分。 !important优先级永远是最高的。（可参考笔记 特异性） 相同权重的选择器，后写的生效。（可参考笔记 源顺序） 权重计算的例子计算例子1： 123456789101112131415161718&lt;head&gt; &lt;style type=\"text/css\"&gt; #id .link a[href] &#123; color: red; &#125; #id .link .active &#123; color: green; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"id\"&gt; &lt;div class=\"link\"&gt; &lt;a href=\"https://huanglizhu.github.io/\" class=\"active\"&gt;zzz&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; [href]作用于所有具有 href 属性的元素当一个元素同时有左右两个选择器时，则左边的选择器优先级高。 计算例子2：十位就算有11也是不进位的！ 面试：伪类选择器和伪元素选择器的区别 伪元素选择器：不会出现在HTML中，也不会出现在DOM树中，但它是真实存在的元素，它可以在页面上显示内容、设置样式等等。 伪类选择器：是已有元素的一种状态下的样式，它不是真实存在的元素（和伪元素要区分开） 补充：很久以前 伪元素选择器 刚出现时也是和 伪类选择器 一样使用单冒号的，所以去兼容一些老旧的IE时也有可能需要使用单冒号来写伪元素选择器，否则可能显示不出来，这是历史遗留问题。 面试：浏览器如何解析CSS浏览器的解析方式是从右往左的，这样比较节省性能浏览器的解析方式是从右往左的，浏览器看到.body div .hello这个选择器后会先去找.hello,找到这个标签后再去进行验证，看看他有没有一个祖先是&lt;div&gt;,再去看有没有一个class是body。原因:这样比较节省性能,可以减少很多工作。这样可以，加快浏览器对CSS的解析速度，可以更快匹配到对应元素。 CSS非布局样式 文字相关的：字体、字重、颜色、大小、行高 盒子相关的：背景、边框 页面相关的：滚动、换行 装饰性的：粗体、斜体、下划线 其他重要的非布局样式 字体 可参考笔记CSS文本1、CSS文本2 font-family属性，多个属性值之间使用,分隔。 在样式中，使用具体字体需要引号，如：Microsoft Yahei，但使用 字体族 时不要用引号！ 字体族可参考笔记 字体栈 衬线字体（serif）：有装饰的，比如：宋体 无衬线字体（sans-serif）：比如：黑体 等宽字体（monospace）：每一个字母占的空间是一样的，编程的时候常用 手写体（cursive）：比如：方正静蕾体） 花体（fantasy）：英文中有一些华丽的写法 注意：在样式中使用字体族时不要用引号 多字体 fallback机制 多字体fallback机制：顾名思义是“应急计划”，可以指定多个字体，当第一种找不到时就会往后找，依次寻找可用的字体。 作用：适配不同的平台（苹果、微软等） 要将只有一个平台有的字体样式写在前面。比如例子中PingFang就只有苹果有，有的苹果用户也会下载 微软雅黑 ，但是 微软雅黑 在苹果中的效果没有PingFang好，所以我们还是应该把PingFang放在前面，以免部分苹果用户识别到了 微软雅黑。 将 字体族 写在最后。（或者说，将 网页安全字体 放在最后） 例子：解析：找不到 苹果系统 中的PingFang就去找 微软雅黑 ，微软雅黑也找不到时就去找 等宽字体monospace中找一个拿来用。 网络字体、自定义字体 从 远程/本地 引用字体。 CSS3 @font-face 规则(可以参考菜鸟教程)来引用 远程/本地 字体。 如果字体文件不在工程文件夹下的位置，请使用完整的URL：src: url(&#39;http://www.w3cschool.css/css3/Sansation_Light.ttf&#39;) 也可以直接连接别的网站的css样式表然后使用font-family属性进行网络字体的引用。（例子2） 如果远程的字体有问题，可能是跨域的问题。如果跨域，必须要求对方服务器出具cois的头，允许跨域。 例子1： 可以参考菜鸟教程 如果字体文件不在工程文件夹下的位置，请使用完整的URL：src: url(&#39;http://www.w3cschool.css/css3/Sansation_Light.ttf&#39;) 例子2： 也可以直接连接别的css样式表然后使用font-family属性进行网络字体的引用。 样式表中已经有对字体的定义，也就可以直接使用了。 iconfont 字体做图标 可以在“阿里巴巴矢量图标库：https://www.iconfont.cn/”找到各种图标。 加入购物车 - 统一 “添加至项目” - 得到一套图标 下载好后里面会有 使用demo： 本质上，这些图标都是字体，使用的是标签&lt;i&gt;（后来改为&lt;span&gt;），但实际上我们调用的是加到CSS中的伪元素::before： 行高（line-height属性） 行高指一行文字的高度（两行文字间基线的距离）就像英文本子里的 倒数第二条线。 css中起着高度作用的是heigh以及line-height，如果一个标签没有定义height属性，那么最终表现的高度一定是line-height起作用。 单行文字垂直：一个空的&lt;div&gt;&lt;/div&gt;没有设置高度，但在元素内添加文字，这个div就有了高度，并不是文字把div撑起来了，真正撑起高度的是line-height，所以直接把line-height当做区块高度来设置，那么其中高于文字的部分就会平均分布在文字上下，可以实现单行文字垂直。 行高的构成 line-height的高度是由组成这一行的众多元素（例子中的inline box ）中的最高高度决定的。（行高是由line box决定的，而line box是由很多inline box组成的） line-height会撑起行内元素的高度，但只改变元素上下多余的高度，不会改变它本身布局（显示）的高度。 &lt;span&gt;元素中字体显示的背景区域高度是由字体大小决定的。 在上图中可以给同一行中的4个&lt;span&gt;元素设置不同的line-height（第三个inline box没有使用&lt;span&gt;），并给&lt;span&gt;红色背景。结果：在网页上渲染出来的高度是一样的，而行高最终是第三个&lt;span&gt;元素的高度，也及时最高元素的高度。 行高相关的现象和方案不能用于图片垂直1，图片的line-height只能根据继承得到，写在内联里会被覆盖。2，给图片设置line-height并不能使其居中。表现为图片底部向上总是距离行高中垂线6px。 图片垂直的方法：将display设置成table-cell，然后水平居中设置text-align为center，垂直居中设置vertical-align为middle。 单行文字垂直居中&lt;span&gt;元素中文字的背景高度由文字大小撑起，当line-height&gt;文字高度时，多余的空间就会分布在上下两端。所以可以通过设置line-height实现单行文字垂直居中。以前我们记文本居中的方法是 设置height与line-height等高，但其实直接设置line-height就可以实现单行文字垂直居中，不需要额外给div设置height。 多行文字垂直居中使用line-height和display:inline-block可实现多行文字的垂直居中 vertical-align属性 CSS 的属性 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。【不作用于span元素】 默认值是 baseline，也就是根据基线对齐。（基线相当于英文中倒数第二条线）【注意：区分基线baseline和底线bottom】 vertical-align属性可被用于两种环境： 使 行内元素盒模型 与其行内元素容器垂直对齐。例如，用于垂直对齐一行文本的内的图片&lt;img&gt;. 垂直对齐表格单元内容. 可参考MDN vertical-align不作用于span元素原因：事实上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。如果把 vertical-align:middle放到一个单元格元素，即table的td元素中，它的垂直居中显示是没任何问题的，因为它表示相对于该行的垂直高度居中显示。一个 span定义了一个60px的高度，但是这个Box行中存在很多个span，这段文本并不能对齐到span的垂直中央。希望这段文本对齐span的中行需要给它定义一个line-height的属性，让line-height为60px，作用于一行的vertical-align就会按你的想法工作了。 面试题问题：img图片下方有空隙是为什么，怎么去除？原因： 因为img实际上也是一个行内元素，而行内元素的属性vertical-align默认值为baseline，所以他是默认基于基线（baseline）对齐的，但baseline和底线之间是有偏差的。 图片偏差的大小是由同一行的文字大小决定的，如果文字是12px的，那么图片下方空隙就是3px左右。 解决方法： 通过设置vertical-align: bottom;将img设置为底线对齐。 通过设置display:block;将img改为块，也就不会基于底线对齐了。（当然也无法同一行显示了）","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML知识点汇总","slug":"HTML知识点汇总","date":"2019-12-03T07:41:59.000Z","updated":"2020-10-27T03:47:28.674Z","comments":true,"path":"2019/12/03/HTML知识点汇总/","link":"","permalink":"http://yoursite.com/2019/12/03/HTML知识点汇总/","excerpt":"DOCTYPE 的意义是什么 让浏览器以标准模式渲染比如：我们都知道 标准盒模型和替代盒模型 ，很久以前IE有很多渲染模式，当我们带上DOCTYPE时，IE就知道要以标准模式渲染，也可以体现在 标准盒模型 上。（不只是IE，很多浏览器都有，也不一定是表现在盒子模型上，很多元素都有） 让浏览器知道元素的合法性比如：直接使用&lt;!DOCTYPE html&gt;浏览器就知道要根据html5的标准来审核元素是否合法（上面的“HTML版本”有图解不同版本的要求），但不合法也不会有什么事情，浏览器会做大量容错。","text":"DOCTYPE 的意义是什么 让浏览器以标准模式渲染比如：我们都知道 标准盒模型和替代盒模型 ，很久以前IE有很多渲染模式，当我们带上DOCTYPE时，IE就知道要以标准模式渲染，也可以体现在 标准盒模型 上。（不只是IE，很多浏览器都有，也不一定是表现在盒子模型上，很多元素都有） 让浏览器知道元素的合法性比如：直接使用&lt;!DOCTYPE html&gt;浏览器就知道要根据html5的标准来审核元素是否合法（上面的“HTML版本”有图解不同版本的要求），但不合法也不会有什么事情，浏览器会做大量容错。 HTML XHTML HTML5的关系 HTML属于SGML （SGML是非常通用的标记语言）。 XHTML属于XML，是HTML进行XML严格化的结果。（XML是SGML的一个子集，严格地讲，XML也还是SGML。） HTML5不属于SGML或XML，他自己就是一个独立的语法规范，保留了SGML的宽松，去掉了XML严格化的一些东西，比XHTML宽松。 HTML5有什么变化 新的语义化元素（新增语义更加明确的标签，不建议使用一些语义不强的元素：b、i、font等），方便写出更加语义化的结构。 表单增强（表单验证（在这之前只能通过js来完成）） 新的API（离线、音视频、图形、实时通信、本地存储、设备能力）【JS层面的】 分类和嵌套变更（变成按照内容分类，分类和推理过程的改变导致嵌套规则的改变，在html5中将a标签视作“透明”再来判断嵌套合法性） 可参考博客“前端基础-HTTP/HTML/浏览器”中“HTML5新增的元素” &lt;em&gt;和&lt;i&gt;的区别主要是语义化上的区别，i的语义不明确，也可用来写小图标icon。 &lt;em&gt;是语义化的标签，不仅表斜体，还表强调 &lt;i&gt;是纯样式的标签，表斜体 HTML5中&lt;i&gt;不推荐使用来表示斜体，一般用作图标（icon）的表示。 HTML语义化语义化简单说来就是用正确的标签做正确的事情，让机器可以读懂页面内容。 好处 大纲结构清晰，开发者容易理解，有利于后期维护。 降低机器处理 Web 内容的难度，方便 机器、爬虫、搜索引擎、读屏软件 去了解你的 网页结构，从而读懂web上发布的各种内容。 有助于SEO（SEO：搜索引擎优化），页面越是符合语义化就越有利于搜索引擎优化。 semantic microdata（另一个规范），她会在html中添加一些新的标记，标注这个东西是什么。【对元素做进一步的语义化标记，方便搜索】 怎么把网页写的符合语义化先对网页功能做一个划分，根据不同功能特点选择合适的标签（机器可读的、被广泛认可的）来创建一个 结构大纲 清晰的网页。 尽可能少使用无语义的标签div和span； 在语义不明显，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、i等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 注意：HTML5 并非 Web 语义唯一倚仗的规范，除了 W3C 和 WHATWG 外，还有其它的组织在为扩展、标准化 Web 语义做着贡献。只要有浏览器厂商、搜索引擎原意支持，它们的规范一样可以成为通用的基础设施。 html与SEO优化 &lt;head&gt;标签放网页的标题，各个页面不同。 &lt;meta keywords&gt;列举出几个重要的关键词。 &lt;meta description&gt;网页内容的高度概括。 每个页面尽量只出现一次H1标签，H2标签可以多次：H1权重很高，普遍认为仅次于title，一般资讯详情页的标题、商品详情页的标题，都放在H1里。 图片一定要添加alt属性，title属性可选：搜索引擎不认识图片上的内容，只能通过alt属性来判断，如果是商品列表页，所有商品都加了alt和title的话，容易造成堆砌关键词，所以我一般是只加alt属性。 换行标签&lt;br/&gt;只用来在文本间进行换行，标签间的换行通过margin或者&lt;p&gt;&lt;br&gt;&lt;/p&gt;。 搜索引擎抓取seo内容是从上到下，重要内容html代码放在最前面。 搜索引擎看不懂js， 重要内容不要用js输出。 尽量少使用iframe框架 谨慎使用display：none，搜索引擎会过滤掉这里面的内容。 哪些元素可以自闭合 表单元素input（注意： 区分表格元素和表单元素） 图片img 换行br 水平线hr 源信息meta link 在html5中自闭合的标签结束不要求加/,但html和html4中是要求的。 补充：表单元素 &lt;form&gt;标签 用于为用户输入创建 HTML 表单。 &lt;input&gt; 元素是最重要的表单元素，根据不同的 type 属性可变化为多种形态。 表单能够包含 input 元素、select下拉框、textarea文本域、复选框、单选框、button按钮等等。 html5新增表单元素：datalist、keygen、output。 HTML和DOM的关系 HTML是“死””的，他其实是没有结构的，只是换行的字符串。 DOM由HTML经过浏览器进行解析而来，是活的，他才是有结构（DOM树）的，他才知道谁在&lt;body&gt;下面 JS去维护的是DOM（其实innerHtml返回的也是DOM） property（特性） 和 attribute（属性） 的区别 property和attribute在中文中都是 属性 的意思，但在DOM中是不同的两个东西。一般我们认为property是特性，attribute是属性。 attribute 是“死”的，写在html上的就是attribute property 是“活”的，经过浏览器解析后，每个元素会有自己的property（特性）。 attribute 的改变不会影响 property ，property的改变也不会影响 attribute。 property是对DOM元素的JS变量的属性进行修改，不会修改HTML结构。 attribute是直接对DOM元素的属性进行修改，会改变HTML结构。 建议使用property，以减少不必要的DOM重新渲染。 例子： value是input框的一个属性（attribute）。 在浏览器解析时会将 value的值 1 赋给 特性 property，那么property的值也会初始化为1。 调试器中的$0代表选中的element，选中输入框后，由$0.value直接得到的是input的特性（property），而由apigetAtrribute(&quot;value&quot;)得到的是input的属性（Attribute） 改变了property（value）的值为2后，使用getAttribute获取到的 attribute 可以发现还是1。同样的，改变了attribute的值为3时，property的值也是没有变化的。 最终显示在输入框内的值是 特性 property，他是活的。 form的作用有哪些 使用form可以通过get/post方法直接提交表单（不使用submit按钮） 使用form就可以使用submit/reset按钮进行表单的提交/重置 便于浏览器保存表单（比如用户使用了第三方插件用来保存用户名、密码） 有form的情况下，可以使用第三方库（比如jquery）批量获取表单的所有数据 有form的情况下，可以使用第三方库（比如angular）进行表单验证 补充：不使用submit按钮提交表单的方法 提交表单一般使用Form对象中的submit按钮，但是在很多场合用其他方法提交却显得更为简捷，如选中单选项，选择下拉列表元素等。 下面这两条语句调用了表单对象的submit()方法，等效于按submit按钮。 方法1： 1document.formName.submit(); 意思：执行到此句时，立即将本文件中名为formName的表单中的所有信息提交给指定的程序。 方法2： 1document.forms[index].submit(); 意思： document.forms：表示获取当前页面的所有表单 document.forms[0]：表示获取当前页面的第一个表单 document.forms[&#39;exportServlet&#39;]：表示获取当前页面的name=&quot;exportServlet&quot;的表单 submit()表示提交表单，相当于按submit按钮 通过AJAX请求而不通过form的submit按钮提交，还需要form元素吗从技术上讲不一定需要，但仍然建议使用form元素。 因为有submit和reset这样的特性在里面，没有form的情况下submit（提交表单内容）和reset（重置表单内容）是不能用的。 因为有form的情况下我们可以通过一些方式去批量获取表单的所有数据，比如说jquery中的serialize方法，当你使用serialize方法时可以获取到整个表单的数据。 有form的时候我们可以和一些框架结合去做表单验证。 对用户来说，有form的时候便于浏览器保存表单，也就是说浏览器比较容易去记住用户名、密码等。 所以不管如何，涉及表单的部分都建议使用form！","categories":[{"name":"面试题","slug":"面试题","permalink":"http://yoursite.com/categories/面试题/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML基础强化（2）","slug":"HTML基础强化（2）","date":"2019-12-02T07:03:06.000Z","updated":"2020-02-15T07:49:01.350Z","comments":true,"path":"2019/12/02/HTML基础强化（2）/","link":"","permalink":"http://yoursite.com/2019/12/02/HTML基础强化（2）/","excerpt":"HTML元素默认样式 意义：只需要写出HTML元素就能看到效果，不需要在写出元素以后再去定义样式才能看到效果，工作量减少了。（比如下拉框，有了默认样式我们就不需要自己去定义箭头的样式、里面的文字的样式、框的样式等等） 问题：有一些元素的默认样式时无法覆盖的，比如下拉框。 注意：&lt;html&gt;元素 是有样式的，当我们发现样式有问题是要从 &lt;html&gt;元素 开始找，而不是直接从 &lt;body&gt;元素 开始。","text":"HTML元素默认样式 意义：只需要写出HTML元素就能看到效果，不需要在写出元素以后再去定义样式才能看到效果，工作量减少了。（比如下拉框，有了默认样式我们就不需要自己去定义箭头的样式、里面的文字的样式、框的样式等等） 问题：有一些元素的默认样式时无法覆盖的，比如下拉框。 注意：&lt;html&gt;元素 是有样式的，当我们发现样式有问题是要从 &lt;html&gt;元素 开始找，而不是直接从 &lt;body&gt;元素 开始。 CSS Reset重置样式reset 并不是CSS的标准，他是人们总结出来的，所以有很多写法。 将样式重置归零的两个reset方法： https://meyerweb.com/eric/tools/css/reset/ https://yuilibrary.com/yui/docs/cssreset/ 将大部分样式重置归零，小部分元素统一各浏览器的样式，可以用来代替reset的存在：http://necolas.github.io/normalize.css/ 如果不想研究上面三种方法，我们也可以自己直接添加： 123456&lt;style&gt; *&#123; margin:0; padding:0; &#125;&lt;/style&gt; （可能会对性能有一点影响，不过关系不大） 面试题DOCTYPE 的意义是什么 让浏览器以标准模式渲染比如：我们都知道 标准盒模型和替代盒模型 ，很久以前IE有很多渲染模式，当我们带上DOCTYPE时，IE就知道要以标准模式渲染，也可以体现在 标准盒模型 上。（不只是IE，很多浏览器都有，也不一定是表现在盒子模型上，很多元素都有） 让浏览器知道元素的合法性比如：直接使用&lt;!DOCTYPE html&gt;浏览器就知道要根据html5的标准来审核元素是否合法（上面的“HTML版本”有图解不同版本的要求），但不合法也不会有什么事情，浏览器会做大量容错。 HTML XHTML HTML5的关系 HTML属于SGML （SGML是非常通用的标记语言）。 XHTML属于XML，是HTML进行XML严格化的结果。（XML是SGML的一个子集，严格地讲，XML也还是SGML。） HTML5不属于SGML或XML，他自己就是一个独立的语法规范，保留了SGML的宽松，去掉了XML严格化的一些东西，比XHTML宽松。 HTML5有什么变化【待补充】 新的语义化元素（新增语义更加明确的标签，不建议使用一些语义不强的元素：b、i、font等），方便写出更加语义化的结构。 表单增强（表单验证（在这之前只能通过js来完成）） 新的API（离线、音视频、图形、实时通信、本地存储、设备能力）【JS层面的】 分类和嵌套变更（变成按照内容分类，分类和推理过程的改变导致嵌套规则的改变，在html5中将a标签视作“透明”再来判断嵌套合法性） &lt;em&gt;和&lt;i&gt;的区别主要是语义化上的区别，i的语义不明确，也可用来写小图标icon。 &lt;em&gt;是语义化的标签，不仅表斜体，还表强调 &lt;i&gt;是纯样式的标签，表斜体 HTML5中&lt;i&gt;不推荐使用来表示斜体，一般用作图标（icon）的表示。 HTML语义化语义化简单说来就是用正确的标签做正确的事情，让机器可以读懂页面内容。 好处 大纲结构清晰，开发者容易理解，有利于后期维护。 降低机器处理 Web 内容的难度，方便 机器、爬虫、搜索引擎、读屏软件 去了解你的 网页结构，从而读懂web上发布的各种内容。 有助于SEO（SEO：搜索引擎优化），页面越是符合语义化就越有利于搜索引擎优化。 semantic microdata（另一个规范），她会在html中添加一些新的标记，标注这个东西是什么。【对元素做进一步的语义化标记，方便搜索】 怎么把网页写的符合语义化先对网页功能做一个划分，根据不同功能特点选择合适的标签（机器可读的、被广泛认可的）来创建一个 结构大纲 清晰的网页。 尽可能少使用无语义的标签div和span； 在语义不明显，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利； 不要使用纯样式标签，如：b、font、i等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）； 使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td； 表单域要用fieldset标签包起来，并用legend标签说明表单的用途； 每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 注意：HTML5 并非 Web 语义唯一倚仗的规范，除了 W3C 和 WHATWG 外，还有其它的组织在为扩展、标准化 Web 语义做着贡献。只要有浏览器厂商、搜索引擎原意支持，它们的规范一样可以成为通用的基础设施。 html与SEO优化 &lt;head&gt;标签放网页的标题，各个页面不同。 &lt;meta keywords&gt;列举出几个重要的关键词。 &lt;meta description&gt;网页内容的高度概括。 每个页面尽量只出现一次H1标签，H2标签可以多次：H1权重很高，普遍认为仅次于title，一般资讯详情页的标题、商品详情页的标题，都放在H1里。 图片一定要添加alt属性，title属性可选：搜索引擎不认识图片上的内容，只能通过alt属性来判断，如果是商品列表页，所有商品都加了alt和title的话，容易造成堆砌关键词，所以我一般是只加alt属性。 换行标签&lt;br/&gt;只用来在文本间进行换行，标签间的换行通过margin或者&lt;p&gt;&lt;br&gt;&lt;/p&gt;。 搜索引擎抓取seo内容是从上到下，重要内容html代码放在最前面。 搜索引擎看不懂js， 重要内容不要用js输出。 尽量少使用iframe框架 谨慎使用display：none，搜索引擎会过滤掉这里面的内容。 哪些元素可以自闭合 表单元素input（注意： 区分表格元素和表单元素） 图片img 换行br 水平线hr 源信息meta link 在html5中自闭合的标签结束不要求加/,但html和html4中是要求的。 补充：表单元素 &lt;form&gt;标签 用于为用户输入创建 HTML 表单。 &lt;input&gt; 元素是最重要的表单元素，根据不同的 type 属性可变化为多种形态。 表单能够包含 input 元素、select下拉框、textarea文本域、复选框、单选框、button按钮等等。 html5新增表单元素：datalist、keygen、output。 HTML和DOM的关系 HTML是“死””的，他其实是没有结构的，只是换行的字符串。 DOM由HTML经过浏览器进行解析而来，是活的，他才是有结构（DOM树）的，他才知道谁在&lt;body&gt;下面 JS去维护的是DOM（其实innerHtml返回的也是DOM） property（特性） 和 attribute（属性） 的区别 property和attribute在中文中都是 属性 的意思，但在DOM中是不同的两个东西。一般我们认为property是特性，attribute是属性。 attribute 是“死”的，写在html上的就是attribute property 是“活”的，经过浏览器解析后，每个元素会有自己的property（特性）。 attribute 的改变不会影响 property ，property的改变也不会影响 attribute。 例子： value是input框的一个属性（attribute）。 在浏览器解析时会将 value的值 1 赋给 特性 property，那么property的值也会初始化为1。 调试器中的$0代表选中的element，选中输入框后，由$0.value直接得到的是input的特性（property），而由apigetAtrribute(&quot;value&quot;)得到的是input的属性（Attribute） 改变了property（value）的值为2后，使用getAttribute获取到的 attribute 可以发现还是1。同样的，改变了attribute的值为3时，property的值也是没有变化的。 最终显示在输入框内的值是 特性 property，他是活的。 form的作用有哪些 使用form可以通过get/post方法直接提交表单（不使用submit按钮） 使用form就可以使用submit/reset按钮进行表单的提交/重置 便于浏览器保存表单（比如用户使用了第三方插件用来保存用户名、密码） 有form的情况下，可以使用第三方库（比如jquery）批量获取表单的所有数据 有form的情况下，可以使用第三方库（比如angular）进行表单验证 补充：不使用submit按钮提交表单的方法 提交表单一般使用Form对象中的submit按钮，但是在很多场合用其他方法提交却显得更为简捷，如选中单选项，选择下拉列表元素等。 下面这两条语句调用了表单对象的submit()方法，等效于按submit按钮。 方法1： 1document.formName.submit(); 意思：执行到此句时，立即将本文件中名为formName的表单中的所有信息提交给指定的程序。 方法2： 1document.forms[index].submit(); 意思： document.forms：表示获取当前页面的所有表单 document.forms[0]：表示获取当前页面的第一个表单 document.forms[&#39;exportServlet&#39;]：表示获取当前页面的name=&quot;exportServlet&quot;的表单 submit()表示提交表单，相当于按submit按钮 通过AJAX请求而不通过form的submit按钮提交，还需要form元素吗从技术上讲不一定需要，但仍然建议使用form元素。 因为有submit和reset这样的特性在里面，没有form的情况下submit（提交表单内容）和reset（重置表单内容）是不能用的。 因为有form的情况下我们可以通过一些方式去批量获取表单的所有数据，比如说jquery中的serialize方法，当你使用serialize方法时可以获取到整个表单的数据。 有form的时候我们可以和一些框架结合去做表单验证。 对用户来说，有form的时候便于浏览器保存表单，也就是说浏览器比较容易去记住用户名、密码等。 所以不管如何，涉及表单的部分都建议使用form！","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"HTML基础强化（1）","slug":"HTML基础强化（1）","date":"2019-12-01T06:49:04.000Z","updated":"2020-02-15T07:48:54.361Z","comments":true,"path":"2019/12/01/HTML基础强化（1）/","link":"","permalink":"http://yoursite.com/2019/12/01/HTML基础强化（1）/","excerpt":"前端三大件：HTML（结构）、CSS（样式）、JavaScript（行为）","text":"前端三大件：HTML（结构）、CSS（样式）、JavaScript（行为） HTML版本 语法验证网站w3c有一个语法验证网站：http://validator.w3.org/,可以在这查看你的网页是否存在HTML4的语法问题。 HTML5新增内容新区块标签：section(区块)、article（标题）、nav（导航）、aside（一般是广告等不太重要的东西，基本不让他出现在大纲中）前三个都会反映在 视图大纲 里。 新增内容：表单增强、日期、时间、搜索、表单验证（在这之前只能通过js来完成）、Placeholder、自动聚焦（网页加载好以后光标自动聚焦在输入框中） HTML5新增语义新增语义更加明确的元素，不建议使用一些语义不强的元素：b（粗体）、i（斜体）、font等，方便写出更加语义化的结构。 header/footer头尾（header可以表示 网站/区块 的头部）section/article区域（比起div，他们有更加明确的语义范围）address 区块容器（必须是作为联系信息出现，邮编地址、邮件地址等等一般出现在footer）nav导航aside不重要内容（侧边栏）em/strong强调(粗体)i 表示 icon（图标）hgroup 对标题元素进行分组（参考例子） html5建议使用 i 标签表示小图标（icon）而不是斜体： div虽然也是一个区块，但是他没有明确的语义，当你可以明确区块内的内容时就不建议使用div。section / article就有明确的语义，section较为零碎（比如一些列表），article比较完整（比如一篇博客，拥有标题、文章等等） HTML常见元素和理解head中的元素标签不会显示在页面上，主要放置配置信息：meta、title、style、link、script、base 网页适配移动端 首先就要设置viewport的宽度 body中的元素标签一块区域：div / section / article / aside / header / footer（div虽然也是一个区块，但是他没有明确的语义，当你可以明确区块内的内容时就不建议使用div。section / article就有明确的语义，section较为零碎（比如一些列表），article比较完整（比如一篇博客，拥有标题、文章等等））段落:p行内元素：span / em / strong表格元素：table / thead / tbody/ tr（行）/ td（表头）列表元素：ul（无序）/ol（有序）/li/dl（定义列表）/dt（标题）/ dd（内容）链接：a表单元素：form（表单） / input / select（下拉框） / textarea（一块文本输入区） /button（这里只列举了一部分） HTML重要属性a[href,target 网页打开的方式]img[src,alt 未显示图片时的提示文字]table td[colspan 合并列,rowspan 合并行]form[target 表单提交到哪里,method 用什么方式提交,enctype 用什么编码方式提交]input[type 多种类型（radio为单选框）,value]【两个单选框二选一时可设置为同样name的两个&lt;input type=&quot;radio&quot;/&gt;】button[type(form中button的submit提交表单，reset重置)]select&gt;option[value]label[for]一般用于单选框/复选框 如何理解HTML（结构与语义化）借助工具看网页大纲工具：http://h5o.github.io/ 拖拽到书签栏即可使用： 点击即可显示页面大纲： 建议书写HTML时要多关注HTML的结构是否清晰，注意语义化。 HTML元素分类按默认样式分块级block默认独占一行的元素，可以直接设置宽高。 行内inline不一定是方形的，甚至不一定是规则的（比如宽度不够被迫换行时）。 inline-block对外像inline元素，对内像block元素（有自己的宽高）。比如：select下拉框、input框。 按内容分国内很少面试会关注这个，但了解之后对后面的“嵌套关系”的学习会比较轻松。W3C中有关于这个分类的动态示意图。 Flow：流，基本所有可见元素 Metadata：配置信息的元素base、link、meta、noscript、script、style、template、title Interactive：和用户有互动的元素，比如a、button等 Heading：h1到h6h1-h6、hgroup Sectioning：区块标签article、aside、nav、section Phrasing：（短语）大部分属于内联元素 Embedded：被嵌入的其他元素，比如img、video等 HTML元素嵌套关系就算我们嵌套错误也不会报错，浏览器做了很多的容错处理，我们可以在F12中通过观察 标签是否增加 看到浏览器做出的是怎么处理的。（比如说p包含div是不合法的，那么浏览器就会让p的结束标签出现在div前，然后再在div的结束标签后增加一个p标签） 原则 块级元素可以包含行内元素 块级元素不一定能包含块级元素 行内元素一般不能包含块级元素（但 a 包含 div 有可能是合法的，可看下方“方法2的例子”解答） 查看嵌套是否合法的方法 方法1：使用w3c的语法验证工具看是否有错（因为原则基本都是html4的，所以可以使用工具查错） 方法2：查看w3c的文档，在文档中可以直观的看到各种嵌套规则。假设我们希望a 嵌套b，则需要看看 被嵌套的元素b 属不属于 文档中 a 的 content model ，属于则可嵌套。 方法2的例子为什么 a 包含 div是合法的？ a 包含 div 的例子：一些小广告，点击就跳转。 首先，a 包含 div不一定是合法的，当包含a的标签是&lt;body&gt;/&lt;div&gt;时，是合法的。当包含a的标签是&lt;p&gt;时，是不合法的。 是否合法决定于包含a的标签再忽略a标签后是否能包含内部的div标签。 因为w3c文档告诉我们：&lt;a&gt;标签在计算嵌套关系时会被当作“透明”的直接忽略掉，变成&lt;body&gt;包含&lt;div&gt;，自然也就合法了。但如果忽略了a标签后变成&lt;p&gt;包含&lt;div&gt;那就不合法了。 推理过程： 在html4的文档中可以直观的看到各种嵌套规则。 找到 BODY-flow-inline：A inline excluding an enclosed A element（a标签只能包含行内元素，且不能包含另一个a标签） 也就是说在html4中 a 包含 div 是不合法的，但是在html5中是合法的。 但在w3c的文档中 a 标签的Content model中说“透明的，但必须没有交互式内容或a元素后代。” 继续点进去可以发现给出的对于“透明的”的解释是：在计算内容模型时，这个元素本身是不参与计算的。 也就是说，在a这里计算嵌套合法性时a是不参与计算的，相当于是&lt;body&gt;包含&lt;div&gt;，自然也就合法了。","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"React.js基础精讲(1)","slug":"React.js基础精讲（1）","date":"2019-11-26T13:25:34.000Z","updated":"2020-01-29T07:48:19.334Z","comments":true,"path":"2019/11/26/React.js基础精讲（1）/","link":"","permalink":"http://yoursite.com/2019/11/26/React.js基础精讲（1）/","excerpt":"使用React编写TodoList功能 在index.js文件中引入TodoList.js文件TodoList组件时使用的import App from &#39;./TodoList&#39;;其实省略了.js，这是因为你不写.js的话脚手架工具会自动到目录下去找js后缀的文件（但是你在根目录下创建TodoList.js时不要忘记后缀！）","text":"使用React编写TodoList功能 在index.js文件中引入TodoList.js文件TodoList组件时使用的import App from &#39;./TodoList&#39;;其实省略了.js，这是因为你不写.js的话脚手架工具会自动到目录下去找js后缀的文件（但是你在根目录下创建TodoList.js时不要忘记后缀！） 在TodoList.js中 1.先引入React才能使用JSX语法，引入{ Component }才能使我们自定义的组件继承Component： 1import React, &#123; Component &#125; from 'react';/* 快捷键imrc */ 2.自定义的组件一定要继承Component，通过render函数返回组件显示的内容，将组件返回的内容写在return（）内（注意是小括号！）： 1234567class TodoList extends Component&#123; render()&#123; return( ) &#125;&#125; 3.在最后必须使用export default TodoList;导出组件（不导出的话组件在外部是无法引用的） 1export default TodoList; 4.对于render函数来说，4个空格一个缩进太大了，我们可以将它修改为2个空格一个缩进。（修改方法如下） 修改缩进长度 5.不要忘记在render函数的return（）括号中写类似html代码时，只允许存在1个最外层标签，否则报错。（也就是说所有标签都必须包含在1个父元素下）但很多时候我们并不希望他们有父元素，此时可以使用React16提供的占位符Fragment代替父元素标签。记得先引入Fragment: 1import React, &#123; Component,Fragment &#125; from 'react'; 然后可以使用&lt;Fragment&gt;代替&lt;div&gt;作为父元素使用，当你在页面F12时可以发现子元素全部都直接挂靠在了我们指定的index.html的root节点上： 1234567891011121314151617181920import React, &#123; Component,Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &lt;input/&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;学习&lt;/li&gt; &lt;li&gt;做题&lt;/li&gt; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125;&#125;export default TodoList; 想要实现输入框中输入的内容被提交以后显示在下方列表中则需要下面讲到的“React中的响应式设计思想和事件绑定”。 React中的响应式设计思想和事件绑定 react在英语中就是“响应、做出反应”的意思，也就是说代码中的数据发生变化时会直接反应在页面上。（也就是说当数据被修改时会被直接反应在页面上）所以在写react时我们不是去改变DOM，而是去修改数据，数据被修改以后会自己反应在DOM上。也就是说我们不需要去关注DOM方面的操作，只需要考虑数据层的操作即可。 实现功能在输入框中键入时页面输入框可同步变化数据内容。 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; constructor(props) &#123;/* 构造函数constructor带有参数props */ super(props);/* 继承父类Component的props */ this.state = &#123;/* 所有的数据都需要保存在状态里（即this.state） */ /* inputValue用于存放输入框内容 */ inputValue: \"\", /* list列表用于存放输入框下方数据 */ list: [] &#125; &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* 注意如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的 */&#125; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &lt;li&gt;学习&lt;/li&gt; &lt;li&gt;做题&lt;/li&gt; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(e) &#123;/* 传入一个事件对象e */ /* target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue */ // console.log(e.target.value); /* 尝试将e.target.value赋给inputValue，但发现this指向有问题 */ // this.state.inputValue = e.target.value;//报错，显示state未定义，那么就是this指向有问题 // console.log(this);//打印出的是undefined，说明handleInputChange函数内的this并未指向TodoList组件，我们需要使用bind(this)将函数内的this指向TodoList组件以便调用存放在它的状态中的inputValue // this.state.inputValue = e.target.value;//转换this指向以后还是报错，是因为react中改变状态中的数据需要调用组件的setState方法 this.setState(&#123; inputValue:e.target.value &#125;) &#125;&#125;export default TodoList; 代码分析 constructor(props){}函数是构造函数，在js里每个类都会有一个自带的构造函数（注意带一个参数props），当我们使用这个组件时，它会在render函数之前执行。构造函数内必须有super(props); 去继承父类component的props，构造函数内所有定义的数据都需要挂靠在当前对象的状态下，也就是写在this. state={}里面。当状态中的数据发生变化时他的变化会直接反应在页面上。（所以你希望页面数据变化时可以直接修改存在状态内的数据） 为了能在输入框中输入数据后显示在输入框下方，我们需要在构造函数中定义两个数据：inputValue用于存储输入框的值，list设为数组，用于存储显示在下方的列表。（注意：数据是存储在this. state={}里的） 注意：render函数中写的是JSX语法，constructor(props){}中写的是js代码，如果想在JSX中插入js的变量或者表达式则需要使用{}将其框起。（如render函数中&lt;input value={this.state.inputValue} /&gt;） 通过&lt;input value={this.state.inputValue} /&gt;我们将状态中的inputValue赋给了输入框，此时输入框具有默认值，但如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的。 此时我们需要给输入框绑定事件onChange，使输入框内容发生变化时触动函数handleInputChange，通过函数handleInputChange将我们输入的值存储到状态中的inputValue上从而使页面发生变化。(注意：绑定事件处理函数的调用没有括号（onChange={this.handleInputChange}），有括号就直接调用该处理函数了，没有括号则是指向处理函数地址，只有触动该事件时才调用函数) 在绑定事件处理函数handleInputChange中，传入一个参数也就是事件对象e(语法上，事件处理函数默认只传递一个参数，也就是事件对象) ，target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，我们需要将状态中的inputValue修改为input节点的value值，从而使得输入以后页面输入框内容有所变化。 尝试将e.target.value赋给inputValue:this.state.inputValue = e.target.value;报错，显示state未定义，说明this指向有问题，打印出this发现是undefined，说明handleInputChange函数内的this并未指向TodoList组件，我们需要使用bind(this)将函数内的this指向TodoList组件以便调用存放在它的状态中的inputValue。（注意：在这里建议在构造函数中绑定bind（），比较节省性能，可以参考“bind（）”笔记） 转换this指向以后还是报错，是因为react中改变状态中的数据需要调用组件的setState方法：123this.setState(&#123; inputValue:e.target.value&#125;) 思路也就是说，每次点击输入框就会触发绑定的事件函数handleInputChange，在该函数内我们通过setState（）将该事件函数对应的事件对象e的target对象（也就是input节点）的value值赋给state内的inputValue，而我们的input的value正是state内的inputValue，所以一旦触发事件函数handleInputChange我们输入的值就会传入state中从而在页面上出现改变。 总结 在js里每个类（组件）都会有一个自带的构造函数constructor(props){}，（注意带一个参数props），当我们使用这个组件时，它会在render函数之前执行。构造函数内必须有super(props); 去继承父类component的props，构造函数内所有定义的数据都需要挂靠在当前对象的状态下，也就是写在this. state={}里面。 render函数中写的是JSX语法，constructor(props){}中写的是js代码，如果想在JSX中插入js的变量或者表达式则需要使用{}将其框起。（如render函数中&lt;input value={this.state.inputValue} /&gt;） 原生js中内容变化时的事件绑定是onchange，而react中是onChange。在react中事件绑定时驼峰形式的！（如onClick,onChange等） 事件绑定时要使用bind(this)进行函数作用域变更使函数中的this指向使其指向事件对象（即组件）才能调用组件的构造函数中的数据，否则函数中的this指向undefined。（注意：在这里建议在构造函数中绑定bind（），比较节省性能，可以参考“bind（）”笔记） 修改this. state中的数据需要通过setState方法：想要改变this. state里面的数据直接引用this. state进行赋值是不行的，要使用this. setState({state中需要修改的属性:修改以后的属性值;})（其实就是将需要修改的属性通过对象的方式传入setState函数） 实现 TodoList 新增及删除功能新增功能在这之前我们实现的功能是：在输入框中输入文字时我们输入的内容可以同步显示在页面上（是的，虽然这个功能看起来完全不需要我们去实现）现在要完成的功能是：点击“提交”按钮之后，输入的内容会显示在下方的列表之中并清空输入框内容。 思路注意，我们不关心DOM层面上的操作，我们只要让state中的数据发生变化页面就会发生变化，也就是只要点击按钮后将inputValue的值放到list数组中并清空inputValue即可。 点击“提交”按钮之后触发onClick事件绑定函数handleBtnClick，在函数中通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list，然后清空输入框中的值。（到这我们虽然把输入框的值放入数组中，但数组并未设置在页面中显示） 我们需要通过数组的map方法将原本页面写死的ul列表改成数组list中遍历读出的内容，注意给数组中的每一项一个唯一的key属性值作为标识符。 注意：JSX语法中写js表达式和js变量都需要{}括起来，表达式中的变量也需要再用{}括起来！！ 补充：JavaScript Array map()遍历数组并进行操作ES5中提供的JavaScript Array map() 方法可以遍历数组列表并按顺序对数组中的每一项执行回调函数。 react中遍历数组时需要加key值在react中循环渲染（遍历数组）时需要给每一项增加一个唯一的key值作为标识符，否则虽不会报错但是会在控制台显示“Warning”：在这里我们暂时使用数组下标index作为key值，实际编程中这样的习惯是很不好的，但具体原因留到后面再写： 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; constructor(props) &#123;/* 构造函数constructor带有参数props */ super(props);/* 继承父类Component的props */ this.state = &#123;/* 所有的数据都需要保存在状态里（即this.state） */ /* inputValue用于存放输入框内容 */ inputValue: \"\", /* list列表用于存放输入框下方数据 */ list: [] &#125; &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* 注意如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的 */&#125; &#123;/* 事件绑定函数handleInputChange被调用后，handleInputChange函数内的this指向会丢失（即undefined），需要使用bind()绑定handleInputChange的this指向使其指向TodoList组件的this以便在handleInputChange函数中可以获取TodoList组件的inputValue */&#125; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; /* 传入一个参数事件对象e(语法上，事件处理函数默认只传递一个参数，也就是事件对象) */ handleInputChange(e) &#123; /* target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue，react中改变状态中的数据需要调用组件的setState方法 */ this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState(&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...this.state.list, this.state.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;) &#125;&#125;export default TodoList; 删除功能实现功能：点击列表中的某一项时该项被删除。 复习：splice()删除数组部分的元素splice()可用于删除、插入、替换数组中部分元素，无论如何返回值都是从原数组中删除的元素组成的数组。 复习删除用法注意：删除时，返回的是含有删除部分的元素的数组，原数组会变成被删除以后的数组。 语法:arrayObject.splice(index,count) 功能:删除从index处开始的零个或多个元素. 返回值:含有被删除的元素的数组. 说明:count是要删除的项目数量,如果设置为0,则不会删除项目.如果不设置,则删除从index开始的所有值. 例子：12345678var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];//删除var delArr = arr.splice(5);//从数组下标为5的元素开始，包括5【注意是数组下标】console.log(arr);// [\"a\", \"b\", \"c\", \"d\", \"e\"]console.log(delArr);//[\"f\"]var delArr = arr.splice(2, 2);console.log(arr);// [\"a\", \"b\", \"e\"]console.log(delArr);//[\"c\", \"d\"] 思路 给每个li标签绑定一个 onClick 事件函数 handleItemDelete ，通过 bind 绑定 this 指向组件 TodoList 的同时将数组下标 index 通过第二个参数传到 handleItemDelete 中，以便我们在 handleItemDelete函数 中获取到数组下标。 （注意：在这里建议在构造函数中绑定bind（），比较节省性能，可以参考“bind（）”笔记） 123456&lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt; &#123;item&#125;&lt;/li&gt; 使用扩展运算符拷贝 state 中的 list 到 变量list1 中，对 变量list 使用 splice方法 删除选中数组下标为 index 的数组元素，再使用 setState方法 将删除被点击元素后的 变量list1 赋给 state 中的list。12345678handleItemDelete(index) &#123; const list1 = [...this.state.list] list1.splice(index, 1); this.setState(&#123; list: list1 &#125;)&#125; 注意：必须将state中的值拷贝出来再对拷贝出来的变量进行修改，不能直接修改state中的值，否则后期性能优化会很麻烦。（immutable：state 不允许我们做任何的改变） 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React, &#123; Component, Fragment &#125; from 'react';/* 快捷键imrc */class TodoList extends Component &#123; constructor(props) &#123;/* 构造函数constructor带有参数props */ super(props);/* 继承父类Component的props */ this.state = &#123;/* 所有的数据都需要保存在状态里（即this.state） */ /* inputValue用于存放输入框内容 */ inputValue: \"\", /* list列表用于存放输入框下方数据 */ list: [] &#125; &#125; render() &#123; return ( &lt;Fragment&gt; &lt;div&gt; &#123;/* 注意如果不绑定onChange事件你不管输入什么框内都不会有所变化，因为每次他都是从状态中读取inputValue再显示在页面上，而inputValue是没有变的 */&#125; &#123;/* 事件绑定函数handleInputChange被调用后，handleInputChange函数内的this指向会丢失（即undefined），需要使用bind()绑定handleInputChange的this指向使其指向TodoList组件的this以便在handleInputChange函数中可以获取TodoList组件的inputValue */&#125; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125; &gt; &#123;item&#125; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; /* 传入一个参数事件对象e(语法上，事件处理函数默认只传递一个参数，也就是事件对象) */ handleInputChange(e) &#123; /* target对应的是事件对象e对应的DOM节点（也就是input节点），input节点的value值实际上就是输入框中的内容，但此时键入后只能在控制台上看到变化，页面输入框中毫无变化。这是因为虽然拿到了内容，但并未改变状态中的值，所以我们还需要修改的是状态中的inputValue，react中改变状态中的数据需要调用组件的setState方法 */ this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState(&#123; /* 通过扩展运算符将原本的list与输入框中得到的inputValue合并数组后赋给list */ list: [...this.state.list, this.state.inputValue], /* 清空输入框中的值 */ inputValue: \"\" &#125;) &#125; handleItemDelete(index) &#123; const list1 = [...this.state.list] list1.splice(index, 1); this.setState(&#123; list: list1 &#125;) &#125;&#125;export default TodoList; 总结注意事项 在JSX语法中插入js的变量或者js表达式则需要使用{}将其框起。表达式中的变量也需要再用{}括起来！ 必须将state中的值拷贝出来再对拷贝出来的变量进行修改，不能直接修改state中的值，否则后期性能优化会很麻烦。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"React.js初探(2)","slug":"React.js初探（2）","date":"2019-11-25T14:00:00.000Z","updated":"2020-01-31T07:04:35.521Z","comments":true,"path":"2019/11/25/React.js初探（2）/","link":"","permalink":"http://yoursite.com/2019/11/25/React.js初探（2）/","excerpt":"react中的组件 页面是由很多个组件构成的。 只要让自定义的类继承React的Component，那么自定义的类就会成为组件（记得要在最后export default自定义的类）。","text":"react中的组件 页面是由很多个组件构成的。 只要让自定义的类继承React的Component，那么自定义的类就会成为组件（记得要在最后export default自定义的类）。 在需要的js文件中使用import 组建名 from 定义组件的js文件名即可引入组件来使用。 （具体请参考ES6“解构赋值”） import React,{Component} from &quot;react&quot;;等价于： 1234567891011import React,&#123;Component&#125; from \"react\";//等价于import React from \"react\";const Component = React.Component;import &#123;Component&#125; from \"react\";//从ES6看相当于import Component from \"react\".Component;//又因为import React from \"react\";//所以 组件的使用步骤 在src下的App.js文件中定义组件App并在最后使用export default App;导出组件（不导出的话在index.js中是无法引用的） 在src下的index.js文件中通过import 组件名 from 定义组件的js文件名来引入组件并使用ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));将组件App挂载到public文件夹下的index.html内的id为root的DOM节点上。（注意：index.html内并未使用script标签引入index.js） 注意： 在index.js文件中需要引入import React from &#39;react&#39;;，是因为挂载组件时使用的&lt;App /&gt;是JSX语法，如果不import React from &#39;react&#39;;就会编译失败而报错。 在index.js文件中要先import ReactDOM from &#39;react-dom&#39;;才能使用ReactDOM这个第三方的render方法来帮我们将组件挂载到DOM节点上。 在App.js文件中也需要引入React，这是因为render函数中的所有看起来像是html标签的代码其实都是JSX语法。 react里的index.js是怎么跟index.html结合起来的可以注意到，index.html里没有用script标签引入index.js。 也许是create-react-app实现的？ create-react-app 把webpack、babel等配置都封装到了依赖项目react-script中，所以你无法直观的看到这些配置。而index.html与index.js的结合是用html-webpack-plugin这个plugin实现的。 总结：关于不同的引用引入React（涉及JSX语法）使用JSX语法时需要import React from &#39;react&#39;;，否则就会编译失败而报错。比如： App.js文件中render函数中的所有看起来像是html标签的代码实际上是JSX代码。 index.js文件中挂载组件时使用的&lt;App /&gt;是JSX语法。 引入ReactDOM在index.js文件中要先import ReactDOM from &#39;react-dom&#39;;才能使用ReactDOM这个第三方的render方法来帮我们将组件挂载到index.html文件的DOM节点上。 引入{ Component }定义组件时需要继承 React 的 Component ，需要先引入才能继承。此时可以使用ES6的解构赋值简单的引入Component： 1import React, &#123; Component &#125; from 'react'; 相当于： 1import Component from 'react'.Component; 也相当于： 12import React from 'react';const Component = React.Component; React中最基础的JSX语法 我们把html代码直接写在js文件里这就算是JSX语法，之前提到的index.js文件中使用的&lt;App /&gt;也是JSX语法。 JSX语法中，如果我们要使用自己创建的组件（例如App.js中自定义的组件App），必须大写字母开头，通过类似html标签的形式进行调用（比如index.js中将组件挂载在index.html页面的DOM节点上使用的&lt;App /&gt;）。 注意：在render函数的return()括号中写类似html代码时，只允许存在1个最外层标签，否则报错。（也就是说所有标签都必须包含在1个父元素下）","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"hexo deploy到github后404问题","slug":"hexo 404","date":"2019-11-25T11:52:31.000Z","updated":"2019-11-26T09:01:49.051Z","comments":true,"path":"2019/11/25/hexo 404/","link":"","permalink":"http://yoursite.com/2019/11/25/hexo 404/","excerpt":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后成功部署到github上。其他页面正常显示，只有新上传的文章出现404，如下图所示：","text":"问题描述在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后成功部署到github上。其他页面正常显示，只有新上传的文章出现404，如下图所示： 页面中有提示 If this is your site. make sure that the filename case matches the URL For root URLS (like htp:/esample. com ) you must provide an index. html file. 翻译成中文也就是对于根网址（如http://example.com/），您必须提供一个`index.html`文件。 在github我们这个博客项目内可以看到每次deploy都会给我们每篇博客新建一个对应的index.html文件，但是出现404的页面不知道为何并未看到对应的index.html文件。 解决方法将本地中存储的显示404的博客文章对应的markdown文件删除并重新放入再进行deploy，如果还是不行可以适当对文章内容进行修改再deploy（比如加点无关紧要的分隔线之类的）。 我出现了2个页面404，两种方法都能解决，具体是为什么不得而知，如果有知道的小伙伴欢迎留言告诉我一下~","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"React官方脚手架工具的使用","slug":"React官方脚手架工具","date":"2019-11-24T13:28:12.000Z","updated":"2020-01-27T06:36:54.206Z","comments":true,"path":"2019/11/24/React官方脚手架工具/","link":"","permalink":"http://yoursite.com/2019/11/24/React官方脚手架工具/","excerpt":"Create React App 中文文档 创建一个项目在cmd中执行命令行： npx create-react-app 项目名 cd 项目名 npm start或者yarn start 接下来你就可以在http://localhost:3000/中访问到新建项目的index页面","text":"Create React App 中文文档 创建一个项目在cmd中执行命令行： npx create-react-app 项目名 cd 项目名 npm start或者yarn start 接下来你就可以在http://localhost:3000/中访问到新建项目的index页面 例子： 项目存储位置是打开cmd是的路径C:\\Users\\HLZ\\todolist关闭cmd以后还想再运行该项目index页面（在http://localhost:3000/中）时，可以在该项目路径目录下打开cmd窗口输入npm start或者yarn start（“在当前目录下启动cmd窗口的方法”见下文） 在当前目录下启动cmd窗口的两种方法方法1：在当前目录地址栏上清空目录，然后输入cmd回车即可： 方法2：按住键盘shift键，然后鼠标右键，点击 “在此处打开Powershell窗口”（在windows上cmd和powershell都是命令行执行窗口，cmd能做的powershell都能做，甚至能做更多）","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"bind()","slug":"bind()","date":"2019-11-24T13:26:40.000Z","updated":"2020-02-14T02:43:52.273Z","comments":true,"path":"2019/11/24/bind()/","link":"","permalink":"http://yoursite.com/2019/11/24/bind()/","excerpt":"bind()ES5 引入了 Function.prototype.bind。bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。","text":"bind()ES5 引入了 Function.prototype.bind。bind()方法创建一个新的函数，在bind()被调用时，这个新函数的this被bind的第一个参数指定，其余的参数将作为新函数的参数供调用时使用。也就是说，调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数上，无论这个函数是如何被调用的。bind绑定的参数只生效一次。 注意 函数使用bind()返回的还是一个函数，而call()/apply()则是直接调用函数。 使用函数声明的方式创建的函数不能使用bind()，只有使用函数表达式的方式创建的函数才能使用。 call()/apply()/bind()都是使用第一个参数改变this的指向。 bind()与call()/apply()的传参方法有所不同。 javascript中apply、call和bind的共同点在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。他们的共同之处： 都是用来改变函数的this对象的指向的。 第一个参数都是this要指向的对象。 都可以利用后续参数传参。 bind（）与apply（）、call（）使用上的区别无参数情况1234567891011121314var xw = &#123; name: \"小王\", gender: \"男\", age: 24, say: function () &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age); &#125;&#125;var xh = &#123; name: \"小红\", gender: \"女\", age: 18&#125;xw.say(); 上面代码显示的是小王 ， 男 ， 今年24。用xw的say方法来显示xh的数据的几种方法: xw.say.call(xh); xw.say.apply(xh); xw.say.bind(xh)();如果直接写xw.say.bind(xh)不会有任何结果,call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。 传参情况12345678910111213var xw = &#123; name : \"小王\", gender : \"男\", age : 24, say : function(school,grade) &#123; alert(this.name + \" , \" + this.gender + \" ,今年\" + this.age + \" ,在\" + school + \"上\" + grade); &#125;&#125;var xh = &#123; name : \"小红\", gender : \"女\", age : 18&#125; 可以看到say方法多了两个参数，我们通过4种方法进行传参： xw.say.call(xh,&quot;实验小学&quot;,&quot;六年级&quot;); xw.say.apply(xh,[&quot;实验小学&quot;,&quot;六年级&quot;]); xw.say.bind(xh,&quot;实验小学&quot;,&quot;六年级&quot;)(); xw.say.bind(xh)(&quot;实验小学&quot;,&quot;六年级&quot;);由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。 事件绑定函数与bind(this)在react中，常看到： 123456789101112131415161718export default class App extends Component &#123; constructor(props) &#123;/*构造函数，用于实例化对象*/ super(props); this.foo = this.foo.bind(this); &#125; foo() &#123; // todo something &#125; render() &#123; return ( &lt;View&gt; &lt;Button onPress=&#123;this.foo&#125;/&gt; &lt;/View&gt; ) &#125;&#125; 事件绑定处理函数（onPress={this.foo}）时，foo方法内部的this的指向就会丢失(此时在foo函数内部打印this得到的是undefined)。这就会出现外部的foo方法内部的this会丢失指向。为了解决这个问题，我们需要在实例化对象的时候就需要在构造函数中绑定this（this.foo = this.foo.bind(this);），使得无论事件处理函数如何传递，它的this的指向都是固定的，固定指向我们所实例化的对象（App组件）。（虽然在render函数中&lt;Button onPress={this.foo.bind(this)}/&gt;效果一样，但比较消耗性能，不推荐。） （具体应用可参考笔记“React.js基础精讲(1)”中的“React中的响应式设计思想和事件绑定”） 事件绑定函数传参方法1：在React这个例子中使用bind绑定事件函数handleItemDelete的this指向时还要将参数index传入函数，那么我们可以在绑定时传入： 1&lt;List.Item onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt;&#123;item&#125;&lt;/List.Item&gt; 方法2：但如果事件函数和bind绑定都在父组件中，而函数的调用和传参在子组件，就可以这样传参： 在父组件的构造函数中使用bind绑定this.handleItemDelete=this.handleItemDelete.bind(); 我们知道bind()返回的还是一个函数，所以在子组件中，我们通过箭头函数在每次调用handleItemDelete()时传入参数index：1&lt;List.Item onClick=&#123;()=&gt;&#123;this.props.handleItemDelete(index)&#125;&#125;&gt;&#123;item&#125;&lt;/List.Item&gt; 注意： 在这里不能直接使用handleItemDelete(index)传参是因为handleItemDelete(index)直接执行了函数，而onClick需要绑定的事件函数是不能立即执行的，所以需要新建一个箭头函数让他不立即执行。 箭头函数是JS表达式，在JSX中需要使用{}，调用的父组件的函数也是JS表达式，同样中需要使用{}。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"React.js初探","slug":"React.js初探（1）","date":"2019-11-24T13:00:00.000Z","updated":"2020-01-27T08:02:00.019Z","comments":true,"path":"2019/11/24/React.js初探（1）/","link":"","permalink":"http://yoursite.com/2019/11/24/React.js初探（1）/","excerpt":"React简介react.js文档中文文档较为滞后，建议阅读英文文档。","text":"React简介react.js文档中文文档较为滞后，建议阅读英文文档。 与vue.js对比 vue.js使用的api更多所以更简单，但正是因为react.js使用的api少，所以他的灵活度更大，更适合用于一些复杂度高的项目。 一些面向用户端，复杂度不高的项目使用vue.js会更加简单。 React开发环境准备脚手架工具 常见的脚手架工具有：webpack、grunt，还有我们接下来使用的react.js官方提供的Create-react-app。 我们可以使用脚手架工具去更加简单的编写代码，但是编写的代码不能直接运行，需要通过脚手架工具进行编译以后才能运行。 工程目录文件简介总结：重要的就是：public下的index.html文件，负责页面上显示的html内容。src下的index.js文件,整个react项目的入口，他会引入一个APP.js文件的APP组件，该组件负责显示出页面上的组件内容。 重启项目具体可参考笔记“React官方脚手架工具的使用”。 根目录下yarn.lock文件放置一些依赖配置，一般不要动。 README.md文件关于项目的说明，可以删掉再使用markdown语法进行书写。 package.json文件是一个node的包文件，他可以让项目变成一个node的包。** 一般不会去动，是脚手架自动生成的文件。**主要是node里面的内容，包含了：项目名字，版本，依赖的包、可供调用的指令。 我们之所以可以在cmd中通过npm start来启动项目，实际上就是通过npm start启动了下图中红框框出的指令，它会帮我们通过react-scripts去启动服务器： .gitignore文件使用git管理代码时，如果有文件不想上传就可以放在这。 todolist文件夹下node_ modules文件夹放一些这个项目依赖的第三方包，不要动他。 public文件夹下favicon.ico index.html文件项目首页的HTML模板，将注释删掉后会简洁很多，&lt;title&gt;标签决定：&lt;noscript&gt;标签是在网页禁掉script的情况下，用来提示用户应该在浏览器上开启script的适配项或者说允许网页去解析JavaScript。这是一段容错的代码。 manifest.json文件在下面的index.js文件中我们提到使用registerServiceWorker可以在没有网络时网页也可以当做app来使用。我们可以将这个网页在桌面上建一个快捷方式，manifest.json文件正是定义这个app的名字、图标、网址跳转到哪儿、主题颜色等的地方。（不使用manifest.json时该文件可删除，同时index.html中的manifest引用代码也可删除。） src文件夹下放置项目所有的源代码，所有代码的入口在index.js文件里。 index.js文件可以注意到import ./index.css,这是因为react讲究 all in js ，所以css和js也就不分离了。 文件中有一个registerServiceWorker，它主要用于帮助我们借助网页去写手机APP应用，使用了它即使断网了，二次访问时也能加载出页面。那么没有网络时该网页也可以当做app使用。因为registerServiceWorker会帮助你将页面存储在我们的浏览器内。（后来新建的项目是如下代码，可查一下是否同一个意思： 12import * as serviceWorker from './serviceWorker';serviceWorker.unregister(); 如不需使用可删除代码后同样可以删去src下的serviceWorker.js） import App from &#39;./App&#39;;以及ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;));则是在index页面上引入并渲染以显示App组件。 App.js文件App.js就是定义App组件的地方。 12345678910111213import React, &#123; Component &#125; from 'react';class App extends Component &#123; render()&#123; return ( &lt;div&gt; hello world &lt;/div&gt; ); &#125;&#125;export default App; App.test.js文件自动化测试文件，还不涉及自动化测试时为使项目简洁可删去该文件。","categories":[{"name":"React.js学习","slug":"React-js学习","permalink":"http://yoursite.com/categories/React-js学习/"},{"name":"简书项目","slug":"简书项目","permalink":"http://yoursite.com/categories/简书项目/"}],"tags":[{"name":"React.js","slug":"React-js","permalink":"http://yoursite.com/tags/React-js/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS 居中）","slug":"百度前端技术学院 第七天学习笔记（CSS居中）","date":"2019-11-22T13:28:12.000Z","updated":"2020-03-18T06:04:29.143Z","comments":true,"path":"2019/11/22/百度前端技术学院 第七天学习笔记（CSS居中）/","link":"","permalink":"http://yoursite.com/2019/11/22/百度前端技术学院 第七天学习笔记（CSS居中）/","excerpt":"水平居中补充：img是行内元素，为什么可以设置宽高？（面试题）（题目来自魅族一面）问题：既然img是行内元素，那为什么可以通过CSS设置宽高呢？答案：尽管img是行内元素，但同时它也是置换元素，置换元素一般内置框高属性，因此可以设置其宽高。","text":"水平居中补充：img是行内元素，为什么可以设置宽高？（面试题）（题目来自魅族一面）问题：既然img是行内元素，那为什么可以通过CSS设置宽高呢？答案：尽管img是行内元素，但同时它也是置换元素，置换元素一般内置框高属性，因此可以设置其宽高。 引申问题：那么什么又是“置换元素”呢？答案：置换元素就是会根据标签属性来显示的元素。反之就是非置换元素了。比如img根据src属性来显示，input根据value属性来显示，因此可知道img和input是置换元素，当然同理select也是置换元素。 行内文本/图片/块内文本的水平居中（text-align） text-align属性定义行内内容（例如文字）相对它的块父元素的水平对齐方式。text-align 并不控制块元素自己的对齐，只控制它的行内内容的对齐。 注意：text-align属性可用于 块级元素 来设置内部文本的水平对齐方式 如果被设置元素为文本、图片等行内元素时，则需要在父元素中设置text-align:center实现行内元素水平居中（必要时可以将子元素的display设置为inline-block，使子元素变成行内元素的同时可设置样式）。 补充：如果想居中一个块元素且不居中它的行内内容可将它的左、右margin设为auto, 例如：margin:auto; 或margin:0 auto; 或margin-left:auto; margin-right:auto; 补充：图片等比缩小可借助max-width和max-height 123456789101112.dad &#123; text-align: center;&#125;img &#123; width: auto; height: auto; max-width: 200px; max-height: 200px;&#125;p&#123; text-align: center;&#125; 12345678910// 父元素设置text-align，图片水平居中&lt;div class=\"dad\"&gt; &lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt;// 父元素设置text-align，行内元素水平居中&lt;div class=\"dad\"&gt; &lt;span&gt;上校&lt;/span&gt;&lt;/div&gt;// 定宽块级元素设置text-align，块元素内文本水平居中&lt;p&gt;喵呜&lt;/p&gt; （定宽）块级元素的水平居中（margin） 当被设置元素为定宽块级元素时用 text-align：center 就不起作用了，可以通过设置“左右margin”值为“auto”来实现居中。 默认情况下，margin: auto; 与margin: 0 auto; 效果是一样的，都是水平居中，但纵向并没有任何变化。这是因为margin-top: auto; 和 margin-bottom: auto;，其计算值为0。而 水平方向的 auto，其计算值取决于可用空间（剩余空间）。 margin 是复合属性，也就是说 margin: auto; 相当于 margin: auto auto auto auto;，margin: 0 auto;相当于 margin: 0 auto 0 auto;，四个值分别对应上右下左。 根据规范，在默认的书写模式 writing-mode: horizontal-tb; 和 文档流方向 direction: ltr; 的前提条件下，margin-top: auto; 和 margin-bottom: auto;，其计算值为0。这也就解释了为什么默认条件下 margin: auto; 等同于 margin: 0 auto; 123456.dad &#123; text-align: center;&#125;.hi &#123; width: 200px;&#125; 123456&lt;div class=\"dad\"&gt;&lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt;&lt;div class=\"dad\"&gt;&lt;div class=\"hi\"&gt;你好呀&lt;/div&gt;&lt;/div&gt; 给.hi添加margin: 0 auto;后： （不定宽）块元素内文本的水平居中（text-align） 在实际工作中我们会遇到需要为“不定宽度的块级元素”设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。 可以直接给不定宽的块级元素设置text-align：center来实现水平居中，也可以给父元素加text-align:center来实现居中效果。 当不想不定宽块级元素的宽度占一行时，可以设置display 为 inline 类型(行内元素 )或inline-block（行内块元素）。12345678910111213.container &#123;text-align: center;background: beige&#125;.container ul &#123;list-style: none;margin: 0;padding: 0;&#125;.container li &#123;margin-right: 8px;display: inline-block;&#125; 1234567&lt;div class=\"container\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 垂直居中首先需要设定两个条件：父元素是盒子容器且高度已经设定。 行内/块内文本垂直居中（line-height） line-height CSS 属性用于设置多行元素的空间量，如多行文本的间距。对于块级元素，它指定元素行盒（line boxes）的最小高度。对于非替代的 inline 元素，它用于计算行盒（line box）的高度。 行内元素高度是由其内容撑开的。这种情况下，需要给他一个固定高度的父元素盒子，通过设定父元素的line-height为行内元素设定高度，通过将父元素的line-height属性值设置与父容器高度相同即可使得子元素实现垂直居中。 直接设置行内元素的line-height为想要的高度即可，文字将在内部居中 12345678.dad &#123; height: 200px; border: 1px solid red;&#125;span&#123; line-height: 200px; background: gray;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校&lt;/span&gt;&lt;/div&gt; 或者子元素是没有给定高度的块级元素时也可以通过相同方法设置块级元素文字垂直居中下： 12345678.dad &#123; height: 200px; border: 1px solid red;&#125;p&#123; line-height: 200px; background: gray;&#125; 123&lt;div class=\"dad\"&gt;&lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 补充：vertical-align属性 行内元素（图片）/单元格 垂直对齐方式 vertical-align 属性指定行内元素（inline）或表格单元格（table-cell）元素 相对父元素的垂直对齐方式。 baseline：使元素的基线与父元素的基线对齐。 middle：使元素的中部与父元素的基线加上父元素x-height（x高度）的一半对齐。 （更多属性可参考这里） 作用于：display属性值为inline、inline-block、inline-table另加一个table-cell的元素。（可参考这篇文章） 注意：不能用它垂直对齐块级元素。 关于基线的位置（不是固定的）： 在文本之类内联元素中，基线是字符x的下边缘位置 在像img元素中基线就是下边缘。 在inline-block元素中，也分两种情况： 如果该元素中有内联元素，基线就是最后一行内联元素的基线。 如果该元素内没有内联元素或者overflow不是visible，其基线就是margin的地边缘。 注意：vertical-align不作用于span元素，原因如下： 实际上，一个Box中由很多行很多元素组成，vertical-align只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。是相对同一行 一个 span定义了一个60px的高度，但是这个span的Box中存在很多行，那段文本并不能对齐到span的中央。因此希望那段文本对齐span的中行需要给它定义一个line-height的属性，让line-height为60px，作用于一行的vertical-align就按你的想法工作了。 table的单元格，因为是一行内的元素，因此vertical-align按照我们的想法来工作，但是在span中并不是这样的。 说到这感觉line-height可以替代vertical-align，但实际不是的。vertical-align使用场景：当一个文本后面跟着个inline-block的元素时，后者是对齐文本的基线的，这就导致文本看上去被挤下来了一样，使用vertical-align: top/text-top就可以解决这个问题，这是line-height解决不了的。（还有这个常见的图片问题） 补充：display:table-cell;表格单元格 设置display:table-cell;会使此元素会作为一个表格单元格显示（类似 &lt;td&gt;和 &lt;th&gt;）。 可以通过在.table-cell中添加vertical-align：middle使表格内部文字垂直居中 （不定高）块级元素垂直居中 子元素是块级元素但是子元素高度没有设定，在这种情况下实际上是不知道子元素的高度的，无法通过计算得到padding或margin来调整，但是还是存在一些解法。 方法1（单元格vertical-align）通过给父元素设定display:table-cell;vertical-align:middle;来实现没有定高的块级子元素垂直居中。 12345678910.dad &#123; height: 200px; display: table-cell; vertical-align: middle; border: 1px solid red;&#125;p &#123; background: gray; margin: 0;&#125; 123&lt;div class=\"dad\"&gt; &lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 方法2（flexbox）给父元素使用display: flex;将其设置为弹性盒子父容器，然后设置align-items: center;定义子项在交叉轴上的对齐方式： 12345678910.dad &#123; height: 200px; border: 1px solid red; display: flex; align-items: center;&#125;p &#123; background: gray; margin: 0;&#125; 123&lt;div class=\"dad\"&gt; &lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 方法3（line-height+inline-block）给块级元素设置display:inline-block,然后使用行内元素的line-height属性实现垂直居中。 补充：绝对定位/固定定位/浮动 都会使元素变为inline-block元素 （定高）块级元素垂直居中此时可以计算子元素的margin-top或margin-bottom，将其设置为(父元素高度-子元素高度)/2 12345678910.dad &#123; height: 200px; border: 1px solid red;&#125;p &#123; background: gray; margin: 0; height: 40px; margin-top: 80px;&#125; 123&lt;div class=\"dad\"&gt; &lt;p&gt;上校&lt;/p&gt;&lt;/div&gt; 水平+垂直居中text-align+ line-height块/行内元素单行文本双向居中text-align+ line-height实现块内单行文本水平垂直居中: 123456div &#123; text-align: center; line-height: 100px; background: gray; width: 200px;&#125; 1&lt;div&gt;上校,喵&lt;/div&gt; 注意：行内元素要实现居中就要去给他的父元素设置，垂直居中就通过父元素line-height给子元素一个高度，再通过父元素设置text-align:center实现行内元素水平居中： 123456789span &#123; background: gray; width: 200px;&#125;.dad &#123; text-align: center; line-height: 100px; border: 1px solid red;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校,喵&lt;/span&gt;&lt;/div&gt; text-align + vertical-align实现行内元素（图片）双向垂直上面有说到vertical-align是只作用于在同一行内的元素，它的垂直并不是相对于整个Box而言的。而table的单元格是一行内的元素，因此vertical-align生效。注意:子元素需要设置为inline-block，父元素需要设置高度。 123456789101112span &#123; background: gray; width: 200px; display: inline-block;&#125;.dad &#123; display: table-cell; text-align: center;/* 行内元素给父元素设置text-align可水平居中 */ height: 200px; vertical-align: middle; border: 1px solid red;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校,喵&lt;/span&gt;&lt;/div&gt; 若子元素是图像，可不使用table-cell，而是其父元素用行高替代高度，且字体大小设为0。子元素本身设置vertical-align:middle： 12345678910111213.dad &#123; text-align: center;/* 行内元素给父元素设置text-align可水平居中 */ line-height: 200px; font-size: 0; border: 1px solid red;&#125;img &#123; vertical-align: middle; width: auto; height: auto; max-width: 200px; max-height: 200px;;&#125; 123&lt;div class=\"dad\"&gt; &lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt; 相对+绝对定位行内元素进行绝对定位/固定定位后会变成inline-block元素。 使用absolute，利用绝对定位元素的盒模型特性，在偏移属性为确定值的基础上，设置margin:auto 1234567891011121314151617span &#123; background: gray; position: absolute; top: 0; left: 0; right: 0; bottom: 0; height: 100px; width: 100px; margin: auto;&#125;.dad &#123; position: relative; border: 1px solid red; width: 200px; height: 200px;&#125; 123&lt;div class=\"dad\"&gt; &lt;span&gt;上校,喵&lt;/span&gt;&lt;/div&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS 布局）","slug":"百度前端技术学院 第七天学习笔记（CSS布局）","date":"2019-11-20T13:28:13.000Z","updated":"2019-11-25T08:54:01.858Z","comments":true,"path":"2019/11/20/百度前端技术学院 第七天学习笔记（CSS布局）/","link":"","permalink":"http://yoursite.com/2019/11/20/百度前端技术学院 第七天学习笔记（CSS布局）/","excerpt":"display属性 display 是CSS中最重要的用于控制布局的属性。 每个元素都有一个默认的 display 值，这与元素的类型有关。 列举一些已经学过的属性值：","text":"display属性 display 是CSS中最重要的用于控制布局的属性。 每个元素都有一个默认的 display 值，这与元素的类型有关。 列举一些已经学过的属性值： 属性值 描述 block 一个 block 元素通常被叫做块级元素。div 是一个标准的块级元素。一个块级元素会新开始一行并且尽可能撑满容器。其他常用的块级元素包括 p、 form和HTML5中的新元素： header 、footer 、 section等等。 inline 一个 inline 元素通常被叫做行内元素。span 是一个标准的行内元素, a元素是最常用的行内元素。 inline-block 它可以让内联的盒子像一个块元素，使元素在一行显示，仍然保持样式可设置 flex 用于设置元素为弹性盒子的父容器 none 一些特殊元素的默认 display 值是它，例如 script 。 display:none 通常被 JavaScript 用来在不删除元素的情况下隐藏或显示元素。它和 visibility 属性不一样。把 display 设置成 none 元素不会占据它本来应该显示的空间，但是设置成 visibility: hidden;还会占据空间。 每个元素都有一个默认的display 类型。不过你可以随时随地的重写它！常见的例子是：把 li 元素修改成 inline，制作成水平菜单。 max-width属性更好地处理小窗口情况使用 max-width替代width 可以使浏览器更好地处理小窗口的情况。 123456789101112131415&lt;head&gt; &lt;style&gt; #main &#123; max-width: 600px; margin: 0 auto; border: 1px solid red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"main\"&gt; 设置块级元素的 width 可以防止它从左到右撑满整个容器。然后你就可以设置左右外边距为 auto 来使其水平居中。元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。 唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。让我们再来改进下这个方案... &lt;/div&gt;&lt;/body&gt; 可以看到缩小窗口以后下方的水平滚动条：使用 max-width替代width 使用 max-width后可以注意到缩小窗口后也不会出现水平滚动条: 替代盒模型注意事项box-sizing是个很新的属性，目前应该像下面例子中那样使用 -webkit-和 -moz-前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+的。 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; position属性与CSS&lt;footer&gt;标签（页脚） 如果你使用了一个固定定位的页眉或页脚，确保有足够的空间来显示它们！比如：在 body 上面加上足够的 margin-bottom 。 例子 float属性Float 可用于实现文字环绕图片，如下： 1234img &#123; float: right; margin: 0 0 1em 1em;&#125; nav元素与float属性这个例子在容器比nav元素高的时候可以正常工作。如果容器比nav元素低，那么nav会溢出到容器的外面。nav改用浮动以后可以解决易出问题。 响应式设计——媒体查询 MDN 媒体查询 一个例子：当屏幕宽度大于600px时执行的CSS样式表与小于599px时执行的CSS样式表有所不同，当窗口缩小到宽度小于599px时，nav中的li元素就会转变为行内元素并出现在section元素上方。 vertical-align属性设置行内元素垂直方向对齐方式 vertical-align 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。 注意： vertical-align 只对行内元素、表格单元格元素生效，不能用它垂直对齐块级元素。 作用于行内元素的属性值（分为“相对父元素的值”和”相对行的值”）：相对父元素的属性值 | 描述（这些值使元素相对其父元素垂直对齐） –|—baseline（默认值） | 使元素的基线与父元素的基线对齐。HTML规范没有详细说明部分可替换元素的基线，如&lt;textarea&gt; ，这意味着这些元素使用此值的表现因浏览器而异。sub | 使元素的基线与父元素的下标基线对齐。super | 使元素的基线与父元素的上标基线对齐。text-top | 使元素的顶部与父元素的字体顶部对齐。text-bottom | 使元素的底部与父元素的字体底部对齐。middle | 使元素的中部与父元素的基线加上父元素x-height（译注：x高度）的一半对齐。&lt;length&gt; | 使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。&lt;percentage&gt; | 使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。 相对行的属性值 描述(下列值使元素相对整行垂直对齐) top 使元素及其后代元素的顶部与整行的顶部对齐。 bottom 使元素及其后代元素的底部与整行的底部对齐。 没有基线的元素，使用外边距的下边缘替代。 vertical-align属性可被用于两种环境： 使行内元素盒模型与其行内元素容器垂直对齐。例如，用于垂直对齐一行文本的内的图片&lt;img&gt;： 垂直对齐表格单元内容: MDN vertical-align属性 inline-block属性值可方便创建网格 想要创建很多网格来铺满浏览器。在过去很长的一段时间内使用 float ，但是使用 display:inline-block; 会更简单。 让我们看下使用这两种方法的例子对比 注意： vertical-align 属性（默认值为baseline）会影响到 inline-block 元素，你可以把它的值设置为 top（使元素及其后代元素的顶部与整行的顶部对齐） 。（例子） 你需要设置每一列的宽度 如果HTML源代码中元素之间有空格，那么列与列之间会产生空隙 你得做些额外工作来让IE6和IE7支持 inline-block 。有些时候人们谈到 inline-block 会触发叫做 hasLayout 的东西，你只需要知道那是用来支持旧浏览器的就可以了。如果你对此很感兴趣，可以在这个链接中找到更详细的信息。 columns属性轻松实现文字的多列布局 CSS columns是很新的标准，所以你需要使用前缀（如下方例子中），并且它不被IE9及以下和Opera Mini支持。还有许多和 column 相关的属性，点击这里了解更多。 一个例子 MDN 关于columns属性 使用flexbox居中布局 同时在父容器设置align-items: center;（沿交叉轴居中）与justify-content: center;（沿主轴居中）可以使子项元素在父容器中居中。 例子 布局模型1. 流动模型（Flow） [默认的]流动（Flow）模型是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。流动布局模型具有2个比较典型的特征： 块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 在流动模型下，行内元素都会在所处的包含元素内从左到右水平分布显示。 2. 浮动模型 (Float)使用CSS的float属性。 3. 层模型（Layer）层模型有三种形式： 相对定位(position: relative) 绝对定位(position: absolute) 固定定位(position: fixed) 注意：固定定位是相对视图定位，不会随着滚动条的操作而移动位置。而绝对定位相对于其最接近的一个非默认position属性值的父元素进行定位，在父元素全部是默认position属性值时则是相对body元素（即相对于浏览器窗口）进行定位，会随着滚动条的操作而移动位置。【注意区分“视图”与“浏览器窗口”】 注意：更改堆叠顺序的z-index属性只适用于定位元素（position属性值为static的对象不是定位元素）父子元素都设置z-index属性时只要父元素z-index属性生效则子元素z-index属性不生效，默认与父元素属性值相等并按照文档流排列，子元素出现在父元素上方。（父元素未设置position属性值或设为默认值static时z-index属性失效，则子元素z-index属性生效） 什么时候用定位，什么时候用浮动 float被设计出来的初衷是用于——文字环绕图片 float是部分脱离文档流，而absolute是完全脱离文档流。也就是说，使用float属性时，其他元素会无视这个float元素，但是其他元素内的文本依然会为这个元素让出位置，环绕在周围，所以称为部分无视。而使用absolute脱离文档流的元素，其它盒子无论是本身还是盒子内的文本都会无视这个元素，也就是完全脱离文档流。 float多个特性具体例子请参考这个链接 破坏性：被设置了float的元素会脱离文档流 包裹性：块级元素设置了float之后，其宽度会自动调整为包裹住内容宽度，而不是撑满整个父容器。 清空格：根本原因是由于float会导致节点脱离文档流结构,float元素都不属于文档流结构了，那么它身边的什么换行、空格就都和它没关系，它就尽量的往一边去靠拢，能靠多近就靠多近，这就是清空格的本质。 float具有“破坏性”，它会导致父元素“坍塌”（即父元素无法包裹float子元素），此时可以为父元素添加overflow:hidden,这样父元素就有高度了 ，父元素的高度便不会被破坏。 网页布局方式网页实质是块与块之间的位置，块挨着块，块嵌套块，块叠着块。三种关系：相邻，嵌套，重叠。参考 一列布局（固定宽高，水平居中）一般都是固定的宽高，设置margin : 0 auto来水平居中，用于界面显著标题的展示等: 1234567 .main&#123; width: 200px; height: 100px; background-color: grey; margin: 0 auto; &#125;&lt;div class=\"main\"&gt;&lt;/div&gt; 两列布局（常用float）最常见的就是使用float来实现。float浮动布局的缺点是浮动后会造成文本环绕等效果，需要及时清除浮动。设置左左浮动，或设置左右浮动（需要设置父元素的宽度）如果父级元素没有设置高度，则需要设置overflow:hidden避免父元素“高度坍塌”。（如果你没有给父元素定义高度，此时给父元素加个overflow:hidden；（超过浮动就隐藏）就相当于清除浮动，没有浮动又没定义高度，父元素就会根据文档流自适应高度，也就不会“坍塌”了） overflow:hidden;属性可以保证div的高度或宽度不变。div里添加的东西再多，高度或宽度也不变。超出的部分隐藏。解决float子元素图片溢出和float父元素“高度坍塌”都可以使用overflow:hidden;。 1234&lt;div class=\"main\"&gt; &lt;div class=\"left\"&gt;left&lt;/div&gt; &lt;div class=\"right\"&gt;right&lt;/div&gt;&lt;/div&gt; 12345678910111213.main&#123; width: 400px; background: red; overflow: hidden;&#125;.left&#123; background: yellow; float: left;&#125;.right&#123; background: green; float: left;&#125; 三列布局（浮动或子绝父相）浮动：首先设置父级元素的宽度（width: 100%;overflow: hidden;） 可以左左右设置浮动。然后中间设置margin调整间距。 也可以都设置成左浮动，设置margin，调整间距。同样注意清除浮动！ 子绝父相：为父元素设置relative属性，再为子元素设置absolute属性，再分别定位，调间距。 混合布局在一列布局的基础上，保留top和foot部分，将中间的main部分改造成两列或三列布局，小的模块可以再逐级同理划分。 对齐方式水平居中补充：img是行内元素，为什么可以设置框高？（面试题）（题目来自魅族一面）问题：既然img是行内元素，那为什么可以通过CSS设置框高呢？答案：尽管img是行内元素，但同时它也是置换元素，置换元素一般内置框高属性，因此可以设置其框高。 引申问题：那么什么又是“置换元素”呢？答案：置换元素就是会根据标签属性来显示的元素。反之就是非置换元素了。比如img根据src属性来显示，input根据value属性来显示，因此可知道img和input是置换元素，当然同理select也是置换元素。 行内元素的水平居中 注意：text-align属性虽然规定元素中的文本的水平对齐方式，但他是作用于块级元素的（p/h1等等）。 如果被设置元素为文本、图片等行内元素时，则需要在父元素中设置text-align:center实现行内元素水平居中（必要时可以将子元素的display设置为inline-block，使子元素变成行内元素的同时可设置样式）。 补充：图片等比缩小可借助max-width和max-height 123456789101112.dad &#123; text-align: center;&#125;img &#123; width: auto; height: auto; max-width: 200px; max-height: 200px;&#125;p&#123; text-align: center;&#125; 1234567&lt;div class=\"dad\"&gt; &lt;img src=\"../上校.jpg\"&gt;&lt;/div&gt;&lt;div class=\"dad\"&gt; &lt;span&gt;上校&lt;/span&gt;&lt;/div&gt;&lt;p&gt;喵呜&lt;/p&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS flexbox）","slug":"百度前端技术学院 第七天学习笔记 （CSS flexbox）","date":"2019-11-20T08:24:30.000Z","updated":"2020-11-21T04:05:18.475Z","comments":true,"path":"2019/11/20/百度前端技术学院 第七天学习笔记 （CSS flexbox）/","link":"","permalink":"http://yoursite.com/2019/11/20/百度前端技术学院 第七天学习笔记 （CSS flexbox）/","excerpt":"flexbox弹性盒子 MDN flexbox例子 想要flex生效必须定义其父元素的display属性为flex或inline-flex flex容器flex container（父级容器） flex子项flex item","text":"flexbox弹性盒子 MDN flexbox例子 想要flex生效必须定义其父元素的display属性为flex或inline-flex flex容器flex container（父级容器） flex子项flex item 主轴main axis（主轴方向是可变的，主要取决于flex-direction属性），它是沿着 flex 元素放置的方向延伸的轴（比如页面上的横向的行、纵向的列）。该轴的开始和结束被称为 main start 和 main end。 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴（垂直于主轴）。该轴的开始和结束被称为 cross start 和 cross end。 父级container的属性display定义flex父容器display属性定义一个flex容器，内联或者根据指定的值，来作用于下面的子类容器。 请注意，CSS列对flex容器无效。 float, clear, vertical-align 在flex项目中不起作用 属性值 含义 flex 块，将对象作为弹性伸缩盒显示 inline-flex 内联，将对象作为内联块级弹性伸缩盒显示 注意：子组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。所以可以给父组件设置flex:1，表示让它占据了垂直的整个空间。 flex-flow简写flex-direction和flex-wrap属性 这是flex-direction和flex-wrap属性的简写，它们一起定义了flexbox的主轴和交叉轴。 默认值为row nowrap。(即：将所有子项排列在一行上)1flex-flow: row wrap; flex-direction规定子项排列方式及方向Flexbox是单向布局概念。可以将弹性项目想像为主要以水平行或垂直列布置。 属性值 含义 row（默认值） 把子项排在同一行，从左到右 row-reverse 行，从右到左 column 把子项排在同一列，从上到下 column-reverse 与row-reverse相似，只是变成了从下到上 flex-wrap使溢出子项换行 默认情况下，所有弹性项目都将尝试放入一行。可以通过修改flex-wrap属性值使溢出父元素宽度的子项换行。 注意：flex-direction属性值为row时将flex-wrap属性值设置为wrap会使得子项换行，但一个子项占据一行，此时可通过设置子项的flex属性值来设置默认宽度来达到一行多个子项的效果。 属性值 含义 nowrap （默认） 所有弹性项目都在一行上 wrap 弹性项目将从上到下分布在多行上。 wrap-reverse 弹性项目将从下到上分布在多行上。 justify-content定义子项沿主轴的对齐方式定义了子项沿主轴的对齐方式。(主轴是可变的，主要取决于flex-direction属性值) 属性值 含义 flex-start （默认） 从flex-direction的开始处开始放置子项 flex-end 从flex-direction的末端开始放置子项 start 子项从书写模式方向的起点开始放置 end 子项从书写模式方向的末端开始放置 left 子项从容器的左边缘开始放置，除非这与flex-direction不一致，否则它的行为类似于start right 子项从容器的右边缘开始放置，除非这与flex-direction不一致，否则它的行为类似于start center 子项沿线居中 space-between 子项在行中均匀分布，第一项位于开始处，最后一项位于结束处 space-around 项目在行中均匀分布，并且周围有相等的空间。请注意，从视觉上看，空间是不相等的，因为所有项目的两侧都具有相等的空间。第一项相对于容器边缘有一个单位的空间，但是它与下一项之间有两个单位的空间。 space-evenly （evenly：均匀地）分配项目，任意两个项目之间的间距（以及到边缘的间距）相等。 请注意，浏览器对这些值的支持是有细微差别的。例如，space-between从来没有获得Edge支持，并且Chrome没有start/end/left/right。MDN 有详细的图表。最安全的值是flex-start，flex-end和center。 还可以这些值与将两个其他关键字（safe和unsafe）配对。使用safe确保无论执行哪种类型的定位，都不能以无法滚动内容的方式推送元素以使其呈现屏幕外（例如，从顶部移出）（称为“数据丢失”） 。 align-items定义子项在交叉轴上的对齐方式用来设置每个flex元素在侧轴上的默认对齐方式 123.container &#123; align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe;&#125; 属性值 含义 stretch （默认） 使所有 flex 项沿着交叉轴的方向拉伸以填充父容器。如果父容器在交叉轴方向上没有固定宽度（即高度），则所有 flex 项将变得与最长的 flex 项一样长（即高度保持一致）。（仍然遵守最小宽度/最大宽度） flex-start/ start/ self-start 项目放置在cross-axis的起点,它们之间的区别是微妙的，并且是遵守flex-direction规则或writing-mode规则的 flex-end/ end/ self-end 项目放置在cross-axis的末端。差异再次是微妙的，尊重flex-direction规则与writing-mode规则 center 使子项保持其原有的高度，在交叉轴上居中 baseline 项目对齐，例如基线对齐 可以结合safe和unsafe关键字与上面的属性值一起使用（但是注意浏览器支持），他可以防止内容变得不可访问。 align-content定义行沿交叉轴的对齐方式 当flex父容器在交叉轴上有多余的空间时，且属性值为：flex-start、flex-end、center、stretch时，将所有子项作为一个整体单位沿交叉轴进行对齐。 当flex父容器在交叉轴上有多余的空间时，且属性值为：space-between/space-around时，将单行子项作为一个单位沿交叉轴进行对齐。 align-content属性设置了不同行之间如何沿着父容器（flexbox container）的交叉轴在行周围分配空间。 注意：只有一行flexbox时，此属性无效。 区分：justify-content的单位是子项，align-content的单位是一行子项。 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe;&#125; 属性值 含义 stretch （默认） 拉伸所有行来填满剩余空间。剩余空间平均的分配给每一行 start 所有行从父容器的起始边缘开始填充 flex-start 所有行从垂直轴起点开始填充。第一行的垂直轴起点边和容器的垂直轴起点边对齐。接下来的每一行紧跟前一行。 end 所有行从父容器的结束边缘开始填充 flex-end 所有行从垂直轴末尾开始填充。最后一行的垂直轴终点和容器的垂直轴终点对齐。同时所有后续行与前一个对齐。 center 所有行朝向父容器的中心填充。每行互相紧挨，相对于容器居中对齐。容器的垂直轴起点边和第一行的距离相等于容器的垂直轴终点边和最后一行的距离。 space-between 所有行在容器中平均分布，相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的边对齐。（第一行在容器的开头，而最后一行在容器的结尾） space-around 所有行在容器中平均分布，相邻两行间距相等。容器的垂直轴起点边和终点边分别与第一行和最后一行的距离是相邻两行间距的一半。（每一行周围具有相等的空间（注意：两行之间有两个单位的空间，参考justify-content属性的space-around属性值）） space-evenly 项目均匀分布，（从视觉上看，每一个行周围具有相等的空间。）所有行沿垂直轴均匀分布在对齐容器内。每对相邻的项之间的间距，主开始边和第一项，以及主结束边和最后一项，都完全相同 区别justify-content与align-content还有align-itemsjustify-content属性可应用于所有的flex容器，定义子项在主轴上的对齐方式（位置）。【子项为单位】 align-items属性可应用于所有的flex容器，定义子项在交叉轴上的对齐方式（位置）。 align-content属性只适用多行的flex容器（也就是flex父容器中的子项不止一行时该属性才有效果）。当flex父容器在交叉轴上有多余的空间时，且属性值为：flex-start、flex-end、center、stretch时，将所有子项作为一个整体单位沿交叉轴进行对齐。当flex父容器在交叉轴上有多余的空间时，且属性值为：space-between/space-around时，将单行子项作为一个单位沿交叉轴进行对齐。 子项item的属性order顺序 默认情况下，flexbox按源顺序排列。但是，该order属性可以控制子项在flex容器中出现的顺序而不会影响到源顺序（即 dom 树里元素的顺序）。这也是传统布局方式很难做到的一点。 order 值小的 flex 项在显示顺序中更靠前。相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是2，1，1和0，那么它们的显示顺序就分别是第四，第二，第三，和第一。 属性值：无单位整数，默认为0，可以为负值。 例子：在众多按钮中将第一个按钮移动到主轴的末尾123button:first-child &#123; order: 1;&#125; flex简写flex-grow、flex-shrink和flex-basis 建议使用该简写属性！ 这是flex-grow、flex-shrink和flex-basis组合的简写。 第二和第三个参数(flex-shrink和flex-basis)是可选的（省略部分属性值时注意有顺序要求）。 默认值是0 1 auto。（即0：如果存在剩余空间，也不放大。1：如果空间不足，则该子项格局1的比例缩小。auto：子项初始大小参照我的width和height属性） 大多数情况下，开发者只需要将 flex 设置为 auto，initial，none，或一个无单位正数 即可。 如果一个子项a给定flex:200px而另一个子项b给定flex:1,那么将会先给a 200px，然后b自适应。 例子：表示“每个flex 子项将首先给出200px的可用空间，然后将剩余的可用空间将根据flex-grow属性值（2）分配的比例共享” 123.item &#123; flex: 2 200px；&#125; 注意： 一般而言我们会使用flex:1来指定某个组件扩张以撑满所有剩余的空间。 子组件能够撑满剩余空间的前提是其父容器的尺寸不为零。如果父容器既没有固定的width和height，也没有设定flex，则父容器的尺寸为零。其子组件如果使用了flex，也是无法显示的。所以可以给父组件设置flex:1，表示让它占据了垂直的整个空间。 属性值 描述 initial 元素会根据自身宽高设置尺寸。它会缩短自身以适应 flex 容器，但不会伸长并吸收 flex 容器中的额外自由空间来适应 flex 容器 。相当于将属性设置为”flex: 0 1 auto”。 auto 元素会根据自身的宽度与高度来确定尺寸，但是会伸长并吸收 flex 容器中额外的自由空间，也会缩短自身来适应 flex 容器。这相当于将属性设置为 “flex: 1 1 auto”. none 元素会根据自身宽高来设置尺寸。它是完全非弹性的：既不会缩短，也不会伸长来适应 flex 容器。相当于将属性设置为”flex: 0 0 auto”。【所以可以通过设置flex为none然后给定width使子项固定大小】 &lt;&#39;flex-grow&#39;&gt; 定义 flex 元素的 flex-grow 属性，详见 &lt;number&gt;。默认值为 0，负值无效。 &lt;&#39;flex-shrink&#39;&gt; 定义 flex 元素的 flex-shrink 属性，详见 &lt;number&gt;。默认值为1，负值无效。 &lt;&#39;flex-basis&#39;&gt; 定义 flex 元素的 flex-basis 属性。若值为0，则必须加上单位，以免被视作伸缩性。 默认值为 auto。 flex 属性值顺序要求flex 属性可以指定1个，2个或3个值。但他是有顺序要求的！ 单值语法: 值必须为以下其中之一: 一个无单位数(&lt;number&gt;): 它会被当作&lt;flex-grow&gt;的值。 一个有效的宽度(width)值: 它会被当作 &lt;flex-basis&gt;的值。 关键字none，auto或initial. 双值语法: 第一个值必须为一个无单位数，并且它会被当作 &lt;flex-grow&gt; 的值。第二个值必须为以下之一： 一个无单位数：它会被当作&lt;flex-shrink&gt;的值。 一个有效的宽度值: 它会被当作 &lt;flex-basis&gt; 的值。 三值语法: 第一个值必须为一个无单位数，并且它会被当作&lt;flex-grow&gt;的值。 第二个值必须为一个无单位数，并且它会被当作 &lt;flex-shrink&gt; 的值。 第三个值必须为一个有效的宽度值， 并且它会被当作 &lt;flex-basis&gt;的值。 flex-grow子项空间占比（放大比例） flex-grow属性值是一个无单位的比例值，规定 flex 项相对于其他flex 项沿主轴的进行扩展的量，它决定了子项在父级容器（flex container）内部占用多少可用空间，占用的空间是在设置 padding 和 margin 之后剩余的空间。 属性值：默认为0(即如果存在剩余空间，也不放大)，不能为负数。 如果所有项目flex-grow都设置为1，则容器中的剩余空间将平均分配给所有子项。如果其中一个孩子的值为2，则剩余空间将占其他孩子的两倍（或者至少会尝试）。123.item &#123; flex-grow: 3; /* default 0 */&#125; 固定子项大小想让子项固定大小可设置flex为none然后给定width flex-shrink弹性收缩（缩小比例） flex-shrink 属性指定了 flex 元素的收缩规则。flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值。 一般用于溢出容器的 flex 子项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 这是一个相当高级的弹性盒子功能. 属性值:默认为1（即如果空间不足，该项目将缩小），不能为负数。如果是0，则空间不足子项也不缩小 123.item &#123; flex-shrink: 2; /* default 1 */&#125; MDN flex-shrink flex-basis子项初始大小（最小值） flex-basis 指定了 flex 元素在主轴方向上的初始大小。如果不使用 box-sizing 改变盒模型的话，那么这个属性就决定了 flex 元素的内容盒（content-box）的尺寸。 即：flex-basis 指定在分配多余空间之前，项目占据的主轴空间（main size） 属性值 含义 长度 例如20％，5rem等 关键字 auto：参照我的width和height属性content(此关键字不能很好地支持,不建议使用):根据子项的内容调整大小 123.item &#123; flex-basis: 200px; /* default auto */&#125; MDN flex-basis 属性值如果设置为0，则不考虑内容周围的额外空间。 属性值如果设置为auto，则根据其flex-grow值分配额外的空间。 align-self调整单个子项在交叉轴上的对齐方式 align-self 会对齐当前 flex 行中的 flex 元素，并覆盖已有的align-items 的值，按照cross axis方向进行排列. 注意：float（浮动）, clear（清除浮动） 和 vertical-align对flex子项没有影响。 默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 属性值 含义 auto (默认值) 设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch flex-start flex 元素会对齐到 cross-axis 的首端 flex-end flex 元素会对齐到 cross-axis 的尾端 center flex元素会对齐到 cross-axis 的中间，如果该元素的 cross-size 的尺寸大于 flex 容器，将在两个方向均等溢出 baseline 所有的 flex 元素会沿着基线对齐。如弹性盒子元素的行内轴与侧轴为同一条，则该值与’flex-start’等效。其它情况下，该值将参与基线对齐。 stretch 子项在交叉轴方向被拉伸以适应容器。如果指定侧轴大小的属性值为’auto’，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照’min/max-width/height’属性的限制。 各种属性值效果参考 flex 嵌套弹性盒子也能创建一些颇为复杂的布局。一个元素即可以是父容器也可以是子项，也就是说你可以为父容器中的一个子项也设置display属性使其成为一个父容器。如上图，我们用一个 &lt;section&gt; 元素作为父容器包含了三个 &lt;article&gt;元素。第三个 &lt;article&gt;元素（作为&lt;section&gt;子项的它同时被设置为父容器）包含了三个&lt;div&gt;,像这样： 1234567section - article article article - div - button div button div button button button 特别注意这里我们设置第三个 元素的子节点的布局同样为 flex ，但是属性值为列布局（flex-flow: column;）。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第七天学习笔记（CSS position）","slug":"百度前端技术学院 第七天学习笔记 （CSS position)","date":"2019-11-19T13:12:24.000Z","updated":"2020-02-26T15:42:45.063Z","comments":true,"path":"2019/11/19/百度前端技术学院 第七天学习笔记 （CSS position)/","link":"","permalink":"http://yoursite.com/2019/11/19/百度前端技术学院 第七天学习笔记 （CSS position)/","excerpt":"position属性position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。","text":"position属性position属性用于指定一个元素在文档中的定位方式。top，right，bottom 和 left 属性则决定了该元素的最终位置。 注意：行内元素进行绝对定位/固定定位后会变成inline-block元素,所以虽然对外表现的像是块级元素，但还是可以使用行内元素的line-height属性实现垂直居中。不论之前什么类型的元素（display:none除外），只要设置了position：absolute/fixed、 float中任意一个，都会让元素以display:inline-block的方式显示 属性值 含义 absolute 生成绝对定位的元素，不为元素预留空间。通过指定元素相对于最近的非 static定位祖先元素的偏移，来确定元素位置。（如果所有父元素都没是默认position值则绝对定位相对浏览器窗口进行定位）绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 fixed 生成固定定位的元素，不为元素预留空间。相对于浏览器窗口进行定位。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。 relative 生成相对定位的元素，相对于其正常位置进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）【即会为元素预留空间】 static 默认值。没有定位，元素出现在正常的流中（此时 top, right, bottom, left 和 z-index 属性无效）。 sticky 基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从浏览器窗口顶部10像素）之后它变得固定。必须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。常用于定位字母列表的头部元素 默认值static 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。 相对定位relative 生成相对定位的元素，文档流中将为元素预留空间。 相对定位会相对元素的原始位置对该元素进行移动。 top, bottom, left, right属性除默认值static外，其他属性值都要配合使用top, bottom, left, 和 right属性值来精确指定要将定位元素移动到的位置。 1234567891011121314&lt;body&gt; &lt;h1&gt;Basic document flow&lt;/h1&gt; &lt;p&gt;I am a basic block level element. My adjacent block level elements sit on new lines below me.&lt;/p&gt; &lt;p class=\"positioned\"&gt;By default we span 100% of the width of our parent element, and we are as tall as our child content. Our total width and height is our content + padding + border width/height.&lt;/p&gt; &lt;p&gt;We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both.&lt;/p&gt; &lt;p&gt;inline elements &lt;span&gt;like this one&lt;/span&gt; and &lt;span&gt;this one&lt;/span&gt; sit on the same line as one another, and adjacent text nodes, if there is space on the same line. Overflowing inline elements will &lt;span&gt;wrap onto a new line if possible (like this one containing text)&lt;/span&gt;, or just go on to a new line if not, much like this image will do: &lt;img src=\"https://mdn.mozillademos.org/files/13360/long.jpg\"&gt; &lt;/p&gt;&lt;/body&gt; 1234567891011121314151617181920212223body &#123; width: 500px; margin: 0 auto; &#125; p &#123; background: aqua; border: 3px solid blue; padding: 10px; margin: 10px; &#125; span &#123; background: red; border: 1px solid black; &#125; .positioned &#123; position: relative; background: yellow; top: 30px; left: 30px; &#125; 绝对定位absolute 使用position:absolute;生成绝对定位的元素，它会相对于第一个非 static 的父元素进行定位。 生成绝对定位的元素，不为元素预留空间。 如果所有的父元素都没有显式地定义position属性(即全部是默认值)，那么所有的父元素默认情况下position属性都是static。结果，绝对定位元素会被包含在初始块容器中。这个初始块容器有着和浏览器窗口一样的尺寸，并且&lt;html&gt;元素也被包含在这个容器里面。简单来说，绝对定位元素会被放在&lt;html&gt;元素的外面，并且根据浏览器窗口来定位。（可以通过子绝父相来解决这一问题） 将上面例子中的position值改为absolute:1position: absolute; 绝对定位元素在HTML源代码中，是被放在&lt;body&gt;中的，但是在最终的布局里面，它是离浏览器窗口页面的左边界、上边界有30px的距离。(而不是&lt;body&gt;) 定位上下文（子绝父相） 上面的例子绝对定位元素会被放在&lt;html&gt;元素的外面，并且根据浏览器窗口来定位。（可以通过子绝父相来解决这一问题） 可以通过设置绝对定位元素的其中一个父元素的定位属性为相对定位relative来使得绝对定位元素不相对初始块容器进行定位，比如下面例子中将body的css样式设为position: relative;就可以使得body中绝对定位的p元素相对body进行定位。（如果不这么做，子元素就会相对body或浏览器定位，产生不好的效果） 【子绝父相】：我们可以改变定位上下文(绝对定位的元素的相对位置元素)来使绝对元素相对于我们给定的父元素进行定位，而不是相对于浏览器窗口进行定位。也就是设置绝对定位元素的其中一个父元素的定位属性为相对定位relative，比如：给父元素body添加css样式：1position: relative; z-index更改堆叠顺序 可以通过修改z-index属性值更改元素堆叠顺序。 我们使用水平（x轴）和垂直（y轴）坐标来讨论网页，以确定像背景图像和阴影偏移之类的东西的位置。（0,0）位于页面（或元素）的左上角，x和y轴跨页面向右和向下（适合从左到右的语言）。 网页也有一个z轴：一条从屏幕表面到你的脸的虚线。z-index 值影响定位元素位于该轴上的位置；正值将它们移动到堆栈上方，负值将它们向下移动到堆栈中。默认情况下，定位的元素都具有z-index为auto，实际上为0。 注意，z-index只接受无单位索引值；你不能指定你想要一个元素是Z轴上23像素。较高的值将高于较低的值，但使用2和3将产生与300和40000相同的效果。 例子 当出现多个绝对定位元素时，源顺序中排在后面的元素将出现在排在前面的元素的顶部,比如给上面的例子加上下面代码，使得第一段文字也变成绝对定位（之前是只有第二段文字绝对定位）：123456p:nth-of-type(1) &#123; position: absolute; background: lime; top: 10px; right: 30px; &#125; 可以看到第一段文字绿色绝对定位出现在了第一段文字黄色绝对定位的下方。 修改z-index值，使得第一段文字绿色绝对定位出现在了第一段文字黄色绝对定位的上方，将以下声明添加到 p:nth-of-type(1) 规则中：1z-index: 1; 固定定位fixed fixed与absolute的工作方式完全相同，只有一个主要区别：父元素都是默认position时，absolute固定元素是相对于浏览器窗口本身的， 但“子绝父相”，当父元素有相对定位时将相对其最近的相对定位祖先来固定元素。而fixed固定元素则一直是相对于浏览器窗口本身。 生成固定定位的元素，也不为元素预留空间。 这意味着您可以创建固定的有用的UI项目，如持久导航菜单。 粘性定位sticky sticky是一个比其他属性要新一些的属性。这基本上是相对位置和固定位置之间的混合，其允许定位的元件像它被相对定位一样动作，直到其滚动到某一阈值点（例如，从浏览器窗口顶部10像素）之后它变得固定。 粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。 必须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;dl&gt; &lt;dt&gt;A&lt;/dt&gt; &lt;dd&gt;Andrew W.K.&lt;/dd&gt; &lt;dd&gt;Apparat&lt;/dd&gt; &lt;dd&gt;Arcade Fire&lt;/dd&gt; &lt;dd&gt;At The Drive-In&lt;/dd&gt; &lt;dd&gt;Aziz Ansari&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;C&lt;/dt&gt; &lt;dd&gt;Chromeo&lt;/dd&gt; &lt;dd&gt;Common&lt;/dd&gt; &lt;dd&gt;Converge&lt;/dd&gt; &lt;dd&gt;Crystal Castles&lt;/dd&gt; &lt;dd&gt;Cursive&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;E&lt;/dt&gt; &lt;dd&gt;Explosions In The Sky&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;T&lt;/dt&gt; &lt;dd&gt;Ted Leo &amp; The Pharmacists&lt;/dd&gt; &lt;dd&gt;T-Pain&lt;/dd&gt; &lt;dd&gt;Thrice&lt;/dd&gt; &lt;dd&gt;TV On The Radio&lt;/dd&gt; &lt;dd&gt;Two Gallants&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031* &#123; box-sizing: border-box;&#125;dl &#123; margin: 0; padding: 24px 0 0 0;&#125;dt &#123; background: #B8C1C8; border-bottom: 1px solid #989EA4; border-top: 1px solid #717D85; color: #FFF; font: bold 18px/21px Helvetica, Arial, sans-serif; margin: 0; padding: 2px 0 0 12px; position: sticky; top: -1px;&#125;dd &#123; font: bold 20px/45px Helvetica, Arial, sans-serif; margin: 0; padding: 0 0 0 12px; white-space: nowrap;&#125;dd + dd &#123; border-top: 1px solid #CCC&#125; （完整例子） 另一个例子： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt; &lt;div class=\"con\"&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题一&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题二&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题三&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题四&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题五&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;div class=\"samecon\"&gt; &lt;h2&gt;标题五六&lt;/h2&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;p&gt;这是一段文本&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 1234567.samecon h2&#123; /* position: -webkit-sticky; */ position: sticky; top: 0; background:#ccc; padding:10px 0;&#125; 如果没有div将h2与p元素框起来则被滚动过去的标题并不会消失。 position实例MDN position实例练习 补充：HTML &lt;section&gt;元素 &lt;section&gt;元素表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。 例如，导航菜单应该包含在&lt;nav&gt;元素中，但搜索结果列表和地图显示及其控件没有特定元素，可以放在&lt;section&gt;里。 MDN 关于&lt;section&gt;元素 注意： 如果元素的内容作为一个独立的有意义的集合，即元素内容可以分为几个部分的话，应该使用&lt;article&gt;而不是&lt;section&gt;。 不要把 &lt;section&gt; 元素作为一个普通的容器来使用，这本应该是&lt;div&gt;的用法（特别是当片段（the sectioning ）仅仅是为了美化样式的时候）。 一般来说，在文档大纲中应该出现不少于一个 &lt;section&gt;。 补充：HTML &lt;article&gt;元素 &lt;article&gt;元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构。如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 例如: 阅读器在博客上滚动时一个接一个地显示每篇文章的文本，每个帖子将包含在&lt;article&gt;元素中，可能包含一个或多个&lt;section&gt;。 每个&lt;article&gt;通常包括标题（&lt;h1&gt; - &lt;h6&gt;元素）作为&lt;article&gt;元素的子元素。 当&lt;article&gt;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&lt;article&gt;元素可嵌套在代表博客文章的&lt;article&gt;元素中。 &lt;article&gt;元素的作者信息可通过&lt;address&gt;元素提供，但是不适用于嵌套的&lt;article&gt;元素。 &lt;article&gt;元素的发布日期和时间可通过&lt;time&gt;元素的pubdate属性表示,但请注意&lt;time&gt;的pubdate 属性不再是W3C HTML5标准。 MDN 关于&lt;article&gt;元素 例子1与例子2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style type=\"text/css\"&gt; html &#123; font-family: sans-serif; /* Sans-serif是专指西文中没有衬线的字体，与汉字字体中的黑体相对应 */ &#125; * &#123; box-sizing: border-box; /* 使用 box-sizing 模型 */ &#125; body &#123; margin: 0; /* 去掉 &lt;body&gt; 默认外边距 */ &#125; .info-box &#123; width: 452px;/* 要给ul列表的框border留出2px的宽度，否则位置不够会换行 */ height: 400px; position: fixed; top: 0; &#125; .info-box ul &#123; /* 从无序列表中移除默认的padding-left和margin-top值 */ border: 1px solid #b60000; height: 50px; margin: 0; padding: 0; &#125; .info-box li &#123; float: left; /* 列表项都要左浮动确保三个li元素能在一行合起来 */ list-style-type: none; /* 去除项目符号 */ width: 150px; /* info-box宽度为450px，三个li元素平铺info-box */ &#125; .info-box li a &#123; display: inline-block; /* 使链接在一行显示并保持样式可设置 */ text-decoration: none; /* 去除链接下划线 */ width: 100%; /* 可点击宽度 */ line-height: 3; background-color: white; color: #a60000; font-weight: 800; text-align: center; &#125; .info-box li a:focus, .info-box li a:hover &#123; /* 获得焦点/鼠标悬浮使红底白字 */ background-color: #a60000; color: white; &#125; .info-box li a.active &#123; /* 使用JavaScript来设置，当一个标签被点击时（当某个选项卡的类（ class ）出现 active 时） */ background-color: #a60000; color: white; &#125; .info-box .panels &#123; height: 352px; position: relative; clear: both; &#125; .info-box article &#123; position: absolute; /* 子绝父相：子元素根据父元素进行定位 */ top: 0; left: 0; height: 352px; padding: 10px; color: white; background-color: #a60000; &#125; .info-box .active-panel &#123; /* 使段落位于最上方 */ z-index: 1; &#125; .fake-content &#123; background-color: #a60000; color: white; padding: 10px; height: 2000px; margin-left: 470px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;section class=\"info-box\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\" class=\"active\"&gt;Tab 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Tab 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;Tab 3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class=\"panels\"&gt; &lt;article class=\"active-panel\"&gt; &lt;h2&gt;The first tab&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque turpis nibh, porttitor nec venenatis eu, pulvinar in augue. Vestibulum et orci scelerisque, vulputate tellus quis, lobortis dui. Vivamus varius libero at ipsum mattis efficitur ut nec nisl. Nullam eget tincidunt metus. Donec ultrices, urna maximus consequat aliquet, dui neque eleifend lorem, a auctor libero turpis at sem. Aliquam ut porttitor urna. Nulla facilisi.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;The second tab&lt;/h2&gt; &lt;p&gt;This tab hasn't got any Lorem Ipsum in it. But the content isn't very exciting all the same.&lt;/p&gt; &lt;/article&gt; &lt;article&gt; &lt;h2&gt;The third tab&lt;/h2&gt; &lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque turpis nibh, porttitor nec venenatis eu, pulvinar in augue. And now an ordered list: how exciting!&lt;/p&gt; &lt;ol&gt; &lt;li&gt;dui neque eleifend lorem, a auctor libero turpis at sem.&lt;/li&gt; &lt;li&gt;Aliquam ut porttitor urna.&lt;/li&gt; &lt;li&gt;Nulla facilisi&lt;/li&gt; &lt;/ol&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt; &lt;section class=\"fake-content\"&gt; &lt;h1&gt;Fake content&lt;/h1&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;p&gt;This is fake content. Your main web page contents would probably go here.&lt;/p&gt; &lt;/section&gt; &lt;script type=\"text/javascript\"&gt; /* 首先我们保存所有的选项卡和所有的面板引用到两个变量中，名为 tabs 和 panels，这样此后我们可以容易地为它们做事。 */ var tabs = document.querySelectorAll('.info-box li a'); var panels = document.querySelectorAll('.info-box article'); /* 遍历所有的选项卡(a标签)，并且在每一个上运行叫做setTabHandler() 的函数，此函数建立当每个选项卡被点击时应该发生的功能。 */ for (i = 0; i &lt; tabs.length; i++) &#123; /* 函数被传递选项卡(a标签)tab和一个索引数i，指明选项卡在tabs 数组中的位置 */ var tab = tabs[i]; setTabHandler(tab, i); &#125; function setTabHandler(tab, tabPos) &#123; /* 创建了一个 onclick 事件来处理点击 */ tab.onclick = function () &#123; /* 用一个 for 循环清除所有标签当前存在的类 */ for (i = 0; i &lt; tabs.length; i++) &#123; /* 实际上清除的是a标签的active类（红底白字） */ if (tabs[i].getAttribute('class')) &#123; tabs[i].removeAttribute('class'); &#125; &#125; /* 在当前a标签上创建一个 active 类以便从相关联的元素中继承CSS的一些属性（红底白字） */ tab.setAttribute('class', 'active'); /* 用一个 for 循环清除所有面板当前存在的类。 */ for (i = 0; i &lt; panels.length; i++) &#123; if (panels[i].getAttribute('class')) &#123; panels[i].removeAttribute('class'); &#125; &#125; /* 当标签被点击的时候在和标签相对应的面板上创建了一个 active-panel 类以便从相关联的元素中继承了CSS的一些属性（使其 z-index 属性被设置为1，让它能位于所有的面板的上面）。 */ panels[tabPos].setAttribute('class', 'active-panel'); &#125; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 例子1、例子2效果 例子3 复习&lt;label&gt;、&lt;aside&gt;标签的使用方法。 复习： margin与padding属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang=\"en-us\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Hidden info panel&lt;/title&gt; &lt;style&gt; /* || Checkbox hack to control information box display */ label[for=\"toggle\"] &#123; font-size: 3rem;/* 设置更大的 font-size 使图标更大更美观。 */ position: absolute;/* 设置 position 为 absolute，使用 top 和 right 属性让他能合适的位于右上角。 */ top: 4px; right: 5px; z-index: 1;/* 设置其 z-index 为1——因此当信息面板被赋予样式和显示的时候，不会覆盖我们的图标；相反图标依然会位于最上层能够再次被按下来隐藏信息平板。 */ cursor: pointer;/* 使用 cursor 属性来改变鼠标的指针，当鼠标悬浮在图标上面的时候变成一个手形指针（就像你看到的当悬浮在链接上一样），作为一个额外的可视化线索告诉用户这个图标可以做一些有趣的事情。 */ &#125; input[type=\"checkbox\"] &#123;/* 在实际的 &lt;input&gt; 元素的checkbox 上设置position 属性为 absolute，并从屏幕上方隐藏掉它，我们并不希望在我们的用户界面里看到它。 */ position: absolute; top: -100px; &#125; /* information box styling */ aside &#123; background-color: #a60000; color: white; /* 填充整个浏览器窗口的视口 */ width: 340px; height: 98%; padding: 10px 1%;/*padding2个属性值：上下 左右 */ /* 设置fixed，即使页面的内容在滚动，他也总是显示在同一个位置。设置 top 属性，使其粘在视口顶部，设置 right 属性使其默认情况下位于屏幕的右边隐藏大部分。 */ position: fixed; top: 0; right: -370px; /* Transitions是一个有意思的特性，允许你在状态改变的时候平滑的过渡，而不是粗暴的“开”或“关”。在这个例子中我们尝试在checkbox被选中时让面板平滑的滚动。 */ transition: 0.6s all; &#125; /* Second part of the checkbox hack — the checked state */ /* 选择与 &lt;input&gt; 元素邻接的 &lt;aside&gt; 元素，但是仅仅在它被选择时（请注意使用 :checked 伪类来实现此目的）*/ input[type=checkbox]:checked+aside &#123; right: 0px;/* 将 &lt;aside&gt; 的 right 属性设置为0px，会造成面板再次出现在屏幕上（由于过渡属性会平滑的出现） */ &#125; /* 再一次点击这个标签会取消选中checkbox，面板将会跟着再一次消失。 */ &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- label通过for属性绑定id到了&lt;input&gt;标签的checkbox元素上，这样点击问号相当于点击checkbox --&gt; &lt;label for=\"toggle\"&gt;❔&lt;/label&gt; &lt;input type=\"checkbox\" id=\"toggle\"&gt; &lt;aside&gt; &lt;h2&gt;Information&lt;/h2&gt; &lt;p&gt;Some very important information about your app:&lt;/p&gt; &lt;ol&gt; &lt;li&gt;It has a really cool slide-out information box.&lt;/li&gt; &lt;li&gt;This information box uses a combination of fixed positioning and a CSS transition for the smooth sliding.&lt;/li&gt; &lt;li&gt;It also uses a cool technique called the &lt;a href=\"https://css-tricks.com/the-checkbox-hack/\"&gt;checkbox hack&lt;/a&gt;.&lt;/li&gt; &lt;li&gt;This allows you to create a nice \"toggle on/toggle off\" UI effect without using any JavaScript, which will work in IE9 and above (the smooth transition will work in IE10 and above.)&lt;/li&gt; &lt;/ol&gt; &lt;/aside&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML5新增（section和article以及aside标签）","slug":"HTML5新增（section和article以及aside标签）","date":"2019-11-19T08:34:59.000Z","updated":"2020-07-04T06:20:39.608Z","comments":true,"path":"2019/11/19/HTML5新增（section和article以及aside标签）/","link":"","permalink":"http://yoursite.com/2019/11/19/HTML5新增（section和article以及aside标签）/","excerpt":"HTML5HTML5 HTML &lt;section&gt;元素 &lt;section&gt;元素表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。","text":"HTML5HTML5 HTML &lt;section&gt;元素 &lt;section&gt;元素表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般来说会有包含一个标题。 例如，导航菜单应该包含在&lt;nav&gt;元素中，但搜索结果列表和地图显示及其控件没有特定元素，可以放在&lt;section&gt;里。 MDN 关于&lt;section&gt;元素 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的例子1中有所使用。 注意： 如果元素的内容作为一个独立的有意义的集合，即元素内容可以分为几个部分的话，应该使用&lt;article&gt;而不是&lt;section&gt;。 不要把 &lt;section&gt; 元素作为一个普通的容器来使用，这本应该是&lt;div&gt;的用法（特别是当片段（the sectioning ）仅仅是为了美化样式的时候）。 一般来说，在文档大纲中应该出现不少于一个 &lt;section&gt;。 HTML &lt;article&gt;元素 &lt;article&gt;元素表示文档、页面、应用或网站中的独立结构，其意在成为可独立分配的或可复用的结构。如在发布中，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件，或者其他独立的内容项目。 例如: 阅读器在博客上滚动时一个接一个地显示每篇文章的文本，每个帖子将包含在&lt;article&gt;元素中，可能包含一个或多个&lt;section&gt;。 每个&lt;article&gt;通常包括标题（&lt;h1&gt; - &lt;h6&gt;元素）作为&lt;article&gt;元素的子元素。 当&lt;article&gt;元素嵌套使用时，则该元素代表与外层元素有关的文章。例如，代表博客评论的&lt;article&gt;元素可嵌套在代表博客文章的&lt;article&gt;元素中。 &lt;article&gt;元素的作者信息可通过&lt;address&gt;元素提供，但是不适用于嵌套的&lt;article&gt;元素。 &lt;article&gt;元素的发布日期和时间可通过&lt;time&gt;元素的pubdate属性表示,但请注意&lt;time&gt;的pubdate 属性不再是W3C HTML5标准。 MDN 关于&lt;article&gt;元素 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的例子1中有所使用。 HTML &lt;aside&gt; 元素 HTML &lt;aside&gt; 元素表示一个和其余页面内容几乎无关的部分，被认为是独立于该内容的一部分并且可以被单独的拆分出来而不会使整体受影响。其通常表现为侧边栏或者标注框（call-out boxes）。 不要使用&lt;aside&gt; 元素去尾随括号内的文本 ，因为这种文本被认为是主要流内容的一部分。 MDN 关于&lt;aside&gt; 元素 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的例子3中有所使用。","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"JS闭包和面试题","slug":"JS闭包","date":"2019-11-17T03:27:14.000Z","updated":"2019-11-17T03:29:22.065Z","comments":true,"path":"2019/11/17/JS闭包/","link":"","permalink":"http://yoursite.com/2019/11/17/JS闭包/","excerpt":"MDN中关于闭包的描述","text":"MDN中关于闭包的描述 关于闭包 MDN 面试题 这是一个闭包，闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。 这里的局部变量i，对f1()来说是全局变量，对f2()来说也是全局变量，但是f1()的i跟f2()的i又是相互独立相互不可见的，f1()每执行一次，f1()的i就加一，f2（）每次执行一次，f2()的i就加油，但是相互之间不影响，因此结果是010。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6扩展 数组扩展","slug":"ES6扩展 数组扩展","date":"2019-11-15T03:36:21.000Z","updated":"2019-11-15T07:25:39.042Z","comments":true,"path":"2019/11/15/ES6扩展 数组扩展/","link":"","permalink":"http://yoursite.com/2019/11/15/ES6扩展 数组扩展/","excerpt":"结合扩展运算符(...)复习：数组合并、复制数组 在解构赋值中讲解了使用扩展运算符将数组合并以及复制数组","text":"结合扩展运算符(...)复习：数组合并、复制数组 在解构赋值中讲解了使用扩展运算符将数组合并以及复制数组 123456789101112131415const arr1 = [1, 2, 3, 4];const arr2 = [4, 3, 2, 1];const arr3 = [\"nihao\", 2.2, false];//数组合并const cArr1 = [1, 2, 3, ...arr1];console.log(cArr1);//[1, 2, 3, 1, 2, 3, 4]const cArr2 = [...arr1, ...arr2, ...arr3];console.log(cArr2);// [1, 2, 3, 4, 4, 3, 2, 1, \"nihao\", 2.2, false]//复制数组arr3const cArr3 = [...arr3];console.log(cArr3);//[\"nihao\", 2.2, false]const [...cArr4] = arr3;console.log(cArr4);//[\"nihao\", 2.2, false] 复习：apply() 语法：func.apply(thisArg, [argsArray]) 可以通过 apply() 方法调用属于另一个对象的方法。 但不仅限于此，当设置第一个参数为null时可以在某些本来需要写成遍历数组变量的任务中使用内建的函数,也就是说此时apply()的作用不是调用属于另一个对象的方法，而是使参数数组中的每一个元素都去执行func函数。【如：下方“读取并展开数组用作多个参数”的“实用例子”中】 参数 描述 thisArg 可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时this会自动替换为指向全局对象，原始值会被包装。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 例子：在“读取并展开数组用作多个参数”的“实用例子”中。 读取并展开数组用作多个参数 另一个作用：在调用函数时把一个数组展开来作为这个函数的参数。 简单例子： 123456function foo(a, b, c) &#123; console.log(a);//1 console.log(b);//3 console.log(c);//2&#125;foo(...[1, 3, 2]); 实用例子：在实际运用中，我们经常将用户信息按照一定的顺序放在数组中而不是对象，这可以节省流量。在这个例子中，我们可以使用扩展运算符简便的读取数组中的每一个元素并作用与对应的参数，避免了重复使用[]去读取各个数组元素）。 补充：需要使用数组的join()将数组hobby转换为字符串。 123456const user = [\"小明\", 15, [\"吃饭\", \"睡觉\", \"打游戏\"], \"我没有女朋友\"];function say(name, age, hobby, desc) &#123; console.log(`我叫$&#123;name&#125;,我今年$&#123;age&#125;岁，我平时喜欢$&#123;hobby.join(\"和\")&#125;，$&#123;desc&#125;。`);&#125;say(user[0],user[1],user[2],user[3]);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say(...user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。 还可以使用apply()(不推荐)：12345678const user = [\"小明\", 15, [\"吃饭\", \"睡觉\", \"打游戏\"], \"我没有女朋友\"];function say(name, age, hobby, desc) &#123; console.log(`我叫$&#123;name&#125;,我今年$&#123;age&#125;岁，我平时喜欢$&#123;hobby.join(\"和\")&#125;，$&#123;desc&#125;。`);&#125;say.apply(null,user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say.apply(\"\",user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say.apply(0,user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。say.apply(1,user);//我叫小明,我今年15岁，我平时喜欢吃饭和睡觉和打游戏，我没有女朋友。 【他会将数组元素将作为单独的参数传给 say 函数】进行数组变对应参数的调用，但是使用扩展运算符语义更加清晰，而且参数如果传入过多会有超出JavaScript引擎的参数长度限制的风险。故不推荐使用apply()。 补充：生成器函数 语法：function* name([param[, param[, ... param]]]) { statements } 参数： name：函数名param：要传递给函数的一个参数的名称，一个函数最多可以有255个参数。statements：普通JS语句。 描述：生成器函数在执行时能暂停，后面又能从暂停处继续执行。 调用一个生成器函数并不会马上执行它里面的语句，而是返回一个这个生成器的 迭代器 （iterator ）对象。当这个迭代器的 next() 方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现yield的位置为止，yield 后紧跟迭代器要返回的值。或者如果用的是 yield*（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。【也就是说,首次执行生成器函数需要调用它的next()，当然也可以使用扩展运算符进行迭代调用，例子在下方“扩展运算符与生成器函数”中】 通过yield关键字可暂停函数的执行 通过next关键字可继续函数的执行 与promise类似 扩展运算符与生成器函数1234567891011121314function* g() &#123; console.log(1); yield \"hi~\"; console.log(2); yield \"imooc~\";&#125;//使用扩展运算符相当于迭代（循环）执行生成器函数【在这也就是执行了两次函数g()】// const arr = [...g()];//分别输出1,2//使用扩展运算符一行代码的效果类似于下面的代码const gg = g();gg.next();//1setTimeout(function () &#123; gg.next();//2&#125;, 1000); 结合去重函数Set() Set()参数可放入数组，返回值是字符串类型，想要让他完成去重后返回数组则可使用扩展运算符：123let set = new Set([1, 2, 3, 3]);console.log(set);//&#123;1, 2, 3&#125;console.log([...set]);//[1, 2, 3] 新的方法复习：构造函数法注意事项与数组字面量法创建数组 数组字面量可用于创建数组。（类似的，对象字面量用于创建对象） 创建数组有两种方法：构造函数法、数组字面量法。 第一：构造函数法 1var arr=new Array(); 注意:使用Array()创建数组对象时，如果只有一个数字参数则默认是用于设置数组长度： 12345let arr1 = new Array(\"10\");console.log(arr1);//[\"10\"]let arr2 = new Array(10);console.log(arr2);// [empty × 10] 第二：数组字面量法 1var arr=[\"zhu\",\"zhen\",\"wei\"]; 在调用数组的内建方法时可以使用Array.prototype.内建方法名,也直接使用数组字面量[]，写作[].内建方法名即可少写Array.prototype。（具体例子在下方“Array.from()将类数组转换为数组”例子中） Array.from()将类数组转换为数组 Array.from()将类数组对象或者Iterable对象转换为数组对象。 比如：arguments函数、document.querySelectorAll、 document.getElementByTagName、 document.getElementsByName、 document.getElementsByClassName返回的都是类数组对象。 注意：类数组对象的属性名必须是数值型或者字符串型的数字。类数组对象的length属性值会直接影响数组长度。12345678910111213141516171819const obj = &#123; 0: 1, 1: \"22\", 2: false, length: 2,&#125;;console.log(Array.from(obj));// [1, \"22\"]//Array.from()还可以接收一个回调函数作为第二个参数对类数组对象进行一些处理//在这里箭头函数item将传入的参数item都*2并返回，\"22\"隐式转换为22后也乘以2倍console.log(Array.from(obj, item =&gt; item * 2));// [2, 44]//后面三种方法虽然也可以将类数组转换为数组，但无法使用回调函数对数组对象进行处理。//方法1：使用call()让对象obj调用Array的slice方法以此转换成数组对象console.log(Array.prototype.slice.call(obj));// [1, \"22\"]//方法2：直接使用数组字面量`[]`即可少写`Array.prototype`console.log([].slice.call(obj));// [1, \"22\"]//方法3：添加遍历器接口(`Symbol.iterator`)后使用扩展运算符【具体例子在下面“使用扩展运算符将类数组转换为数组”中】 补充：使用扩展运算符将类数组转换为数组 扩展运算符...背后调用的是遍历器接口(Symbol.iterator)，所以任何有interator接口的对象都可以用...转化为真正的数组。 MDN 关于遍历器接口(Symbol.iterator) 而类数组对象是有interator接口的，所以我们也可以使用扩展运算符将类数组转换为数组。 注意：扩展运算符背后调用的是遍历器接口(Symbol.iterator)，如果一个对象没有部署这个接口，就无法转换。所以如果这个类数组对象是我们自己写的就一定要记得为它部署 Iterator 接口，否则无法使用扩展运算符将它转换为数组。（如下所示） 1234567const obj = &#123; 0: 1, 1: \"22\", 2: false, length: 2&#125;;console.log([...obj]); 在这个例子中，我们没有部署Symbol.iterator接口，就无法转换为数组并报错：TypeError: object is not iterable (cannot read property Symbol(Symbol.iterator)) 正确写法：添加遍历器接口(Symbol.iterator)： 12345678const obj = &#123; 0: 1, 1: \"22\", 2: false, length: 2, [Symbol.iterator]: Array.prototype[Symbol.iterator]//添加遍历器接口&#125;;console.log([...obj]); 注意：不能在对象外面使用obj.obj[Symbol.iterator]= Array.prototype[Symbol.iterator];去添加遍历器接口。只有类数组对象才可以直接使用 Array 的 Iterator，普通对象部署数组的Symbol.iterator方法，并无效果。普通对象需要手动添加 Iterator 方法，添加 Iterator 接口的一种比较常用的方法,是使用Generator函数。普通的对象就算没有实现 Iterator 接口，不能使用 for … of 的情况下，仍然可以使用 for … in 来遍历 key。 Array.of()将参数合成数组 Array.of()将传入的参数合成数组。 语法：Array.of(参数1,参数2,参数3)1console.log(Array.of(1, 2, \"123\", 2.2, false));//[1, 2, \"123\", 2.2, false] Array#fill()固定值替换数组的元素 注意：fill不是静态方法，不能通过Array.fill来调用。 fill()方法用于将一个固定值替换数组的元素。并且可以指定填充的范围（起始值与结束值的数组下标）。 语法：array.fill(value, start, end) 参数 描述 value 必需。填充的值。 start 可选。开始填充位置的数组下标。 end 可选。停止填充位置的数组下标 (默认为 array.length)【注意：不包括end，也就是说array.fill(1, 0, 3)替换的是数组[0]、[1]、[2]】 注意：数组原有参数会被填充的值覆盖。 例子： 12let fruits = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];fruits.fill(\"lalala\", 2, 4); 输出结果： 1Banana,Orange,lalala,lalala Array.includes()判断是否含有某元素 与字符串类似，数组也有includes()，用于检测数组中是否包含某元素，是则返回true，否则返回false。 可以代替以前的indexOf()来判断元素是否存在，但indexOf()可以找到数组下标，这个不可替代。123var arr = [1, 2, 3, 4];console.log(arr.includes(1));//trueconsole.log(arr.includes(55));//false keys()和values()还有entries() 与对象类似的，数组也有keys()和values()还有entries()，不过它们是作用在实例上的，即arr.keys()和arr.values()还有arr.entries()。而对象是作用在Object上Object.keys(obj实例) arr.keys()拿到数组下标 补充：拥有迭代（遍历）器接口iterator的对象都可以使用for-of语句。 可以使用keys()拿到数组每一项元素的数组下标。12345const arr = [1, 2, 3, 4.4, \"lalal\", false];console.log(arr.keys());//Array Iterator &#123;&#125;,说明arr.keys()含有迭代器接口Iterator ，故可以使用`for-of`for (let i of arr.keys()) &#123; console.log(i);&#125; arr.values()拿到数组元素使用values()可以按顺序拿到数组中的每一项。 12345const arr = [1, 2, 3, 4.4, \"lalal\", false];for (let v of arr.values()) &#123; console.log(v);&#125; arr.entries()同时拿到数组下标和元素 使用entries()可同时拿到数组下标和元素。 返回值：数组，[数组下标，对应的数组元素] 例子：12345const arr = [1, 2, 3, 4.4, \"lalal\", false];for (let e of arr.entries()) &#123; console.log(e);&#125; 上面例子拿到的e都是数组形式的，所以我们可以对取出来的e进行数组的解构赋值，同时拿到数组下标i和数组元素v：12345const arr = [1, 2, 3, 4.4, \"lalal\", false];for (let [i,v] of arr.entries()) &#123;//对取出来的e进行数组的解构赋值，e = [i,v] console.log(i,v);&#125; find()返回数组中满足回调函数的第一个元素 find()方法会按顺序对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。 语法：arr.find(callback[, thisArg]) 参数 描述 callback 在数组每一项上执行的测试函数(回调函数)，接收 3 个参数：element:当前遍历到的元素。index:可选,当前遍历到的索引。array:可选,数组本身。 thisArg 可选,执行回调时用作this的对象。 返回值：数组中满足提供的测试函数(回调函数)的第一个元素的值。否则返回 undefined。 例子(使用find()找到双数的数组元素)：1234567const res = [1, 7, 6, 3].find(function (value) &#123; console.log(\"value\", value); return value % 2 === 0;//通过取余找到双数&#125;);console.log(res);//6 例子分析：可以从运行结果上看到，1和7循环以后都不符合要求，循环到6时符合要求，输出6。 使用箭头函数简化例子：12const res = [1, 7, 6, 3].find(value =&gt; value % 2 === 0);//通过取余找到双数console.log(res);//6 findIndex()返回数组中找到的元素的下标 根据条件（回调函数）按顺序遍历数组,当回调返回true时就返回当前遍历到的下标,语法、参数都与find()非常相似。 语法：arr.findIndex(callback[, thisArg]) 参数 描述 callback 在数组每一项上执行的测试函数(回调函数)，接收 3 个参数：element:当前遍历到的元素。index:可选,当前遍历到的索引。array:可选,数组本身。 thisArg 可选,执行回调时用作this的对象。 返回值：数组中满足提供的测试函数的第一个元素的索引(下标)。否则返回-1。 例子（找到双数的数组元素的下标）：12const res = [1, 7, 6, 3].findIndex(value =&gt; value % 2 === 0);//通过取余找到双数console.log(res);//2 findIndex()与indexOf()的区别 findIndex()与indexOf()都是返回查找元素的数组下标的，但是findIndex()多了一个回调函数（测试函数），所以可以做一些indexOf()做不到的事情。 indexOf()无法查询数组中是否含有NaN: 但是findIndex()可以通过回调函数里调用Number的isNaN()来判断数组里是否含有NaN：12const res = [1, 7, 6, 3, NaN].findIndex(value =&gt; Number.isNaN(value));console.log(res);//4,也就是说找到了NaN的下标为4","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 对象扩展","slug":"ES6扩展 对象扩展","date":"2019-11-13T09:42:27.000Z","updated":"2019-11-15T07:26:05.144Z","comments":true,"path":"2019/11/13/ES6扩展 对象扩展/","link":"","permalink":"http://yoursite.com/2019/11/13/ES6扩展 对象扩展/","excerpt":"简洁表示法（简写对象属性、方法） 简写对象属性：对象的属性名与变量名同名后可从属性名:变量名简写为属性名。","text":"简洁表示法（简写对象属性、方法） 简写对象属性：对象的属性名与变量名同名后可从属性名:变量名简写为属性名。 简写对象方法：对象的方法可以直接省略冒号和function,从方法名:function(){函数体}简写为方法名(){函数体} 例子：1234567891011121314151617const getUserInfo = (id = 1) =&gt; &#123; //AJAX... const name = \"xiaoming\"; const age = 10; return &#123; name,//相当于`name:name`简写以后属性名name会自动去找到和它同名的变量，把它的值拿过来当值 age,//相当于`age:age` say() &#123;//相当于say:function()&#123;&#125;,简写可以省略冒号与function console.log(this.name + this.age); &#125; &#125;;&#125;;const xiaoming = getUserInfo();console.log(xiaoming);//&#123;name: \"xiaoming\", age: 10, say: ƒ&#125;console.log(xiaoming.say());//xiaoming10 属性名表达式 定义属性时可以用一个简单的表达式。 语法：先定义一个常量，然后[包含常量名的简单表达式]:属性值 123456const key=\"age\";//先定义一个常量keyconst xiaoming =&#123; name:\"xiaoming\", [`now$&#123;key&#125;`]:14//注意：模板字符串是反引号&#125;;console.log(xiaoming);//&#123;name: \"xiaoming\", nowage: 14&#125; 复习：扩展运算符复制对象 使用扩展运算符复制对象是浅拷贝的。 也就是说当你复制的对象obj1中包含一个对象c时，你实际上复制的是c的引用，当你修改复制所得到的对象copyObj1中的对象c的aa属性时，被复制的obj1对象中的对象c的属性aa也会被改变。 而修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的： 123456789101112131415161718const obj1=&#123; a:1, b:2, c:&#123; aa:3, bb:4 &#125;&#125;;const copyObj1=&#123;...obj1&#125;;console.log(copyObj1.c.aa);//3copyObj1.c.aa=999;console.log(copyObj1.c.aa);//999console.log(obj1.c.aa);//999,可以发现obj1的c中的aa也被修改了console.log(copyObj1.b);//2copyObj1.b=222;console.log(copyObj1.b);//222console.log(obj1.b);//2,可以看到修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的 复习：扩展运算符合并对象 如果合并的两个对象中都含有相同属性名的属性，则属性顺序还是按照前面对象的，但后面对象的属性值覆盖前面的。 不管是使用扩展运算符复制对象还是合并对象，他们都是浅拷贝的。 123456789101112131415161718192021const obj1 = &#123; a: 1, b: 2, c: &#123; aa: 3, bb: 4 &#125;, s:8&#125;;const obj2=&#123; a:555, d:33&#125;;const newObj=&#123; ...obj1, ...obj2&#125;;console.log(newObj);//&#123;a: 555, b: 2, c: &#123;…&#125;, s: 8, d: 33&#125;newObj.c.aa=999;console.log(obj1.c.aa);//999，证明合并对象也是浅拷贝的 部分新方法Object.is()判断全等(类似===) 语法：传入两个参数到Object.is() 返回值：全等则返回true，否则返回false。 与===的区别体现在+0与-0、NaN与NaN的判断上： 12345678console.log(Object.is(+0, -0));//falseconsole.log(+0 === -0);//trueconsole.log(Object.is(NaN, NaN));//trueconsole.log(NaN === NaN);//falseconsole.log(Object.is(true, false));//falseconsole.log(true === false);//false Object.assign()合并对象(类似...扩展运算符) assign:分配/赋值. 语法：Object.assign(对象1,对象2,对象3); Object.assign()类似...(扩展运算符),可用于合并对象。 Object.assign()与扩展运算符在合并对象时都是浅拷贝的。当合并的多个对象拥有相同属性时后面的属性值覆盖前面的。 12345678910111213141516//可以看到b的最终属性值是2，后面的覆盖前面的const allObj = Object.assign(&#123; a: 1 &#125;, &#123; b: 3 &#125;, &#123; b: 2 &#125;, &#123; c: 3, d: 4 &#125;);console.log(allObj);//&#123;a: 1, b: 2, c: 3, d: const obj = &#123; h: 1, i: &#123; j: 222, a: 66 &#125;&#125;const newObj = Object.assign(allObj, obj);console.log(newObj);//&#123;a: 1, b: 2, c: 3, d: 4, h: 1, i:&#123;j: 222, a: 66&#125;&#125;//浅拷贝newObj.i.j=999;console.log(obj.i.j);//999 Object.keys()和Object.values()和Object.entries() 注意：这三个方法都是返回对象自身的对应元素的，不包含对象内的对象的元素。 参数：对象。 Object.keys()返回由对象自身的键（属性名）组成的数组。（注意：数组每一项都是放在引号内的【字符串形式】） Object.values()返回由对象自身的值（属性值）组成的数组。 Object.entries()返回由对象自身的键值（属性名和属性值）组成的数组。 1234567891011const obj = &#123; a: 1, b: 2, c: &#123; j: 222, a: 66 &#125;&#125;console.log(Object.keys(obj));//[\"a\", \"b\", \"c\"]console.log(Object.values(obj)); //[1, 2, &#123;j: 222, a: 66&#125;]console.log(Object.entries(obj));//[[\"a\", 1], [\"b\", 2], [\"c\", &#123;j: 222, a: 66&#125;]] 补充：Object的hasOwnProperty()方法 语法：obj.hasOwnProperty(&quot;属性名&quot;) 参数：要检测的属性的 String 字符串形式表示的名称。 返回：布尔值，是对象自身属性则true，不是则false。 例子：下面“for-in遍历对象自身属性”的例子中。 补充：for-in判断对象自身属性(不推荐) 用 for-in 语句遍历对象属性时我们可以使用hasOwnProperty()方法判断属性来源。 关于for-in与hasOwnProperty()遍历对象自身属性的例子：12345678910111213const obj = &#123; a: 1, b: 2, c: &#123; j: 222, a: 66 &#125;&#125;for (let key in obj)&#123; if(obj.hasOwnProperty(key))&#123; console.log(key); &#125;&#125; Object.keys()结合for-of判断自身属性（推荐使用） 可使用Object.keys()代替上面例子中的hasOwnProperty()来判断是否为自身属性。 for-of语句遍历对象属性。 使用for-of语句与Object.keys()打印自身属性的例子： 1234567891011const obj = &#123; a: 1, b: 2, c: &#123; j: 222, a: 66 &#125;&#125;for (let key of Object.keys(obj)) &#123; console.log(key);&#125; 注意：for-of语句与Object.keys()搭配，for-in与hasOwnProperty()搭配。 for-in与Object.keys()与hasOwnProperty()区别 for-in遍历对象所有可枚举属性，包括原型链上的属性。 Object.keys()遍历对象所有可枚举属性，不包括原型链上的属性。(仅自身属性) 1234567const obj1 = &#123; a: 1&#125;;const obj = Object.create(obj1);//以obj1为原型创建对象objconsole.log(Object.keys(obj));//[],可以看到Object.keys()并未枚举原型上的属性obj.b = 22;console.log(Object.keys(obj));//[\"b\"] hasOwnProperty() 检查对象是否包含属性名，无法检查原型链上是否具有此属性名。结合for-in可遍历自身属性（同样不包含原型上的属性），但语句复杂且不是直接放入数组，故不推荐使用。 操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for-in循环，而用for-of与Object.keys()结合来代替。 for-in与for-of 无论是for-in还是for-of语句都是迭代一些东西。它们之间的主要区别在于它们的迭代方式。 for-in 语句以原始插入顺序迭代对象的可枚举属性。 for-of 语句遍历可迭代对象定义要迭代的数据。 for-in for-in 语句用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。 使用for-in会遍历数组所有的可枚举属性，包括原型。index索引为字符串型数字，不能直接进行几何运算。故更加适合用于遍历对象。（不是对象属性！） 因为迭代的顺序是依赖于执行环境的，所以数组遍历不一定按次序访问元素。因此当迭代访问顺序很重要的数组时，最好用整数索引去进行for循环（或者使用 Array.prototype.forEach() 或 for-of 循环）。 for-of【ES6引入】 for-of语句在可迭代对象（包括Array，Map，Set，String，TypedArray，arguments对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句。 for-of更加适合用于遍历对象属性。 for-in遍历的是数组的索引（即键名），而for-of遍历的是数组元素值，而不包括原型属性method和索引name。 __proto__属性读取对象原型 __proto__属性代表当前对象的原型。 很多浏览器不支持，只出现在ES6附录中没出现在正文。 调试的时候使用就好，不要使用在正式代码中。 例子：（下方“Object.setPrototypeOf()修改对象原型”的例子中） 比起__proto__属性更加推荐使用Object.getPrototypeOf()读取对象原型（下方详述）。 补充：Object.create()创建对象并指定原型 Object.create()用于创建一个对象时指定原型。 语法：const objName = Object.create(原型对象名); 例子：（下方“Object.setPrototypeOf()修改对象原型”的例子中） Object.setPrototypeOf()修改对象原型 语法：Object.setPrototypeOf(需要修改的对象名，新的原型名) Object.setPrototypeOf()性能底下，建议不要使用。 12345678910111213const obj1=&#123; a:1&#125;;const obj2=&#123; b:2&#125;const obj=Object.create(obj1);//以obj1为原型创建对象objconsole.log(obj.__proto__);//&#123;a: 1&#125;Object.setPrototypeOf(obj,obj2);//使用setPrototypeOf()将obj的原型改为obj2console.log(obj.__proto__);//&#123;b: 2&#125; 注意：console.log(obj);打印出的是{}。 Object.getPrototypeOf()读取对象原型 语法：Object.getPrototypeOf(对象名) 比起__proto__属性更加推荐使用Object.getPrototypeOf()读取对象原型。123456789const obj1 = &#123; a: 1&#125;;const obj = Object.create(obj1);//以obj1为原型创建对象objconsole.log(obj.__proto__);//&#123;a: 1&#125;console.log(Object.getPrototypeOf(obj));//&#123;a: 1&#125;console.log(obj.__proto__ === Object.getPrototypeOf(obj));//true super关键字(访问原型对象) 可以通过super关键字访问原型对象上的属性和方法。 注意：只有使用简洁表示法写函数才可以调用super关键字，换成箭头函数或者普通函数写法去调用super关键字会报错呢。123456789const obj=&#123;name:\"小明\"&#125;;const copyObj=&#123; say()&#123; console.log(`我的名字是$&#123;super.name&#125;`); &#125;&#125;//将对象copyObj的原型改为对象obj才可以在copyObj中通过supeobj的属性nameObject.setPrototypeOf(copyObj,obj);copyObj.say();//我的名字是小明","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 函数扩展 箭头函数","slug":"ES6扩展 函数扩展 箭头函数","date":"2019-11-12T13:05:20.000Z","updated":"2020-11-19T03:20:06.094Z","comments":true,"path":"2019/11/12/ES6扩展 函数扩展 箭头函数/","link":"","permalink":"http://yoursite.com/2019/11/12/ES6扩展 函数扩展 箭头函数/","excerpt":"默认参数 和解构赋值一样，ES6中也可以给函数一个默认参数，并且可以用简单的表达式来设定默认值。","text":"默认参数 和解构赋值一样，ES6中也可以给函数一个默认参数，并且可以用简单的表达式来设定默认值。 但要注意：用例子来解释，b的默认值表达式中不能出现b或者c，会报错（b、c未定义）。1234function add(a, b = 999 + a, c = 1) &#123; console.log(a, b, c);&#125;add(1);//1 1000 1 结合对象的解构赋值如果直接调用People（）函数，但什么对象都不传进去，此时则使用age的默认值38，name则undefined。如果调用People（）函数的同时将带有name属性值的对象传入则得到hhh 38： 12345function People(&#123; name, age = 38 &#125; = &#123;&#125;) &#123; console.log(name, age);&#125;People();//undefined 38,什么对象都不传People(&#123; name: \"hhh\" &#125;);//hhh 38，传入带有name属性值的对象 或者直接在对象的解构赋值等号右边设置和调用People（）函数的时候再传入name属性的效果也是一样的： 1234function People1(&#123; name, age = 38 &#125; = &#123;name:\"xiaohuang\"&#125;) &#123; console.log(name, age);&#125;People1();//xiaohuang 38 复习：arguments对象 arguments 是一个对应于传递给函数的参数的类数组对象。arguments对象是所有（非箭头）函数中都可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。 此对象包含传递给函数的每个参数，第一个参数在索引0处。[]语法可访问它的每一个元素: 123arguments[0]arguments[1]arguments[2] 参数也可以被设置： 1arguments[1] = 'new value'; arguments对象不是一个 Array实例 ，它类似于Array。 但除了length属性和索引元素之外没有任何Array属性（length属性确定传递参数的个数）。例如，它没有 pop 方法。 但是它可以被转换为一个真正的Array(下面“结合扩展运算符”中2个例子4种方法都可以将类数组转换为数组) MDN更多参考信息 结合扩展运算符...（剩余参数...） 剩余参数...是做聚合的，它会将那些没有对应形参的实参们聚合成一个数组。而扩展运算符...是做展开的，符号都是...,但含义不同。 其实在下面这个例子中...表示剩余参数而不是扩展运算符，sum函数通过将所有的剩余参数1,2,3,4,&quot;ddd&quot;传进args做一个聚合将他们组转换为数组： 1234function sum(...args)&#123;//将传进来的类数组匹配到的剩余参数都放到args中组成数组 console.log(args);//[1, 2, 3, 4, \"ddd\"]&#125;sum(1,2,3,4,\"ddd\");//传入一个类数组,通过剩余参数可以转换为数组 在[1,2,...[1,2,3]];中...就表示扩展运算符，意为将[1,2,3]展开来放入另一个数组中。 除了上面例子，我们还可以回顾一下使用扩展运算符将类数组转换为数组的三种不同方法： 1234567function sum() &#123; let args = Array.prototype.slice.call(arguments); // let args = [...arguments]; // let [...args] = arguments; console.log(args);//[1, 2, 3, 4, \"ddd\"]&#125;sum(1, 2, 3, 4, \"ddd\");//传入一个类数组,通过剩余参数可以转换为数组 注意：无论...表示剩余参数还是扩展运算符，当它作为参数时她都必须在最后一个: 12345function op(type, ...nums) &#123; console.log(type);//sum console.log(nums);//[1, 2, 3, 4, 5]&#125;op(\"sum\", 1, 2, 3, 4, 5); 补充：回调函数 回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 注意：调用回调函数时是不需要()的，直接使用函数名！ 下面reduce()方法的第一个参数就是回调函数。 回调函数与调用普通函数的区别 性能没有区别。 回调函数是作为参数传递的,操作更加灵活。比如，你定义了函数a，b，c,那么使用回调函数时不用修改 a 的代码就可以让 a 调用 c、d、e….当你调用普通函数的时候不修改代码只能在函数a内运行函数b，就失去了变量的灵活性。 补充：数组的reduce()方法 reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。即，对数组每个元素执行回调函数，返回值用于下一次计算参数 reduce()方法的参数由回调函数和一个初始值参数组成。 语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 语法理解： 1234reduce( function( 回调函数返回的值,数组当前元素,当前元素索引,调用reduce的数组 ) ,回调函数第一个参数的初始值); 返回值：返回计算结果(不改变原数组) 例子： 12345678const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// 15 实现加法的函数 通过上面的例子我们可以知道传进来的类数组会被转换为数组numbers，而数组拥有累加方法reduce() 先设置参数total的默认值为0，第一次会将1传入num中，相加以后返回1给total；第二次则将2传入num中，相加以后返回3给total，以此类推得到最终total123456function sum(...numbers) &#123; return numbers.reduce(function (a, b) &#123; return a + b; &#125;, 0);&#125;console.log(sum(1,2,3,4));//10 相当于：（注意函数add的调用没有()） 1234567function add(total, num) &#123; return total + num; &#125;function sum(...numbers) &#123; return numbers.reduce(add, 0);&#125;console.log(sum(1, 2, 3, 4));//10 箭头函数=&gt;使用箭头函数可以省略function。 复习：数组的pop()用于删除最后一个元素，返回值为被删除的元素。 多个参数需要用(),多行代码时需要用{}12345const add1 = (a, b) =&gt; &#123; a += 1; return a + b;&#125;console.log(add1(2,4));//7 相当于： 12345const add1 = function (a, b)&#123; a += 1; return a + b;&#125;console.log(add1(2,4));//7 单行代码可省略{}和return,直接表示为返回值12const add2 = (a, b) =&gt; a + b;console.log(add2(1, 3));//4 单个参数时可省略()这种情况下pop()的返回值会被赋给arr，也就打印出3: 12const popArr1 = arr1 =&gt; arr1.pop();console.log(popArr1([1, 2, 3]));//3 不想要返回值可以添加void使返回值为undefined: 12const popArr2 = arr2 =&gt; void arr2.pop();console.log(popArr2([1, 2, 3]));//undefined 放在大括号里也可以，但没必要，推荐使用void: 12const popArr3 = arr3 =&gt; &#123; arr3.pop() &#125;;console.log(popArr3([1, 2, 3]));//undefined 不需要传参时只写()即可比如： 123log222 = () =&gt; &#123; console.log(222);&#125; 箭头函数和普通函数的区别箭头函数没有arguments对象在箭头函数中调用arguments报错： 1234const arg=()=&gt;&#123; console.log(arguments);&#125;arg(1,2,3);//报错：arguments is not defined at arg 但是我们可以使用 剩余参数运算符 代替arguments去拿传入的参数：（注意：剩余参数...是做聚合的，它会将传入的参数们聚合成一个数组） 1234const arg=(...args)=&gt;&#123; console.log(args);&#125;arg(1,2,3);//[1, 2, 3] 箭头函数没有自己的this this:自动引用正在调用当前方法的.前的对象。 箭头函数获取到的this是调用他的对象外层的this，不一定是windows。 例子中say1的this指向xiaoming，而say2的this却指向windows，它和xiaoming同级： 1234567891011const xiaoming=&#123; name:\"小明\", say1:function()&#123; console.log(this); &#125;, say2:()=&gt;&#123; console.log(this); &#125;&#125;xiaoming.say1();//&#123;name: \"小明\", say1: ƒ, say2: ƒ&#125;xiaoming.say2();//Window &#123;postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …&#125; 更加明显的例子： 123456789101112name=\"小红\";const xiaoming=&#123; name:\"小明\", say1:function()&#123; console.log(this.name); &#125;, say2:()=&gt;&#123; console.log(this.name); &#125;&#125;xiaoming.say1();//小明xiaoming.say2();//小红 回调函数中的this 回调函数中的this默认是指向windows的，因为本质上是在函数内callback,并没有.前的对象调用。 注意：回调函数和箭头函数不同，回调函数时指向windows，而箭头函数只是指向调用他的对象当前所处对象的this，也就是调用他的对象的外层的this，不一定是windows。 闭包获取 也就是说，如果回调函数中想要使用this有两种解决方法(如下)。 要么在使用回调函数之前利用闭包的特性先使用一个变量_this保存this：12345678910111213const xiaoming = &#123; name:\"xiaoming\", age: null, getAge: function () &#123; let _this = this; //...ajax setTimeout(function () &#123; _this.age = 15; console.log(_this); &#125;, 1000); &#125;&#125;;xiaoming.getAge();//&#123;name: \"xiaoming\", age: 15, getAge: ƒ&#125; 箭头函数获取要么将回调函数改为箭头函数，这样this取到外层的this，即我们需要的对象xiaoming： 123456789101112const xiaoming = &#123; name: \"xiaoming\", age: null, getAge: function () &#123; //...ajax setTimeout(() =&gt; &#123; this.age = 15; console.log(this); &#125;, 1000); &#125;&#125;;xiaoming.getAge();//&#123;name: \"xiaoming\", age: 15, getAge: ƒ&#125;","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"回调函数","slug":"JS回调函数","date":"2019-11-12T12:28:12.000Z","updated":"2020-02-29T09:02:56.794Z","comments":true,"path":"2019/11/12/JS回调函数/","link":"","permalink":"http://yoursite.com/2019/11/12/JS回调函数/","excerpt":"回调函数 回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。","text":"回调函数 回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。 注意：调用回调函数时是不需要()的，直接使用函数名！ 例子：下面reduce()方法的第一个参数就是回调函数。 回调函数与调用普通函数的区别 性能没有区别。 回调函数是作为参数传递的,操作更加灵活。比如，你定义了函数a，b，c,那么使用回调函数时不用修改 a 的代码就可以让 a 调用 c、d、e….当你调用普通函数的时候不修改代码只能在函数a内运行函数b，就失去了变量的灵活性。 补充：数组的reduce()方法 reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。即，对数组每个元素执行回调函数，返回值用于下一次计算参数 reduce()方法的参数由回调函数和一个初始值参数组成。 语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 语法理解：reduce(function(回调返回的值,数组当前元素,当前元素序号值,调用reduce的数组) , 回调函数第一个参数的初始值); 返回值：返回计算结果 例子：12345678910111213141516171819&lt;body&gt;&lt;p&gt;点击按钮计算数组元素相加后的总和。&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;点我&lt;/button&gt;&lt;p&gt;数组元素总和: &lt;span id=\"demo\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;script&gt;var numbers = [65, 44, 12, 4];function getSum(total, num) &#123; return total + num;&#125;function myFunction(item) &#123; document.getElementById(\"demo\").innerHTML = numbers.reduce(getSum,0);&#125;&lt;/script&gt;&lt;/body&gt; 同步回调与异步回调其实回调函数并不一定是同步/异步的，主要看我们的函数是否支持异步处理，一旦支持我们就当做异步回调来看。 同步回调1234567891011var callback = function(arg3) &#123; console.log('callback Totle is:' + arg3) &#125;function fn(arg1, arg2, cb) &#123; var Total = arg1 + arg2; cb(Total); console.log('mainFunction Totle is:' + Total)&#125;fn(2, 2, callback) // 调用fn()函数，并传入2, 2, callback作为参数 执行结果为： 12callback Totle is:4mainFunction Totle is:4 异步回调js中的例子123456789101112function f2() &#123; console.log('f2 finished') &#125;function f1(cb) &#123; setTimeout(cb,1000) //用setTimeout()模拟耗时操作 console.log('f1 finished')&#125;f1(f2); //得到的结果是 f1 finished ，f2 finished js中的setTimeout()函数支持异步处理。 所以我们可以用setTimeout()来模拟耗时操作。得到的结果是：12f1 finished f2 finished nodejs中的例子12345678var fs = require(\"fs\");fs.readFile('input.txt','utf-8', function (err, data) &#123; if (err) return console.error(err); console.log(data.toString());&#125;);console.log(\"程序执行结束!\"); 执行的结果是: 123$ node app程序执行结束!我们来测试一下异步回调函数 上面例子中我们先创建了一个文件input.txt，里面的内容是:’我们来测试一下异步回调函数’ 首先我们要明确，node中fs.readFile()读取文件内容是异步的。 因此程序执行到这儿的时候并不会阻塞，而是继续向后执行，当文件读取完毕之后再自动调用传入的匿名回调函数，因此出现了上面的结果。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6扩展 数值扩展","slug":"ES6扩展 数值扩展","date":"2019-11-12T02:29:50.000Z","updated":"2019-11-15T07:26:25.465Z","comments":true,"path":"2019/11/12/ES6扩展 数值扩展/","link":"","permalink":"http://yoursite.com/2019/11/12/ES6扩展 数值扩展/","excerpt":"新的进制表示法 以前八进制可以直接以0开头（octonary），为了将它与十进制区分开，ES6规定八进制必须以0O或者0o开头。 二进制则以0b或者0B开头（binary）。","text":"新的进制表示法 以前八进制可以直接以0开头（octonary），为了将它与十进制区分开，ES6规定八进制必须以0O或者0o开头。 二进制则以0b或者0B开头（binary）。 12console.log(0o16);//14console.log(0b111);//7 新的方法parseInt()与parseFloat()转换为整数与小数 ES6之前，parseInt()与parseFloat()都是挂在window对象上的，window可省略。ES6则将parseInt()与parseFloat()都放在了Number对象上。 但无论对象如何改变，parseInt()与parseFloat()的用途都没改变，依旧是可以将字符串或者数字转换为相应的整数或小数。1234console.log(window.parseInt(\"1.23\"));//1console.log(parseFloat(\"1.23\"));//1.23console.log(Number.parseInt(\"1.23\"));//1console.log(Number.parseFloat(\"1.23\"));//1.23 isNaN()判断是否“非数值” isNaN()判断是否“非数值”，遇到字符串会看能不能将其转换为数值再进行判断. 注意：只有遇到Nan他才会返回true，其他不管是什么类型，包括true与false都被算作是数值，返回false！123456console.log(Number.isNaN(NaN));//trueconsole.log(Number.isNaN(-NaN));//trueconsole.log(Number.isNaN(1)); //falseconsole.log(Number.isNaN('1'));//falseconsole.log(Number.isNaN(true));//falseconsole.log(Number.isNaN(false));//false isFinite()判断是否是无限的1234567console. log(Number. isFinite(Infinity)); //false，Infinity有限的console. log(Number. isFinite(2/0)); //falseconsole. log(Number. isFinite(2/4)); //trueconsole. log(Number. isFinite(1234)); //trueconsole. log(Number. isFinite('12341')); //falseconsole. log(Number. isFinite(true)); //falseconsole. log(Number. isFinite(NaN));//false 安全数 用来判断这个整数是否处于JS内表示的范围之内。 即判断这个整数是否在最大值Number.MAX_SAFE_INTEGER与最小值Number.MIN_SAFE_INTEGER之间。12console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER-1));//true,比最大值小1肯定是安全数console.log(Number.isSafeInteger(Number.MAX_SAFE_INTEGER+1));//false 幂运算**(新的运算符) 注意：它是右结合的，也就是说，在没有括号的情况下他是自动从右往左进行运算的。 例子分析：a算出的是2的10次方1024；b如果是左结合则应该得到1，但是得到的是2，和d得到的值一样，也就是说**幂运算是右结合的；想要达到左结合的效果，可以像c一样使用括号。12345678let a = 2 ** 10;console.log(a);//1024let b = 2 ** 10 ** 0;console.log(b);//2let c = (2 ** 10) ** 0;console.log(c);//1let d = 2 ** (10 ** 0);console.log(d);//2","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 正则扩展","slug":"ES6扩展 正则扩展","date":"2019-11-11T10:47:25.000Z","updated":"2019-11-15T07:26:32.741Z","comments":true,"path":"2019/11/11/ES6扩展 正则扩展/","link":"","permalink":"http://yoursite.com/2019/11/11/ES6扩展 正则扩展/","excerpt":"复习：正则表达式简单来说就是用一定的规则去查找、替换符合这个规则的文本。","text":"复习：正则表达式简单来说就是用一定的规则去查找、替换符合这个规则的文本。 JS中生成RegExp对象的两种方法 RegExp 对象表示正则表达式。 修饰符包含属性** “g”、”i” 和 “m”，分别用于指定全局匹配、区分大小写的匹配和多行匹配**。 方法1：使用直接量的方式规则用//包裹起来，修饰符跟在后面： 1const regexp1=/规则/修饰符; 例子： 12//^表示开头，g表示全局匹配。即：开头为a的字符串就满足这个正则表达式const regexp1=/^a/g; 方法2：使用构造函数RegExp的方式规则和修饰符都用引号包裹起来： 1const regexp2=new RegExp('规则','修饰符'); 例子： 1const regexp2=new RegExp('^a','g'); 或者 1const regexp2=new RegExp(/规则/修饰符); 例子： 1const regexp3=new RegExp(/^a/g); 正则方法 字符串的正则方法有：match()、replace()、search()、split() 正则对象的方法有：exec()、test() 注意区分match()和exec()，他们都是返回匹配结果的数组，但区别如下表： match() exec() 字符串的正则方法，使用字符串对象进行调用 正则对象的方法，使用RegExp对象进行调用 返回的是匹配完成后完整的数组 每调用一次返回单次对应的匹配结果并用数组的方式显示 区分match()和exec()的例子：12345678910const r1 = /imooc/g;const str = \"imoocimooc_imooc\";console.log(r1.exec(str));//[\"imooc\", index: 0, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 5, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//[\"imooc\", index: 11, input: \"imoocimooc_imooc\", groups: undefined]console.log(r1.exec(str));//nullconsole.log(str.match(r1));//[\"imooc\", \"imooc\", \"imooc\"] match() 方法 match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。 该方法类似 indexOf() 和 lastIndexOf()，但是它返回指定的值(数组)，而不是字符串的位置。 返回值:存放匹配结果的数组。 语法：12stringObject.match(searchvalue)stringObject.match(regexp) 参数 描述 searchvalue 必需。规定要检索的字符串值。 regexp 必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。 例子：在下面正则表达式完整例子中使用。 exec()方法 exec() 方法用于使用正则表达式，检索字符串中的正则表达式的匹配。 语法：RegExpObject.exec(要检索的字符串) 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 与match()类似，他们都是返回匹配结果的数组，但match()是字符串的正则方法（是使用字符串对象进行调用），exec()是正则对象的方法（使用RegExp对象进行调用）。 例子：在下面y粘连修饰符的例子*中使用。 test()方法 test()方法用于检测一个字符串是否匹配某个模式. 返回值：布尔型。如果字符串中有匹配的值返回 true ，否则返回 false。 注意：和match()类似，不过他返回的是布尔值而不是匹配值构成的数组。 语法：RegExp对象.test(要检测的字符串) 例子：在下面u修饰符的例子中使用。 正则表达式完整例子123456789101112131415//^表示开头，g表示全局匹配。即：开头为\"你\"的字符串就满足这个正则表达式const regexp1 = /^你/g;console.log(\"你好呀你好呀你好呀\".match(regexp1));//[\"你\"]const regexp2 = new RegExp(\"^你好\", \"g\");//不要漏掉g的引号console.log(\"你好呀你好呀你好呀\".match(regexp2));//[\"你好\"]const regexp3 = new RegExp(/^我/g);console.log(\"你好呀你好呀你好呀\".match(regexp3));//null，不符合规则const regexp4 = /你/g;//去掉^console.log(\"你好呀你好呀你好呀\".match(regexp4));//[\"你\", \"你\", \"你\"]const regexp5 = /你/;//去掉g,不再全局搜索console.log(\"你好呀你好呀你好呀\".match(regexp5));//[\"你\"] 正则表达式构造函数RegExp的变化不管有多少个“原来的修饰符”，都都会被”新增的修饰符”覆盖，注意：新增的修饰符需要引号 1const regexp = new RegExp(/规则/原来的修饰符,\"新增的修饰符\"); 例子： 1const regexp = new RegExp(/^你/igm,\"i\");//最后生效的是i 新增的u、y修饰符u修饰符 ES6 对正则表达式添加了 u 修饰符，含义为 “Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。 u修饰符的作用：使得要检测的字符串会被识别成一个字符而不是拆分成几个字符。使得可以正确处理四个字符的 UTF-16 编码。 例子： 1234//匹配开头为“\\ud83d”的字符串，结果返回true，可是\"\\ud83d\\udc36\"是\"🐶\"console.log(/^\\ud83d/.test(\"\\ud83d\\udc36\"));//true//加上u修饰符：console.log(/^\\ud83d/u.test(\"\\ud83d\\udc36\"));//false 例子分析：上面代码中，\\ud83d\\udc36 是一个四字节的UTF-16 编码，代表一个字符“🐶”。但是，ES5不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第一行代码结果为 true。 加了u修饰符以后，ES6就会识别其为一个字符，所以第二行代码结果为false。 y 粘连修饰符 y即 sticky（adj. 粘的；粘性的） y修饰符和g修饰符很像，他们都是全局匹配的，但y修饰符需要匹配到的第1个和第2个规则直接相粘连才能匹配到第2个，第一个匹配结束以后如果不是马上遇到第2个就停止匹配，返回null。 例子：123456789101112131415const r1 = /imooc/g;const r2 = /imooc/y;const str = \"imoocimooc_imooc\";console.log(r1.exec(str));console.log(r1.exec(str));console.log(r1.exec(str));console.log(r1.exec(str));console.log(\"-----------我是分割线-------------\");console.log(r2.exec(str));console.log(r2.exec(str));console.log(r2.exec(str)); 例子分析：可以看到全局匹配则可以的到3个“imooc”，而使用y（粘连修饰符）只能匹配到2个“imooc”。这是因为y需要匹配到的第一个和第二个规则直接相粘连才能匹配到第2个，在这个例子中第二个“imooc”匹配完以后出现了-于是就停止匹配了。","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子","slug":"ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子","date":"2019-11-07T13:31:20.000Z","updated":"2019-11-15T07:26:11.949Z","comments":true,"path":"2019/11/07/ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子/","link":"","permalink":"http://yoursite.com/2019/11/07/ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子/","excerpt":"ES6之前遍历字符串的方式步骤1：使用for循环","text":"ES6之前遍历字符串的方式步骤1：使用for循环 补充：charAt()查找字符 语法:stringObject.charAt(index) 功能:返回stringObject中index位置的字符. 例子：123456let str=\"我超级棒的！\";for(let i=0,len=str.length;i&lt;len;i++)&#123; // console.log(str[i]); console.log(str.charAt(i));&#125; 直接使用str[index]与str.charAt(index)效果一样。 步骤2：将字符串转换成数组补充：[].slice和Array.prototype.slice的区别 slice()截取，语法：arrayObject.clice(start,end);，start可省、end可省，返回值：数组。如果省略 start，则 slice 从索引 0 开始。 Array是一个构造函数。浏览器内置的特殊对象。 Array没有slice方法,但是”Array的实例[]“有slice方法。 Array.prototype原型上有方法slice()我们可以用Array.prototype.slice或者Array的实例[].slice都行，但不能Array.slice。 Array.prototype.slice.call(arguments)可以将类数组对象（如：字符串）转成数组。（下面的“将字符串转换成数组的各种方法”的“方法一”中有使用） 方法1 Array是一个构造函数。浏览器内置的特殊对象。Array没有slice方法。Array.prototype原型上有方法slice()我们可以用Array.prototype.slice或者Array的实例[].slice都行，但不能Array.slice。 Array.prototype.xx方法.call(str)可以使str调用Array的xx方法从而将字符串转换为数组。 slice()截取，语法：arrayObject.clice(start,end);，start可省、end可省，返回值：数组。如果省略 start，则 slice 从索引 0 开始。 call()传参使用方法：Array.prototype.slice.call(str);1234let str=\"我超级棒的！\";var oStr=Array.prototype.slice.call(str);console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 或者使用var oStr=Array.prototype.slice.call(str,0);也可以。 方法2使用字符串的split()进行切割可以将字符串转换成数组： 1234let str=\"我超级棒的！\";var oStr=str.split(\"\");console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 方法3使用字符串的解构赋结合扩展运算符值可以将字符串转换成数组： 使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。 使用扩展运算符时会把每个oStr中剩余未匹配的字符作为一项组成一个数组来匹配给oStr： 1234let str=\"我超级棒的！\";const [...oStr]=str;console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 方法4使用扩展运算符也可以将字符串转换成数组(即：创建数组oStr的时候，通过扩展运算符将字符串展开，字符串的每一个字符构成一个数组元素。)： 1234let str=\"我超级棒的！\";const oStr=[...str];console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 或者 12let str = \"antzone\";console.log([...str]);// [\"a\", \"n\", \"t\", \"z\", \"o\", \"n\", \"e\"] 补充：forEach()遍历数组的每个元素 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。 注意: forEach() 对于空数组是不会执行回调函数的。 语法：array.forEach(function(currentValue, index, arr), thisValue)12345678910111213141516&lt;body&gt;&lt;p&gt;点击按钮列出数组的每个元素。&lt;/p&gt;&lt;button onclick=\"numbers.forEach(myFunction)\"&gt;点我&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;demoP = document.getElementById(\"demo\");var numbers = [4, 9, 16, 25];function myFunction(item, index) &#123; demoP.innerHTML = demoP.innerHTML + \"index[\" + index + \"]: \" + item + \"&lt;br&gt;\"; &#125;&lt;/script&gt;&lt;/body&gt; 使用3个参数的例子 步骤3：对数组进行遍历使用数组的forEach()对数组进行遍历，整合上面的将字符串转换为数组则可以得到： 12345678let str=\"我超级棒的！\";//将字符串转换为数组var oStr=str.split(\"\");//使用数组的forEach()对数组进行遍历oStr.forEach(function(word)&#123; console.log(word);&#125;);console.log(oStr); ES6之前遍历字符串并进行加密的例子 注意： 可以使用对象名[&quot;property&quot;]来访问对象属性。 但是在该例子中可以发现并没有引号，有引号则取不到，这是因为切割字符串时我们使用的分隔符是引号，所以数组oStr中的每一个元素已经自带引号，即map的属性名word已经是有引号的了。（如下所示）123456789101112let str = \"我超级棒的！\";var oStr=str.split(\"\");//使用字符串的split()进行切割得到数组console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"]const map = &#123; 我: \"www\", 超: \"ccc\", 棒: \"bbb\",级:\"jjj\",的:\"ddd\",'！':\"lll\" &#125;;console.log(map[\"棒\"]);//bbb,注意这里的属性名需要放到引号内oStr.forEach(function(word,index)&#123; if(str.includes(word))&#123; oStr[index]=map[word]; &#125;&#125;);console.log(oStr);//[\"www\", \"ccc\", \"jjj\", \"bbb\", \"ddd\", \"lll\"]","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"ES6扩展 字符串扩展","slug":"ES6扩展 字符串扩展","date":"2019-11-07T13:29:42.000Z","updated":"2020-02-16T03:08:31.228Z","comments":true,"path":"2019/11/07/ES6扩展 字符串扩展/","link":"","permalink":"http://yoursite.com/2019/11/07/ES6扩展 字符串扩展/","excerpt":"补充：敲代码中需要注意的地方永远记住对象的属性键值对中间是冒号不是等号！！（具体参考下方“模版字符串”的例子1）","text":"补充：敲代码中需要注意的地方永远记住对象的属性键值对中间是冒号不是等号！！（具体参考下方“模版字符串”的例子1） 补充：在js文件里插入html代码的规则 方法一：html代码放在一行内显示（去掉所有空格/tab/换行） 方法二：想要保留格式可以在每行代码尾部加反斜线\\ 普通字符串拼接中，与变量的拼接可使用+，行尾有+则不需要\\即可折行（如下图例子）但是+前后需要使用引号将html标签单独括起来。（复杂，推荐使用模板字符串） 模板字符串中插入html代码时可以换行，行尾不需要插入转义符\\，但要注意模板字符串是使用反引号`代替引号的。 复习：数组的join()将数组转换为字符串1数组.join(分隔符) 分隔符默认为, 参数类型为string，需要修改分隔符时注意用引号 复习：访问对象属性的两种方法 可以使用 对象名.property (例子1 ) 或对象名[&quot;property&quot;]( 例子2) 模版字符串（拼接）模版字符串(注意:使用的是反引号！)： 1`一些值$&#123;想要拼接的值，变量等&#125;另一些值` 以前常用的字符串拼接： 1\"一些值\"+变量+\"另一些值\" 模版字符串中，${变量}是变量的占位符。 模板字符串中插入html代码时可以换行，行尾不需要插入转义符\\。 普通的字符串拼接插入html代码时不能换行，换行时行尾需要插入转义符\\。 可用于凭借变量和值，比如在js中修改元素el的transform属性 的 属性值translate(a,b),其中x、y是变量:1el.style.transform = `translate($&#123;x&#125;px,$&#123;y&#125;px)` 例子1 从say1和say4可以看出，使用反引号`来代替最外层引号,使用${}将需要引入的变量括起来代替前后的连接符+。 从say2可以看出${}内还可以包裹${}。也就是模板字符串内还可以拼接模板字符串。 12345678910111213141516171819202122&lt;script&gt; const xiaoming = &#123; name: \"xiaoming\", age: 14, //永远记住属性键值对中间是冒号不是等号！！ say1: function() &#123; console.log(\"我叫\" + this.name.toUpperCase() + \",我今年\" + this.age + \"岁！\"); &#125;, say2: function() &#123; console.log(`我叫$&#123;`Mr.$&#123;this.name.toUpperCase() &#125;`&#125;,我今年$&#123;this.age &#125;岁！`); &#125;, say3: function() &#123; console.log(`我叫$&#123;this.name.toUpperCase() &#125;$&#123;this.age &#125;岁是我的年龄！`); &#125;, say4: function() &#123; console.log(`我叫$&#123;this.name.toUpperCase() &#125;,我今年$&#123;this.age &#125;岁！`); &#125; &#125; xiaoming.say1();//我叫XIAOMING,我今年14岁！ xiaoming.say2();//我叫Mr.XIAOMING,我今年14岁！ xiaoming.say3();//我叫XIAOMING14岁是我的年龄！ xiaoming.say4();//我叫XIAOMING,我今年14岁！&lt;/script&gt; 例子2在该例子中使用数组的join()将数组转换为字符串时类似于: 1[`&lt;li&gt;123&lt;/li&gt;`,`&lt;li&gt;456&lt;/li&gt;`].join(\"\") 会得到&lt;li&gt;123&lt;/li&gt;&lt;li&gt;456&lt;/li&gt;此时只要把准换好的字符串放入ul标签即可得到无序列表在代码1中，我们可以发现：字符串中插入html代码很麻烦，行尾需要插入转义符\\。 推荐将代码1插入html部分改为模板字符串：模板字符串中插入html代码时可以换行，行尾不需要插入转义符\\。在代码2中，我们可以发现： 模板字符串可以对模板字符串进行嵌套。 模板字符串内可以插入简单表达式（比如调用函数） 字符串的部分新方法padStart()与padEnd()补全字符串 第一个参数：补全后的字符串总长度 第二个参数：用来补全的字符串 返回值：字符串 语法：返回的字符串=调用该方法的字符串.padStart(补全后的字符串总长度,用来补全的字符串); 当参数1&gt;调用该方法的字符串长度+用来补全的字符串长度时，用来补全的字符串会被循环使用。（如下面例子str3） padStart()从调用该方法的字符串前面开始插入参数2给出的字符串 padEnd()从调用该方法的字符串后面开始插入参数2给出的字符串 123456789101112&#123; let str=\"L\" let str1=str.padStart(4,\"OVE\"); console.log(str1);//OVEL let str2=str.padEnd(4,\"OVE\"); console.log(str2);//LOVE let str3=str.padEnd(8,'OVE'); console.log(str3);//LOVEOVEO&#125; repeat()重复字符串 语法：返回的字符串=调用该方法的字符串.repeat(重复的次数); 注意：参数可以是大于-1的小数，如果是小数则取整（如：2.33取2，-0.88取0）123&#123; console.log(\"hlb\".repeat(5));//hlbhlbhlbhlbhlb&#125; 也可以自己实现一个简易的repeat方法： 123456//可以自己实现一个repeat方法，将需要重复的字符串str和重复次数num传进去function repeatMe(str,num)&#123; //（返回的数组+1）转换为字符串，间隔符为传入的字符串str return new Array(num+1).join(str);&#125;console.log(repeatMe(\"hlb\",3));//hlbhlbhlb startsWith()与endsWith()判断字符串开头、结尾 语法：需要被判断的字符串.startsWith(&quot;想要验证的字符或者字符串&quot;) 返回值：是则返回true，不是则返回false 字符串中中文/英文/标点符号都支持1234567891011121314151617&#123; const str=\"I am a extremely happy girl\"; console.log(str.startsWith(\"b\"));//false console.log(str.startsWith(\"I am\"));//true console.log(str.endsWith(\"py girl\"));//true console.log(str.endsWith(\"b\"));//false const str1=\"我超级棒的！\"; console.log(str1.startsWith(\"我\"));//true console.log(str1.startsWith(\"I\"));//false console.log(str1.endsWith(\"的！\"));//true console.log(str1.endsWith(\"b\"));//false&#125; include()查找是否含有某字符(串)语法：需要被查询的字符串.includes(&quot;需要查询的字符或字符串&quot;); 123456const str = \"I am a extremely happy girl\";if (str.includes(\"哈哈\")) &#123;//不存在 console.log(\"存在\");&#125;else&#123; console.log(\"不存在\"); &#125; 补充：没有include()前实现该功能的方法 在没有include()之前字符串使用查询字符串下标indexOf()的方式来判断字符串是否拥有另一个字符或者字符串。 原理：如果该字符串不包含参数中的字符或者字符串则返回值为-1，如果包含则返回值为数组下标。123456const str = \"I am a extremely happy girl\";if (str.indexOf(\"哈哈\") != -1) &#123;//不存在 console.log(\"存在\");&#125;else&#123; console.log(\"不存在\"); &#125; 补充：使用“按位取反~”简化上面例子 按位取反~可以简单的理解为~x=-(x+1) 使用按位取反替换上面的例子：123456const str = \"I am a extremely happy girl\";if(~str.indexOf(\"哈哈\"))&#123;//不存在 console.log(\"存在\");&#125;else&#123; console.log(\"不存在\"); &#125; 原理：当str.indexOf(&quot;哈哈&quot;)值为-1时就是没取到，此时使用按位取反结果为0，在if中0为false。 for-of()遍历（迭代）对象 for-of()语句在可迭代对象（包括 Array，Map，Set，String，TypedArray，arguments 对象等等）上创建一个迭代循环（遍历），调用自定义迭代钩子，并为每个不同属性的值执行语句。 语法： 123for (variable of iterable) &#123; //statements&#125; 参数：variable：在每次迭代中，将不同属性的值分配给变量。iterable：被迭代枚举其属性的对象。 补充：拥有迭代（遍历）器接口iterator的对象都可以使用for-of语句,比如： 12345const arr = [1, 2, 3, 4.4, \"lalal\", false];console.log(arr.keys());//Array Iterator &#123;&#125;,说明arr.keys()含有迭代器接口Iterator ，故可以使用`for-of`for (let i of arr.keys()) &#123; console.log(i);&#125; 例子： 迭代数组： 123456789let iterable = [10, 20, 30];for (let value of iterable) &#123; value += 1; console.log(value);&#125;// 11// 21// 31 迭代字符串： 12345678let iterable = \"boo\";for (let value of iterable) &#123; console.log(value);&#125;// \"b\"// \"o\"// \"o\" 迭代去重函数Set()： 12345678let iterable = new Set([1, 1, 2, 2, 3, 3]);for (let value of iterable) &#123; console.log(value);&#125;// 1// 2// 3 迭代arguments对象： 123456789(function() &#123; for (let argument of arguments) &#123; console.log(argument); &#125;&#125;)(1, 2, 3);// 1// 2// 3 迭代 DOM 元素集合，比如一个NodeList对象：MDN中关于NodeList的描述下面的例子演示给每一个 article 标签内的 p 标签添加一个 “read” 类： 123456//注意：这只能在实现了NodeList.prototype[Symbol.iterator]的平台上运行let articleParagraphs = document.querySelectorAll(\"article &gt; p\");for (let paragraph of articleParagraphs) &#123; paragraph.classList.add(\"read\");&#125; MDN中更多关于for-of的知识 for-of()遍历字符串 语法：for(let word of str){执行操作语句} 参数含义：word：当前循环到的元素str：需要遍历的字符串名 注意：word的数据类型是string，所以在下面的加密小例子中用它来当属性名调用对象属性时不需要再加引号！ for-of()还可以遍历对象属性，具体例子在笔记“ES6扩展 对象扩展”中。12345let str=\"我超级棒的！\";for (let word of str)&#123; console.log(word); console.log(typeof(word));//string&#125; 使用for-of()完成加密小例子 注意： 可以使用对象名[&quot;property&quot;]来访问对象属性。 但是在该例子中可以发现并没有引号，这是因为：word的数据类型是string，所以在下面的例子中用它来当属性名调用对象属性时不需要再加引号！ ES6之前遍历字符串的方式以及遍历字符串并进行加密的例子在下一篇笔记。 新的Unicode表示法和遍历方式 概念：Unicode是一项标准包括字符集、编码方案等。 他是为了解决传统的字符编码方案的局限而产生的，为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。 js中遇到\\u机器就知道后面跟的是码点，以前的Unicode只能识别0000-ffff之间的码点，现在可以使用{}将码点包起来识别超过0000-ffff这个范围的二进制编码。例如&quot;\\u{1f436}&quot;识别出小狗🐶（注意引号） 使用codePointAt()获取字符串中对应字符的一个码点 语法：&quot;对应字符&quot;.codePointAt(0).toString(16); 例子：123\"🐶\".codePointAt(0);//得到128054//128054是码点，但它是10进制的，要转换为16进制才是我们要的\"🐶\".codePointAt(0).toString(16);//得到\"1f436\" 补充：at()根据下标取字符虽然chrome不支持at()，但是后期可以使用软件将ES6代码转换成ES5，这里了解一下。 1\"🐶\".at(0);","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"百度前端技术学院 第五天学习总结","slug":"百度前端技术学院 第五天学习总结","date":"2019-11-06T12:02:35.000Z","updated":"2020-02-26T07:56:45.098Z","comments":true,"path":"2019/11/06/百度前端技术学院 第五天学习总结/","link":"","permalink":"http://yoursite.com/2019/11/06/百度前端技术学院 第五天学习总结/","excerpt":"补充：CSS块内文字居中参考方法 块内单方文字垂直居中 设置line-height与height相同。","text":"补充：CSS块内文字居中参考方法 块内单方文字垂直居中 设置line-height与height相同。 块内文水平居中 text-align: center; 补充：在github的readme中展示网页效果参考方法 盒模型的概念以及内外边距，宽度，高度，box-sizing等属性首先我们要明确盒模型分两种:标准盒模型和替代盒模型，他们的区别在于宽度和高度的计算方法不同。默认情况下，浏览器使用标准盒模型。如果要为元素打开替代盒模型，可以通过对其进行设置如下代码来实现： 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; box-sizing是个很新的属性，目前应该像上面例子中那样使用 -webkit-和 -moz-前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+的。 注意：标准盒模型 的宽度只是内容的宽度，不包括padding与border，所以我们一旦设置padding与border就应该设置替代盒模型，以确保我们设置的width就是我们看到的宽度。 通过对比图可以很明显的发现：在标准盒模型中，盒子占用的总大小由框的宽度（width）和高度（height）以及任何填充（padding）和边框（border）相加得到。在替代盒模型中，宽度（width）是页面上可见框的宽度（不用加上padding与border），因此内容区域的宽度是该宽度减去填充和边框的宽度。注意：padding与margin属性值可以为1——4个，含义有所不同，如下表： 属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 inline、block和inline-block的概念首先，inline、block和inline-block都是display的属性值。 inlinedisplay属性inline可以让块元素像行内元素。 block display属性block可以使span元素像块元素。 内联元素高宽与他们的内容高宽一样，所以不能对内联元素设置宽度或高度，它们只是位于块级元素的内容中。 如果要控制内联元素的大小，则需要将其设置为类似块级元素display: block;。 inline-block 这个属性可以让内联盒子不与包含他的盒子内容重叠，也就是说他会让内联盒子的width与height属性生效。 直接从属性名也可以看出他可以让内联的盒子像一个块元素。 他会使元素在一行显示，仍然保持样式可设置。 浮动，清除浮动浮动(float属性)属性值有left、right。 清除浮动(clear属性)要注意及时清理浮动。如果不清楚浮动，所有在浮动下面的自身不浮动的内容都将围绕浮动元素，在最长的列旁边环绕着。 clear 属性值 含义 left 停止任何活动的左浮动 right 停止任何活动的右浮动 both 停止任何活动的左右浮动 建议使用::after 伪元素来清除浮动：只需要给想要浮动的元素一个div框起来并给这个div添加.clearfix并在css里设置如下代码就可以使这个div以后的元素都停止浮动： 12.clearfix::after &#123;content:\".\"; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; ::after的意思是在.clearfix内部的最后加入伪元素::after 首先要显示伪元素，所以display:block 然后为伪元素加入空内容，以便伪元素中不会有内容显示在页面中，所以， content:&quot;&quot;；(.也可以，只要加上visibility:hidden;) 其次，为使伪元素不影响页面布局，将伪元素高度设置为0，所以， height:0 最后，要清除浮动，所以，clear:both。 after伪元素其实是通过 content 在元素的后面生成了内容为一个点的块级元素。这样一来只要设置这两个非浮动元素之间的距离就行了。 使用::after清除浮动的例子未清除浮动时“联系方式”与“姓名”等信息在同一行。因为姓名、性别和应聘职位是浮动三列，所以如果我们希望“联系方式”出现在“姓名”正下方就需要清除浮动。 1234567891011121314151617181920&lt;body&gt; &lt;h1&gt;简历&lt;/h1&gt; &lt;h2&gt;基本信息&lt;/h2&gt; &lt;div class=\".clear\"&gt; &lt;div&gt; &lt;strong&gt;姓名&lt;/strong&gt; &lt;span&gt;张三&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;strong&gt;性别&lt;/strong&gt; &lt;span&gt;男&lt;/span&gt; &lt;/div&gt; &lt;div&gt; &lt;strong&gt;应聘职位&lt;/strong&gt; &lt;span&gt;Web前端工程师&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;h2&gt;联系方式&lt;/h2&gt;&lt;/body&gt; 1234567891011121314151617181920212223div div:nth-of-type(1) &#123; width: 10%; float: left;&#125;div div:nth-of-type(2) &#123; width: 10%; float: left;&#125;div div:nth-of-type(3) &#123; width: 20%; float: left;&#125;.clear::after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden;&#125; 如何使用浮动进行布局设置float属性参考MDN浮动","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"jQuery入门","slug":"JQuery入门","date":"2019-11-05T13:27:50.000Z","updated":"2020-02-13T14:19:13.069Z","comments":true,"path":"2019/11/05/JQuery入门/","link":"","permalink":"http://yoursite.com/2019/11/05/JQuery入门/","excerpt":"补充：结构层、表示层、行为层 结构层：HTML文件 表示层：CSS文件 行为层：JS文件","text":"补充：结构层、表示层、行为层 结构层：HTML文件 表示层：CSS文件 行为层：JS文件 jQueryjQuery是一个JavaScript函数库jQuery是一个轻量级的“写得少，做的多”的JavaScript库 jQuery引用 先去下载jQuery文件 使用jQuery只需要在页面的中引入jQuery 文件即可（注意需要在引入自己的js文件的上面先引入jQuery 文件） $的使用 $是一个变量。 jQuery 把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名。(变量$冲突时可以使用变量jQuery代替它) 绝大多数时候，我们都直接用$。 若$变量已被占用，且不能改，就只能使用jQuery 这个变量。（$===jQuery） jQuery语法基础语法： $(selector).action() 美元符:定义 jQuery选择符（selector）:“查询”和”查找” HTML 元素jQuery 的 action(): 执行对元素的操作 实例: 1234$(this).hide() - 隐藏当前元素$(\"p\").hide() - 隐藏所有 &lt;p&gt; 元素$(\"p.test\").hide() - 隐藏所有 class=\"test\" 的 &lt;p&gt; 元素$(\"#test\").hide() - 隐藏所有 id=\"test\" 的元素 文档就绪事件建议使用下面的方式写jquery： 123$(document).ready(function()&#123;$('div').addClass('div');//这中间写的是jquery代码&#125;); 将jquery代码包含在$(document).ready(function(){}中而不是直接在js文件中书写jquery代码的原因是：我们在html文件中加载js文件是从上至下的，此时jquery代码的js文件放在head中，这就导致运行该js文件时body中的元素还未加载，也就是例子中的div都还不存在，$(document).ready(function(){}的意思就是等到document都准备好了才运行其中的代码。 提示：简洁写法（与以上写法效果相同）: 12345$(function()&#123; // 开始写 jQuery 代码... &#125;); 补充：HTML&lt;nav&gt;标签 &lt;nav&gt;标签定义导航链接的部分,是 HTML 5 中的新标签。 例子 补充：vscode同时选中多行输入按shift+alt，再使用鼠标拖动，可以出现竖直的列光标，同时可以选中多列进行输入。 jquery中HTML方法html() 方法设置innerHTML html() 方法设置或返回被选元素的内容（innerHTML）。 当该方法用于返回内容时，则返回第一个匹配元素的内容。 当该方法用于设置内容时，则重写所有匹配元素的内容。 提示：如只需设置或返回被选元素的文本内容，请使用 text() 方法。 例子 语法：返回内容： 1$(selector).html() 设置内容： 1$(selector).html(content) 使用函数设置内容： 1$(selector).html(function(index,currentcontent)) content:必需。规定被选元素的新内容（可包含 HTML 标签）。function(index,currentcontent)：可选。规定返回被选元素的新内容的函数。index - 返回集合中元素的 index 位置。currentcontent - 返回被选元素的当前 HTML 内容。 jquery中CSS方法.eq方法用于选择元素 选取带有指定 index 值的元素。 语法：$(&quot;:eq(index)&quot;) 可参考菜鸟教程 .css方法用于修改css样式 css() 方法设置或返回被选元素的一个或多个样式属性。 返回语法：css(&quot;propertyname&quot;);,比如$(&quot;p&quot;).css(&quot;background-color&quot;); 设置语法：css(&quot;propertyname&quot;,&quot;value&quot;);，比如$(&quot;p&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); 设置多个CSS属性语法：css({&quot;propertyname&quot;:&quot;value&quot;,&quot;propertyname&quot;:&quot;value&quot;,...});,如$(&quot;p&quot;).css({&quot;background-color&quot;:&quot;yellow&quot;,&quot;font-size&quot;:&quot;200%&quot;}); 可参考菜鸟教程 例子获取导航条nav标签中的多个a标签为变量alinks（他会成为一个数组，所以修改a标签的样式需要遍历）已经屏蔽的是原生js的写法。 .text方法用于改变文字内容变量名.text({操作}) 例子 .html方法用于改变文本的同时读取html标签在获取html元素以后使用.html方法可以在改变文本的同时读取插入的html标签。（比如例子中就读取了&lt;strong&gt;实现了加粗效果）变量名.html({操作}) 例子","categories":[{"name":"jQuery学习","slug":"jQuery学习","permalink":"http://yoursite.com/categories/jQuery学习/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"vscode同时选中多行输入","slug":"vscode","date":"2019-11-05T07:02:57.000Z","updated":"2019-11-05T07:03:51.375Z","comments":true,"path":"2019/11/05/vscode/","link":"","permalink":"http://yoursite.com/2019/11/05/vscode/","excerpt":"vscode同时选中多行输入按shift+alt，再使用鼠标拖动，可以出现竖直的列光标，同时可以选中多列进行输入。","text":"vscode同时选中多行输入按shift+alt，再使用鼠标拖动，可以出现竖直的列光标，同时可以选中多列进行输入。 例子以&lt;nav&gt;标签为例： 在html文件中输入nav&gt;a*5得到： 按住shift+alt，再使用鼠标左键拖动可同时选中并进行输入。 也可以使用该方法一次性将多行文本引入：","categories":[{"name":"vscode使用过程中的小tips","slug":"vscode使用过程中的小tips","permalink":"http://yoursite.com/categories/vscode使用过程中的小tips/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://yoursite.com/tags/vscode/"}]},{"title":"hexo部署到github后页面效果无变化","slug":"hexo部署到github后页面效果无变化","date":"2019-11-05T03:06:48.000Z","updated":"2019-11-05T03:06:51.652Z","comments":true,"path":"2019/11/05/hexo部署到github后页面效果无变化/","link":"","permalink":"http://yoursite.com/2019/11/05/hexo部署到github后页面效果无变化/","excerpt":"问题描述修改了hexo的部分内容后成功push到了github上，但页面效果无变化。","text":"问题描述修改了hexo的部分内容后成功push到了github上，但页面效果无变化。 解决方法清除浏览器缓存。以谷歌chrom为例： 点击右上角 点击“更多工具”-“清除浏览器缓存” 点击“清除数据”","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"hexo可以本地预览但deploy到github失败","slug":"hexo可以本地预览但deploy到github失败","date":"2019-11-05T02:57:45.000Z","updated":"2019-11-05T03:05:20.713Z","comments":true,"path":"2019/11/05/hexo可以本地预览但deploy到github失败/","link":"","permalink":"http://yoursite.com/2019/11/05/hexo可以本地预览但deploy到github失败/","excerpt":"背景之前修改了hexo内容后在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后都可以成功部署（push）到github上，这一次修改了_config.yml中的部分配置后发现页面效果未发生更改且无法push到github上。","text":"背景之前修改了hexo内容后在git bush中使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后都可以成功部署（push）到github上，这一次修改了_config.yml中的部分配置后发现页面效果未发生更改且无法push到github上。 问题描述在git bush中使用hexo s时可以在本地预览到正确的页面效果，但是使用hexo clean &amp;&amp; hexo g &amp;&amp; hexo d后发现并未部署到github上。并且在git bush中出现类似 FATAL can not read a block mapping entry; a multiline key may not be an implicit key at line 70, column 1: ...错误 解决方法_config.yml中配置项的冒号后面要用空格隔开，再跟内容","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"解构赋值（2）","slug":"解构赋值（2）","date":"2019-11-02T13:30:00.000Z","updated":"2020-01-22T09:29:09.937Z","comments":true,"path":"2019/11/02/解构赋值（2）/","link":"","permalink":"http://yoursite.com/2019/11/02/解构赋值（2）/","excerpt":"字符串的解构赋值和数组的解构赋值使用方法是类似的，使用[]，空格也会被匹配到，不使用扩展运算符时返回的是字符，使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。","text":"字符串的解构赋值和数组的解构赋值使用方法是类似的，使用[]，空格也会被匹配到，不使用扩展运算符时返回的是字符，使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。 等号左边是数组结构，右边是字符串let [a,b,c,d]=const &quot;I am hlz&quot; 左边的[]中为需要赋值的变量 右边为需要解构的字符串 结合扩展运算符（...）将字符串转换为数组使用扩展运算符时会把每个剩余未匹配的字符作为一项组成一个数组。 例子中spStr1与spStr2、spStr3得到的都是一样的。 spStr1使用的是字符串的解构赋值与扩展运算符结合。 spStr2使用的是字符串的split方法。 spStr3使用的是纯粹的扩展运算符，可以理解为“展开运算符”，较难理解，通过下面2个例子来解释： 在创建数组(例子中的oStr)的时候，通过扩展运算符将字符串展开，字符串的每一个字符构成一个数组元素。 1234let str=\"我超级棒的！\";const oStr=[...str];console.log(oStr);//[\"我\", \"超\", \"级\", \"棒\", \"的\", \"！\"] 或者 12let str = \"antzone\";console.log([...str]);// [\"a\", \"n\", \"t\", \"z\", \"o\", \"n\", \"e\"] 提取属性（了解即可） 数值与布尔值的解构赋值（了解即可）数值与布尔值的解构赋值与对象的结构赋值方法类似。他获取到的是数值与布尔值的属性。在这个例子中我们先是获取到数值1的属性valueOf，并将其赋给vo，当然不赋给vo也是可以的，结果可以看到是获取成功了。（关于valueOf 方法）然后我们获取布尔值true的属性toString，并将其赋给ts，当然不赋给ts也是可以的，结果可以看到也是获取成功的。我们可以通过数值的解构赋值得到属性valueOf，但是却无法直接通过1.valueOf来获取属性valueOf，这是因为我们在对数值或者布尔值进行解构赋值时会先将他们转换为包装对象再获取属性。str是一个字符串对象，给他一个属性a以后发现并查询不到，这是因为他先把str转换为包装对象以后才进行属性的获取，相当于先把str包装成sStr 函数参数的解构赋值在上图的例子中，我们将传进的参数（数组）进行解构赋值放入变量x与y中，并将他们在返回时调换位置。 Node.js 函数引用 与解构赋值为什么有时候引用外部js文件中的函数时要使用{}进行解构赋值？ 可以看笔记“Node.js函数引用与解构赋值” React.js与解构赋值可以看笔记“React.js基础精讲（1）”","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"解构赋值（1）","slug":"解构赋值（1）","date":"2019-11-02T13:00:00.000Z","updated":"2020-02-11T09:06:25.282Z","comments":true,"path":"2019/11/02/解构赋值（1）/","link":"","permalink":"http://yoursite.com/2019/11/02/解构赋值（1）/","excerpt":"补充：扩展运算符位置 对象中的扩展运算符（…）用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中(数组也一样，自己替换) 扩展运算符用作合并时他是放在需要被合并的数组/对象前的。 扩展运算符用作表示将还未匹配的数据包起来匹配给某变量时放在该变量前面。","text":"补充：扩展运算符位置 对象中的扩展运算符（…）用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中(数组也一样，自己替换) 扩展运算符用作合并时他是放在需要被合并的数组/对象前的。 扩展运算符用作表示将还未匹配的数据包起来匹配给某变量时放在该变量前面。 补充：扩展运算符与深、浅拷贝 基本数据类型（值类型），比如number，string，boolean，是可以使用扩展运算符进行深拷贝的 引用类型的值，比如Object，Array，。引用类型使用扩展运算符进行的是浅拷贝，只是拷贝了引用地址。 解构赋值 解构赋值语法是一个JavaScript表达式，它可以将值从数组或属性从对象中提取到不同的变量中。–MDN 我认为，解构赋值可以将 值从数组 或 属性从对象 中提取到不同的变量或者常量const中。 举例理解：对象中,const {name} = obj;等价于const name = obj.name; 数组与对象的解构赋值相对重要一些，字符串、数值与布尔值、函数的解构赋值建立在数组与对象的解构赋的基础之上。 数组的解构赋值 等号两边都是数组结构let [a,b,c,d]=const[1,2,3,4] 左边的[]中为需要赋值的变量 右边为需要解构的数组 更复杂的匹配规则 默认值 在数组的解构赋值中可以使用=设置默认值，当解构赋值中匹配到undefined时自动使用默认值。 const常量没有匹配到默认值时在这并不会报错，会反回undefined。 注意：一定是undefined才会使用默认值，null不会。 交换变量使用数组的解构赋值可以使交换变量更加方便。 接收多个“函数返回值”使用数组的解构赋值可以使接收多个“函数返回值”更加方便。注意：return返回的是一个数组，第一项返回的是布尔值，第二项是一个对象，第三项返回字符串。通过数组的解构赋值可以将函数的多个返回值分别获取为status、data、msg。 数组的解构赋值与扩展运算符（...)结合用法1：通过扩展运算符可以将多个数组合并为一个数组。 用法2：注意：扩展运算符与数组的解构赋值结合使用时只能放在最后，因为扩展运算符在这的意思是将数组后面剩余的还未匹配的值都包起来赋给使用了扩展运算符的那个变量。变量a和b分别取到1和2，扩展运算符使得arr中剩余的3,4,5,6都包在一个数组内给了变量c。 对象的解构赋值 对象的结构赋值与数组的结构赋值相似。 等号左右两边都为对象结构const{a，b}={a：1，b：2} 左边的{}中为需要赋值的变量（常量） 右边为需要解构的对象 注意：等号左边的变量名必须与等号右边的对象属性完全一致才能匹配到，不一致则会返回undefined。 数组的解构赋值之所以不需要左右一样是因为数组是有序的，他可以通过数组下标进行查找。而对象是无序的，所以必须要变量名与属性名一致才能完成查找。 帮助理解：const { saber } = obj;相当于const saber = obj.saber; 稍微复杂的解构条件总结：可以将数组的解构赋值和对象的解构赋值一起使用，只要保证等号两边模式一致就能匹配上。（如何才是保证等号两边模式一致可以看第三个例子） 只想获取skill中的数组第一项而不想获取skill时，可以在对象的解构赋值中使用数组的解构赋值，此时就可以使用skill1,因为数组解构赋值对命名没有要求。（注意：要保证两边模式一致，不要漏掉对象的解构赋值和数组的解构赋值中间的冒号） 在对象中使用数组的解构赋值，获取skillNarme属性值注意：等号左右两边要模式一致才能匹配成功！所以不要漏掉大括号、冒号、中括号！ const不能重复定义，而{skillName}的意思是“获取skll中验组第二项的skillName属性值并赋给常量skillName”，所以采用{skillName：sklName}以免出现两个常量skillName而报错 结合扩展运算符（...）使用（...）获取剩余属性 如果只知道对象的部分属性名又想获取剩余的属性时可以使用扩展运算符（其实这里应该叫剩余参数，他们符号相同含义不同）。 扩展运算符（...oth）在对象的解构赋值中的作用是获取没有匹配到的剩余属性并把它们作为对象包起来返回。 123456789101112&lt;script&gt; const obj = &#123; a: \"lalalla\", b: \"kkk\", c: \"hahah\" &#125;; const &#123; b, ...other &#125; = obj; //查询other得到&#123;a: \"lalalla\", c: \"hahah\"&#125;&lt;/script&gt; 使用扩展运算符复制对象 使用扩展运算符复制对象是浅拷贝的。 也就是说当你复制的对象obj1中包含一个对象c时，你实际上复制的是c的引用，当你修改复制所得到的对象copyObj1中的对象c的aa属性时，被复制的obj1对象中的对象c的属性aa也会被改变。 而修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的：123456789101112131415161718const obj1=&#123; a:1, b:2, c:&#123; aa:3, bb:4 &#125;&#125;;const copyObj1=&#123;...obj1&#125;;console.log(copyObj1.c.aa);//3copyObj1.c.aa=999;console.log(copyObj1.c.aa);//999console.log(obj1.c.aa);//999,可以发现obj1的c中的aa也被修改了console.log(copyObj1.b);//2copyObj1.b=222;console.log(copyObj1.b);//222console.log(obj1.b);//2,可以看到修改对象copyObj1的第一层属性b时是不会改动到复制对象obj1的属性b的值的 扩展运算符合并对象 如果合并的两个对象中都含有相同属性名的属性，则属性顺序还是按照前面对象的，但后面对象的属性值覆盖前面的。（例子如下） 不管是使用扩展运算符复制对象还是合并对象，他们都是浅拷贝的。（例子如下）123456789101112131415161718192021const obj1 = &#123; a: 1, b: 2, c: &#123; aa: 3, bb: 4 &#125;, s:8&#125;;const obj2=&#123; a:555, d:33&#125;;const newObj=&#123; ...obj1, ...obj2&#125;;console.log(newObj);//&#123;a: 555, b: 2, c: &#123;…&#125;, s: 8, d: 33&#125;newObj.c.aa=999;console.log(obj1.c.aa);//999，证明合并对象也是浅拷贝的 如何对已经申明了的变量进行对象的解构赋值首先我们要明确，虽然可以解决这个问题，但还是建议变量的申明与对象解构赋值同时进行。（也就是例子中的第一张图片） 解决方法：使用小括号将这一条解构赋值的语句括起来即可。 例子：下图变量age是已经申明才进行解构赋值的，此时{}会被认为是块级作用域而不是对象的解构赋值，想要将对象obj赋给一个块级作用域就报错了。 默认值和数组的解构赋值的默认值用法一样，使用=,当属性没有匹配到或者匹配到undefined时就会返回默认值。 对象的解构赋值的主要用途提取对象属性在上图中可以看到hobby属性是没有获取到的，我们只获取了name属性以及hobby属性中的数组第一项。想要获取hobby属性需要在对象的解构赋值中另外加上hobby： 使用对象传入乱序的函数参数在这个例子中可以看到调用AJAX函数会传入一个对象作为参数，在这里我们使用AJAX函数时传入的参数具有属性url、data，虽然没有type，但是type有默认值，所以最后打印出来的是默认值get。data和url的顺序可以颠倒，毕竟对象的解构赋值只要属性名一致即可这也就是为什么可以传入乱序的函数参数。 获取多个“函数返回值” 在这个例子中，可以发现利用对象的解构赋值来获取多个“函数返回值”的方法和数组时非常相似。 需要注意的是变量名与属性名一致才能匹配到，如果你希望获取到的值不是原本的属性名，可以直接在解构赋值时采用属性名:希望获得的变量名的写法，比如例子中的msg:message意思就是获取对象中的msg属性值并赋给变量message。","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"let命令与const命令","slug":"let与const","date":"2019-11-01T13:00:00.000Z","updated":"2020-02-27T07:24:13.675Z","comments":true,"path":"2019/11/01/let与const/","link":"","permalink":"http://yoursite.com/2019/11/01/let与const/","excerpt":"注意 变量是从里面往外面找，块级作用域嵌套时是没有包含关系的，也就是说这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块。 const优于let,在 let 和 const 建议优先使用const，尤其在全局环境，不应设置变量，只因设置常量。 const优于let的原因： const可以提醒阅读程序的人这个变量不应该改变。 const比较符合函数式编程思想，运算不改变值，只是新建值，防止无意间修改变量值所导致的错误，而且这样也有利于将来分布式运算。 JavaScript编译器会对const进行优化。 多使用const，有利于提高程序的运行效率。 let和const的本质区别，其实是编译器内部的处理不同。","text":"注意 变量是从里面往外面找，块级作用域嵌套时是没有包含关系的，也就是说这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块。 const优于let,在 let 和 const 建议优先使用const，尤其在全局环境，不应设置变量，只因设置常量。 const优于let的原因： const可以提醒阅读程序的人这个变量不应该改变。 const比较符合函数式编程思想，运算不改变值，只是新建值，防止无意间修改变量值所导致的错误，而且这样也有利于将来分布式运算。 JavaScript编译器会对const进行优化。 多使用const，有利于提高程序的运行效率。 let和const的本质区别，其实是编译器内部的处理不同。 块级作用域 注意：花括号包含块级作用域，但声明一个一个对并不是块级作用域。 var结果：打印出0 1 2和3 letlet用于声明变量，用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。 使用let或者const声明的变量不能再被重新声明 let不存在变量提升 暂存死区 ES6规定，如果块级作用域中存在let或者const声明的变量，那么这个变量一开始就会形成封闭的作用域。 也就是说，即使向上的作用域中存在同名变量也是拿不到的。 var不存在暂存死区，所以第一个console可以向上去上面的作用域找同名变量，拿过来打印。（其实有没有大括号意义不大） let存在暂存死区，也就是说向上的作用域中存在同名变量也拿不到，所以第一个console拿不到上面的“我是美猴王”。let又不存在变量提升，所以第一个console中的monkey也没有被声明，只能报错。 补充：appendChild()、createElement()HTML DOM Document 对象、appendChild() 方法、createElement()方法、createTextNode()都可以参考笔记”JS中修改/创建HTML DOM元素的方法” 使用let实现面试常见小例子代码解析： 先在HTML文档中创建一个按钮节点btn 再改变节点文字 然后给节点btn设置一个点击事件 最后将节点btn添加到body中 原因：执行事件时，alert（）首先需要i，但是当前作用域找不到，它就会到上一级找，上一级通过自调用时有传进来的i，这个i是随着函数的调用而产生，随着函数调用结束而释放的，不是作用在一开始的var i身上的，所以每一个函数都对应不同的数字。 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所以每一次循环中btn的innerText所指向的i其实都是同一个，循环到最后时前面的i全部被最后的结果覆盖了。而局部变量的话就是每循环一次产生一个新的i，所以不会被覆盖。 原因：执行事件时，alert（）首先需要i，但是当前作用域找不到，它就会到上一级找，上一级直接就是var i了，所有的代码都作用在它身上，所以他会是11。 可以发现，使用let以后就不需要额外放一个自调用函数把他们框起来了。变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。 const与let特性十分相似：不能重复声明、不存在提升、只在当前（块级）作用域内有效。 使用const来声明常量（不可改变的量） 使用var或者let声明的是变量 1const a=1; 常量必须在声明的时候赋值，否则报错：Missing initializer in const declaration 常量声明后不能被修改 常量为引用类型的时候可以修改该引用类型常量为引用类型：对象、数组、函数。 常量声明一个对象 修改xiaoming.age可以，修改xiaoming却会报错，因为const只能保证我们声明指向的地址不变，不能保证声明的值不变。 xiaoming指向的地址和两个属性指向的地址是一样的，常量要求xiaoming指向的地址不变。修改属性值以后属性依旧指向原本的地址，所以不会报错。但是修改xiaoming会使得指向地址变化，因此报错。 也就是说，常量为对象时，不能直接修改这个对象，但是可以修改这个对象的属性，因为此时该常量是引用类型。 12345678&lt;script&gt; const xiaoming = &#123; age: 14, name: '小名' &#125;; xiaoming.sax = '男'; console.log(xiaoming.sax); //男&lt;/script&gt; 说明常量对象如果不处理是可以增加属性的。 常量声明一个数组 可以往常量数组中放入值，此时该常量数组指向的地址不变，不会报错。 30试图让常量数组指向另一个地址，报错。 常量为引用类型时需要冻结来防止被修改使用Object.freeze(常量名)注意：使用Object.freeze()以后也不能再给常量增加属性了（比如xiaoming.dd=11;） es6之前怎么声明常量补充：Object.definePropertyObject.defineProperty除了可以增加一个属性以外还可以对已有的属性进行设置writable:false使该属性不可修改。 补充：Object.seal(变量名);Object.seal(变量名);可以使该变量不能再增加属性。两者结合可以使变量成为常量。 补充：对象名.hasOwnProperty(属性名)对象名.hasOwnProperty(属性名)可以帮助我们判断这个属性是自身的还是继承过来的。其中，obj2是通过obj1创建的，遍历打印obj2可以发现除了obj2自身的属性c、d之外还会打印出继承来的a、b属性。 es6之前声明常量的方法思路：自定义一个Object的带有参数obj（需要成为常量的变量名）的方法freezePolyfill，需要声明常量时就使用Object.freezePolyfill(变量名) 实现步骤： 遍历属性和方法 修改遍历到的属性的描述 Object.seal（） 解决方法：可以用递归来判断一下属性是不是方法，再去套上面的代码。（直接使用迭代的方式也可以）","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS transition属性（过渡效果）","slug":"CSS transition属性","date":"2019-10-28T11:46:42.000Z","updated":"2020-03-11T03:21:36.745Z","comments":true,"path":"2019/10/28/CSS transition属性/","link":"","permalink":"http://yoursite.com/2019/10/28/CSS transition属性/","excerpt":"","text":"transition 属性实现过渡效果 transition 属性是 transition-property，transition-duration，transition-timing-function 和 transition-delay 的一个简写属性。 2个属性：property name | duration，比如all .2s 3个属性： property name | duration | delay，比如all .2s 1s property name | duration | timing function,比如all .2s ease-in 4个属性：property name | duration | timing function | delay，比如all .2s ease-in 1s 默认值：all 0 ease 0 transition 可以为一个元素在不同状态之间切换的时候定义不同的过渡效果。比如在不同的伪元素之间切换，像是:hover，:active 或者通过 JavaScript 实现的状态变化。 注意：一定要设置 transition-duration属性，否则时长为 0，就不会产生过渡效果。 transition属性可以被指定为一个或多个 CSS 属性的过渡效果，多个属性之间用逗号进行分隔。 比如transition: margin-right 4s, color 1s MDN 关于transition 属性 例子：在“百度前端技术学院 第七天学习笔记（CSS position）”的“例子3”中。 语法：1234567891011121314151617181920212223/* 1个 CSS 属性的过渡效果 *//* property name | duration */transition: margin-right 4s;/* property name | duration | delay */transition: margin-right 4s 1s;/* property name | duration | timing function */transition: margin-right 4s ease-in-out;/* property name | duration | timing function | delay */transition: margin-right 4s ease-in-out 1s;/* 2个 CSS 属性的过渡效果 */transition: margin-right 4s, color 1s;/* 所有 CSS 属性的过渡效果 */transition: all 0.5s ease-out;/* Global values */transition: inherit;transition: initial;transition: unset; transition-property属性规定设置过渡效果的 CSS 属性的名称 transition-property属性规定应用过渡效果的 CSS 属性的名称。（当指定的 CSS 属性改变时，过渡效果将开始）。 提示：过渡效果通常在用户将鼠标指针浮动到元素上时发生。 MDN 关于transition-property属性 属性值 描述 none 没有属性会获得过渡效果 all 所有可被动画的属性都表现出过渡动画 IDENT 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔。由小写字母 a 到 z，数字 0 到 9，下划线（_）和破折号（-）组成。第一个非破折号字符不能是数字。同时，不能以两个破折号开头。。 transition-duration属性指定过渡效果时长 transition-duration 属性以秒或毫秒为单位指定过渡动画所需的时间。默认值为 0s ，表示不出现过渡动画。不接受负值。 可以指定多个时长，每个时长会被应用到由 transition-property 指定的对应属性上。 如果指定的时长个数小于属性个数，那么时长列表会重复。如果时长列表更长，那么该列表会被裁减。两种情况下，属性列表都保持不变。 注意：这是一个实验中的功能。此功能某些浏览器尚在开发中，请参考MDN中浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 MDN 关于transition-duration属性 transition-timing-function 属性规定速度效果的速度曲线 该属性允许过渡效果随着时间来改变其速度。 可以规定多个timing function,通过使用 transition-property属性，可以根据主列表(transition property的列表)给每个CSS属性应用相应的timing function. 如果timing function的个数比主列表中数量少，缺少的值被设置为初始值（ease） 。如果timing function比主列表要多，timing function函数列表会被截断至合适的大小。这两种情况下声明的CSS属性都是有效的。 属性值 描述 linear 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。 ease 默认值，规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。 ease-in 规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。 ease-out 规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。 ease-in-out 规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。 cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。 注意：这是一个实验中的功能。此功能某些浏览器尚在开发中，请参考MDN中浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 MDN 关于transition-timing-function 属性 transition-delay属性定义过渡效果何时开始 transition-delay属性规定了在过渡效果开始作用之前需要等待的时间。 属性值以秒（s）或毫秒（ms）为单位，表明动画过渡效果将在何时开始。取值为正时会延迟一段时间来响应过渡效果；取值为负时会导致过渡立即开始。 可以指定多个延迟时间，每个延迟将会分别作用于你所指定的相符合的css属性（transition-property） 注意：这是一个实验中的功能。此功能某些浏览器尚在开发中，请参考MDN中浏览器兼容性表格以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。 MDN 关于transition-delay属性","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML知识补充（label标签）","slug":"HTML知识补充 label","date":"2019-10-28T11:46:42.000Z","updated":"2019-11-19T08:43:53.496Z","comments":true,"path":"2019/10/28/HTML知识补充 label/","link":"","permalink":"http://yoursite.com/2019/10/28/HTML知识补充 label/","excerpt":"&lt;label&gt;标签 &lt;label&gt;标签为 input 元素定义标注（标记）。","text":"&lt;label&gt;标签 &lt;label&gt;标签为 input 元素定义标注（标记）。 label 元素不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性。如果您在 label 元素内点击文本，就会触发此控件。就是说，当用户选择label 标签时，浏览器就会自动将焦点转到和标签相关的表单控件（input元素）上。 注意：&lt;label&gt; 标签的 for 属性需要与相关元素的 id 属性相同，否则不起作用。 下面例子中的文字“Male”也可以是特殊符号，比如一个问号❔。 例子点击文本“Male”可以发现对应的input元素被选中。 123456789101112131415&lt;html&gt;&lt;body&gt;&lt;p&gt;请点击文本标记之一，就可以触发相关控件：&lt;/p&gt;&lt;form&gt;&lt;label for=\"male\"&gt;Male&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"male\" /&gt;&lt;br /&gt;&lt;label for=\"female\"&gt;Female&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"female\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 具体实现","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第五天学习笔记（CSS浮动）","slug":"百度前端技术学院 第五天学习笔记 （CSS浮动）","date":"2019-10-24T08:20:00.000Z","updated":"2019-11-20T11:44:17.879Z","comments":true,"path":"2019/10/24/百度前端技术学院 第五天学习笔记 （CSS浮动）/","link":"","permalink":"http://yoursite.com/2019/10/24/百度前端技术学院 第五天学习笔记 （CSS浮动）/","excerpt":"补充：margin:auto;与margin: 0 auto; 意思不同。margin:auto=margin:auto auto auto auto，表示上下左右都为auto；margin:0 auto=margin:0 auto 0 auto，表示上下为0，左右为auto； 居中方式不同。margin:auto表示横竖都居中。margin: 0 auto表示横居中，竖不居中。","text":"补充：margin:auto;与margin: 0 auto; 意思不同。margin:auto=margin:auto auto auto auto，表示上下左右都为auto；margin:0 auto=margin:0 auto 0 auto，表示上下为0，左右为auto； 居中方式不同。margin:auto表示横竖都居中。margin: 0 auto表示横居中，竖不居中。 补充：:nth-of-type(n)选择器 选择器匹配属于父元素的特定类型的第 N 个子元素的每个元素. n 可以是数字、关键词或公式。 在MDN的浮动的双列表或三列表的例子中我们用到了这个选择器。 1234div:nth-of-type(1) &#123; width: 48%; float: left; &#125; 上面这个例子是选择了父元素的第一个div子元素。（注意：不是div的第一个子元素，是第一个div元素！！） 更多用法 浮动(float属性) 属性值有left、right。 注意：如果是三列浮动，前面两列最好指定left，第三列指定right。如果第二列和第三列都指定right，那么第二列会显示在最右边，而第三列会显示在中间，因为第二列源代码顺序上比第三列等级要高 (DOM上第二列先出现并声明了float: right;) ，所以在浮动顺序上也会比第三列等级要高。又因为两者同时像右浮动，所以第二列就会更加地靠右。 参考MDN浮动 Float 可用于实现文字环绕图片，如下：1234img &#123; float: right; margin: 0 0 1em 1em;&#125; 清除浮动( clear 属性) 如果不清楚浮动，所有在浮动下面的自身不浮动的内容都将围绕浮动元素，在最长的列旁边环绕着。 清除浮动原理：通过在浮动元素的末尾添加一个空元素，设置 clear：both属性。 clear 属性值 含义 left 停止任何活动的左浮动 right 停止任何活动的右浮动 both 停止任何活动的左右浮动 当你把clear 属性应用到一个元素上时，它主要意味着”此处停止浮动”,这个元素和源码中后面的元素将不浮动，除非您稍后将一个新的float声明应用到此后的另一个元素。 注意及时清理浮动，必要时增加clearfix块。（不推荐使用）&lt;div class=&quot;clearfix&quot;&gt;&lt;/div&gt;来设定.clearfix {clear: both;}使得自他以后的元素都清除浮动。 建议使用::after 伪元素来清除浮动： 12.clearfix::after &#123;content:\".\"; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; ::after的意思是在.clearfix内部的最后加入伪元素::after 首先要显示伪元素，所以display:block 然后为伪元素加入空内容，以便伪元素中不会有内容显示在页面中，所以， content:&quot;&quot;；(.也可以，只要加上visibility:hidden;) 其次，为使伪元素不影响页面布局，将伪元素高度设置为0，所以， height:0 最后，要清除浮动，所以，clear:both。 after伪元素其实是通过 content 在元素的后面生成了内容为一个点的块级元素。这样一来只要设置这两个非浮动元素之间的距离就行了。 浮动中可能遇到的问题给浮动框加上样式时原有的布局有可能因为宽度不够被挤乱 在上面的例子中三列浮动没什么问题，但给这些框加上样式时，比如添加背景、外边距、内边距等等，就有可能出现由于内边距和边界引入的额外宽度，一行容纳不下三列了，因此第三列下降到另外两列之下的情况。 解决问题的方法：通过box-sizing更改盒模型为替代盒模型来保证增加内边距或边界的宽度时，不会使盒子更宽，而是会使内容调整得更窄。 123* &#123; box-sizing: border-box;&#125; 这里要注意的另一小点是，box-sizing 出现可以追溯到Internet Explorer 8，如果明确需要支持较老的浏览器，可能需要手动调整列的宽度，以允许内边距和边界宽度。 非浮动元素的外边距不能用于它们和浮动元素之间来创建空间使用::after 伪元素(利用::after在元素内部插入元素块，从而达到清除浮动的效果)： 12.clearfix:after &#123;content:\".\"; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; ::after的意思是在.clearfix内部的最后加入伪元素::after 首先要显示伪元素，所以display:block 然后为伪元素加入空内容，以便伪元素中不会有内容显示在页面中，所以， content:&quot;&quot;；(.也可以，只要加上visibility:hidden;) 其次，为使伪元素不影响页面布局，将伪元素高度设置为0，所以， height:0 最后，要清除浮动，所以，clear:both。 after伪元素其实是通过 content 在元素的后面生成了内容为一个点的块级元素。这样一来只要设置这两个非浮动元素之间的距离就行了。 注意及时清除浮动元素 我们在文章中建立的简单例子很容易理解，但是当布局变得更加复杂时清理（clearing）也会变得更加复杂。你需要确保所有的浮动都能尽快清除，以避免它们给下方的内容制造麻烦。如果没有一个方便的容器来进行清理，那么在必要的时候使用clearfix块。 使用overflow属性防止浮动的图片溢出容器 浮动的元素存在于正常的文档布局流之外，在某些方面的行为相当奇怪，比如，他们在父元素中所占的面积的有效高度为0（高度塌陷）。此时就要使用overflow属性让浮动的图片可以被包含在其他元素里面了。 overflow属性值 例子中图片比包含它的元素还高， 而且它是浮动的，于是它就溢出到了容器外面。 例子：123img &#123; float: right;&#125; 解决方法：给包含图片的元素增加overflow属性123.clearfix &#123; overflow: auto;&#125; 如果你想要支持IE6，你就需要再加入如下样式：1234.clearfix &#123; overflow: auto; zoom: 1;&#125; 浮动项目的背景高度 浮动的元素存在于正常的文档布局流之外，在某些方面的行为相当奇怪，比如，他们在父元素中所占的面积的有效高度为0（高度塌陷）。 不同列的高度不同会不太美观。 可以使用overflow属性使得浮动元素的内容滚动来解决浮动元素的高度问题。 参考解决方法: Flexbox可以自动地延长列，这样他们就会像最长的一列一样。（具体用法可看下一篇笔记） 将这些列的背景颜色设置为父元素的背景颜色，这样您就不会看到高度是不同的。这是目前最好的选择。 将它们设置为固定的高度（height），并使内容滚动（overflow属性）。 问题 关于闭合浮动与清除浮动(所以应该是闭合还是清除呢？) 其实我们想要达到的效果更确切地说是闭合浮动，而不是单纯的清除浮动，在footer上设置clear：both清除浮动并不能解决warp高度塌陷的问题。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第五天学习笔记（CSS盒模型）","slug":"百度前端技术学院 第五天学习笔记 （CSS盒模型）","date":"2019-10-18T08:20:00.000Z","updated":"2020-02-26T07:54:23.811Z","comments":true,"path":"2019/10/18/百度前端技术学院 第五天学习笔记 （CSS盒模型）/","link":"","permalink":"http://yoursite.com/2019/10/18/百度前端技术学院 第五天学习笔记 （CSS盒模型）/","excerpt":"块和内联布局 水平书写模式时块垂直放置，但在垂直书写模式下块将水平放置：","text":"块和内联布局 水平书写模式时块垂直放置，但在垂直书写模式下块将水平放置： display属性值block 从下方例子中可以看到，display属性block使span元素像一个块元素，独占一行被包含在p元素内。 flex display属性定义框及其内部任何框的行为。 flex的行为就像一个块元素（自己占一行），它显示在新行上并占据其在行内方向上可以使用的所有空间。 如果应用在&lt;ul&gt;上则会让&lt;li&gt;都显示在一行上，并占据其在行内方向上可以使用的所有空间。 block与flex的例子 1234567891011121314151617181920p, ul &#123; border: 2px solid rebeccapurple; padding: .5em;&#125;.block,li &#123; border: 2px solid blue; padding: .5em;&#125;ul &#123; display: flex; list-style: none;&#125;.block &#123; display: block;&#125; 1234567&lt;p&gt;I am a paragraph. A short one.&lt;/p&gt;&lt;ul&gt; &lt;li&gt;Item One&lt;/li&gt; &lt;li&gt;Item Two&lt;/li&gt; &lt;li&gt;Item Three&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;I am another paragraph. Some of the &lt;span class=\"block\"&gt;words&lt;/span&gt; have been wrapped in a &lt;span&gt;span element&lt;/span&gt;.&lt;/p&gt; inlinedisplay属性inline可以让块元素像行内（内联）元素 inline-flexinline-flex与flex比起来更像一个行内元素，它后面如果有一个段落的话，inline-flex容器和段落都在一行上一起运行，而不是像flex显示为块级元素那样将它们换成新行。 inline-block直接从属性名也可以看出他可以让内联的盒子像一个块元素。这个属性可以让内联盒子不与包含他的盒子内容重叠，也就是说他会让内联盒子的width与height属性生效。 123456789span &#123; margin: 20px; padding: 20px; width: 80px; height: 50px; background-color: lightblue; border: 2px solid blue; display: inline-block;&#125; 123&lt;p&gt; I am a paragraph and this is a &lt;span&gt;span&lt;/span&gt; inside that paragraph. A span is an inline element and so does not respect width and height.&lt;/p&gt; display各属性值直观对比图 12345678910111213141516171819p, ul &#123; border: 2px solid rebeccapurple;&#125;span,li &#123; border: 2px solid blue;&#125;ul &#123; display: inline-flex; list-style: none; padding: 0;&#125; .inline &#123; display: inline;&#125; 123456789101112&lt;p&gt; I am a paragraph. Some of the &lt;span&gt;words&lt;/span&gt; have been wrapped in a &lt;span&gt;span element&lt;/span&gt;.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;Item One&lt;/li&gt; &lt;li&gt;Item Two&lt;/li&gt; &lt;li&gt;Item Three&lt;/li&gt;&lt;/ul&gt;&lt;p class=\"inline\"&gt;I am a paragraph. A short one.&lt;/p&gt;&lt;p class=\"inline\"&gt;I am another paragraph. Also a short one.&lt;/p&gt; 盒模型盒子的组成 内容框：显示内容的区域，可以使用width和属性来调整大小height。 填充框：填充物围绕内容位于空白处；可以使用padding和相关属性控制其大小。 边框：边框用于包装内容和任何填充。可以使用border及其相关属性来控制其大小和样式。 边距框：边距是最外层，将内容，填充和边框包装为此框与其他元素之间的空白。可以使用margin及其相关属性来控制其大小。 注意：边距（margin）影响框外的空间以及框在页面上所占的总空间，但它不计入框的实际大小。框的区域在边界处（border）停止，不会延伸到边缘。 标准盒模型 在标准盒模型中，盒子占用的总大小由框的宽度（width）和高度（height）以及任何填充（padding）和边框（border）相加得到。 例子中盒子占用的空间宽度实际上将为410px（350 + 25 + 25 + 5 + 5），高度为210px（150 + 25 + 25 + 5 + 5），因为填充和边框为添加到用于内容框的宽度。 替代盒模型注意：标准盒模型 的宽度只是内容的宽度，不包括padding与border，所以我们一旦设置padding与border就应该设置替代盒模型，以确保我们设置的width就是我们看到的宽度 使用此模型，任何宽度都是页面上可见框的宽度（不用加上padding与border），因此内容区域的宽度是该宽度减去填充和边框的宽度。 默认情况下，浏览器使用标准盒模型。如果要为元素打开替代盒模型，可以通过对其进行设置box-sizing: border-box;来实现。box-sizing是个很新的属性，目前应该像下面例子中那样使用 -webkit-和 -moz-前缀。这可以启用特定浏览器实验中的特性。同时记住它是支持IE8+的： 12345.box &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 如果希望所有元素都使用替代盒模型，请在元素上设置box-sizing属性，然后将所有其他元素设置为继承该值，如： 12345678html &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;*, *::before, *::after &#123; box-sizing: inherit;&#125; 或者： 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; (块之间的)外边距margin折叠 补充：margin可以是负值。 首先，两个兄弟块之间的垂直距离由margin属性 （外边距）确定。 通过两个例子我们可以发现折叠的是两个块之间较小的边距。 也就是说如果有两个具有边距的元素撞在一起，作用于同一个位置的边距将合并为一个边距，即最大单个边距的大小。两个边距撞在一起会合并（折叠），而不是等于两个边距的总和。 属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 例子1：1234p &#123; border: 2px solid green; margin: 20px 0 40px 0;&#125; 1234&lt;div class=\"box\"&gt; &lt;p&gt;文段1&lt;/p&gt; &lt;p&gt;文段2&lt;/p&gt;&lt;/div&gt; 例子2：1234&lt;div class=\"box\"&gt; &lt;p&gt;文段1&lt;/p&gt; &lt;p&gt;文段2&lt;/p&gt;&lt;/div&gt; 1234&lt;div class=\"box\"&gt; &lt;p&gt;文段1&lt;/p&gt; &lt;p&gt;文段2&lt;/p&gt;&lt;/div&gt; 边框border 简写包括border-width、border-style、border-color 也可以只设置单边的这三个属性 例子： 123456789101112.container &#123; border-top: 5px dotted green; border-right: 1px solid black; border-bottom: 20px double rgb(23,45,145);&#125;.box &#123; border: 1px solid #333333; border-top-style: dotted; border-right-width: 20px; border-bottom-color: hotpink;&#125; 123&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;Change my borders.&lt;/div&gt;&lt;/div&gt; 内边距（填充）padding 属性值数量 含义 4 上 右 下 左 3 上 左右 下 2 上下 左右 1 4个方向 12345678910.box &#123; padding-top: 0; padding-right: 30px; padding-bottom: 40px; padding-left: 4em;&#125;.container &#123; padding: 20px;&#125; 123&lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt;Change my padding.&lt;/div&gt;&lt;/div&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"let命令","slug":"let","date":"2019-10-15T13:00:00.000Z","updated":"2019-10-31T11:17:06.218Z","comments":true,"path":"2019/10/15/let/","link":"","permalink":"http://yoursite.com/2019/10/15/let/","excerpt":"了解块级作用域 块级作用域是一个语句，将多个操作封装在一起，通常是放在一个大括号里，没有返回值。（但是对象声明用到的大括号不包括块级作用域，它包括的是对象） 块级作用域之中的每个函数都类似一个代码块。（但是这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块）","text":"了解块级作用域 块级作用域是一个语句，将多个操作封装在一起，通常是放在一个大括号里，没有返回值。（但是对象声明用到的大括号不包括块级作用域，它包括的是对象） 块级作用域之中的每个函数都类似一个代码块。（但是这个代码块不包含它体内的另一个函数内的内容，类似于“我的附庸的附庸不是我的附庸”，函数1所包含的函数2的内容也不属于函数1的代码块） 块级作用域于函数声明 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let ，在块级作用域之外不可引用。 但应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 但为了减轻因此产生的不兼容问题，在ES6环境的浏览器中： 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 ES6 允许块级作用域的任意嵌套先了解一下，匿名立即执行函数表达式（匿名 IIFE）可以用块级作用域实现： 1234567891011// IIFE 写法(function () &#123; var a = 1; console.log(a);&#125;());// 块级作用域写法&#123; let a = 1; console.log(a);&#125; 下面代码使用了一个五层的块级作用域，每一层都是一个单独的作用域。。 1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 注意：内层作用域可以定义外层作用域的同名变量。 let 命令 声明变量，用法类似于var，但是所声明的变量只在let命令所在的代码块内有效。 for循环的计数器，就很合适使用let命令。 for循环的例子(var与let) 首先要明确，for循环有一个特别之处，设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 使用var的例子： 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10,数组a中的10个元素都是打印10 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所以a[0]指向的i以及a[1]到a[8]指向的i都被后来循环的a[9]指向的i（也就是10）覆盖掉了。而局部变量的话就是每循环一次产生一个新的i，所以不会被覆盖。 使用let的例子： 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 暂时性死区 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量从一开始就形成了封闭作用域。凡是在声明之前使用这些变量(包括声明或者赋值)，就会报错。 存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。12345var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; let不允许重复声明不能在函数内部重新声明参数不能在函数内部重新声明参数，这相当于在同一个块级作用域里面两次用let声明变量： 1234567891011function func(arg) &#123; let arg;&#125;func() // 报错function func(arg) &#123; &#123; let arg; &#125;&#125;func() // 不报错，注意这里是两个代码块了（不理解的话可以看下面的另一个例子） 下面的函数有两个代码块，都声明了变量n，运行后输出5。（因为代码块2的变量n不作用于代码块2之外）这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 123456789function f1() &#123; let n = 5; //代码块1定义的变量n if (true) &#123; let n = 10; //代码块2定义的变量n //在这console.log(n);会得到10 &#125; console.log(n); // 5&#125;f1();","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"百度前端技术学院 第四天学习总结","slug":"百度前端技术学院 第四天学习总结","date":"2019-10-13T07:15:05.000Z","updated":"2019-11-19T09:25:21.108Z","comments":true,"path":"2019/10/13/百度前端技术学院 第四天学习总结/","link":"","permalink":"http://yoursite.com/2019/10/13/百度前端技术学院 第四天学习总结/","excerpt":"背景，边框，列表，链接相关属性背景相关属性background简写：","text":"背景，边框，列表，链接相关属性背景相关属性background简写： 属性 值 background-color 特别注意：rgba中的a是透明度（0.0到1.0之间，0.5为半透明）如：rgba(255,255,255,0)完全透明的白色 background-image url(xxx.jpg) background-size 长度:百分比:cover:保留宽高比,使背景图像完全覆盖背景区域contain:把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。 background-repeat repeat-x:在水平方向上重复 repeat-y :在垂直方向上重复no-repeat :不允许图像平铺 background-position 一对或单个关键字、百分数、长度值/混合使用（使用单个则默认另一个关键字是 center）关键字:top、bottom、left、right 和 center 边框相关属性前三个属性可简写border属性：属性 | 值—|—border-style |默认值：none，所以必须记得设置border-style，否则边框就不会出现border-width | 长度值/关键字border-color|命名颜色/十六进制/ RGB 值border-radius|一个或两个长度或百分比，第一个值定义水平半径，第二个值定义垂直半径 列表相关属性可以在 &lt;ul&gt; 或 &lt;ol&gt; 或&lt;li&gt;元素上简写list-style： 属性 值 list-style-type项目符号的类型 默认disc（实心圆） list-style-position列表标志位置 默认 outside list-style-image图像标志 url(xxx.jpg)默认none 链接相关属性选择器四种状态：(他们不是属性！) a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方 a:active - 链接被点击的时刻 注意： a:hover 必须位于 a:link 和 a:visited 之后 a:active 必须位于 a:hover 之后 举例： 1a:link &#123;color:#FF0000;&#125; 属性 属性 值 文本修饰（下划线）text-decoration（多个属性值) 具体参考 背景色background-color 常用俱可 鼠标光标的样式cursor 属性值 文字的轮廓（框）outline 简写：宽度 （outline-width）、样式（outline-style） 、颜色 outline-width 关键字（取决于用户代理）：thin/medium/thick长度：10px/1rem全局值:inherit outline-style 关键字：none(默认值);auto; dotted;dashed; solid; double;groove; ridge;inset; outset;全局值:inherit;initial; unset; CSS 各种选择器的概念，使用方法及使用场景。简单选择器 ID选择器：#ID名称{属性：值;} 类选择器：.类名称{属性：值;} 标签（元素）选择器：html元素名{属性：值;} 通用选择器：*{属性：值;} 属性选择器 属性选择器：[属性名]{CSS样式} 属性和值选择器：[属性名=值]{CSS样式} 属性和（多个）值选择器(类似模糊查找)： 语法 含义 [属性名~=值]{CSS样式} 适用于HTML中由空格分隔的属性值 `[属性名 =值]{CSS样式}` [属性名^=值]{CSS样式} 匹配属性值以指定值开头的每个元素 [属性名$=值]{CSS样式} 匹配属性值以指定值结尾的每个元素 [属性名*=值]{CSS样式} 匹配属性值中包含指定值的每个元素 伪类选择器 :first-child表示一组同级元素中的第一元素 :last-child表示一组同级元素中的最后一个元素 :only-child表示没有任何兄弟姐妹的元素 :invalid设置值无效时的样式 伪元素选择器 注意：使用双冒号，与伪类选择器区分开。 ::first-line伪元素设置文本首行的特殊样式 ::first-letter 伪元素设置文本首字母的特殊样式 ::before伪元素在元素前面插入新内容 派生选择器 用于选择一个标签中的所有另一个标签。（id选择器与类选择器、属性选择器也可以派生） 用空格分隔开两个元素名称。 后代选择器 空格分隔两个选择器名称 选择的元素是其选择器的后代。他们不需要是直接子元素就可以配对(子孙后代都可以)。 儿童组合器 大于号分隔 仅当选择器选择直接子元素时才匹配。层次结构后面的子孙不匹配。（注意：直接子元素并不是一定只有一个，要与伪类选择器:first-child区别开来） 直接相邻的同级选择器 加号分隔 用于选择与层次结构中相同级别的另一个元素相邻的对象。 注意：这两个选择器不仅要是同级别的，还要直接相邻。 一般同级[所有的同级选择器] 用~分隔开两个选择器。 用于选择与层次结构中相同级别的所有指定选择器的对象（包括直接相邻的同级），也可以使用常规的同级组合器。 注意：空格分隔开的是父元素与子元素组成的后代选择器，~分隔开的是同级别的所有指定选择器的对象。 CSS 选择器的优先级 影响优先级的因素从高到低的顺序是：重要性、特异性、源顺序。 注意：并不是整个规则都会被覆盖，只是相同的属性。 源顺序（靠后的获胜）如果有多个选择器作用于同一个元素，则靠后的将获胜。 特异性(计算各个选择器的特异性值) 选择器具有的特异性程度是使用四个不同的值（或成分）来衡量的，可以将其视为千位，百位，十位和个位这四列中的四个个位数： 值 范围 千 如果声明位于style属性内（也称为内联样式）内，则在此列中得一千分。这样的声明没有选择器，因此它们的特异性始终只是1000 百 在此列中为整体选择器中包含的每个ID选择器打分（有几个ID选择器就几百分） 十 在此列中为整体选择器中包含的每个类选择器，属性选择器或伪类计分（注意属性选择器的书写方法） 一 在此列中为整体选择器中包含的每个元素选择器或伪元素*打一分。 重要性!important 超越了上述两个级联的常规规则，但最好不要用。 语法选择器{属性: 属性值 !important;}","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第四天学习笔记（选择器的优先级、了解级联、!important）（4）","slug":"百度前端技术学院 第四天学习笔记（4）","date":"2019-10-13T04:58:05.000Z","updated":"2019-11-19T09:25:59.091Z","comments":true,"path":"2019/10/13/百度前端技术学院 第四天学习笔记（4）/","link":"","permalink":"http://yoursite.com/2019/10/13/百度前端技术学院 第四天学习笔记（4）/","excerpt":"选择器的优先级级联（cascade） 对于相同的选择器，在CSS中排在最后的那个将被使用。","text":"选择器的优先级级联（cascade） 对于相同的选择器，在CSS中排在最后的那个将被使用。 例子： 123456h1 &#123; color: red; &#125;h1 &#123; color: blue; &#125; 1&lt;h1&gt;This is my heading.&lt;/h1&gt; 特异性 有多个选择器作用于同一元素时，类选择器的优先级高于元素选择器。（但这个是针对同一属性的时候，两个选择器没有重合的属性实际都作用于该元素） 例子中有两个适用于h1的规则。类选择器为其规则赋予了更高的特异性，下面的内容h1最终变为红色。因此即使带有颜色的元素选择器的规则在源顺序中排在更下方，类选择器的颜色也将被应用。但元素选择器的其他属性还是会生效。 12345678.main-heading &#123; color: red; /*生效*/&#125; h1 &#123; color: blue; /*未生效*/ text-decoration:underline;/*生效*/&#125; 1&lt;h1 class=\"main-heading\"&gt;This is my heading.&lt;/h1&gt; 继承（Inheritance） 如果在元素上设置color和font-family，除非它直接应用了不同的颜色和字体值，否则其中的每个元素也将使用该颜色和字体的样式。 某些属性不会继承。width, margin, padding,border 等内容不会继承。例如，如果在width元素上设置50％的值，则其所有后代的宽度都不会达到其父级宽度的50％。 例子： 1234567body &#123; color: blue;&#125;span &#123; color: black;&#125; 12&lt;p&gt;As the body has been set to have a color of blue this is inherited through the descendants.&lt;/p&gt;&lt;p&gt;We can change the color by targetting the element with a selector, such as this &lt;span&gt;span&lt;/span&gt;.&lt;/p&gt; 提示：在MDN CSS属性参考页上，通常可以在规格部分的底部找到一个技术信息框，其中列出了有关该属性的许多数据点，包括是否继承。例如，MDN颜色属性 通过四个属性值控制继承CSS提供了四个特殊的通用属性值来控制继承。每个CSS属性都接受这些值。 属性值 作用 inherit继承 将应用于选定元素的属性值设置为其父元素的属性值 initial 最初的 将应用于所选元素的属性值设置为与浏览器默认样式表中为该元素设置的值相同。如果浏览器的默认样式表未设置任何值，就会继承该属性，相当于将属性值设置为inherit。 unset 重置 将属性重置为其自然值，这意味着，如果该属性是自然继承的，则其行为类似于inherit，否则，其行为类似于initial。 新值 revert 它对浏览器的支持有限。revert 例子： 123456789101112131415body &#123; color: green;&#125; .my-class-1 a &#123; color: inherit/*设置为其父元素的属性值*/&#125; .my-class-2 a &#123; color: initial;/*设置为与浏览器默认样式表中为该元素设置的值相同*/&#125; .my-class-3 a &#123; color: unset;/*重置为其自然值.如果该属性是自然继承的，则其行为类似于inherit，否则，其行为类似于initial*/&#125; 123456&lt;ul&gt; &lt;li&gt;Default &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt; &lt;li class=\"my-class-1\"&gt;Inherit the &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt; &lt;li class=\"my-class-2\"&gt;Reset the &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt; &lt;li class=\"my-class-3\"&gt;Unset the &lt;a href=\"#\"&gt;link&lt;/a&gt; color&lt;/li&gt;&lt;/ul&gt; 如果添加a { color: red; }则 通过all属性重置所有属性值 all速记属性一次控制（几乎）所有属性的继承，该属性将其值应用于所有属性。这是撤消对样式所做的更改的便捷方法。 属性值：inherit，initial，unset，和revert inherit关键字允许作者显式指定的继承,它适用于继承和非继承属性。可以使用all速记属性一次控制所有属性的继承，该属性将其值应用于所有属性。例如： 12345font: &#123; all: revert; font-size: 200%; font-weight: bold;&#125; 这会将font属性的样式还原为用户代理的默认样式，除非存在用户样式表，否则将使用该样式表。然后将字体大小加倍，并应用font-weight的”bold”。 默认样式表由浏览器供应商提供。(浏览器默认的CSS)用户样式表由浏览器的用户提供,用户自定义的CSS（用户自己写的）。作者样式表由网页作者提供（前端开发人员写的CSS)。 例子： 12345678blockquote &#123; background-color: red; border: 2px solid green;&#125; .fix-this &#123; all: unset;&#125; 1234567&lt;blockquote&gt; &lt;p&gt;This blockquote is styled&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote class=\"fix-this\"&gt; &lt;p&gt;This blockquote is not styled&lt;/p&gt;&lt;/blockquote&gt; 了解级联 要考虑三个因素，这里按重要性从高到低的顺序列出。较早的优先于较晚的：重要性、特异性、源顺序。 注意：并不是整个规则都会被覆盖，只是相同的属性。 源顺序（Source order）如果有多个选择器作用于同一个元素，则靠后的将获胜，也就是说靠后的选择器更加接近元素，他们将覆盖早期的规则，直到最后一个规则获胜并开始为元素设置样式。 特异性（Specificity） 选择器具有的特异性程度是使用四个不同的值（或成分）来衡量的，可以将其视为千位，百位，十位和个位这四列中的四个个位数： 值 范围 千 如果声明位于style属性内（也称为内联样式）内，则在此列中得一千分。这样的声明没有选择器，因此它们的特异性始终只是1000 百 在此列中为整体选择器中包含的每个ID选择器打分（有几个ID选择器就几百分） 十 在此列中为整体选择器中包含的每个类选择器，属性选择器或伪类计分（注意属性选择器的书写方法） 一 在此列中为整体选择器中包含的每个元素选择器或伪元素打一分。 例子： 12345678&lt;div id=\"outer\" class=\"container\"&gt; &lt;div id=\"inner\" class=\"container\"&gt; &lt;ul&gt; &lt;li class=\"nav\"&gt;&lt;a href=\"#\"&gt;One&lt;/a&gt;&lt;/li&gt; &lt;li class=\"nav\"&gt;&lt;a href=\"#\"&gt;Two&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* specificity: 0101 */#outer a &#123; background-color: red;&#125; /* specificity: 0201 */#outer #inner a &#123; background-color: blue;&#125;/* specificity: 0104 */#outer div ul li a &#123; color: yellow;&#125;/* specificity: 0113 */#outer div ul .nav a &#123; color: white;&#125;/* specificity: 0024 */div div li:nth-child(2) a:hover &#123; border: 10px solid black;&#125;/* specificity: 0023 */div li:nth-child(2) a:hover &#123; border: 10px dashed black;&#125;/* specificity: 0033 */div div .nav:nth-child(2) a:hover &#123; border: 10px double black;&#125;a &#123; display: inline-block; line-height: 40px; font-size: 20px; text-decoration: none; text-align: center; width: 200px; margin-bottom: 10px;&#125;ul &#123; padding: 0;&#125;li &#123; list-style-type: none;&#125; 解释： 前两个选择器在争夺链接背景颜色的样式上竞争,第二个选择器获胜并使背景颜色变成蓝色，因为它在链中有一个额外的ID选择器,其特异性是201对101。 第三和第四个选择器正在争夺链接文本颜色的样式,第二个选择器获胜并使文本变成白色，因为尽管元素选择器（1分）少了一个，但缺少的选择器却换成了一个类选择器(10分)。因此获胜的特异性是113比104。 选择器5–7在争夺链接边框的样式。选择器6显然输给了5，特异性为23 vs. 24，链中元素选择器少了一个。但是，选择器7击败了5和6，它在子链中具有与五个相同的子选择器数量，但是一个元素已换成类选择器。因此获胜的特异性是33 vs. 23和24。 重要性（!important） 他可以用来推翻所有上述计算，但是使用它时应格外小心。!important用于使特定属性和值成为最特定的事物，从而超越了级联的常规规则。 语法：选择器{属性: 属性值 !important;} 注意：覆盖此!important声明的方法是在源顺序中稍后的同样特异性的声明中包含另一个!important声明，或者在更高特异性的声明中包含另一个!important声明。 强烈建议除非绝对必要，否则不要使用它。!important更改了级联的正常工作方式，因此可能很难解决调试CSS问题. 例子： 123456789101112131415#winning &#123; background-color: red; border: 1px solid black;&#125; .better &#123; background-color: gray; border: none !important;&#125; p &#123; background-color: blue; color: white; padding: 5px;&#125; 12&lt;p class=\"better\"&gt;This is a paragraph.&lt;/p&gt;&lt;p class=\"better\" id=\"winning\"&gt;One selector to rule them all!&lt;/p&gt; 解释： 可以看到已应用了第三条规则color和padding值，但尚未应用background-color。为什么？确实应该确实适用所有这三个规则，因为源顺序中的后面的规则通常会覆盖前面的规则。 但是，上面的规则会获胜，因为类选择器比元素选择器具有更高的特异性。 这两种元素都有class的better，但第二个一个有一个id的winning了。由于ID 比类具有更高的特异性（页面上每个ID只能具有一个元素，但是具有相同类的许多元素-ID选择器针对的对象非常具体），红色背景色和1像素黑色边框应同时应用于第二个元素，第一个元素将获得灰色背景色，并且没有边框（如该类所指定）。 第二个元素的确获得红色背景色，但没有边框。为什么？由于!important第二条规则中的声明-后面加上该字符串border: none意味着即使ID具有更高的特异性，此声明也将超过上一条规则中的边界值。 声明覆盖顺序（针对冲突声明）冲突声明将按以下顺序应用，后面的声明将覆盖前面的声明： 用户代理样式表中的声明（例如，浏览器的默认样式，未设置其他样式时使用）。 用户样式表中的常规声明（用户设置的自定义样式）。 作者样式表中的常规声明（这些是我们，Web开发人员设置的样式）。 作者样式表中的重要声明。 用户样式表中的重要声明。 最后，注意到CSS声明的重要性取决于在其中指定的样式表，这也是有用的。用户可以设置自定义样式表中的！important来覆盖开发人员的样式。 说明: Web开发人员的样式表覆盖用户样式表是有意义的，因此可以按预期进行设计。 但是如上所述，用户有充分的理由覆盖Web开发人员样式时可以通过!important在其规则中使用来实现。例如，用户可能在视觉上有缺陷，并且想要将所访问的所有网页上的字体大小设置为正常大小的两倍，以便于阅读","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第四天学习笔记（伪类选择器、组合）（3）","slug":"百度前端技术学院 第四天学习笔记（3）","date":"2019-10-11T12:58:05.000Z","updated":"2020-11-21T04:38:53.424Z","comments":true,"path":"2019/10/11/百度前端技术学院 第四天学习笔记（3）/","link":"","permalink":"http://yoursite.com/2019/10/11/百度前端技术学院 第四天学习笔记（3）/","excerpt":"伪类选择器伪类选择器：是已有元素的一种状态下的样式，它不是真实存在的元素（和伪元素要区分开） :first-child表示一组同级元素中的第一元素","text":"伪类选择器伪类选择器：是已有元素的一种状态下的样式，它不是真实存在的元素（和伪元素要区分开） :first-child表示一组同级元素中的第一元素 例子： 1234567891011&lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3 &lt;ul&gt; &lt;li&gt;Item 3.1&lt;/li&gt; &lt;li&gt;Item 3.2&lt;/li&gt; &lt;li&gt;Item 3.3&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 12345678ul li &#123; color: blue;&#125;ul li:first-child &#123; color: red; font-weight: bold;&#125; :last-child表示一组同级元素中的最后一个元素 用法与:first-child相似。 :only-child表示没有任何兄弟姐妹的元素 例子1： 123456789&lt;div&gt; &lt;div&gt;I am an only child.&lt;/div&gt;&lt;/div&gt;&lt;div&gt; &lt;div&gt;I am the 1st sibling.&lt;/div&gt; &lt;div&gt;I am the 2nd sibling.&lt;/div&gt; &lt;div&gt;I am the 3rd sibling, &lt;div&gt;but this is an only child.&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 123456789div:only-child &#123; color: red;&#125;div &#123; display: inline-block; margin: 6px; outline: 1px solid;&#125; 例子2： 1234567891011121314&lt;ol&gt; &lt;li&gt;First &lt;ul&gt; &lt;li&gt;This list has just one element.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;Second &lt;ul&gt; &lt;li&gt;This list has three elements.&lt;/li&gt; &lt;li&gt;This list has three elements.&lt;/li&gt; &lt;li&gt;This list has three elements.&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ol&gt; 12345678li li &#123; list-style-type: disc;&#125;li:only-child &#123; color: red; list-style-type: square;&#125; :invalid设置值无效时的样式 用于在表单元素中的值是非法时设置指定样式。该伪类对于突出显示用户的字段错误很有用。 例子 参考 :checked表示某些特定的元素被选中 :checked表示任何处于选中状态的radio(), checkbox () 或(“select”) 元素中的option HTML元素(“option”)。 用户通过勾选/选中元素或取消勾选/取消选中，来改变该元素的 :checked状态。 MDN 关于:checked 可以通过:checked借用隐藏的checkbox来切换元素的样式（无需使用JavaScript），比如“CSS选择器 知识点汇总”中的例子 :hover鼠标移到时添加的特殊样式可参考菜鸟教程 :nth-child(n) 选择器（CSS3） E:nth-child(n)选择器匹配E元素的父元素中的第 n 个子元素E（假设该子元素不是E，则选择符无效），元素类型没有限制。n 可以是一个数字，一个关键字，或者一个公式。 父元素最高是body 例子中注意：p:nth-child(2)选择是属于其父元素的第二个子元素的每个 p（不是第二个p元素） 提示: 请参阅选择器。该选择器匹配同类型中的第 n 个同级兄弟元素。 伪元素 注意：按照规范，应该使用双冒号（::）而不是单个冒号（:），以便区分伪类和伪元素。 伪元素选择器：不会出现在HTML中，也不会出现在DOM树中，但它是真实存在的元素，它可以在页面上显示内容、设置样式等等。 语法： 1selector::pseudo-element &#123;property:value;&#125; 补充：很久以前 伪元素选择器 刚出现时也是和 伪类选择器 一样使用单冒号的，所以去兼容一些老旧的IE时也有可能需要使用单冒号来写伪元素选择器，否则可能显示不出来，这是历史遗留问题。 从MDN了解更多伪元素 CSS 类也可以与伪元素配合使用： 1selector.class::pseudo-element &#123;property:value;&#125; 伪元素与 CSS 类配合使用的例子： 123456p.article::first-letter &#123; color: #FF0000; &#125;&lt;p class=\"article\"&gt;This is a paragraph in an article。&lt;/p&gt; 上面的例子会使所有 class 为 article 的段落的首字母变为红色。 ::first-line 伪元素设置文本首行的特殊样式 用于向文本的首行设置特殊样式,只能用于块级元素。 在下面的例子中，浏览器会根据 “first-line” 伪元素中的样式对 p 元素的第一行文本进行格式化：12345p::first-line &#123; color:#ff0000; font-variant:small-caps; &#125; ::first-letter 伪元素设置文本首字母的特殊样式 用于向文本的首字母设置特殊样式,只能用于块级元素。 ::before 伪元素在元素前面插入新内容 可以在元素的内容前面插入新内容。 下面的例子在每个 &lt;h1&gt; 元素前面插入一幅图片：1234h1::before &#123; content:url(logo.gif); &#125; 组合后代选择器（Descendant selector） 用空格分隔开两个选择器。 这些选择器选择的元素是其选择器的后代。他们不需要是直接子元素就可以配对(子孙后代都可以)。 通过这个概念我们遇到父元素有class时子元素就不需要再添加额外的class了。 例子： 123.box p &#123; color: red;&#125; 12&lt;div class=\"box\"&gt;&lt;p&gt;Text in .box&lt;/p&gt;&lt;/div&gt;&lt;p&gt;Text not in .box&lt;/p&gt; 儿童组合器（Child combinator） 用大于号分隔开两个选择器。 仅当选择器选择直接子元素时才匹配。层次结构后面的子孙不匹配。（注意：直接子元素并不是一定只有一个，要与伪类选择器:first-child区别开来） 例子： 123ul &gt; li &#123; border-top: 5px solid red;&#125; 1234567891011&lt;ul&gt; &lt;!--这个`&lt;li&gt;`是`&lt;ul&gt;`的直接子元素--&gt; &lt;li&gt;Unordered item&lt;/li&gt; &lt;!--这个`&lt;li&gt;`也是`&lt;ul&gt;`的直接子元素--&gt; &lt;li&gt;Unordered item &lt;ol&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt;&lt;/ul&gt; 上面的例子中有一个无序列表，嵌套在其中的是另一个无序列表。我正在使用子组合器来选择仅&lt;li&gt;是&lt;ul&gt;的直接子元素的元素，并为其赋予了顶部边框。 如果删除&gt;,则最终&lt;li&gt;将得到后代选择器，所有元素都将显示红色边框。 直接相邻的同级选择器(Adjacent sibling) 又叫“兄弟选择器” 用加号分隔开两个选择器。 用于选择与层次结构中相同级别的另一个元素相邻的对象。 注意：这两个选择器不仅要是同级别的，还要直接相邻。 例子： 123456h1 + p &#123; font-weight: bold; background-color: green; color: #fff; padding: .5em;&#125; 12345678&lt;article&gt; &lt;h1&gt;A heading&lt;/h1&gt; &lt;p&gt;Veggies es bonus vobis, proinde vos postulo essum magis kohlrabi welsh onion daikon amaranth tatsoi tomatillo melon azuki bean garlic.&lt;/p&gt; &lt;p&gt;Gumbo beet greens corn soko endive gumbo gourd. Parsley shallot courgette tatsoi pea sprouts fava bean collard greens dandelion okra wakame tomato. Dandelion cucumber earthnut pea peanut soko zucchini.&lt;/p&gt;&lt;/article&gt; 一个常见的用例是对标题后面的段落进行处理，如上面的额例子所示。在这里，我们正在寻找与&lt;h1&gt;相邻的段落，并为其设置样式。 如果在&lt;h1&gt;与&lt;p&gt;之间插入其他元素，例如&lt;h2&gt;，则会发现该段落不再与选择器匹配，因此当该元素相邻时，也不会应用背景色和前景色。 一般同级（General sibling）[所有同级选择器] 用~分隔开两个选择器。 用于选择与层次结构中相同级别的所有指定选择器的对象（包括直接相邻的同级），也可以使用常规的同级组合器。 注意：空格分隔开的是父元素与子元素组成的后代选择器，~分隔开的是同级别的所有指定选择器的对象。 例子： 123456h1~p &#123; font-weight: bold; background-color: #333; color: #fff; padding: .5em;&#125; 123456&lt;article&gt; &lt;h1&gt;A heading&lt;/h1&gt; &lt;p&gt;I am a paragraph.&lt;/p&gt; &lt;div&gt;I am a div&lt;/div&gt; &lt;p&gt;I am another paragraph.&lt;/p&gt;&lt;/article&gt;","categories":[{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第四天学习笔记（CSS边框、列表）（2）","slug":"百度前端技术学院 第四天学习笔记（2）","date":"2019-10-09T13:04:38.000Z","updated":"2019-11-19T09:27:19.636Z","comments":true,"path":"2019/10/09/百度前端技术学院 第四天学习笔记（2）/","link":"","permalink":"http://yoursite.com/2019/10/09/百度前端技术学院 第四天学习笔记（2）/","excerpt":"总结 按照 top-right-bottom-left 的顺序设置（不同的四边样式/宽度）","text":"总结 按照 top-right-bottom-left 的顺序设置（不同的四边样式/宽度） 1border-width: 15px 5px 15px 5px; 1border-style: solid dotted dashed double;/*实线上边框、点线右边框、虚线下边框和一个双线左边框*/ border-style 的默认值是 none，如果没有声明样式，就相当于 border-style: none。必须记得设置边框样式border-style，否则边框就不会出现。（不管宽度设置了多少） border简写三个属性123.box &#123; border: 1px solid black; &#125; 相当于 12345.box &#123; border-width: 1px; border-style: solid; border-color: black; &#125; 综合运用例子1234567891011.box &#123; background-color: #567895; border: 5px solid #0b385f;/*宽度为5px ，solid 实线*/ border-bottom-style: dashed;/*底部：dashed虚线,样式与颜色和其他三边一样*/ color: #fff;&#125;h2 &#123; border-top: 2px dotted rebeccapurple;/*顶部：宽度为2px ，dotted 点线，rebeccapurple紫色*/ border-bottom: 1em double rgb(24, 163, 78);/*底部双实线*/&#125; 1234&lt;div class=\"box\"&gt; &lt;h2&gt;Borders&lt;/h2&gt; &lt;p&gt;Try changing the borders.&lt;/p&gt;&lt;/div&gt; 边框样式border-styleborder-style 的默认值是 none，如果没有声明样式，就相当于 border-style: none注意：必须记得设置边框样式border-style，否则边框就不会出现。 定义不同的四边样式：这里的值采用了top-right-bottom-left 的顺序： 12345.box &#123; background-color: #567895; border-width:8px; border-style: solid dotted dashed double;/*实线上边框、点线右边框、虚线下边框和一个双线左边框*/&#125; 定义单边样式： border-top-style border-right-style border-bottom-style border-left-style 因此这两种方法是等价的： 12p &#123;border-style: solid solid solid none;&#125;p &#123;border-style: solid; border-left-style: none;&#125; 注意：如果要使用第二种方法，必须把单边属性放在简写属性之后，因为如果把单边属性放在 border-style 之前，简写属性的值就会覆盖单边值 none。 边框宽度 border-width属性值： 长度值 关键字 比如 2px 或 0.1em thin 、medium（默认值） 和 thick 注释：CSS 没有定义 3 个关键字的具体宽度，所以一个用户代理可能把 thin 、medium 和 thick 分别设置为等于 5px、3px 和 2px，而另一个用户代理则分别设置为 3px、2px 和 1px。 定义不同边的宽度按照 top-right-bottom-left 的顺序设置元素的各边边框： border-width: 15px 5px 15px 5px; 也可以简写为（这样写法称为值复制）：border-width: 15px 5px; 定义单边样式： border-top-width border-right-width border-bottom-width border-left-width 边框的颜色 border-color属性值：可以是命名颜色，也可以是十六进制和 RGB 值。 1234p &#123; border-style: solid; border-color: blue rgb(25%,35%,45%) #909090 red; &#125; 默认值： 默认的边框颜色是元素本身的前景色。如果没有为边框声明颜色，它将与元素的文本颜色相同。 如果元素没有任何文本，假设它是一个表格，其中只包含图像，那么该表的边框颜色就是其父元素的文本颜色（因为 color 可以继承）。这个父元素很可能是 body、div 或另一个 table。 值复制：如果颜色值小于 4 个，值复制就会起作用。例如下面的规则声明了段落的上下边框是蓝色，左右边框是红色(按照top-right-bottom-left 的顺序)： 1234p &#123; border-style: solid; border-color: blue red; &#125; 定义单边颜色： border-top-color border-right-color border-bottom-color border-left-color 透明边框transparent：边框颜色值 transparent。这个值用于创建有宽度的不可见边框。 123456a:link, a:visited &#123; border-style: solid; border-width: 5px; border-color: transparent; &#125;a:hover &#123;border-color: gray;&#125; 完整例子 从某种意义上说，利用 transparent，使用边框就像是额外的内边距一样；此外还有一个好处，就是能在你需要的时候使其可见。这种透明边框相当于内边距，因为元素的背景会延伸到边框区域（如果有可见背景的话）。 重要事项：在 IE7 之前，IE/WIN 没有提供对 transparent 的支持。在以前的版本，IE 会根据元素的 color 值来设置边框颜色。 圆角border-radius属性值：一个或两个长度或百分比，第一个值定义水平半径，第二个值定义垂直半径。 1border-radius: 10px; /*使一个框的所有四个角的半径为10px*/ 1border-top-right-radius: 1em 10%; /*使右上角的水平半径为1em，垂直半径为10％*/ 例子: 12345.box &#123; border: 10px solid rebeccapurple; border-radius: 1em; border-top-right-radius: 10% 30%;&#125; 1234&lt;div class=\"box\"&gt; &lt;h2&gt;Borders&lt;/h2&gt; &lt;p&gt;Try changing the borders.&lt;/p&gt;&lt;/div&gt; 列表简写list-style 这个属性可以在 &lt;ul&gt; 或 &lt;ol&gt; 或&lt;li&gt;元素上设置。 属性值可以任意顺序排列，你可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside） list-style-type的默认值是disc（实心圆）list-style-position的默认值是outside（标志出现在列表项内容之外）list-style-image的默认值是none 只要提供了一个值，其它的就会填入其默认值。如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。123li &#123;list-style : url(example.gif) square inside&#125; 列表的项目符号的类型list-style-type 设置列表的项目符号的类型，例如无序列表的方形或圆形项目符号，或有序列表的数字，字母或罗马数字。 取值参考1 把无序列表中的列表项标志设置为方块:1ul &#123;list-style-type : square&#125; 图像标志list-style-image1ul li &#123;list-style-image : url(xxx.gif)&#125; 列表标志位置list-style-position 决定标志出现在列表项内容之外还是内容内部。 默认值为 outside。 设置链接的样式链接的四种状态： a:link - 普通的、未被访问的链接 a:visited - 用户已访问的链接 a:hover - 鼠标指针位于链接的上方 a:active - 链接被点击的时刻 注意： a:hover 必须位于 a:link 和 a:visited 之后 a:active 必须位于 a:hover 之后 举例： 1234a:link &#123;color:#FF0000;&#125; /* 未被访问的链接 */a:visited &#123;color:#00FF00;&#125; /* 已被访问的链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标指针移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 正在被点击的链接 */ 常见的链接样式属性文本修饰（下划线）text-decoration 大多用于去掉链接中的下划线 underline、none 背景色background-color 规定链接的背景色 鼠标光标的样式cursor 不应该把这个关掉，除非你有非常好的理由。 属性值 文字的轮廓（框）outline 轮廓有点像边框，唯一的区别是边框占用了盒模型的空间，而轮廓没有； 它只是设置在背景图片的顶部。 语法： 12/* 宽度 | 样式 | 颜色 */outline: 1px solid white; 取值： 任意顺序的1~3个属性值。 属性 值 outline-width 关键字（取决于用户代理）：thin/medium/thick长度：10px/1rem全局值:inherit outline-style 关键字：none(默认值);auto; dotted;dashed; solid; double;groove; ridge;inset; outset;全局值:inherit;initial; unset; 例子：123456789101112&lt;head&gt;&lt;style&gt;a:link &#123;/* 未被访问的链接 */ background-color:yellow; outline: solid #000;/*黑色实线框*/&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;b&gt;&lt;a href=\"www.huanglizhu.github.io\" target=\"_blank\"&gt;点我点我&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;/body&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"call（）与apply（）","slug":"call()与apply()","date":"2019-10-08T06:26:40.000Z","updated":"2019-11-15T07:14:02.304Z","comments":true,"path":"2019/10/08/call()与apply()/","link":"","permalink":"http://yoursite.com/2019/10/08/call()与apply()/","excerpt":"方法重用：call() 和 apply() 不带参数的使用方法非常相似。 带参数的使用方法有所区别：","text":"方法重用：call() 和 apply() 不带参数的使用方法非常相似。 带参数的使用方法有所区别： 方法 参数 举例 call() 参数列表 person.fullName.call(person1, “Oslo”, “Norway”); apply() 数组形式 person.fullName.apply(person1, [“Oslo”, “Norway”]); 如果要使用数组而不是参数列表，则 apply() 方法非常方便。 面试题语句var arr=[a,b,c,d];执行后，数组arr中每项都是一个整数，能得到其中最大整数语句有： Math.max(arr[0], arr[1], arr[2], arr[3]) Math.max.call(Math, arr[0], arr[1], arr[2], arr[3]) Math.max.apply(Math,arr) 不能得到其中最大整数语句有： 1Math.max(arr) 解析Math的max（）不支持传入数组,所以错误。 JavaScript 函数 Call可以通过 call()调用属于另一个对象的方法。 例子1:普通方法调用 下面的例子创建了带有三个属性的对象（firstName、lastName、fullName）。 12345678var person = &#123; firstName:\"Bill\", lastName: \"Gates\", fullName: function () &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;person.fullName(); // 将返回 \"Bill Gates\" fullName 属性是一个方法。person 对象是该方法的拥有者。 fullName 属性属于 person 对象的方法。 例子2：使用函数 Call分别让person1与person2去调用person的fullName 方法： 123456789101112131415var person = &#123; fullName: function() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;var person1 = &#123; firstName:\"Bill\", lastName: \"Gates\",&#125;var person2 = &#123; firstName:\"Steve\", lastName: \"Jobs\",&#125;person.fullName.call(person1); // 将返回 \"Bill Gates\"person.fullName.call(person2); // 将返回 \"Steve Jobs\" 完整例子 例子3：带参数的 call() 方法让person1带着参数”Seattle”, “USA”去调用person的fullName属性（方法）： 12345678910var person = &#123; fullName: function(city, country) &#123; return this.firstName + \" \" + this.lastName + \",\" + city + \",\" + country; &#125;&#125;var person1 = &#123; firstName:\"Bill\", lastName: \"Gates\"&#125;person.fullName.call(person1, \"Seattle\", \"USA\"); 完整例子 JavaScript 函数 Apply apply()会改变this的指向， 可以通过 apply() 方法调用属于另一个对象的方法。 但不仅限于此，当设置第一个参数为null时可以在某些本来需要写成遍历数组变量的任务中使用内建的函数,也就是说此时apply()的作用不是调用属于另一个对象的方法，而是使参数数组中的每一个元素都去执行func函数。【如：下方例子“使用Apply（）在数组上模拟 max 方法”】 call()方法的作用和 apply() 方法类似，区别就是call()方法接受的是参数列表，而apply()方法接受的是一个参数数组。 apply() 方法调用一个具有给定this值的函数，以及作为一个数组（或类似数组对象）提供的参数。 语法：func.apply(thisArg, [argsArray]) 参数 描述 thisArg 可选的。在 func 函数运行时使用的 this 值。请注意，this可能不是该方法看到的实际值：如果这个函数处于非严格模式下，则指定为 null 或 undefined 时this会自动替换为指向全局对象，原始值会被包装。 argsArray 可选的。一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 func 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。 返回值：调用有指定this值和参数的函数的结果。 描述：在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。你也可以使用 arguments对象作为 argsArray 参数。 arguments 是一个函数的局部变量。 它可以被用作被调用对象的所有未指定的参数。 这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 例子：使用函数Apply让person1去调用person的fullName 方法： 12345678910var person = &#123; fullName: function() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;var person1 = &#123; firstName: \"Bill\", lastName: \"Gates\",&#125;person.fullName.apply(person1); // 将返回 \"Bill Gates\" 例子：带参数的 apply() 方法apply() 方法接受数组中的参数: 12345678910var person = &#123; fullName: function(city, country) &#123; return this.firstName + \" \" + this.lastName + \",\" + city + \",\" + country; &#125;&#125;var person1 = &#123; firstName:\"John\", lastName: \"Doe\"&#125;person.fullName.apply(person1, [\"Oslo\", \"Norway\"]); 完整例子 使用Apply（）在数组上模拟 max 方法Math的max()方法首先我们了解可以使用Math.max() 方法找到（数字列表中的）最大数字： 1Math.max(1,2,3); // 会返回 3 完整例子 让数组调用Math的max()方法 但是JavaScript 数组没有 max() 方法，因此我们可以通过apply（）让数组调用 Math的max() 方法： 1Math.max.apply(null, [1,2,3]); // 也会返回 3 完整例子 第一个参数（null）无关紧要。在本例中未使用它。这些例子会给出相同的结果： Math.max.apply(Math, [1,2,3]); // 也会返回 3 Math.max.apply(&quot; &quot;, [1,2,3]); // 也会返回 3 Math.max.apply(0, [1,2,3]); // 也会返回 3 JavaScript 严格模式在 JavaScript 严格模式下，如果 apply()方法的第一个参数不是对象，则它将成为被调用函数的所有者（对象）。在“非严格”模式下，它成为全局对象。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"函数相关知识点补充","slug":"函数相关知识点补充","date":"2019-10-07T08:10:44.000Z","updated":"2020-06-27T09:34:25.196Z","comments":true,"path":"2019/10/07/函数相关知识点补充/","link":"","permalink":"http://yoursite.com/2019/10/07/函数相关知识点补充/","excerpt":"函数是对象 JavaScript 函数是通过 function 关键词定义的。JavaScript 中的 typeof 运算符会为函数返回 “function”。但是最好是把 JavaScript 函数描述为对象。 JavaScript 函数都有属性和方法。","text":"函数是对象 JavaScript 函数是通过 function 关键词定义的。JavaScript 中的 typeof 运算符会为函数返回 “function”。但是最好是把 JavaScript 函数描述为对象。 JavaScript 函数都有属性和方法。 函数的对象属性arguments.length返回函数被调用时收到的参数数目： 123function myFunction(a, b) &#123; return arguments.length;//2&#125; 完整例子 函数的对象方法toString()以字符串形式返回函数： 12345function myFunction(a, b) &#123; return a * b;&#125;var txt = myFunction.toString(); 完整例子 函数声明与函数表达式函数声明 被声明的函数不会直接执行。它们被“保存供稍后使用”，当它们被调用时执行。 无法对函数声明进行自调用 一个名为multiply的函数声明：123function multiply(x, y) &#123; return x * y;&#125; // 没有分号 函数表达式 JavaScript 函数也可以用表达式来定义。 函数表达式可以在变量中存储。 在变量中保存函数表达式之后，此变量可用作函数. 存放在变量中的函数不需要函数名。他们总是使用变量名调用。 一个匿名函数的函数表达式，被赋值给变量multiply： 123var multiply = function(x, y) &#123; return x * y; &#125;; 一个命名为func_named的函数的函数表达式，被赋值给变量multiply： 123var multiply = function func_name(x, y) &#123; return x * y;&#125;; 注意：在函数外部无法通过 func_name 访问到函数，因为这已经变成了一个表达式。 自调用函数 函数表达式可以自调用。 自调用表达式是自动被调用（开始）的，在不进行调用的情况下。 函数表达式会自动执行，假如表达式后面跟着 ()。 您无法对函数声明进行自调用。 您需要在函数周围添加括号，以指示它是一个函数表达式。 匿名的自调用函数（没有名称的函数）例子(完整例子)： 12345678// 写法1(function () &#123; var x = \"Hello!!\"; //我会调用我自己&#125;)();// 写法2!function () &#123; var x = \"Hello!!\"; //我会调用我自己&#125;(); 写法2解释：! function (){}() 表示该函数是一个函数表达式而不是函数声明，前面的！可以理解成它是将函数声明转化成函数表达式的一种方法。!function (){}()也等同于（function (){})();，！也可换成+、-这样的一元运算符，都可以起到相同的作用。这些运算符会将后面的函数体当成一个整体，先对匿名函数进行求值，然后在对结果进行运算。 变量与函数提升 关于提升MDN 首先要明确，变量是声明被提升，函数在ES5中是整个函数被提升，在ES6中是只提升函数的声明（具体见例子），函数内容（变量初始化的值）是不会被提升的，他们将被留在原来的位置。 这导致了JavaScript 函数能够在声明之前被调用，不过会undefined，还是建议规范书写代码。 ES6之前只有全局作用域和函数作用域，这两个作用域都存在变量提升。 var命令声明的变量，不管在什么位置，变量声明都会被提升到当前作用域的头部。（变量的提升只会对var命令声明的变量有效，其他不是用var命令声明的变量，不会发生变量的提升。） 注意：变量的提升只存在全局/函数作用域中，if(){}或for(){}都不是函数作用域，他们里面的变量会提升到包裹他们的全局/函数作用域的顶部。 ES6中取代var的let命令的作用域限定在块级，使用let声明的变量不存在变量提升。 函数和变量相比，会被优先提升。这意味着函数会被提升到更靠前的位置。 ES5中说，在全局和函数作用域中定义的函数的声明和定义都将会被提前到当前作用域的顶部。 补充：当出现多个同名变量与同名函数时，调用该变量名时的优先级为：变量声明&lt; 函数声明 &lt; 变量赋值（具体参考牛客网20191215第7题） 通过函数声明方式创建的函数会被提升，通过表达式方法创建的函数不会被提升： 变量提升 ES6之前只有全局作用域和函数作用域，这两个作用域都存在变量提升。 var命令声明的变量，不管在什么位置，变量声明都会被提升到当前作用域的头部。（变量的提升只会对var命令声明的变量有效，其他不是用var命令声明的变量，不会发生变量的提升。） ES6中取代var的let命令的作用域限定在块级，使用let声明的变量不存在变量提升。 注意：变量声明被提升到了当前作用域的头部， ES6之前只有全局作用域和函数作用域，if不是函数作用域，所以变量tmp提升到了foo函数的头部。123456789101112function foo(x) &#123; if (x &gt; 100) &#123; var tmp = x - 100; &#125;&#125; // 等同于function foo(x) &#123; var tmp;//注意：提升到了if的外面 if (x &gt; 100) &#123; tmp = x - 100; &#125;; 函数提升通过声明创建的函数会被提升，通过表达式创建的函数不会被提升： 例子我们正常书写的代码： 12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 实际在内存中被函数提升以后： 123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); 在ES5中，在if内声明的函数f会被提升到函数头部（作用域顶部）。 1234567891011// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined;//函数f的声明提升 if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 而在ES6中，块级作用域内声明的函数，行为类似于var声明的变量。（只提升声明）函数f是在块级作用域内被声明的，因此函数f的声明被提升到了块级作用域的顶部。 箭头函数 IE11 或更早的版本不支持箭头函数。 箭头函数允许使用简短的语法来编写函数表达式。 不需要 function 关键字、return 关键字和花括号。 1234567// ES5var x = function(x, y) &#123; return x * y;&#125;// ES6const x = (x, y) =&gt; x * y; 箭头函数没有自己的 this。它们不适合定义对象方法。 箭头函数未被提升。它们必须在使用前进行定义。 使用 const 比使用 var 更安全，因为函数表达式始终是常量值。 如果函数是单个语句，则只能省略 return 关键字和大括号。因此，保留它们可能是一个好习惯： 1const x = (x, y) =&gt; &#123; return x * y &#125;; 返回对象需要注意如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错： 12// SyntaxError:x =&gt; &#123; foo: x &#125; 因为和函数体的{ ... }有语法冲突，所以要改为： 12// ok:x =&gt; (&#123; foo: x &#125;) 可参考廖雪峰的博客 箭头函数的this指向箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this。 因此，在下面的代码中，传递给setInterval的函数内的this与封闭函数中的this值相同： 123456789function Person()&#123; this.age = 0; setInterval(() =&gt; &#123; this.age++; // |this| 正确地指向 p 实例 &#125;, 1000);&#125;var p = new Person(); (详细可参考MDN) 与严格模式的关系鉴于 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。 12var f = () =&gt; &#123; 'use strict'; return this; &#125;;f() === window; // 或者 global 与call()/apply()/bind()由于 箭头函数没有自己的this指针，所有通过 call()/apply()/bind() 方法调用一个函数时，只能传递参数，不能绑定this，即 他们的第一个参数会被忽略。 return 当在函数体中使用return语句时，函数将会停止执行。 如果指定一个值，则这个值返回给函数调用者。 如果省略该值，则返回undefined。 返回多个值可以放到对象中： 1234return &#123; aa:20, bb:30&#125; return是关键字，不是函数，其后面的括号不是必须的，加括号易于阅读代码。 可参考MDN 例子： 12345function square(x) &#123; return x * x;&#125;var demo = square(3);// demo will equal 9 HTML事件绑定函数时不加括号 加括号就是直接执行函数了，不加括号则是指向函数地址，当事件发生时才去调用函数。 事件=function(){}或者事件=函数名都是可以的，不能使用事件=(function(){})(参数)或事件=函数名()。 事件绑定函数传参如果事件绑定函数想要传参可以将传参的函数放到另一个匿名函数中，事件绑定该匿名函数。 例子：想要使用onclick事件绑定一个想传参的函数。我们将传参的函数放入匿名函数中，再让onclick事件绑定该匿名函数: 1xx.onclick=function()&#123;函数名(参数);&#125; 或者 1xx.onclick= ()=&gt;&#123;函数名(参数)&#125; 在这里不能直接绑定函数名(参数)传参是因为函数名(参数)直接执行了函数，而onClick需要绑定的事件函数是不能立即执行的，所以需要新建一个 箭头函数/匿名函数 让他不立即执行。 区分react和html中的事件写法 react中是onClick html中是onclick","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"js对象 学习笔记（2）","slug":"js对象 学习笔记（2）","date":"2019-10-06T13:55:06.000Z","updated":"2019-10-07T07:03:50.451Z","comments":true,"path":"2019/10/06/js对象 学习笔记（2）/","link":"","permalink":"http://yoursite.com/2019/10/06/js对象 学习笔记（2）/","excerpt":"JavaScript 对象访问器（Getter 和 Setter）Getter 和 Setter与函数相比的优点： 它提供了更简洁的语法（Getter 和 Setter使用属性形式访问对象方法，不用加括号）","text":"JavaScript 对象访问器（Getter 和 Setter）Getter 和 Setter与函数相比的优点： 它提供了更简洁的语法（Getter 和 Setter使用属性形式访问对象方法，不用加括号） 它允许属性和方法的语法相同 它可以确保更好的数据质量 有利于后台工作 Getter（get 关键词）12345678910111213141516171819202122&lt;body&gt;&lt;p&gt;Getter 和 Setter 允许您通过方法获取和设置属性。&lt;/p&gt;&lt;p&gt;此示例使用 lang 属性来获取语言属性的值。&lt;/p&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;// 创建对象：var person = &#123; firstName: \"Bill\", lastName : \"Gates\", language : \"en\", get lang() &#123; return this.language; &#125;&#125;;// 使用 getter 显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.lang;&lt;/script&gt;&lt;/body&gt; 完整例子 Setter（set 关键词）1234567891011121314var person = &#123; firstName: \"Bill\", lastName : \"Gates\", language : \"\", set lang(lang) &#123; this.language = lang; &#125;&#125;;// 使用 setter 来设置对象属性：person.lang = \"en\";// 显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.language; 完整例子 JavaScript 函数与 Getter的访问方法不同例子1使用函数： 12345678910var person = &#123; firstName: \"Bill\", lastName : \"Gates\", fullName : function() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;;// 使用方法来显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.fullName(); 例子2使用Getter： 12345678910var person = &#123; firstName: \"Bill\", lastName : \"Gates\", get fullName() &#123; return this.firstName + \" \" + this.lastName; &#125;&#125;;// 使用 getter 来显示来自对象的数据：document.getElementById(\"demo\").innerHTML = person.fullName; 总结： 例子 1 以函数形式访问 fullName：person.fullName()。 例子 2 以属性形式访问 fullName：person.fullName。 第二个例子提供了更简洁的语法。 JavaScript 对象构造器总结 用大写首字母对构造器函数命名是个好习惯。 123456function Person(first, last, age, eye) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eye;&#125; 给已有对象添加属性： 1对象名.新属性名=\"新属性值\" 给已有对象添加新方法: 1对象名.新方法名=function()&#123;函数内容&#125; 给构造器添加新属性: 方法1：回到构造器函数中进行增加。 方法2：构造器名.prototype.新属性名=&quot;新属性值&quot; 给构造器添加新方法： 方法1：回到构造器函数中进行增加。 方法2：构造器名.prototype.新方法名=function(){函数内容} 对象类型（蓝图）（类） 在上面的例子中，函数 Person() 就是对象构造器函数。 通过 new 关键词调用构造器函数可以创建相同类型的对象：12var myFather = new Person(\"Bill\", \"Gates\", 62, \"blue\");var myMother = new Person(\"Steve\", \"Jobs\", 56, \"green\"); 完整例子 this 关键词 在 JavaScript 中，被称为 this 的事物是代码的“拥有者”。 this 的值，在对象中使用时，就是对象本身。 在构造器函数中，this 是没有值的。它是新对象的替代物。 当一个新对象被创建时，this 的值会成为这个新对象。 请注意 this 并不是变量。它是关键词。您无法改变 this 的值。 为(已有)对象添加属性新属性被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 1myFather.nationality = \"English\"; 为(已有)对象添加方法新方法被添加到 myFather。不是 myMother，也不是任何其他 person 对象。 123myFather.name = function () &#123; return this.firstName + \" \" + this.lastName;&#125;; 为构造器添加属性 为(已有)对象添加新属性与新方法都很简单，但与他们不同，为对象构造器添加新属性必须添加到构造器函数内（错误示范：像Person.nationality = &quot;English&quot;;这样会undefined） 1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor; this.nationality = \"English\";&#125; 这样对象属性就可以拥有默认值。 完整例子 为构造器添加方法 同样无法为对象构造器添加新方法，必须在构造器函数内部向一个对象添加方法：12345678910111213141516171819202122232425&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;// Person 对象的构造器函数function Person(firstName,lastName,age,eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; //在构造器函数内部向一个对象添加方法 this.changeName = function (name) &#123; //changeName() 函数把 name 赋值给 person 的 lastName 属性 this.lastName = name; &#125;&#125;// 创建 Person 对象var myFriend = new Person(\"Bill\",\"Gates\",62,\"green\");// 修改姓氏myFriend.changeName(\"Jobs\");// 显示姓氏document.getElementById(\"demo\").innerHTML =\"My friend's last name is \" + myFriend.lastName;&lt;/script&gt; 完整例子 内建 JavaScript 构造器Math() 对象不算，Math 是全局对象。new 关键词不可用于 Math。 12345678var x1 = &#123;&#125;; // 新对象var x2 = \"\"; // 新的原始字符串var x3 = 0; // 新的原始数值var x4 = false; // 新的原始逻辑值var x5 = []; // 新的数组对象var x6 = /()/ // 新的正则表达式对象var x7 = function()&#123;&#125;; // 新的函数对象var x8 = new Date(); // 一个新的 Date 对象 完整例子 JavaScript 对象原型所有 JavaScript 对象都从原型继承属性和方法。 原型继承 日期对象继承自 Date.prototype。 数组对象继承自 Array.prototype。 Person 对象继承自 Person.prototype。 Object.prototype 位于原型继承链的顶端：日期对象、数组对象和 Person 对象都继承自 Object.prototype。 使用 prototype 属性为对象构造器添加新属性/方法注意：请只修改自己的原型。绝不要修改标准 JavaScript 对象的原型。 为对象构造器添加新属性：1234567function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.nationality = \"English\"; 完整例子 为对象构造器添加新方法：123456789function Person(first, last, age, eyecolor) &#123; this.firstName = first; this.lastName = last; this.age = age; this.eyeColor = eyecolor;&#125;Person.prototype.name = function() &#123; return this.firstName + \" \" + this.lastName;&#125;; 完整例子","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"hexo中hipaper主题——解决小火箭被目录覆盖问题","slug":"解决小火箭被目录覆盖问题","date":"2019-10-05T10:29:00.000Z","updated":"2019-10-05T10:51:10.641Z","comments":true,"path":"2019/10/05/解决小火箭被目录覆盖问题/","link":"","permalink":"http://yoursite.com/2019/10/05/解决小火箭被目录覆盖问题/","excerpt":"出问题页面F12 发现目录覆盖小火箭","text":"出问题页面F12 发现目录覆盖小火箭 找出样式表 通过style.css找到样式表位置在css文件夹里 全局搜索找到toc-fixed全局搜索真的很重要！一开始在style.styl里面搜索了好久都找不到 打开E:\\Program Files\\Hexo\\themes\\hipaper\\source\\css 在css文件夹内空白处右键打开vscode 点击左边放大镜图标，全局搜索toc-fixed 发现我们要修改的实际上在E:\\Program Files\\Hexo\\themes\\hipaper\\source\\css\\ partial\\article.styl里面 修改为width: 350px !important; 发现小火箭不会被覆盖了","categories":[{"name":"hexo中遇到过的问题与解决方案","slug":"hexo中遇到过的问题与解决方案","permalink":"http://yoursite.com/categories/hexo中遇到过的问题与解决方案/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"hipaper","slug":"hipaper","permalink":"http://yoursite.com/tags/hipaper/"}]},{"title":"js对象 学习笔记（1）","slug":"js对象 学习笔记（1）","date":"2019-10-03T12:31:00.000Z","updated":"2019-10-07T07:03:24.094Z","comments":true,"path":"2019/10/03/js对象 学习笔记（1）/","link":"","permalink":"http://yoursite.com/2019/10/03/js对象 学习笔记（1）/","excerpt":"对象 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。","text":"对象 在 JavaScript 中，几乎“所有事物”都是对象。所有 JavaScript 值，除了原始值，都是对象。 布尔是对象（如果用 new 关键词定义） 数字是对象（如果用 new 关键词定义） 字符串是对象（如果用 new 关键词定义） 日期永远都是对象 算术永远都是对象 正则表达式永远都是对象 数组永远都是对象 函数永远都是对象 对象永远都是对象 原始值 原始值指的是没有属性或方法的值。 原始数据类型指的是拥有原始值的数据。 JavaScript 定义了 5 种原始数据类型： string number boolean null undefined 原始值是一成不变的（它们是硬编码的，因此不能改变）。 假设 x = 3.14，您能够改变 x 的值。但是您无法改变 3.14 的值。 对象定义 对象是包含变量的变量 JavaScript 对象是命名值的集合。 对象也是变量。但是对象能够包含很多值。 值按照名称 : 值对的形式编写（名称和值以冒号分隔）。1var person = &#123;firstName:\"Bill\", lastName:\"Gates\", age:62, eyeColor:\"blue\"&#125;; 对象属性 属性指的是与 JavaScript 对象相关的值。 JavaScript 对象是无序属性的集合。 属性通常可以被修改、添加和删除，但是某些属性是只读的。 firstName、lastName、age、eyeColor就是属性。 访问对象属性的两种方法 您可以使用 .property (例子1 )或[&quot;property&quot;]( 例子2) JavaScript for…in 循环JavaScript for…in 语句遍历对象的属性。 123for (variable in object) &#123; 要执行的代码&#125; for…in 循环中的代码块会为每个属性执行一次。 1234567891011121314151617&lt;body&gt;&lt;h1&gt;JavaScript 对象属性&lt;/h1&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;var txt = \"\";var person = &#123;fname:\"Bill\", lname:\"Gates\", age:62&#125;; var x;for (x in person) &#123; txt += person[x] + \" \";&#125;document.getElementById(\"demo\").innerHTML = txt;&lt;/script&gt;&lt;/body&gt; 在这里，x依次是fname、lname、age。 例子运行效果 添加新属性 可以通过简单的赋值，向已存在的对象添加新属性。 不能使用预留词作为属性名（或方法名）。请使用 JavaScript 命名规则。1person.nationality = \"English\"; 完整例子 删除属性 delete 关键词会同时删除属性的值和属性本身。 删除完成后，属性在被添加回来之前是无法使用的。 delete 操作符被设计用于对象属性。它对变量或函数没有影响。 delete 操作符不应被用于预定义的 JavaScript 对象属性。这样做会使应用程序崩溃。12var person = &#123;firstName:\"Bill\", lastName:\"Gates\", age:62, eyeColor:\"blue\"&#125;;delete person.age; // 或 delete person[\"age\"]; 完整例子 JavaScript 对象继承了它们的原型的属性。 delete 关键词不会删除被继承的属性，但是如果您删除了某个原型属性，则将影响到所有从原型继承的对象。 对象方法 方法是可以在对象上执行的动作。 对象属性可以是原始值、其他对象以及函数。 对象方法是包含函数定义的对象属性。 属性 值 firstName Bill fullName function() {return this.firstName + “ “ + this.lastName;} this 关键词 在 JavaScript 中，被称为 this 的事物，指的是拥有该 JavaScript 代码的对象。 this 的值，在函数中使用时，是“拥有”该函数的对象。 请注意 this 并非变量。它是关键词。您无法改变 this 的值。 创建与访问对象方法 创建对象方法： 1methodName : function() &#123; 代码行 &#125; 访问对象方法： 1objectName.methodName() 此例访问 person 对象的 fullName() 方法：例子 如果访问 fullName 属性时没有使用 ()，则将返回函数定义：例子 使用内建方法 此例使用 String 对象的 toUpperCase() 方法，把文本转换为大写：12var message = \"Hello world!\";var x = message.toUpperCase(); x 的值，在以上代码执行后将是： 1HELLO WORLD! 添加新的方法向对象添加方法是在构造器函数内部完成的：(更多相关知识在js对象 学习笔记（2）中的“JavaScript 对象构造器”内) 123456789function person(firstName, lastName, age, eyeColor) &#123; this.firstName = firstName; this.lastName = lastName; this.age = age; this.eyeColor = eyeColor; this.changeName = function (name) &#123; this.lastName = name; &#125;;&#125; changeName() 函数 name 的值赋给了 person 的 lastName 属性。 1myMother.changeName(\"Jobs\"); 完整例子 通过用 myMother “替代” this。 this 的值，在对象中使用时，就是对象本身。 在构造器函数中，this 是没有值的。它是新对象的替代物。 当一个新对象被创建时，this 的值会成为这个新对象。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"外联样式表没有效果，但是内联正常的解决方法","slug":"综合课程问题1","date":"2019-10-02T12:10:37.000Z","updated":"2019-10-20T08:42:51.828Z","comments":true,"path":"2019/10/02/综合课程问题1/","link":"","permalink":"http://yoursite.com/2019/10/02/综合课程问题1/","excerpt":"在做学校综合课程的大作业时遇到的问题外联样式表没有效果，但是内联正常的解决方法外联css不起作用但是内联样式表没问题时，可能是服务器端缓存导致样式不刷新了?反正解决方法是： 右键“刷新”按钮 点击“清空缓存并硬性重新加载”","text":"在做学校综合课程的大作业时遇到的问题外联样式表没有效果，但是内联正常的解决方法外联css不起作用但是内联样式表没问题时，可能是服务器端缓存导致样式不刷新了?反正解决方法是： 右键“刷新”按钮 点击“清空缓存并硬性重新加载” &lt;c:url&gt;标签 标签中的value属性如果以/开头，则标签会在重新生成的URL中加上当前Web应用的根路径。 例子 如果你想在login.jsp（路径是goods/WebRoot/jsps/user/login.jsp）里面外联样式表goods/WebRoot/jsps/css/user/login.css,但当前web应用的根路径是http://localhost:8080/goods,所以要想使用login.css要用&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;&lt;c:url value=&#39;/jsps/css/user/login.css&#39;/&gt;&quot;&gt;，他会自动在前面补上当前web应用的路径，也就相当于goods/WebRoot/jsps/css/user/login.css了。 如果不这样写的话，经过UserServlet刷新以后有可能读不到外联的样式表。（因为经过请求转发以后路径变了，依照普通的写法就读不到我们想要的样式表了，这个时候就要借助&lt;c:url&gt;标签） 在通常情况下，我们的JSP和这些资源文件的引入都是正常的，也就是说浏览器在解析页面的时候可以通过路径找到这些资源文件；而当我们在内部Servlet处理页面传回来的数据的时候，如果我们进行了请求转发，并且请求转发给了JSP（嵌入JAVA代码的JSP页面可以看成是一个Servlet），最后由JSP返回页面数据，那么这个过程是纯服务端操作，在客户端浏览器并不知情； 通俗点说，即假设A与B不在一个路径下且其外部资源路径都与自己同目录下存放，浏览器向A发起了一个请求，A不想干，让B去干，然后由B返回给浏览器结果，但是浏览器以为还是A发来的，这个时候浏览器还是把A所需要的外部资源给B，结果发现不是B所需要的！","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"AJAX异步更新","slug":"AJAX异步更新","date":"2019-10-02T12:10:37.000Z","updated":"2020-08-10T12:03:38.967Z","comments":true,"path":"2019/10/02/AJAX异步更新/","link":"","permalink":"http://yoursite.com/2019/10/02/AJAX异步更新/","excerpt":"什么是 AJAX ？ AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），意思就是用JavaScript执行异步网络请求。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。 用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象","text":"什么是 AJAX ？ AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML），意思就是用JavaScript执行异步网络请求。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。 用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。 在现代浏览器上写AJAX主要依靠XMLHttpRequest对象 步骤 创建XMLHttpRequest对象：通过检测window对象是否有XMLHttpRequest属性来判断浏览器是否支持标准的XMLHttpRequest，创建XMLHttpRequest对象（不支持则创建ActiveXObject对象）。 判断对象状态：通过XMLHttpRequest的onreadystatechange事件（以及readyState还有status属性）判断对象状态（请求是否初始化、服务器连接是否建立、请求是否接收、请求是否处理中、请求是否已完成且响应已就绪）。 获取响应数据：判断到“请求已完成且响应已就绪”时可使用XMLHttpRequest 对象的 responseText 或 responseXML 属性来获得响应数据。 向服务器发送请求：使用XMLHttpRequest 对象（或者ActiveXObject对象）的 open() 和 send() 方法向服务器发送请求。 12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function loadXMLDoc()&#123;var xmlhttp;//1.创建XMLHttpRequest对象if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;//2.每当XMLHttpRequest对象状态发生变化时，调用onreadystatechange属性xmlhttp.onreadystatechange=function() &#123;//3.通过readyState和status判断请求是否初始化等（具体看readyState参数值） if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123;//4.判断出“请求已完成，且响应已就绪”时, //通过responseText属性获取来自服务器响应的数据 document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;//5.向服务器发送请求xmlhttp.open(\"GET\",\"/ajax/test1.txt\",true);xmlhttp.send();&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"myDiv\"&gt;&lt;h2&gt;Let AJAX change this text&lt;/h2&gt;&lt;/div&gt;&lt;button type=\"button\" onclick=\"loadXMLDoc()\"&gt;通过 AJAX 改变内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 原链接 使用多个AJAX任务的步骤 如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。 该函数调用应该包含 URL (发送请求时open方法的参数url)以及发生 onreadystatechange 事件（发生状态变化）时执行的任务（每次调用可能不尽相同） 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;var xmlhttp;//标准函数loadXMLDocfunction loadXMLDoc(url,cfunc)&#123;//1.判断是否含有XMLHttpRequest属性，创建对象if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;//2.每当 XMLHttpRequest对象状态发生改变时，就会调用onreadystatechange（也就是cfunc）xmlhttp.onreadystatechange=cfunc;//4.向服务器发送请求xmlhttp.open(\"GET\",url,true);xmlhttp.send();&#125;function myFunction()&#123;loadXMLDoc(\"/ajax/test1.txt\",function() &#123;//3.调用标准函数，把url传入并编写标准函数中的cfunc（即：每当XMLHttpRequest对象状态发生改变时会调用的函数） if (xmlhttp.readyState===4 &amp;&amp; xmlhttp.status===200) &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"myDiv\"&gt;&lt;h2&gt;Let AJAX change this text&lt;/h2&gt;&lt;/div&gt;&lt;button type=\"button\" onclick=\"myFunction()\"&gt;通过 AJAX 改变内容&lt;/button&gt;&lt;/body&gt;&lt;/html&gt; 原链接 AJAX 的基础：XMLHttpRequest() XMLHttpRequest 对象用于和服务器交换数据。 创建 XMLHttpRequest 对象 所有现代浏览器（IE7+、Firefox、Chrome、Safari 以及 Opera）均内建 XMLHttpRequest 对象。 但是老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象. 所以为了应对所有的现代浏览器，包括 IE5 和 IE6，请检查浏览器是否支持 XMLHttpRequest 对象。如果支持，则创建 XMLHttpRequest 对象。如果不支持，则创建 ActiveXObject ： 123456789var xmlhttp;if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest();//创建 XMLHttpRequest 对象 &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");//创建ActiveX 对象 &#125; 通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest。注意，不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性，一是因为这个字符串本身可以伪造，二是通过IE版本判断JavaScript特性将非常复杂。 向服务器发送请求 如需将请求发送到服务器，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：12xmlhttp.open(\"GET\",\"test1.txt\",true);xmlhttp.send(); 方法 描述 open(method,url,async) 规定请求的类型、URL 以及是否异步处理请求。 method:请求的类型,GET 或 POSTurl:文件在服务器上的位置async:true（异步）或 false（同步）,默认true，可不写 send(string) 将请求发送到服务器。string:仅用于 POST 请求 最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。 GET 还是 POST？ 与 POST 相比，GET 更简单也更快，并且在大部分情况下都能用。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 注意区分:表单中的method属性值默认GET，推荐使用 POST（更加安全）。 GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。 服务器响应如需获得来自服务器的响应，请使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性。 属性 描述 responseText 获得字符串形式的响应数据 responseXML 获得 XML 形式的响应数据 responseText属性1document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; responseXML 属性 如果来自服务器的响应是 XML，而且需要作为 XML 对象进行解析，请使用 responseXML 属性： 请求 books.xml 文件，并解析响应： 12345678xmlDoc=xmlhttp.responseXML;txt=\"\";x=xmlDoc.getElementsByTagName(\"ARTIST\");for (i=0;i&lt;x.length;i++) &#123; txt=txt + x[i].childNodes[0].nodeValue + \"&lt;br /&gt;\"; &#125;document.getElementById(\"myDiv\").innerHTML=txt; 完整例子 onreadystatechange 事件 每当 readyState 改变时(即XMLHttpRequest对象的状态发生变化时)，就会触发 onreadystatechange 事件。 类似image对象的onload事件和onerror事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化1: 服务器连接已建立2: 请求已接收3: 请求处理中4: 请求已完成，且响应已就绪 status 200: “OK” ；404: 未找到页面 在 onreadystatechange 事件中，我们规定当服务器响应已做好被处理的准备时所执行的任务。 当 readyState 等于 4 且状态为 200 时，表示响应已就绪。 使用 Callback 函数 callback 函数是一种以参数形式传递给另一个函数的函数。 如果您的网站上存在多个 AJAX 任务，那么您应该为创建 XMLHttpRequest 对象编写一个标准的函数，并为每个 AJAX 任务调用该函数。 该函数调用应该包含 URL (发送请求时open方法的参数url)以及发生 onreadystatechange 事件（发生状态变化）时执行的任务（每次调用可能不尽相同） 函数调用： 1234567891011function myFunction()&#123;//调用标准函数，把url传入并编写标准函数中的cfunc（即：每当readyState 属性改变时会调用的函数）loadXMLDoc(\"/ajax/test1.txt\",function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById(\"myDiv\").innerHTML=xmlhttp.responseText; &#125; &#125;);&#125; 被调用的标准的函数： 1234567891011121314151617function loadXMLDoc(url,cfunc)&#123;//判断是否含有XMLHttpRequest属性，创建对象if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;//每当 readyState 属性改变时，就会调用onreadystatechange（也就是cfunc）xmlhttp.onreadystatechange=cfunc;//向服务器发送请求xmlhttp.open(\"GET\",url,true);xmlhttp.send();&#125; 例子 jQuery中的ajax方法注意：HTTP请求的类型不止GET和POST，还有PUT、PATCH、DELETE $.ajax()执行异步 AJAX 请求 ajax() 方法用于执行 AJAX（异步 HTTP）请求。 所有的 jQuery AJAX 方法都使用 ajax() 方法。该方法通常用于其他方法不能完成的请求。 语法：$.ajax({name:value, name:value, ... }) 返回值：一个Promise对象 该参数规定 AJAX 请求的一个或多个名称/值对。 url:规定发送请求的 URL。默认是当前页面。 success(result,status,xhr):当请求成功时运行的函数。 更多参数可参考菜鸟教程 例子 $.get()使用 AJAX 的 HTTP GET 请求从服务器加载数据 $.get() 方法使用 HTTP GET 请求从服务器加载数据。 语法：$.get(URL,data,function(data,status,xhr),dataType) 返回值：一个Promise对象 例子 $.post()使用 AJAX 的 HTTP POST 请求从服务器加载数据 $.post() 方法使用 HTTP POST 请求从服务器加载数据. 语法：$(selector).post(URL,data,function(data,status,xhr),dataType) 返回值：一个Promise对象 例子 中断ajax请求XMLHttpRequest.abort() 可参考MDN 文档 jquery ajax abort() 可参考这篇文章 廖雪峰关于AJAX的文章","categories":[{"name":"AJAX学习","slug":"AJAX学习","permalink":"http://yoursite.com/categories/AJAX学习/"}],"tags":[{"name":"AJAX","slug":"AJAX","permalink":"http://yoursite.com/tags/AJAX/"}]},{"title":"JS中的同步与异步","slug":"js同步与异步","date":"2019-10-01T10:00:05.000Z","updated":"2020-03-31T04:24:06.047Z","comments":true,"path":"2019/10/01/js同步与异步/","link":"","permalink":"http://yoursite.com/2019/10/01/js同步与异步/","excerpt":"","text":"作用域 作用域就是代码的执行环境，全局执行环境就是全局作用域，函数的执行环境就是私有作用域，它们都是栈内存。总的来说，作用域就是代码执行时开辟的栈内存。 总结 描述 私有作用域 函数执行都会形成一个私有作用域 全局作用域 页面一打开就会形成一个全局的作用域 私有变量 在私有作用域里边形成的变量 (通过 var 声明； 形参) 全局变量 在全局作用域形成的变量（var a = 12 或者函数内没有声明，直接赋值的变量） 某个执行环境中所有的代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出时，如关闭浏览器或网页，才会被销毁） 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将被环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 作用域链 当代码在一个环境中执行时，会创建变量对象的一个作用域链（作用域形成的链条） 作用域链的前端，始终都是当前执行的代码所在环境的变量对象 作用域链中的下一个对象来自于外部环境，而在下一个变量对象则来自下一个外部环境，一直到全局执行环境 全局执行环境的变量对象始终都是作用域链上的最后一个对象 内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。 所以执行函数时，作用域链是从内到外来排序的。（有形参找形参，没有才找外部的全局变量） 形参与实参 参数 概念 形参（形式参数） 是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。 实参（实际参数） 是在调用时传递给函数的参数，即传递给被调用函数的值。 形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元。因此，形参只在函数内部有效。函数调用结束返回主调用函数后则不能再使用该形参变量。（随着函数被调用而新建，随着函数销毁而销毁） 函数调用中发生的数据传送是单向的，即只能把实参的值传给形参，而不能把形参的值传给实参。因此，在函数调用的过程中，形参的值可以改变，而实参的值则不会变化。 参考 执行栈例子注意：执行函数时，作用域链是从内到外来排序的。（有形参找形参，没有才找外部的全局变量） 1234567var count = 0;function foo(count) &#123;//count形参 count += 1;//私有变量count console.log(count);//私有变量count&#125;foo(count); // 1 count实参foo(count); // 1 函数的形参属于函数执行上下文，所以当指定这个形参后，它就随着函数被调用而新建，随着函数销毁而销毁。 指定了这个形参，调用函数时传递进来的实参count（0）会沿着作用域链找到私有变量 count（接下来的操作都在私有变量上进行），而不是全局变量count。 步骤我们用执行栈来理解一下 函数每次被调用都会产生新的执行上下文（私有变量 count），实参count（全局变量count）的数据（0）被传入函数，私有变量 count变为0，并被压入执行栈，执行完毕后输出1，当前上下文接着被弹出执行栈，私有变量 count被销毁。 再次调用时又随着函数被调用而新建私有变量 count，重复第一步。 （函数内的操作都在私有变量身上进行，随着私有变量的销毁上一次的操作就没了）所以第一次调用应该返回 1，第二次调用也应该返回 1，第 n 次调用都应该返回 1。 1234567var count = 0;function foo() &#123; count += 1;//全局变量count console.log(count);//全局变量count&#125;foo(count); // 1foo(count); // 2 函数的形参属于函数执行上下文，所以当指定这个形参后，它就随着函数被调用而新建，随着函数销毁而销毁。如果不指定这个形参，实参count（0）传进函数以后找不到形参就会沿着作用域链找到全局变量 count，它属于全局执行上下文，这个时候再去调用 foo() 函数就会读写这个全局变量（也就是函数里的所有操作都是在全局变量上进行的）。 全局变量不会随着函数的调用而新建，也不会随着函数的销毁而销毁。 每个 foo() 函数调用后，给 count（全局变量） 加一，然后被弹出执行栈，而全局执行上下文的生命周期将伴随着整个程序，所以第一次调用打印 1，第二次调用打印 2，第 n 次调用打印 n。 JS的同步与异步为什么会有同步和异步因为JavaScript是单线程，因此单一时间内只能处理单一任务，所有任务都需要排队，前一个任务执行完，才能继续执行下一个任务。但是，如果前一个任务的执行时间很长，比如文件的读取操作或ajax操作，后一个任务就不得不等着，拿ajax来说，当用户向后台获取大量的数据时，不得不等到所有数据都获取完毕才能进行下一步操作，用户只能在那里干等着，严重影响用户体验。因此，JavaScript在设计的时候，就已经考虑到这个问题，主线程可以完全不用等待文件的读取完毕或ajax的加载成功，可以先挂起处于等待中的加载任务，先运行排在后面的任务，等到文件的读取或ajax有了结果后，再回过头执行挂起的任务（这就是异步），因此，任务就可以分为同步任务和异步任务。 同步任务同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。当我们打开网站时，网站的渲染过程，比如元素的渲染，其实就是一个同步任务。 异步任务异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程。当我们打开网站时，像图片的加载，音乐的加载，其实就是一个异步任务 js的执行机制（事件循环） 同步任务进入总线程，异步任务不会进入主线程，而是会先进入任务队列，任务队列其实是一个先进先出的数据结构，也是一个事件队列。 比如说文件读取操作，因为这是一个异步任务，因此该任务会被添加到任务队列中，等到IO（输入输出）完成后，就会在任务队列中添加一个事件，表示异步任务准备好啦，可以进入执行栈啦~但是这时候呀，主线程不一定有空，当主线程处理完其它任务有空时，就会读取任务队列，读取里面有哪些事件，排在前面的事件会被优先进行处理，如果该任务指定了回调函数，那么主线程在处理该事件时，就会执行回调函数中的代码，也就是执行异步任务啦 单线程从从任务队列中读取任务是不断循环的，每次栈被清空后，都会在任务队列中读取新的任务，如果没有任务，就会等，直到有新的任务，这就叫做任务循环，因为每个任务都是由一个事件触发的，因此也叫作事件循环。 步骤总结： 所有同步任务都在主线程上执行，行成一个执行栈 主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件 一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面还有哪些事件，那些对应的异步任务，于是结束等待状态，（异步任务）进入执行栈，开始执行 主线程不断的重复上面的第三步 注意：同步任务由JS引擎执行，异步任务挂起时由浏览器的引擎执行，直到有了结果才放入任务队列等待被执行。 宏任务和微任务 所有同步任务和异步任务又会分为宏任务和微任务，所以异步任务中也分先后。 可参考笔记宏任务和微任务 js的异步编程回调函数这是异步编程最基本的方法。 例：假定有两个函数f1和f2，后者等待前者的执行结果，如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函数。【此时f2是异步的，她耗费的时间并不影响同步任务的执行】12345678910111213function f2() &#123; console.log(\"f2\");&#125;console.log(\"start\");function f1(callback) &#123; console.log(\"f1\"); setTimeout(function () &#123; callback(); &#125;, 1000);&#125;f1(f2);console.log(\"end\");// start f1 end f2 Promise可参考笔记Promise1、Promise2、Promise3. 事件监听任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 例：为f1绑定一个事件，当f1发生done事件，就执行f2。 发布/订阅与”事件监听”类似。 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。 前端使用异步的场景 定时任务：setTimeout，setInverval(可参考笔记“setTimeout()与setInterval()”） 网络请求：ajax请求，动态&lt;img&gt;加载 事件绑定：事件函数绑定以后并不会等触发事件函数才继续执行程序，程序照常执行，等需要触发的时候才会执行事件绑定函数。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"从输入url到页面显示都经历了什么","slug":"从输入url到页面显示都经历了什么","date":"2019-09-27T12:05:01.000Z","updated":"2020-11-03T08:23:04.619Z","comments":true,"path":"2019/09/27/从输入url到页面显示都经历了什么/","link":"","permalink":"http://yoursite.com/2019/09/27/从输入url到页面显示都经历了什么/","excerpt":"从输入url到页面显示都经历了什么（可参考简书、知乎） 客户端（浏览器）： DNS解析：通过输入的域名解析到一个IP地址； 建立TCP连接（三次握手）； 发送http请求。 服务端： server接收到http请求（Request），处理，并返回HTTP报文（Response）。（具体处理过程在“开发博客项目之接口(1)”中的“nodejs处理HTTP请求”中）（res返回的都是字符串，只是形式不同，通过content-type来决定，比如html或者json） 客户端（浏览器）： 接收到服务端返回的数据，处理数据（如渲染页面，执行js）。","text":"从输入url到页面显示都经历了什么（可参考简书、知乎） 客户端（浏览器）： DNS解析：通过输入的域名解析到一个IP地址； 建立TCP连接（三次握手）； 发送http请求。 服务端： server接收到http请求（Request），处理，并返回HTTP报文（Response）。（具体处理过程在“开发博客项目之接口(1)”中的“nodejs处理HTTP请求”中）（res返回的都是字符串，只是形式不同，通过content-type来决定，比如html或者json） 客户端（浏览器）： 接收到服务端返回的数据，处理数据（如渲染页面，执行js）。 具体流程： 客户端： DNS解析：首先需要找到这个url域名的服务器ip,为了寻找这个ip，先搜索浏览器自身的DNS缓存,如果存在，则域名解析到此完成。如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试读取操作系统的hosts文件看是否存在对应的映射关系,如果存在，则域名解析到此完成。如果本地hosts文件不存在映射关系，则查找本地DNS服务器(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。如果本地DNS服务器还没找到的话,它就会向根服务器发出请求,进行递归查询。 建立TCP连接（三次握手）：客户机发送一个TCP连接请求报文-》服务器回送一个TCP确认响应报文-》客户机向服务器发送一个包含“HTTP请求”与“TCP确认”的报文 发送http请求：浏览器根据这个ip以及相应的端口号，构造一个http请求，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个http请求封装在一个tcp包中，这个tcp包会依次经过传输层，网络层，数据链路层，物理层到达服务器。 服务端服务器解析这个请求来作出响应，返回相应的html给浏览器。 客户端： 构建DOM树：浏览器根据这个html来构建DOM树 构建CSS对象模型CSSOM：解析html过程中遇到引入了css，则会在解析html的同时解析css，根据外部样式，内部样式，内联样式构建CSS对象模型CSSOM 建议CSS写在head中：页面边解析边渲染，如果把CSS写在HTML后，则先解析DOM树渲染在页面上，再生成CSSOM合成渲染树重新渲染在页面上，这样会有一个过程，用户可能会看到一个过程变化。所以在DOM树生成之前就先生成CSSOM会更好，这样当DOM树生成时就可直接和所有CSSOM进行合并，一步渲染完成。 合并为渲染树： CSSOM树构建完成后CSSOM树和DOM树合并为渲染树，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点。 最后浏览器将渲染树绘制到屏幕上显示。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 回流：浏览器去计算各个元素（盒模型）的位置和大小等 重绘：当盒模型的位置,大小以及其他属性，如颜色,字体等确定下来之后，浏览器便开始绘制内容 注意:在渲染树的渲染过程中如果遇到JS脚本和外部JS连接，则会停止渲染（因为JS有可能修改DOM结构）来执行和下载相应的代码，这会造成阻塞，这就是为什么推荐JS代码应该放在html代码的后面。 js的解析涉及同步、异步（宏任务与微任务），事件循环 另外的HTTP请求： html文件中会含有 图片、视频、音频、js、jquery、css等其他资源，这些又是另外的HTTP请求。在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，可能会通过一个网页产生很多的HTTP请求，请求越少性能越好。 为提高性能要关注缓存（强缓存和协商缓存），缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 Cache-Control和Expires的区别在于Cache-Control使用相对时间，Expires使用的是基于服务器 端的绝对时间，因为存在时差问题，一般采用Cache-Control。 在请求这些有设置了缓存的数据时，如是强缓存，则不发送请求，直接从缓存中获取数据。 如是协商缓存，则会发送请求到服务器，如果上一次 响应设置了ETag值，则会在这次请求的时候作为If-None-Match的值交给服务器校验，如果一致，继续校验客户端发送的IF-Modified-Since与服务端的 Last-Modified是否一致，没有设置ETag则直接验证Last-Modified，都一致则返回304（Not Changed）告知浏览器可以直接从缓存获取，否则返回最新的资源内容。 连接结束：主机向服务器发送一个断开连接的请求（不早了，我该走了）；服务器接到请求后发送确认收到请求的信号（知道了）；服务器向主机发送断开通知（我也该走了）；主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； 实例演示客户端（浏览器）进行DNS解析 DNS解析的过程就是寻找哪台机器上有你需要资源的过程。 当你在浏览器中输入一个地址时，例如http://www.baidu.com，其实不是百度网站真正意义上的地址。 互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。 当然如果你直接输入的是另一台电脑的IP地址来访问它，那么则不存在这一步。 例子：浏览器或者操作系统本身是有缓存的，如果是 缓存过期 或者 没有缓存 又或者是 第一次访问，浏览器 或者 操作系统 就会去域名工程商去通过域名去DNS服务器换取IP地址。（更多详情需要复习 计算机网络 ）server端就是这个IP地址的服务器！！（百度比较大，全国各地使用人数多，看到的IP地址不一样是正常的，就算是自己今天看到的和昨天看到的不一样也是很正常的） 建立TCP连接客户端找到IP地址之后就会和这个IP地址的服务器（server端）进行TCP连接（三次握手） 握手 作用 第1次 客户端（浏览器）询问服务器（server端）：“你是否可以使用？”【客户机发送一个TCP连接请求报文 】 第2次 服务器（server端）回答客户端（浏览器）：“我可以用。”【服务器回送一个TCP确认响应报文】 第3次 客户端（浏览器）告诉服务器（server端）：“我知道啦，我来访问你啦。”【客户机向服务器发送一个包含“HTTP请求”与“TCP确认”的报文】 计算机网络知识补充：HTTP是无状态协议：服务器不保存关于客户机的任何信息。HTTP协议使用的底层运输协议是TCP。TCP是面向连接（握手）的、可靠的传输服务，TCP协议能保证交付所有的数据，但并不保证这些数据传输的速率以及期待的传输时延（不适合实时应用，实时应用可采用无握手过程的UDP协议，不过UDP是不可靠数据传输）。 客户端（浏览器）发送http请求例子：客户端（浏览器）通过url使用get方法向服务端发送http请求，头部包含了请求信息，他们告诉了服务端这个客户端（浏览器）是什么样子的以及有什么要求。（注意：请求req都是客户端发起的，而回复res都是服务端做的。） HTTP请求报文 HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，浏览器向服务器发出一个 HTTP 请求。 HTTP请求报文 是由三部分组成: 请求行, 首部行和报文主体。 HTTP请求报文（get）： HTTP请求报文（post）： 请求行（请求方法 URI 协议/版本）： 例如：GET/sample.jsp HTTP/1.1“GET”代表请求方法，“/sample.jsp”表示URI，“HTTP/1.1代表协议和协议的版本。 POST/sample.jsp HTTP/1.1，POST方法之后是URI(“/sample.jsp”)，表示请求的页面地址，“/”表示服务器的根目录。之后是表示http的版本。 首部行包含许多有关的客户端环境和请求正文的有用信息。例如，声明浏览器所用的语言，请求正文的长度等。例如： Accept:image/gif.image/jpeg.*/*请求的对象类型。如果是“/”表示任意类型，如果是指定的类型，则会变成“type/”。 Accept-Language:zh-cn使用的语言种类 Connection:Keep-Alive对于HTTP连接的处理，keep-alive表示保持连接，如果是在响应报文中发送页面完毕就会关闭连接，状态变为close。 Host:localhost连接的目标主机，如果连接的服务器是非标准端口，在这里会出现使用的非标准端口。 User-Agent:Mozila/4.0(compatible:MSIE5.01:Windows NT5.0)提供了客户端浏览器的类型和版本 Accept-Encoding:gzip,deflate.页面编码种类 报文主体 报文首部 和 报文主体 之间是一个空行，这个行非常重要，它表示 报文首部 已经结束，接下来的是 报文主体。 报文主体 中可以包含客户提交的查询字符串信息：username=jinqiao&amp;password=1234 在实际应用中，HTTP请求报文主体可以包含更多的内容。 server端接收http请求，处理并返回我们已经清楚：server端就是这个IP地址的服务器。server端接到HTTP请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件，再将得到的 HTML 文件发送给浏览器（客户端），最后返回HTTP响应报文。 例子：例子中，服务器 通过Response Headers 告诉客户端：我反回的是html代码而不是纯文本： HTTP响应报文 当收到get或post等方法发来的请求后，服务器就要对报文进行响应。 HTTP响应报文也是由三部分组成: 状态行, 首部行和报文实体。 状态行（服务器的http版本，状态码，状态短语）： 1xx：指示信息–表示请求已接收，继续处理（继续进程，在发送post后可以收到该应答）。 2xx：成功–表示请求已被成功接收、理解、接受。(在发送get后返回) 200 OK:请求成功，请求的对象在这个报文后面 3xx：重定向–要完成请求必须进行更进一步的操作。 301 Moved Permanently:请求的对象已转移，新的URL在响应报文的Location:首部行中指定。 4xx：客户端错误–请求有语法错误或请求无法实现。 400 Bad Request:请求报文不为服务器理解 404 Not Found:请求的文档没有在该服务器上发现 5xx：服务器端错误–服务器未能实现合法的请求。 505 HTTP Version Not Supported:服务器不支持请求报文使用的HTTP版本 首部行： Server:服务器软件版本 Content-Type:应答请求后返回的数据类型 Date:发送日期(当前服务器的时间) Content-Length(对象长度) Connection:close为关闭连接，抓包可以发现在响应返回后服务器向客户端发出fin包单向关闭了连接。 Expires：在某个时间以前可以不用重新缓存该页面。（cookie的有效期） cache-control表示对页面是否进行缓存。 Pragma的参数no-cache表示对页面不进行缓存。 报文实体： 服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 对比 请求报文、响应报文 客户端（浏览器)解析数据 渲染页面 客户端（浏览器）接收到server端返回的 HTML 文件 后就会解析这些html代码，在还没有完全接收 HTML 文件时便开始渲染、显示网页。 在执行 HTML 中代码时，先是解析html，解析html过程中遇到引入了css，则会在解析html的同时解析css。 如果遇到引入了js，则会解析js，停止html和css解析（因为JS有可能修改DOM结构）。等解析完js再解析剩下未解析完的html和css。 页面显示之后的 加载图片、加载js、加载jquery、加载css等，这些又是另外的HTTP请求。可能会通过一个网页产生很多的HTTP请求，请求越少性能越好。 边解析边渲染浏览器是一个边解析边渲染的过程。（可参考CSS是如何工作的、容易理解的渲染树） 首先浏览器解析HTML文件构建DOM树 然后解析CSS文件构建 CSS对象模型：解析提取的CSS文件，并根据选择器类型分到不同的“存储桶”，例如元素，类，ID等。根据找到的选择器，它确定应将哪些 CSS规则 应用于DOM中的哪些节点，并根据需要向其附加样式。（CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。） 等到渲染树构建完成后，浏览器开始根据DOM树合成渲染树（将 渲染树 放在合适的HTML元素中） 最后浏览器将渲染树绘制到屏幕上显示。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 渲染过程中遇到&lt;script&gt;则暂停渲染（因为JS有可能修改DOM结构），优先加载并执行JS代码，完成再继续渲染 浏览器 reflow(回流)和repain(重绘) DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow(回流); 当盒模型的位置,大小以及其他属性，如颜色,字体等确定下来之后，浏览器便开始绘制内容，这个过程称为repain(重绘)。 页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 JS的解析（同步、异步） JS的解析是由浏览器中的JS解析引擎完成的。 JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。（HTML5提供的Web Workers API可以让浏览器作为宿主环境提供给JS一个多线程运行的环境） 但是又存在某些任务比较耗时，如 IO读写 等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。 同步任务就是放在主线程（执行栈）上执行的任务，异步任务是放在任务队列中的任务。【注意：异步任务中有两个任务队列：宏任务和微任务】 JS的执行机制就可以看做是一个 主线程（执行栈） 加上一个 任务队列(task queue)。 JS的执行步骤（事件循环） 事件循环是解决javaScript单线程运行阻塞的一种机制。 所有的同步任务在主线程上执行，形成一个执行栈。异步任务有了运行结果就会在任务队列中放置一个事件。脚本运行时先依次运行执行栈中的所有同步任务，然后会从任务队列里提取事件，选择需要首先执行的异步任务然后执行。 任务队列 分为（但不包含） 宏任务队列 和 微任务队列（因为script中的同步任务也属于宏任务）。 宏任务先于微任务执行（第一个执行的宏任务是script中的同步任务） 在此过程中，主线程要做的就是从任务队列中去执行事件，执行完毕，再取事件，再执行事件…这样不断取事件，执行事件的循环机制就叫做事件循环机制。 注意：异步任务被挂起时会由浏览器的引擎去执行他们，而同步任务则是由JS的引擎去执行。 总结事件循环：执行栈（第一个宏任务） 全部执行完毕后 –&gt;清空 微任务 –&gt;会取出一个 宏任务 –&gt; 执行完毕后–&gt;清空 微任务 -&gt; 无线循环 宏任务和微任务 宏任务先于微任务执行。 MacroTask（宏任务）： script(整体代码)：第一个宏任务队列中只有一个任务： 执行主线程的js代码 定时器： setTimeout、setInterval I/O UI交互事件 postMessage MessageChannel setImmediate(浏览器暂时不支持，只有IE10支持，具体可见MDN) MicroTask（微任务）： Process.nextTick（Node独有） Promise MutationObserver（具体使用方式查看这里） 在挂起异步任务时，JS 引擎会将所有异步任务按照类别分到这两个队列中，首先在 宏任务 的队列中取出第一个任务，执行完毕后取出 微任务 队列中的所有任务顺序执行；之后再取 宏任务，周而复始，直至两个队列的任务都取完。【注意：同步任务也属于宏任务，所以第一个取出的宏任务是同步任务】 事件循环例子（面试题）12345678910111213141516171819console.log('script start')setTimeout(function() &#123; console.log('timer over')&#125;, 0)Promise.resolve().then(function() &#123; console.log('promise1')&#125;).then(function() &#123; console.log('promise2')&#125;)console.log('script end')// script start// script end// promise1// promise2// timer over 整体代码script是宏任务，所以先打印script start 再执行到setTimeout属于异步任务，也是宏任务的一种，放到 宏任务队列 里面 接着就执行到Promise也是异步任务，但是属于微任务，进入到 微任务队列 然后执行到 script的最后打印出script end，主线程（执行栈）被清空 这里要注意的是主线程一旦全部执行完毕就会取清空微任务，所以接下来微任务队列中的 Promise.then()被加入到主线程中执行。执行了回调，打印出promise1，同时产生了新的微任务 Promise.then()，执行完毕后，主线程又被清空了 微任务队列里还有刚刚产生的Promise.then()，又被加入到主线程执行打印出promise2 此时微任务队列和主线程都被清空,接着在宏任务队列里取出一个宏任务加入到主线程中执行 setTimeout callback，打印出setTimeout 这时主线程、微任务队列、宏任务队列都被清空，代码执行完毕，所以最后的执行结果为script start、script end、promise1、promise2、setTimeout。如果宏任务队列和微任务队列还没清空，就会：执行栈 全部执行完毕后 –&gt;清空 微任务 –&gt;会取出一个 宏任务 –&gt; 执行完毕后–&gt;清空 微任务 -&gt; 无线循环，这就是我们所说的事件循环（Event Loop），也就是javascript的执行机制。 连接结束 主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； 补充 浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。这些又是另外的HTTP请求，浏览器将重复以上所有过程下载该资源。可能会通过一个网页产生很多的HTTP请求，请求越少性能越好。 请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。 原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。 CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。 堆堆表示一大块非结构化的内存区域。对象，数据被存放在堆中。 栈 栈在javascript中又称执行栈、调用栈，是一种后进先出的数组结构， Javascript 有一个 主线程（main thread）和 调用栈(或执行栈call-stack)，主线各所有的任务都会被放到执行栈等待主线程执行。 JS调用栈采用的是后进先出的规则，当函数执行的时候，会被添加到栈的顶部，当执行栈执行完该函数后，函数就会从栈顶移出，直到栈内被清空。 举个例子： 1234567891011function foo(b) &#123; var a = 10; return a + b + 11;&#125;function bar(x) &#123; var y = 3; return foo(x * y);&#125;console.log(bar(7)); // 返回 42 当调用 bar 时，创建了第一个帧 ，帧中包含了 bar 的参数和局部变量。当 bar 调用 foo 时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 foo 的参数和局部变量。当 foo 返回时，最上层的帧就被弹出栈（剩下 bar 函数的调用帧 ）。当 bar 返回的时候，栈就空了。 注意：这里的堆栈，是数据结构的堆栈，不是内存中的堆栈（内存中的堆栈，堆存放引用类型的数据，栈存放基本类型的数据） 队列队列即任务队列Task Queue，是一种先进先出的一种数据结构。在队尾添加新元素，从队头移除元素。 cookie cookie是一种类似缓存的机制，它保存在一个本地的文本文件中，其主要作用是在发送请求时将cookie放在请求首部中发送给服务器，服务器收到cookie后查找自己已有的cookie信息，确定客户端的身份，然后返回相应的页面。 cookie的方便之处在于可以保持一种已登录的状态，例如：我们注册一个论坛，每次访问都需要进行填写用户名和密码然后登录。而使用了cookie后，如果cookie没有到达过期时间，那么我们只需在第一次登录时填写信息然后登录，以后的访问就可以省略这一步骤。 在HTTP协议中，cookie的交互过程： 首先是三次握手建立TCP连接 然后客户端发出一个http request，（第一次请求时）这个request中不包含任何cookie信息： 当服务器收到这个报文后，针对request method作出响应动作，在响应报文的头部（首部行）加入了set-cookie段，set-cookie段中给出了cookie的id，过期时间以及参数path，path是表示在哪个虚拟目录路径下的页面可以读取使用该cookie。 客户端接受到这些信息后，在以后的http request中就会将自己的cookie段用这些信息填充。 如果用户在连接中通过了服务器相应的认证程序，服务器会添加一个cdb_auth到set-cookie中，这个段表示了客户端的认证信息，而客户端以后在访问过程中也会将cdb_auth信息写入自己的cookie字段。服务器每次收到http request后读取cookie，然后根据cookie的信息返回不同的页面。例如，没有通过认证的客户端在request中不会有cdb_auth，因此服务器读取cookie后，不会将通过认证的客户端的页面返回给该客户端。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"Node.js学习","slug":"Node-js学习","permalink":"http://yoursite.com/categories/Node-js学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第四天学习笔记（CSS背景）（1）","slug":"百度前端技术学院 第四天学习笔记（1）","date":"2019-09-26T07:47:25.000Z","updated":"2020-10-09T08:25:51.829Z","comments":true,"path":"2019/09/26/百度前端技术学院 第四天学习笔记（1）/","link":"","permalink":"http://yoursite.com/2019/09/26/百度前端技术学院 第四天学习笔记（1）/","excerpt":"补充：margin和padding的区别 在CSS中margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。 在CSS中padding是指自身边框到自身内部另一个容器边框之间的距离，就是容器内边距。","text":"补充：margin和padding的区别 在CSS中margin是指从自身边框到另一个容器边框之间的距离，就是容器外距离。 在CSS中padding是指自身边框到自身内部另一个容器边框之间的距离，就是容器内边距。 特别注意 background内如果想要放background-size的值呢就必须有position的值才行 参考MDN并且，&lt;background-size&gt;值只能紧接在&lt;position&gt;后面，并以/字符分隔，例如：“ left/cover”。 不起作用： 1background: url(上校.jpg) cover no-repeat fixed; 起作用： 1background: url(上校.jpg) left/cover no-repeat fixed; 1background: url(上校.jpg) no-repeat fixed; 背景background总结 为了清晰地显示出段落和链接的背景图像，需要为它们设置了少许内边距（padding），外边距（margin）是没用的。 【推荐使用】background简写所有背景属性编写background值时，需要遵循一些规则例如： background-color只能在最后一个逗号后指定。 background-size只能紧随在background-position后并以/字符分隔，如下所示：center/80%。 所有注意事项 概述1234body &#123; background : #00FF00 url(bgimage.gif) no-repeat fixed top; &#125; 通常建议使用这个属性，而不是分别使用单个属性，因为这个属性在较老的浏览器中能够得到更好的支持。 注意：属性值之间使用空格分隔开。如果使用多个背景，则需要为第一个背景指定所有属性，然后在逗号后添加下一个背景。 如果不设置其中的某个值，也不会出问题，所有省略的子值都将设置为其初始值。 可以设置如下属性： background-color background-position background-size background-repeat background-origin background-clip background-attachment background-image 例子123456.box &#123; background : linear-gradient(105deg, rgba(255,255,255,.2) 39%, rgba(51,56,57,1) 96%) center 400px 200px no-repeat,/*渐变*/ url(big-star.png) center no-repeat, /*background-size（400px 200px）只能紧随在background-position（center）后并以'/'字符分隔*/ purple;/*紫色背景色要放在最后*/&#125; background-color属性设置背景颜色1background-color: gray; 补充： rgba颜色中Alpha为色彩空间，也就是透明度/不透明度。它的范围为0.0到1.0之间，0.5为半透明。 rgba(255,255,255,0)则表示完全透明的白色； rgba(0,0,0,1)则表示完全不透明的黑色； background-image属性设置背景图片12background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);padding: 20px; 如果除了背景图像之外还指定了背景色，则图像会显示在该颜色的顶部: 1234.b &#123; background-image: url(star.png); background-color:red;&#125; background-size属性设置背景图片大小 background-size: length|percentage|cover|contain 属性值为length用法 设置背景图像的高度和宽度。 第一个值设置宽度，第二个值设置高度。 如果只设置一个值，则第二个值会被设置为 “auto”。123background-size:100px； //背景图片显示的宽为100像素background-size:100px 160px；//背景图片显示的宽为100像素，高为600像素 属性值为percentage用法 以父元素的百分比来设置背景图像的宽度和高度。 第一个值设置宽度，第二个值设置高度。 如果只设置一个值，则第二个值会被设置为 “auto”。123background-size：60%； //背景图片的显示宽度和高度是图片大小60%；background-size：60% 80%； // 背景图片的显示宽度是图片大小的60%，高度是80%； 属性值为cover用法 对图片进行等比缩放 缩放背景图片以完全 覆盖 背景区，可能背景图片部分看不见。 该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被 裁剪。1background-size：cover； //把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。 注意：加上background-attachment: fixed;将图片固定在可视范围内时，图片把x轴拉满（反过来了） 属性值为contain用法: 对图片进行等比缩放 保证图片始终 完整 的显示在背景区域，不裁剪图片 缩放背景图片以完全 装入 背景区，可能背景区部分空白。 该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。1background-size：contain； //把图像图像扩展至最大尺 注意：加上background-attachment: fixed;将图片固定在可视范围内时，图片把y轴拉满（反过来了），x轴右边可能空缺一部分。 background-repeat属性设置背景重复注意：不设置该属性则默认全屏重复（铺满）。 属性值repeat-x 和 repeat-y 分别导致图像只在水平或垂直方向上重复，no-repeat 则不允许图像在任何方向上平铺。 1background-repeat: repeat-y; background-position属性设置背景定位注意 使用该属性之前需要先设置background-repeat:no-repeat;确保图片不会被铺满整个页面。 位置关键字如果是一对则可以按任何顺序出现。如果是单个关键字和长度/百分比混合使用最好将lefy/right放在长度/百分比左边，将top/bottom放在长度/百分比右边。另，要保证不超过两个关键字(注意是关键字！background-position: top 20px right 10px;表示将背景从顶部放置20px，从右侧放置10px)，一个对应水平方向，另一个对应垂直方向。 属性值可以通过一对或单个关键字、百分数、长度值来给他提供值，如果使用单个则默认另一个关键字是 center。 使用关键字提供属性值 top、bottom、left、right 和 center 123background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);background-repeat:no-repeat;background-position:top right; 使用百分数值提供属性值 百分数值同时应用于元素和图像 如果只提供一个百分数值，所提供的这个值将用作水平值，垂直值将假设为 50%。这一点与关键字类似。 background-position 的默认值是 0% 0%，在功能上相当于 top left。 123background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);background-repeat:no-repeat;background-position:50% 50%; 其中心与其元素的中心对齐。也就是说，图像中描述为 50% 50% 的点（中心点）与元素中描述为 50% 50% 的点（中心点）对齐。 如果图像位于 0% 0%，其左上角将放在元素内边距区的左上角。如果图像位置是 100% 100%，会使图像的右下角放在右边距的右下角。 使用长度值提供属性值 还可以使用长度值，如 100px 或 5cm。 长度值解释的是元素内边距区左上角的偏移。偏移点是图像的左上角。 注意，这一点与百分数值不同，因为偏移只是从一个左上角到另一个左上角。也就是说，图像的左上角与 background-position 声明中的指定的点对齐。 123background-image:url(C:/Users/HLZ/Desktop/百度前端/上校.jpg);background-repeat:no-repeat;background-position:50px 100px; 比如，如果设置值为 50px 100px，图像的左上角将在元素内边距区左上角向右 50 像素、向下 100 像素的位置上。 属性值混合使用 将背景从顶部放置20px，从右侧放置10px(只有两个关键词)：12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: top 20px right 10px; &#125; 长度以及百分比：12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: 20px 10%; &#125; 将关键字值与长度或百分比混合: 注意：只使用一个关键字的情况最好按照表格顺序，颠倒以后没有效果： 第一个属性值 第二个属性值 lefy/right 长度或百分比 长度或百分比 top/bottom 12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: 20px bottom;&#125; background-attachment属性固定背景图片（背景关联） 如果文档比较长，那么当文档向下滚动时，背景图像也会随之滚动。当文档滚动到超过图像的位置时，图像就会消失。 通过设置属性值为fixed可以使图像固定。 属性值 fixed：声明图像相对于可视区是固定的，因此不会受到滚动的影响。 scroll：（默认值）也就是说，在默认的情况下，背景会随文档滚动。123456body &#123; background-image url(CUsersHLZDesktop百度前端上校.jpg); background-size 200px; background-repeat no-repeat; background-attachment fixed;&#125; 多个背景图像 在一个属性中可以指定多个值，并用逗号分隔每个值。 注意：可能最终得到彼此重叠的背景图像。背景将分层，最后列出的背景图像位于堆栈底部，而每个先前的图像堆栈均位于代码后的背景图像的顶部。 123background-image url(image1.png), url(image2.png), url(image3.png), url(image1.png);background-repeat no-repeat, repeat-x, repeat;background-position 10px 20px, top right; 不同属性的每个值将与其他属性中相同位置的值匹配。例如，在上面image1的background-repeat值将为no-repeat。 当不同的属性具有不同数量的值时,数量较少的值会循环,在上面的示例中，有四个背景图像，但只有两个background-position值。前两个位置值将应用于前两个图像，然后它们将再次循环返回(image3将获得第一个位置值，并将image4获得第二个位置值。) 例子最后列出的背景图像位于堆栈底部，而每个先前的图像堆栈均位于代码后的背景图像的顶部： 123.box &#123; background-image url(star.png), url(big-star.png);&#125; 123div class=wrapper div class=boxdivdiv 123.box &#123; background-imageurl(big-star.png), url(star.png);&#125; MDN参考","categories":[{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第三天学习总结（CSS文本、派生选择器）（2）","slug":"百度前端技术学院 第三天学习总结（CSS文本） 2","date":"2019-09-25T05:30:16.000Z","updated":"2019-11-19T09:21:08.016Z","comments":true,"path":"2019/09/25/百度前端技术学院 第三天学习总结（CSS文本） 2/","link":"","permalink":"http://yoursite.com/2019/09/25/百度前端技术学院 第三天学习总结（CSS文本） 2/","excerpt":"派生(上下文)选择器非常重要！ 如果希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器：","text":"派生(上下文)选择器非常重要！ 如果希望列表中的 strong 元素变为斜体字，而不是通常的粗体字，可以这样定义一个派生选择器： 1234li strong &#123; font-style: italic;/*斜体*/ font-weight: normal; &#125; 对下面strong元素起作用： 1&lt;li&gt;&lt;strong&gt;我是斜体字。这是因为 strong 元素位于 li 元素内。&lt;/strong&gt;&lt;/li&gt; 只有 li 元素中的 strong 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。 id 选择器和派生选择器12345#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125; 上面的样式只会应用于出现在 id 是 sidebar 的元素内的段落。 这个元素很可能是 div 或者是表格单元，尽管它也可能是一个表格或者其他块级元素。它甚至可以是一个内联元素，比如&lt;em&gt;&lt;/em&gt; 或者 &lt;span&gt;&lt;/span&gt;，不过这样的用法是非法的,因为 不可以在内联元素 &lt;span&gt; 中嵌入&lt;p&gt;(原因) 即使被标注为 sidebar 的元素只能在文档中出现一次，这个 id 选择器作为派生选择器也可以被使用很多次：1234567891011121314#sidebar p &#123; font-style: italic; text-align: right; margin-top: 0.5em; &#125;#sidebar h2 &#123; font-size: 1em; font-weight: normal; font-style: italic; margin: 0; line-height: 1.5; text-align: right; &#125; class 也可被用作派生选择器1234.fancy td &#123; color: #f60; background: #666; &#125; 在上面这个例子中，类名为 fancy 的更大的元素内部的表格单元都会以灰色背景显示橙色文字。（名为 fancy 的更大的元素可能是一个表格或者一个 div）反过来，元素也可以基于它们的类而被选择：（要注意包含关系，前包含后） 1234td .fancy &#123; color: #f60; background: #666; &#125; 在上面的例子中，类名为 fancy 的表格单元将是带有灰色背景的橙色。 1&lt;td class=\"fancy\"&gt; 选择器的分组你可以对选择器进行分组，这样，被分组的选择器就可以分享相同的声明。 用逗号将需要分组的选择器分开。 在下面的例子中，我们对所有的标题元素进行了分组。所有的标题元素都是绿色的。 123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; 文本样式都有哪些相关属性，对应哪些值“color 属性”设置字体颜色 color 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 text-decoration 属性放置在文本下方或上方的线 (underline overline)。 “font-size属性”设置字体大小 千万注意 数字与单位之间不要有空 格！ 使用rem更加便于以后的维护 需要注意的是rem不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用em 或 px。 需要先设置html的字体大小（ 1rem 等于 HTML 中的根元素的字体大小），设置为10px将便于后面的计算。12345678910111213html &#123; font-size: 10px;//1em=10px&#125;h1 &#123; font-size: 2.6rem;//26px&#125;p &#123; font-size: 1.4rem;//14px color: red; font-family: Helvetica, Arial, sans-serif;&#125; “font-family属性”设置字体样式 使用字体栈并且将字体栈的最后一个值设置为网络安全字体（通用字体）。 123p &#123; font-family: \"Trebuchet MS\", Verdana, sans-serif;&#125; 注意: 有一些字体名称不止一个单词，比如Trebuchet MS ，那么就需要用引号包裹。 “text-decoration属性”非常有趣可用于在设置链接时取消设置链接上的默认下划线。 可用值为： none: 取消已经存在的任何文本装饰。 underline: 文本下划线. overline: 文本上划线 line-through: 穿过文本的线 注意到 text-decoration 可以一次接受多个值.同时注意 text-decoration 是一个缩写形式，它由 text-decoration-line, text-decoration-style 和 text-decoration-color 构成。 123.la&#123; text-decoration: wavy line-through red;&#125; text-decoration-style属性值的选择参考 “line-height 属性”设置行高 推荐使用数字作为无单位的属性值，无单位的值乘以 font-size 来获得 line-height。1line-height: 1.5; “text-indent 属性”设置首行文本缩进 规定文本块中首行文本的缩进。 注释：允许使用负值。如果使用负值，那么首行会被缩进到左边。 例子1234p&#123;text-indent:50px;&#125;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第三天学习总结（CSS文本、选择器）（1）","slug":"百度前端技术学院 第三天学习总结（CSS文本）","date":"2019-09-25T03:36:16.000Z","updated":"2019-11-19T09:20:48.440Z","comments":true,"path":"2019/09/25/百度前端技术学院 第三天学习总结（CSS文本）/","link":"","permalink":"http://yoursite.com/2019/09/25/百度前端技术学院 第三天学习总结（CSS文本）/","excerpt":"补充：HTML知识title 属性 规定关于元素的额外信息。 这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text）。 提示：title 属性常与 form 以及 a 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 abbr 和 acronym 元素的必需属性。","text":"补充：HTML知识title 属性 规定关于元素的额外信息。 这些信息通常会在鼠标移到元素上时显示一段工具提示文本（tooltip text）。 提示：title 属性常与 form 以及 a 元素一同使用，以提供关于输入格式和链接目标的信息。同时它也是 abbr 和 acronym 元素的必需属性。 p标签的嵌套 内联元素可以嵌套内联元素，块级元素可以嵌套部分块级元素并也能嵌套内联元素，但内联元素不能嵌套块级元素。块级元素为block，内联元素为inline，拥有“inline”特性的同时又拥有“block”的特性称为replace元素。 在&lt;p&gt;元素中是不能嵌套&lt;div&gt;元素的，在&lt;p&gt;标签还没结束时，遇到下一个块级元素就会自动结束。 什么是CSSCSS 指层叠样式表 (Cascading Style Sheets)，样式表中的样式定义如何显示 HTML 元素，存储在 CSS 文件中的外部样式表可以极大提高工作效率。 CSS是如何工作的解释1(来自MDN)（具体可以参考这个链接有实际的转换例子） 浏览器加载HTML 浏览器将HTML转换为DOM 浏览器获取HTML文档链接的大多数资源以及CSS（在此过程只呢个稍后会处理JS） 浏览器解析提取的CSS，并根据选择器类型分到不同的“存储桶”，例如元素，类，ID等。根据找到的选择器，它确定应将哪些规则应用于DOM中的哪些节点，并根据需要向其附加样式（此中间步骤称为渲染树）。 将渲染树放置在规则应用到其后应出现的结构中。（放在合适的HTML元素中） 页面的视觉显示在屏幕上显示（此阶段称为绘画）。 解释2（比较好理解）参考(里面有详细的图片解释) 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 补充：DOMDOM具有树状结构。标记语言中的每个元素，属性和一段文本都成为树结构中的DOM节点。 CSS的基本语法是怎样的参考图 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器通常是您需要改变样式的** HTML 元素**。 每条声明由一个属性和一个值组成。 多条声明中间用分号隔开。 1234选择器 &#123; 属性:值; 属性:值;&#125; 注意：如果值为若干单词，则要给值加引号： 1p &#123;font-family: \"sans serif\";&#125; CSS选择器是什么概念 选择器通常是您需要改变样式的HTML 元素。 简单选择器id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。id 选择器以 “#” 来定义。（id 属性只能在每个 HTML 文档中出现一次。） 类选择器 以一个点号显示 1.center &#123;text-align: center&#125; 在下面的 HTML 代码中，h1 和 p 元素都有 center 类。这意味着两者都将遵守 “.center” 选择器中的规则。 1234567&lt;h1 class=\"center\"&gt;This heading will be center-aligned&lt;/h1&gt;&lt;p class=\"center\"&gt;This paragraph will also be center-aligned.&lt;/p&gt; 注意：类名的第一个字符不能使用数字！它无法在 Mozilla 或 Firefox 中起作用。 类型（标签名/元素）选择器1234567891011span &#123; background-color: yellow;&#125;strong &#123; color: rebeccapurple;&#125;em &#123; color: rebeccapurple;&#125; 通用选择器用星号（*）表示，并选择文档中的所有内容 123* &#123; margin: 0;&#125; 属性选择器 参考 属性选择器 语法[属性名]{css样式} 可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。 注释：只有在规定了 !DOCTYPE 时，IE7 和 IE8 才支持属性选择器。在 IE6 及更低的版本中，不支持属性选择。 下面的例子为带有 title 属性的所有元素设置样式：1234[title]&#123;color:red;&#125; 属性和值选择器 下面的例子为 title=”W3School” 的所有元素设置样式：1234[title=W3School]&#123;border:5px solid blue;&#125; 属性和值选择器 - 多个值 下面的例子为包含指定值的 title 属性的所有元素设置样式。适用于HTML中由空格分隔的属性值：（比如：HTML中属性值为”hello world”或”student hello”） 1[title~=hello] &#123; color:red; &#125; 下面的例子为带有包含指定值的 lang 属性的所有元素设置样式。适用于HTML中由连字符分隔的属性值：(比如：HTML中属性值为”en-us”或者”en”) 1[lang|=en] &#123; color:red; &#125; [attribute|=value] 用于选取带有以指定值开头的属性值的元素，该值必须是整个单词。 [attribute^=value] 匹配属性值以指定值开头的每个元素。 [attribute$=value] 匹配属性值以指定值结尾的每个元素。 [attribute*=value] 匹配属性值中包含指定值的每个元素。 扩展 设置表单的样式的例子 属性选择器在为不带有 class 或 id 的表单设置样式时特别有用。","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第三天学习笔记（CSS文本）","slug":"百度前端技术学院 第三天学习笔记（CSS文本）","date":"2019-09-24T03:36:16.000Z","updated":"2020-02-10T08:55:55.998Z","comments":true,"path":"2019/09/24/百度前端技术学院 第三天学习笔记（CSS文本）/","link":"","permalink":"http://yoursite.com/2019/09/24/百度前端技术学院 第三天学习笔记（CSS文本）/","excerpt":"参考 字体颜色 color 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 text-decoration 属性放置在文本下方或上方的线 (underline overline)。","text":"参考 字体颜色 color 属性设置选中元素的前景内容的颜色 (通常指文本，不过也包含一些其他东西，或者是使用 text-decoration 属性放置在文本下方或上方的线 (underline overline)。 123p &#123; color: red;&#125; 字体大小重点在rem （千万注意数字与单位之间不要有空格！） px (像素) 将像素的值赋予给你的文本。这是一个绝对单位， 它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。 em 1em 等于我们设计的当前元素的父元素上设置的字体大小 (更加具体的话，比如包含在父元素中的大写字母 M 的宽度) 如果你有大量设置了不同字体大小的嵌套元素，这可能会变得棘手, 但它是可行的，为什么要使用这个麻烦的单位呢? 当你习惯这样做时，那么就会变得很自然，你可以使用em调整任何东西的大小，不只是文本。你可以有一个单位全部都使用 em 的网站，这样维护起来会很简单。 rem 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小， (i.e. ) ，而不是父元素。 这可以让你更容易计算字体大小，但是遗憾的是， rem 不支持 Internet Explorer 8 和以下的版本。如果你的项目需要支持较老的浏览器，你可以坚持使用em 或 px, 或者是 polyfill 就像 REM-unit-polyfill. （这个单位在“CSS的值和单位”一节也有讲解）12345678910111213html &#123; font-size: 10px;&#125;h1 &#123; font-size: 2.6rem;//26px&#125;p &#123; font-size: 1.4rem;//14px color: red; font-family: Helvetica, Arial, sans-serif;&#125; 字体样式需要了解“网页安全字体” 字体栈 由于你无法保证你想在你的网页上使用的字体的可用性 (甚至一个网络字体可能由于某些原因而出错), 你可以提供一个字体栈 (font stack)，这样的话，浏览器就有多种字体可以选择了。只需包含一个font-family属性，其值由几个用逗号分离的字体名称组成。 123p &#123; font-family: \"Trebuchet MS\", Verdana, sans-serif;&#125; 注意: 有一些字体名称不止一个单词，比如Trebuchet MS ，那么就需要用引号包裹。 在这种情况下，浏览器从列表的第一个开始，然后查看在当前机器中，这个字体是否可用。如果可用，就把这个字体应用到选中的元素中。如果不可用，它就移到列表中的下一个字体，然后再检查。 在 字体栈的最后提供一个合适的通用的字体名称(网页安全字体) 是个不错的办法，这样的话，即使列出的字体都无法使用，浏览器至少可以提供一个还算合适的选择。 font-style属性用来打开和关闭文本 italic (斜体)。 (你很少会用到这个属性，除非你因为一些理由想将斜体文字关闭斜体状态) 属性值 含义 normal 【标准字体】将文本设置为普通字体 (将存在的斜体关闭) italic 【斜体】如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。 oblique 【倾斜字体】将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。 inherit 规定应该从父元素继承字体样式 例子： font-weight属性设置文字的粗体大小。这里有很多值可选 (比如 -light, -normal, -bold, -extrabold, -black, 等等), 不过事实上你很少会用到 normal 和 bold以外的值： normal, bold: 普通或者加粗的字体粗细 lighter, bolder: 将当前元素的粗体设置为比其父元素粗体更细或更粗一步。100–900: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。 text-transform属性允许你设置要转换的字体。 值包括： none: 防止任何转型。 uppercase: 将所有文本转为大写。 lowercase: 将所有文本转为小写。 capitalize: 转换所有单词让其首字母大写。 full-width: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。 text-decoration属性（有趣！）设置/取消字体上的文本装饰(你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为： none: 取消已经存在的任何文本装饰。 underline: 文本下划线. overline: 文本上划线 line-through: 穿过文本的线 注意 text-decoration 是一个缩写形式，它由 text-decoration-line, text-decoration-style 和 text-decoration-color 构成****。 text-decoration-style属性值的选择 最好不要分开写，因为分开写只有火狐浏览器支持。注意到 **text-decoration 可以一次接受多个值.** 1&lt;h1 class=\"la\"&gt;lalala&lt;/h1&gt; 123.la&#123; text-decoration: wavy line-through red;&#125; 文字阴影 你可以为你的文本应用阴影，使用 text-shadow 属性。这最多需要 4 个值， (前两个值是必须的) 如下例所示： 1text-shadow: 4px 4px 5px red; 4 个属性如下: 阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 length and size units, 但是 px 是比较合适的。这个值必须指定。 阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。 模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为0，这意味着没有模糊。可以使用大多数的 CSS 单位 length and size units. 阴影的基础颜色，可以使用大多数的 CSS 颜色单位 CSS color unit. 如果没有指定，默认为 black. 多种阴影可以通过包含以逗号分隔的多个阴影值，将多个阴影应用于同一文本 1234text-shadow: -1px -1px 1px #aaa, 0px 4px 1px rgba(0,0,0,0.5), 4px 4px 5px rgba(0,0,0,0.7), 0px 0px 7px rgba(0,0,0,0.4); 补充 颜色中Alpha为色彩空间，也就是透明度/不透明度。它的范围为0.0到1.0之间，0.5为半透明。 rgba(255,255,255,0)则表示完全透明的白色； rgba(0,0,0,1)则表示完全不透明的黑色； 文本对齐 text-align 属性用来控制文本如何和它所在的内容盒子对齐。可用值如下，并且在与常规文字处理器应用程序中的工作方式几乎相同： left: 左对齐文本。 right: 右对齐文本。 center: 居中文字 justify: 使文本展开，改变单词之间的差距，使所有文本行的宽度相同。你需要仔细使用，它可以看起来很可怕。特别是当应用于其中有很多长单词的段落时。如果你要使用这个，你也应该考虑一起使用别的东西，比如 hyphens，打破一些更长的词语。 行高 line-height 属性 设置文本每行之间的高，可以接受大多数单位 length and size units，不过也可以设置一个无单位的值，作为乘数，通常这种是比较好的做法。无单位的值乘以 font-size 来获得 line-height。 推荐的行高大约是 1.5–2 (双倍间距。) 所以要把我们的文本行高设置为字体高度的1.5倍，你可以使用这个:1line-height: 1.5; 子元素为行内元素时垂直居中可设置该属性值与父元素（盒子容器）高度相同。 字母和单词间距letter-spacing 和 word-spacing 属性允许你设置你的文本中的字母与字母之间的间距、或是单词与单词之间的间距。 选择器 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。 选择器通常是您需要改变样式的** HTML 元素**。 每条声明由一个属性和一个值组成。 多条声明中间用分号隔开。 1234选择器 &#123; 属性:值; 属性:值;&#125; 注意：如果值为若干单词，则要给值加引号： 1p &#123;font-family: \"sans serif\";&#125; 选择器列表 被分组的选择器就可以分享相同的声明。用逗号将需要分组的选择器分开。123h1,h2,h3,h4,h5,h6 &#123; color: green; &#125; 插入外部样式表123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\" /&gt;&lt;/head&gt; 内部样式表1234567&lt;head&gt;&lt;style type=\"text/css\"&gt; hr &#123;color: sienna;&#125; p &#123;margin-left: 20px;&#125; body &#123;background-image: url(\"images/back40.gif\");&#125;&lt;/style&gt;&lt;/head&gt; 内联样式123&lt;p style=\"color: sienna; margin-left: 20px\"&gt;This is a paragraph&lt;/p&gt;","categories":[{"name":"CSS学习","slug":"CSS学习","permalink":"http://yoursite.com/categories/CSS学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"百度前端技术学院 第二天学习总结（HTML）","slug":"百度前端技术学院 第二天学习总结（HTML）","date":"2019-09-23T06:10:16.000Z","updated":"2019-11-19T09:21:58.138Z","comments":true,"path":"2019/09/23/百度前端技术学院 第二天学习总结（HTML）/","link":"","permalink":"http://yoursite.com/2019/09/23/百度前端技术学院 第二天学习总结（HTML）/","excerpt":"要好好利用input的type属性值 &lt;input&gt; 元素是最重要的表单元素。","text":"要好好利用input的type属性值 &lt;input&gt; 元素是最重要的表单元素。 最基础的：type=”text” 定义常规文本输入。 type=”radio” 定义单选按钮输入（选择多个选择之一） type=”submit” 定义提交按钮（提交表单） 像是type=”email”能对邮件地址进行验证。 type=”number”可以让输入框变成上下可选择数字范围。type=”range”可以让输入框变成滑动条可选择数字范围。 type=”date”让输入框有日期选择器。 type=”color”让输入框可以弹出颜色选择器。 属性值记得引号 js中写属性值一定要记得加上引号！！！ 验证今天的学习情况HTML是什么，HTML5是什么HTML HTML 是用来描述网页的一种语言。 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML5 HTML5 是最新的 HTML 标准。 HTML5 是专门为承载丰富的 web 内容而设计的，并且无需额外插件。 HTML5 拥有新的语义、图形以及多媒体元素。 HTML5 提供的新元素和新的 API 简化了 web 应用程序的搭建。 HTML5 是跨平台的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。 新的语义元素，比如 &lt;header&gt;, &lt;footer&gt;, &lt;article&gt;, and &lt;section&gt;。 新的表单控件，比如数字、日期、时间、日历和滑块。 强大的图像支持（借由 &lt;canvas&gt;和 &lt;svg&gt;） 强大的多媒体支持（借由 &lt;video&gt; 和 &lt;audio&gt;） 强大的新 API，比如用本地存储取代 cookie。 HTML元素标签、属性都是什么概念？HTML元素标签 HTML 标签是由尖括号包围的关键词，比如&lt;html&gt; HTML 标签通常是成对出现的，比如&lt;b&gt;和 &lt;/b&gt; 标签对中的第一个标签是开始(开放)标签，第二个标签是结束(闭合)标签 HTML元素属性 HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。 属性总是以名称/值对的形式出现，比如：name=”value”。 属性总是在 HTML 元素的开始标签中规定。 文档类型是什么概念，起什么作用？&lt;!DOCTYPE&gt; 声明帮助浏览器正确地显示网页。 Web 世界中存在许多不同的文档。只有了解文档的类型，浏览器才能正确地显示文档。 HTML 也有多个不同的版本，只有完全明白页面中使用的确切 HTML 版本，浏览器才能完全正确地显示出 HTML 页面。这就是 &lt;!DOCTYPE&gt; 的用处。 &lt;!DOCTYPE&gt;不是 HTML 标签。它为浏览器提供一项信息（声明），告诉浏览器 HTML 是用什么版本编写的。 它的出现位置在head标签的上面。 比如：HTML5的声明方式是：&lt;!DOCTYPE html&gt; meta标签都用来做什么的？ 元数据（metadata）是关于数据的信息。 &lt;meta&gt; 标签提供关于 HTML 文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。 典型的情况是，meta 元素被用于规定页面的描述、关键词、文档的作者、最后修改时间以及其他元数据。 标签始终位于 head 元素中。 元数据可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 针对搜索引擎的关键词一些搜索引擎会利用 meta 元素的 name 和 content 属性来索引您的页面。 下面的 meta 元素定义页面的描述： 1&lt;meta name=\"description\" content=\"Free Web tutorials on HTML, CSS, XML\" /&gt; name 和 content 属性的作用是描述页面的内容。 Web语义化是什么，是为了解决什么问题? 语义化简单说来就是让机器可以读懂内容。在发布内容的时候，就用机器可读的、被广泛认可的语义信息来描述内容，来降低机器处理 Web 内容的难度。 我们在提供内容的时候，首先要做的就是将内容本身进行合理的描述，暂时不用考虑它的最终呈现会是什么样子。 HTML5 并非 Web 语义唯一倚仗的规范，除了 W3C 和 WHATWG 外，还有其它的组织在为扩展、标准化 Web 语义做着贡献。只要有浏览器厂商、搜索引擎原意支持，它们的规范一样可以成为通用的基础设施。 为了解决机器难以读懂web上发布的各种内容的问题。 链接是什么概念，对应什么标签？ HTML 使用超级链接与网络上的另一个文档相连。 超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。 当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。 我们通过使用&lt;a&gt; 标签在 HTML 中创建链接。 有两种使用 &lt;a&gt;标签的方式：通过使用 href 属性 - 创建指向另一个文档的链接通过使用 name 属性 - 创建文档内的书签(锚) 常用标签都有哪些，都适合用在什么场景 head标签中的title标签定义文档的标题，显示在浏览器的标题栏或标签页上 h1-h6标签用于标题 a标签用于超链接（其中name属性可以用于创建导航栏） p标签用于文段，span标签用于行内文字 input标签非常多用，像他的type的不同属性值让他可以用于多个场景。 最基础的：type=”text” 定义常规文本输入。 type=”radio” 定义单选按钮输入（选择多个选择之一） type=”submit” 定义提交按钮（提交表单） 像是type=”email”能对邮件地址进行验证。 type=”number”可以让输入框变成上下可选择数字范围。type=”range”可以让输入框变成滑动条可选择数字范围。 type=”date”让输入框有日期选择器。 type=”color”让输入框可以弹出颜色选择器。 表单标签都有哪些，对应着什么功能，都有哪些属性？&lt;input&gt;元素是最重要的表单元素。 type属性：他决定了input这个输入框具体用来做什么，比如text那他就是用来输入文本的，button就是按钮，submit定义提交表单数据至表单处理程序的按钮。，radio是单选按钮，checkbox复选框， name 属性：如果form表单要正确地被提交，每个输入字段必须设置一个 name 属性。 ol, ul, li, dl, dd, dt等这些标签都适合用在什么地方，举个例子ol（有序 HTML 列表） start属性：规定开始数字，如从“50.咖啡”开始： 12345&lt;ol start=\"50\"&gt; &lt;li&gt;咖啡&lt;/li&gt; &lt;li&gt;牛奶&lt;/li&gt; &lt;li&gt;茶&lt;/li&gt;&lt;/ol&gt; type属性：不同的属性值决定了有序列表前面的序号表示。 实例 ul（无序 HTML 列表） type属性：不同的属性值决定了无序列表前面的小图标图形。 实例 li 标签 定义列表项目。 &lt;li&gt; 标签可用在有序列表 &lt;ol&gt; 和无序列表 &lt;ul&gt; 中。 dl 标签 &lt;dl&gt; 标签定义了定义列表（definition list）。 &lt;dl&gt; 标签用于结合&lt;dt&gt; （定义列表中的项目）和&lt;dd&gt; （描述列表中的项目）。 实例 dt标签 &lt;dt&gt; 标签定义了定义列表中的项目（即术语部分）。 会顶格显示。 dd标签 &lt;dd&gt;在定义列表中定义条目的定义部分。 会缩进2个字符显示。 总的来说dl相当于ol与ul，dt、dd相当于li的位置。","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（5）","slug":"百度前端技术学院 第二天学习笔记（HTML） 5","date":"2019-09-22T13:30:30.000Z","updated":"2019-11-19T09:22:42.217Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 5/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 5/","excerpt":"height 和 width 属性 height 和 width 属性仅用于 &lt;input type=&quot;image&quot;&gt;。,规定 &lt;input&gt; 元素的高度和宽度。","text":"height 和 width 属性 height 和 width 属性仅用于 &lt;input type=&quot;image&quot;&gt;。,规定 &lt;input&gt; 元素的高度和宽度。 注释：请始终规定图像的尺寸。如果浏览器不清楚图像尺寸，则页面会在图像加载时闪烁。 list 属性 list 属性引用的 &lt;datalist&gt; 元素中包含了&lt;input&gt; 元素的预定义选项。 具体使用如上datalist的实例。 min 和 max 属性 min 和 max 属性规定 &lt;input&gt; 元素的最小值和最大值。 min 和 max 属性适用于如需输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。12345678Enter a date before 1980-01-01:&lt;input type=\"date\" name=\"bday\" max=\"1979-12-31\"&gt; Enter a date after 2000-01-01:&lt;input type=\"date\" name=\"bday\" min=\"2000-01-02\"&gt; Quantity (between 1 and 5):&lt;input type=\"number\" name=\"quantity\" min=\"1\" max=\"5\"&gt; multiple 属性（同时上传多个文件） multiple 属性是布尔属性。 如果设置multiple=&quot;multiple&quot;，则规定允许用户在&lt;input&gt; 元素中输入一个以上的值。 multiple 属性适用于以下输入类型：email 和 file。 实例1234567891011&lt;html&gt;&lt;body&gt;&lt;form action=\"/example/html5/demo_form.asp\" method=\"get\"&gt;选择图片：&lt;input type=\"file\" name=\"img\" multiple=\"multiple\" /&gt;&lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;p&gt;请尝试在浏览文件时选取一个以上的文件。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; pattern 属性 pattern 属性规定用于检查&lt;input&gt; 元素值的正则表达式。 pattern 属性适用于以下输入类型：text、search、url、tel、email、and password。 提示：请使用全局的 title 属性对模式进行描述以帮助用户。 提示：请在我们的 JavaScript 教程中学习更多有关正则表达式的知识。 实例123456789&lt;body&gt;&lt;form action=\"/example/html5/demo_form.asp\" method=\"get\"&gt;国家代码：&lt;input type=\"text\" name=\"country_code\" pattern=\"[A-z]&#123;3&#125;\"title=\"三个字母的国家代码\" /&gt;&lt;input type=\"submit\" /&gt;&lt;/form&gt;&lt;/body&gt; placeholder 属性 placeholder 属性规定用以描述输入字段预期值的提示（样本值或有关格式的简短描述）。 该提示会在用户输入值之前显示在输入字段中。 placeholder 属性适用于以下输入类型：text、search、url、tel、email 以及 password。 required 属性 required 属性是布尔属性。 如果设置，则规定在提交表单之前必须填写输入字段。 required 属性适用于以下输入类型：text、search、url、tel、email、password、date pickers、number、checkbox、radio、and file. required或者required=&quot;required&quot;都行。1Username: &lt;input type=\"text\" name=\"usrname\" required&gt; 或者 1Name: &lt;input type=\"text\" name=\"usr_name\" required=\"required\" /&gt; step 属性 step 属性规定&lt;input&gt; 元素的合法数字间隔。 示例：如果 step=”3”，则合法数字应该是 -3、0、3、6、等等。 提示：step 属性可与 max 以及 min 属性一同使用，来创建合法值的范围。 step 属性适用于以下输入类型：number、range、date、datetime、datetime-local、month、time 以及 week。 实例 HTML5 为 &lt;form&gt;增加如需属性：autocompletenovalidate","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（4）","slug":"百度前端技术学院 第二天学习笔记（HTML） 4","date":"2019-09-22T12:10:30.000Z","updated":"2019-11-19T09:22:57.873Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 4/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 4/","excerpt":"&lt;textarea&gt; 元素 &lt;textarea&gt;元素定义多行输入字段（文本域） 实例","text":"&lt;textarea&gt; 元素 &lt;textarea&gt;元素定义多行输入字段（文本域） 实例123&lt;textarea name=\"message\" rows=\"10\" cols=\"30\"&gt;The cat was playing in the garden.&lt;/textarea&gt; &lt;input&gt; 元素 元素是最重要的表单元素。 text 定义常规文本输入。 radio 定义单选按钮输入（选择多个选择之一） submit 定义提交按钮（提交表单） &lt;input&gt; 元素的type属性值 &lt;input type=&quot;text&quot;&gt; 定义供文本输入的单行输入字段 &lt;input type=&quot;password&quot;&gt; 定义密码字段 &lt;input type=&quot;submit&quot;&gt; 定义提交表单数据至表单处理程序的按钮。(在表单的 action 属性中规定表单处理程序（form-handler) &lt;input type=&quot;radio&quot;&gt; 定义单选按钮。(checked属性为默认选中) &lt;input type=&quot;checkbox&quot;&gt; 定义复选框。(允许用户在有限数量的选项中选择零个或多个选项) &lt;input type=&quot;button&gt;定义按钮。 HTML5增加了多个新的输入类型（type属性值） &lt;input type=&quot;number&quot;&gt; 用于应该包含数字值的输入字段。您能够对数字做出限制。根据浏览器支持，限制可应用到输入字段。例子 输入限制（input）有很多属性：max规定输入字段的最大值。min 规定输入字段的最小值。value 规定输入字段的默认值。等等 &lt;input type=&quot;color&quot;&gt;用于应该包含颜色的输入字段。根据浏览器支持，点击输入字段时颜色选择器会出现输入字段中。例子 &lt;input type=&quot;range&quot;&gt; 用于应该包含一定范围内的值的输入字段。根据浏览器支持，输入字段能够显示为滑块控件。(number的效果是上下按键选择范围)例子 &lt;input type=&quot;date&quot;&gt; 用于应该包含日期(年月日)的输入字段。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;month&quot;&gt; 允许用户选择月份和年份。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;week&quot;&gt; 允许用户选择周和年。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;time&quot;&gt; 允许用户选择时间（无时区）。根据浏览器支持，时间选择器会出现输入字段中。 &lt;input type=&quot;datetime&quot;&gt;允许用户选择日期(年月日)和时间（有时区）。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;datetime-local&quot;&gt;允许用户选择日期(年月日)和时间（无时区）。根据浏览器支持，日期选择器会出现输入字段中。 &lt;input type=&quot;email&quot;&gt;用于应该包含电子邮件地址的输入字段。根据浏览器支持，能够在被提交时自动对电子邮件地址进行验证。某些智能手机会识别 email 类型，并在键盘增加 “.com” 以匹配电子邮件输入. &lt;input type=&quot;search&quot;&gt;用于搜索字段（搜索字段的表现类似常规文本字段）。 &lt;input type=&quot;tel&quot;&gt;用于应该包含电话号码的输入字段。目前只有 Safari 8 支持 tel 类型。 &lt;input type=&quot;url&quot;&gt; 用于应该包含 URL 地址的输入字段。根据浏览器支持，在提交时能够自动验证 url 字段。某些智能手机识别 url 类型，并向键盘添加 “.com” 以匹配 url 输入。 &lt;input&gt; 元素的不同属性 value属性规定输入字段的初始值 readonly属性规定输入字段为只读（不能修改）例子 disabled属性规定输入字段是禁用的。被禁用的元素是不可用和不可点击的。被禁用的元素不会被提交。==disabled 属性不需要值。它等同于 disabled=”disabled”。== size 属性规定输入字段的尺寸（输入框长度）（以字符计）size=&quot;40&quot; maxlength属性规定输入字段允许的最大长度.==(不会改变输入框长度)== 如设置 maxlength 属性，则输入控件不会接受超过所允许数的字符。该属性不会提供任何反馈。如果需要提醒用户，则必须编写 JavaScript 代码。 HTML5 表单元素 HTML5 增加了如下表单元素：&lt;datalist&gt;&lt;keygen&gt;&lt;output&gt; HTML5 &lt;datalist&gt; 元素 &lt;datalist&gt; 元素为 &lt;input&gt; 元素规定预定义选项列表。 用户会在他们输入数据时看到预定义选项的下拉列表。 &lt;input&gt; 元素的 list 属性必须引用&lt;datalist&gt; 元素的 id 属性。 效果：当用户点击输入框时可以看到下拉框里有Internet Explorer、Firefox…12345678910&lt;form action=\"action_page.php\"&gt;&lt;input list=\"browsers\"&gt;&lt;datalist id=\"browsers\"&gt; &lt;option value=\"Internet Explorer\"&gt; &lt;option value=\"Firefox\"&gt; &lt;option value=\"Chrome\"&gt; &lt;option value=\"Opera\"&gt; &lt;option value=\"Safari\"&gt;&lt;/datalist&gt; &lt;/form&gt; HTML5 为 &lt;input&gt;增加了如下属性 autocomplete(&lt;form&gt;也增加该属性) autofocus form formaction formenctype formmethod formnovalidate formtarget height 和 width list min 和 max multiple pattern (regexp) placeholder required step 总结 formxxxx的属性都是用于覆盖xxx属性的，也就是有两个input的情况下，一个input使用默认xxx属性，另一个input通过设置formxxxx达到另一个属性。 formaction用于==拥有两个提交按钮并对于不同动作的 HTML 表单== formmethod第一个提交按钮使用表单中method规定的GET/POST，第二个提交按钮通设置formmethod覆盖表单的 HTTP 方法。 formnovalidate用于拥有==两个提交按钮的表单（验证和不验证）== formtarget用于表单有两个提交按钮，对应==不同的目标窗口==（默认是原窗口，formtarget可设置提交到新窗口） autocomplete 属性 自动填值 autocomplete 属性适用于&lt;form&gt; 以及如下&lt;input&gt; 类型：text、search、url、tel、email、password、datepickers、range 以及 color。 autocomplete 属性规定表单或输入字段是否应该自动完成。 当自动完成开启（autocomplete=”on”），浏览器会基于用户之前的输入值自动填写值。 提示：您可以把表单的 autocomplete 设置为 on，同时把特定的输入字段==(手动填值)== 设置为 off，反之亦然。 例子 novalidate 属性 不验证数据 novalidate 属性属于 &lt;form&gt;属性。 如果设置，则 novalidate 规定在提交表单时不对表单数据进行验证。 例子 autofocus 属性 鼠标自动到达输入框 autofocus 属性是布尔属性。 如果设置，则规定当页面加载时&lt;input&gt; 元素应该自动获得焦点。 例子 form 属性 form 属性规定&lt;input&gt; 元素所属的一个或多个表单。 提示：如需引用一个以上的表单，请使用空格分隔的表单 id 列表。 实例输入字段位于 HTML 表单之外（但仍属表单） formaction 属性 注意：formaction是form action的意思，可以用于拥有两个提交按钮并对于不同动作的 HTML 表单 formaction 属性规定当提交表单时处理该输入控件的文件的 URL。 formaction 属性覆盖 元素的 action 属性 formaction 属性适用于 type=”submit” 以及 type=”image”。 实例拥有两个提交按钮并对于不同动作的 HTML 表单1234567&lt;form action=\"action_page.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Submit\"&gt;&lt;br&gt; &lt;input type=\"submit\" formaction=\"demo_admin.asp\" value=\"Submit as admin\"&gt;&lt;/form&gt; formenctype 属性==没弄明白== formmethod 属性 formmethod 属性定义用以向 action URL 发送表单数据（form-data）的 HTTP 方法。(GET/POST) formmethod 属性覆盖 &lt;form&gt; 元素的 method 属性。 formmethod 属性适用于 type=”submit” 以及 type=”image”。 实例第二个提交按钮覆盖表单的 HTTP 方法1234567&lt;form action=\"action_page.php\" method=\"get\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Submit\"&gt; &lt;input type=\"submit\" formmethod=\"post\" formaction=\"demo_post.asp\" value=\"Submit using POST\"&gt;&lt;/form&gt; formnovalidate 属性 novalidate 属性是布尔属性。 如果设置，则规定在提交表单时不对 &lt;input&gt; 元素进行验证。 formnovalidate 属性覆盖&lt;form&gt; 元素的 novalidate 属性。 formnovalidate 属性可用于 type=”submit”。 实例拥有两个提交按钮的表单（验证和不验证）12345&lt;form action=\"/example/html5/demo_form.asp\" method=\"get\"&gt;E-mail: &lt;input type=\"email\" name=\"userid\" /&gt;&lt;br /&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;br /&gt;&lt;input type=\"submit\" formnovalidate=\"formnovalidate\" value=\"进行没有验证的提交\" /&gt;&lt;/form&gt; formtarget 属性 formtarget 属性规定的名称或关键词指示提交表单后在何处显示接收到的响应。 formtarget 属性会覆盖 &lt;form&gt; 元素的 target 属性。 formtarget 属性可与 type=”submit” 和 type=”image” 使用。 实例这个表单有两个提交按钮，对应不同的目标窗口：1234567&lt;form action=\"action_page.php\"&gt; First name: &lt;input type=\"text\" name=\"fname\"&gt;&lt;br&gt; Last name: &lt;input type=\"text\" name=\"lname\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"Submit as normal\"&gt; &lt;input type=\"submit\" formtarget=\"_blank\" value=\"Submit to a new window\"&gt;&lt;/form&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（3）","slug":"百度前端技术学院 第二天学习笔记（HTML） 3","date":"2019-09-22T11:20:22.000Z","updated":"2019-11-19T09:23:10.301Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 3/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 3/","excerpt":"Iframeiframe 用于在网页内显示网页。 语法&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt;","text":"Iframeiframe 用于在网页内显示网页。 语法&lt;iframe src=&quot;URL&quot;&gt;&lt;/iframe&gt; Iframe - 设置高度和宽度&lt;iframe src=&quot;demo_iframe.htm&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/iframe&gt; height 和 width 属性用于规定 iframe 的高度和宽度。 属性值的默认单位是像素，但也可以用百分比来设定（比如 “80%”）。 Iframe - 删除边框&lt;iframe src=&quot;demo_iframe.htm&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt; frameborder 属性规定是否显示 iframe 周围的边框。 设置属性值为 “0” 就可以移除边框： 使用 iframe 作为链接的目标 iframe 可用作链接的目标（target）。 链接的 target 属性必须引用 iframe 的 name 属性： 初始页面是百度，点击“W3School.com.cn”后百度页面会变成w3school页面。123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;iframe src=\"https://www.baidu.com/\" name=\"iframe_a\"&gt;&lt;/iframe&gt;&lt;p&gt;&lt;a href=\"https://www.w3school.com.cn/html/html_iframe.asp\" target=\"iframe_a\"&gt;W3School.com.cn&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;注释：&lt;/b&gt;由于链接的目标匹配 iframe 的名称，所以链接会在 iframe 中打开。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 背景需要注意：背景图像是否增加了页面的加载时间。小贴士：图像文件==不应超过 10k==。 文件路径 使用==相对路径==是个==好==习惯（如果可能）。 如果使用了相对路径，那么您的网页就不会与当前的基准 URL 进行绑定。所有链接在您的电脑上 (localhost) 或未来的公共域中均可正常工作。 绝对文件路径绝对文件路径是指向一个因特网文件的完整 URL：&lt;img src=&quot;https://www.w3school.com.cn/images/picture.jpg&quot; alt=&quot;flower&quot;&gt; 相对路径相对路径指向了相对于当前页面的文件。 &lt;img src=&quot;picture.jpg&quot;&gt; picture.jpg 位于与当前网页相同的文件夹 &lt;img src=&quot;images/picture.jpg&quot;&gt; picture.jpg 位于当前文件夹的 images 文件夹中 &lt;img src=&quot;/images/picture.jpg&quot;&gt; picture.jpg 当前站点根目录的 images 文件夹中 &lt;img src=&quot;../picture.jpg&quot;&gt; picture.jpg 位于当前文件夹的上一级文件夹中 标签&lt;base&gt; 标签为页面上的所有链接规定==默认地址==或==默认目标==（target） 1234&lt;head&gt;&lt;base href=\"http://www.w3school.com.cn/images/\" /&gt;&lt;base target=\"_blank\" /&gt;&lt;/head&gt; 所有链接一个目标(target)【使用 base】 在内使用使页面中的所有标签在新窗口中打开。 比如&lt;base target=&quot;_blank&quot; /&gt;使得内的超链接都将在==新窗口==中加载，因为 target 属性被设置为 “_blank”。（个别超链接需要不同的打开方式可以单独在设置target属性） 例子 HTML 字符实体 HTML 中的预留字符必须被替换为字符实体。 比如：如需显示小于号，我们必须这样写：&amp;lt; 或 &amp;#60; 有用的字符实体 表单（form）Action 属性 action 属性定义在提交表单时执行的动作。 &lt;form action=&quot;action_page.php&quot;&gt;如果省略 action 属性，则 action 会被设置为当前页面。 Method 属性 method 属性规定在提交表单时所用的 HTTP 方法（GET 或 POST） &lt;form action=&quot;action_page.php&quot; method=&quot;GET&quot;&gt;使用 GET（默认方法）不安全 当您使用 GET 时，表单数据在页面地址栏中是可见的：action_page.php?firstname=Mickey&amp;lastname=Mouse 如果表单提交是被动的（比如搜索引擎查询），并且没有敏感信息，可以使用GET。 注释：GET 最适合少量数据的提交。浏览器会设定容量限制。 推荐使用 POST： 如果表单正在更新数据，或者包含敏感信息（例如密码）。 POST 的安全性更加，因为在页面地址栏中被提交的数据是不可见的。 Name 属性 如果要正确地被提交，每个输入字段必须设置一个 name 属性。 &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 用&lt;fieldset&gt;组合表单数据 &lt;fieldset&gt; 元素组合表单中的相关数据 &lt;legend&gt; 元素为 &lt;fieldset&gt; 元素定义标题。 例子 效果：会有一个粗框把表格内容框住。 &lt;select&gt; 元素（下拉列表）123456&lt;select name=\"cars\"&gt;&lt;option value=\"volvo\"&gt;Volvo&lt;/option&gt;&lt;option value=\"saab\"&gt;Saab&lt;/option&gt;&lt;option value=\"fiat\"&gt;Fiat&lt;/option&gt;&lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt; 列表通常会把==首个==选项显示为==被选选项==。 您能够通过添加==selected属性==来==定义预定义选项==。&lt;option value=&quot;fiat&quot; selected&gt;Fiat&lt;/option&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（2）","slug":"百度前端技术学院 第二天学习笔记（HTML） 2","date":"2019-09-22T10:20:22.000Z","updated":"2019-11-19T09:22:27.493Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 2/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML） 2/","excerpt":"单元格边距(Cell padding)本例演示如何使用 Cell padding 来创建单元格内容与其边框之间的空白。","text":"单元格边距(Cell padding)本例演示如何使用 Cell padding 来创建单元格内容与其边框之间的空白。 单元格间距(Cell spacing)本例演示如何使用 Cell spacing 增加单元格之间的距离。 有序列表（ol）与无序列表（ul） ul: unordered lists 无序列表 ol: ordered lists 有序列表 两种列表中的每个列表项始于&lt;li&gt; 1234&lt;ul&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 1234&lt;ol&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; 无序列表中的不同类型&lt;ul&gt;的属性 type=”disc”实心圆（默认） type=”circle”空心圆 type=”square”实心方块 有序列表中的不同类型&lt;ol&gt;的属性 默认：数字列表 type=”A”：大写字母列表 type=”a”:小写字母列表 type=”I”：罗马字母列表 type=”i”：小写罗马字母列表 定义列表dl dl：definition list 自定义列表以&lt;dl&gt;标签开始。每个自定义列表项以&lt;dt&gt;开始。每个自定义列表项的定义以&lt;dd&gt; 开始。123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;&lt;dd&gt;Black hot drink&lt;/dd&gt;&lt;dt&gt;Milk&lt;/dt&gt;&lt;dd&gt;White cold drink&lt;/dd&gt;&lt;/dl&gt; 实现效果： Coffee Black hot drink Milk White cold drink 分类块级元素:&lt;div&gt;元素 &lt;div&gt;元素是块级元素，它是可用于组合其他 HTML 元素的容器。 &lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。 设置&lt;div&gt; 元素的类(style)，使我们能够为相同的 元素设置相同的类1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.cities &#123; background-color:black; color:white; margin:20px; padding:20px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"cities\"&gt;&lt;h2&gt;London&lt;/h2&gt;&lt;p&gt;London is the capital city of England. It is the most populous city in the United Kingdom, with a metropolitan area of over 13 million inhabitants.&lt;/p&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 分类行内元素:&lt;span&gt; 元素 &lt;span&gt;元素是内联元素，可用作文本的容器。 元素也没有特定的含义。 内联元素在显示时通常不会以新行开始。 设置 &lt;span&gt; 元素的类(style)，能够为相同的 元素设置相同的样式。12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt; span.red &#123;color:red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My &lt;span class=\"red\"&gt;Important&lt;/span&gt; Heading&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; HTML布局 参考 行间距line-height HTML 框架 重要提示： 不能 将 标签与 标签同时使用！不过，假如你添加包含一段文本的 标签，就必须将这段文字嵌套于 标签内。（在下面的第一个实例中，可以查看它是如何实现的。） 1234567891011121314&lt;html&gt;&lt;frameset cols=\"25%,50%,25%\"&gt; &lt;frame src=\"/example/html/frame_a.html\"&gt; &lt;frame src=\"/example/html/frame_b.html\"&gt; &lt;frame src=\"/example/html/frame_c.html\"&gt;&lt;noframes&gt;&lt;body&gt;您的浏览器无法处理框架！&lt;/body&gt;&lt;/noframes&gt;&lt;/frameset&gt;&lt;/html&gt; 通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。 框架结构标签（&lt;frameset&gt;） 框架结构标签（&lt;frameset&gt;）定义如何将窗口分割为框架 每个 frameset 定义了一系列行或列（混合框架结构使用两对 将含有三份文档的框架结构混合置于行和列之中） rows/columns(cols)的值规定了每行或每列占据屏幕的面积(rows=”25%,50%,25%”规定了每行占据屏幕的面积【宽度】) frameset 标签也被某些文章和书籍译为框架集。 框架标签（Frame）Frame 标签定义了放置在每个框架中的 HTML 文档。 1234567891011&lt;html&gt;&lt;frameset cols=\"25%,50%,25%\"&gt; &lt;frame src=\"/example/html/frame_a.html\"&gt; &lt;frame src=\"/example/html/frame_b.html\"&gt; &lt;frame src=\"/example/html/frame_c.html\"&gt;&lt;/frameset&gt;&lt;/html&gt; 在上面的这个例子中，我们设置了一个三列的框架集。第一列被设置为占据浏览器窗口的 25%。第二列被设置为占据浏览器窗口的 50%。第三列被设置为占据浏览器窗口的 25%。HTML 文档 “frame_a.htm” 被置于第一个列中，而 HTML 文档 “frame_b.htm” 被置于第二个列中，而 HTML 文档 “frame_c.htm” 被置于第三个列中。 noresize 属性 给加上noresize=”noresize”，则框架是不可调整尺寸的。在框架间的边框上拖动鼠标，你会发现边框是无法移动的。 单独给加上noresize=”noresize”,则该框架不可调整尺寸。123456789&lt;html&gt;&lt;frameset cols=\"50%,25%,25%\"&gt; &lt;frame src=\"/example/html/frame_a.html\" noresize=\"noresize\" /&gt; &lt;frame src=\"/example/html/frame_b.html\" /&gt; &lt;frame src=\"/example/html/frame_c.html\" /&gt;&lt;/frameset&gt;&lt;/html&gt; rows，cols，colspan，rowspan rows排 cols列 colspan合并列 rowspan合并排 导航框架本例演示如何制作导航框架。导航框架包含一个将第二个框架作为目标的链接列表。名为 “contents.htm” 的文件包含三个链接。 123456&lt;html&gt;&lt;frameset cols=\"120,*\"&gt; &lt;frame src=\"/example/html/html_contents.html\"&gt; &lt;frame src=\"/example/html/frame_a.html\" name=\"showframe\"&gt;&lt;/frameset&gt;&lt;/html&gt; https://www.w3school.com.cn/example/html/html_contents.html中代码： 1234567&lt;body&gt;&lt;a href=\"/example/html/frame_a, html\"target=\"showframe\"&gt;Frame a&lt;/a&gt;&lt;br&gt;&lt;a href=\"/example/html/frame_b. html\"target=\"showframe\"&gt;Frame b&lt;/a&gt;&lt;br&gt;&lt;a href=\"/example/html/frame_c. html\"target=\"showframe\"&gt;Frame c&lt;/a&gt;&lt;/body&gt; 回顾一下标签中的target属性 参考 在框架中打开窗口不用打开一个完整的浏览器窗口，使用 target 更通常的方法是在一个 显示中将超链接内容定向到一个或者多个框架中。可以将这个内容列表放入一个带有两个框架的文档的其中一个框架中，并用这个相邻的框架来显示选定的文档. 举例： 1234&lt;frameset cols=\"100,*\"&gt; &lt;frame src=\"toc.html\"&gt; &lt;frame src=\"pref.html\" name=\"view_frame\"&gt;&lt;/frameset&gt; 当浏览器最初显示这两个框架的时候，左边这个框架包含目录，右边这个框架包含前言(初始化时就显示在页面右侧的pref.html)。这是 “toc.html” （即：左侧目录）的源代码： 1234567&lt;h3&gt;Table of Contents&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;&lt;a href=\"pref.html\" target=\"view_frame\"&gt;Preface&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"chap1.html\" target=\"view_frame\"&gt;Chapter 1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"chap2.html\" target=\"view_frame\"&gt;Chapter 2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"chap3.html\" target=\"view_frame\"&gt;Chapter 3&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 请注意，在文档 “toc.html” 中，每个链接的目标（target属性值） 都是 “view_frame”，也就是右边的框架。当用户从左边框架中的目录中选择一个链接时，浏览器会将这个关联的文档载入并显示在右边这个 “view_frame” 框架中。当其他链接被选中时，右边这个框架中的内容也会发生变化，而左边这个框架始终保持不变。 结合我们上文说过的“锚”跳转至框架内的一个指定的节本例演示两个框架。其中的一个框架设置了指向另一个文件内指定的节的链接。这个”link.htm”文件内指定的节使用 进行标识。 123456&lt;html&gt;&lt;frameset cols=\"20%,80%\"&gt; &lt;frame src=\"/example/html/frame_a.html\"&gt; &lt;frame src=\"/example/html/link.html#C10\"&gt;&lt;/frameset&gt;&lt;/html&gt; 使用框架导航跳转至指定的节本例演示两个框架。左侧的导航框架包含了一个链接列表，这些链接将第二个框架作为目标。第二个框架显示被链接的文档。导航框架其中的链接指向目标文件中指定的节。 123456&lt;html&gt;&lt;frameset cols=\"180,*\"&gt;&lt;frame src=\"/example/html/content.html\"&gt;&lt;frame src=\"/example/html/link.html\" name=\"showframe\"&gt;&lt;/frameset&gt;&lt;/html&gt;","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"百度前端技术学院 第二天学习笔记（HTML）（1）","slug":"百度前端技术学院 第二天学习笔记（HTML）","date":"2019-09-22T08:18:22.000Z","updated":"2019-11-19T09:22:11.256Z","comments":true,"path":"2019/09/22/百度前端技术学院 第二天学习笔记（HTML）/","link":"","permalink":"http://yoursite.com/2019/09/22/百度前端技术学院 第二天学习笔记（HTML）/","excerpt":"HTML 水平线&lt;hr /&gt;","text":"HTML 水平线&lt;hr /&gt; &lt;p&gt;&lt;/p&gt;与&lt;br /&gt; &lt;br /&gt;是换行,但不是空行，如果想要中间空行就需要&lt;br /&gt;&lt;br /&gt;才能实现效果 &lt;p&gt;&lt;/p&gt;前后会出现空行 两段文字中&lt;br /&gt;&lt;br /&gt;相当于放置两组&lt;p&gt;&lt;/p&gt; 上标与下标 &lt;sup&gt;&lt;/sup&gt;实现效果：上标 &lt;sub&gt;&lt;/subs&gt;实现效果：下标 W3School的例子 附赠粗体&lt;b&gt;，斜体&lt;i&gt;，大号字体&lt;big&gt;,小号字体&lt;small&gt; &lt;p&gt;&lt;/p&gt;与&lt;pre&gt;&lt;/pre&gt; &lt;p&gt;&lt;/p&gt;中无论出现多少个空格或换行都只识别为一个空格。 它不能保留（我是空格） 空格 （我是换行）和换行。 &lt;pre&gt;&lt;/pre&gt;是预格式文本。 它保留了 空格 和换行。 ==&lt;pre&gt;&lt;/pre&gt;适合用来显示计算机代码== &lt;abbr&gt;&lt;/abbr&gt;与&lt;acronym&gt;&lt;/acronym&gt; 在某些浏览器中，当您把鼠标移至缩略词语上时，会展示表达的完整版本。 该标签的title属性值为想要表达的完整版本。 在chrome中两个都可用。比如:缩略词语 [W3School的例子](https://www.w3school.com.cn/tiy/t.asp?f=html_abbracronym) 长引用与短引用 长(块)引用&lt;blockquote&gt;&lt;/blockquote&gt;浏览器会插入换行和外边距。（浏览器通常会对&lt;blockquote&gt;元素进行缩进处理） 短引用&lt;q&gt;&lt;/q&gt;不会插入换行和外边距，但会有双引号。 删除字效果和插入字效果 &lt;del&gt;&lt;/del&gt;实现效果：二十 &lt;ins&gt;&lt;/ins&gt;实现效果：十二 没有下划线的链接123&lt;a href=\"/example/html/lastpage.html\" style=\"text-decoration:none\"&gt;这是一个没有下划线的链接！&lt;/a&gt; 这是一个没有下划线的链接！ 超链接中的链接可以是图片或其他 HTML 元素-提示：”链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。 1&lt;a href=\"C:\\Users\\HLZ\\Desktop\\证件\\立介摄影 一寸.jpg\"&gt;证件照&lt;/a&gt; 新窗口打开超链接 target=&quot;_blank&quot;如果把链接的 target 属性设置为 “_blank”，该链接会在新窗口中打开。1&lt;a href=\"http://www.w3school.com.cn/\" target=\"_blank\"&gt;Visit W3School!&lt;/a&gt; 命名锚 可以作为目录导航来使用。 提示：命名锚经常用于在大型文档开始位置上创建目录。可以为每个章节赋予一个命名锚，然后把链接到这些锚的链接放到文档的上部。==如果您经常访问百度百科，您会发现其中几乎每个词条都采用这样的导航方式。== 提示：假如浏览器找不到已定义的命名锚，那么就会定位到文档的顶端。不会有错误发生。 1&lt;a name=\"label\"&gt;锚（显示在页面上的文本）&lt;/a&gt; name 属性规定锚（anchor）的名称。 当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 实际运用首先，我们在 HTML 文档中对锚进行命名（创建一个书签）： 1&lt;a name=\"tips\"&gt;基本的注意事项 - 有用的提示&lt;/a&gt; 然后，我们在同一个文档中创建指向该锚的链接： 1&lt;a href=\"#tips\"&gt;有用的提示&lt;/a&gt; 您也可以在其他页面中创建指向该锚的链接： 1&lt;a href=\"http://www.w3school.com.cn/html/html_links.asp#tips\"&gt;有用的提示&lt;/a&gt; 在上面的代码中，我们将 # 符号和锚名称添加到 URL 的末端，就可以直接链接到 tips 这个命名锚了。 一个完整的例子 外部样式表当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt;&lt;/head&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在head 部分通过 &lt;style&gt; 标签定义内部样式表。 123456&lt;head&gt;&lt;style type=\"text/css\"&gt;body &#123;background-color: red&#125;p &#123;margin-left: 20px&#125;&lt;/style&gt;&lt;/head&gt; 内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。 123&lt;p style=\"color: red; margin-left: 20px\"&gt;This is a paragraph&lt;/p&gt; 图片的替换文本属性（Alt）alt 属性用来为图像定义一串预备的可替换的文本。替换文本属性的值是用户定义的。 1&lt;img src=\"boat.gif\" alt=\"Big Boat\"&gt; 图片的align属性 align vi. 排列；排成一行 他的属性值（bottom，middle，top）设置图片的对齐方式 left,right使图片浮动在文本的左右侧。 标签的usemap属性——创建图像映射 本例显示如何创建带有可供点击区域的图像地图。其中的每个区域都是一个超级链接。 usemap用法 标签中的&lt;area&gt; 标签定义图像映射中的区域（注：图像映射指得是带有可点击区域的图像）。area 元素总是嵌套在 标签中。&lt;area&gt; 标签相关用法规定区域的coords属性","categories":[{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"},{"name":"百度前端技术学院","slug":"百度前端技术学院","permalink":"http://yoursite.com/categories/百度前端技术学院/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"history对象","slug":"history对象","date":"2019-09-16T03:36:16.000Z","updated":"2019-09-26T06:23:47.386Z","comments":true,"path":"2019/09/16/history对象/","link":"","permalink":"http://yoursite.com/2019/09/16/history对象/","excerpt":"history历史对象history 对象保存了用户在浏览器中访问页面的历史记录。","text":"history历史对象history 对象保存了用户在浏览器中访问页面的历史记录。 history对象的属性 length返回浏览器历史列表中的 URL数量 history对象的方法回到历史记录的上一步 语法：history.back（） 功能：回到历史记录的上一步 说明：相当于使用了history.go（-1） 补充：使用history.go（-2）则是回到历史记录的上一步的再上一步 举例： index10.html里面给个超链接跳转到index11.html： 1&lt;a href=\"index11.html\"&gt;跳转到index11.html&lt;/a&gt; index11.html里给个后退按钮： 1234567891011&lt;body&gt; &lt;p&gt;这是index11.html&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn\" value=\"后退\"&gt;&lt;/p&gt; &lt;script&gt; var btn=document.getElementById(\"btn\"); btn.onclick=function()&#123; history.back(); //history.go(-1); &#125; &lt;/script&gt;&lt;/body&gt; 回到历史记录的下一步 语法：location.forward（） 注意：千万不要忘记forward后面的括号 功能：回到历史记录的下一步 说明：相当于使用了history.go（1） 举例 index11.html：有新增的2个按钮（前进，前进两个页面）和一个跳转index12.html的链接 1234567891011121314151617181920212223242526&lt;body&gt; &lt;p&gt;这是index11.html&lt;/p&gt; &lt;p&gt; &lt;a href=\"index12.html\"&gt;跳转到index12.html&lt;/a&gt; &lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn\" value=\"后退\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn2\" value=\"前进\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"button\" id=\"btn3\" value=\"前进2\"&gt;&lt;/p&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); var btn2 = document.getElementById(\"btn2\"); var btn3 = document.getElementById(\"btn3\"); btn.onclick = function () &#123; // history.back(); history.go(-1); &#125; btn2.onclick = function () &#123; history.forward(); // history.go(1); &#125; btn3.onclick = function () &#123; history.go(2); &#125; &lt;/script&gt;&lt;/body&gt; 做两个可供跳转的页面index12.html和index13.html，从12跳到13 123456&lt;body&gt; &lt;p&gt;这是index12.html&lt;/p&gt; &lt;p&gt; &lt;a href=\"index13.html\"&gt;跳转到index13.html&lt;/a&gt; &lt;/p&gt;&lt;/body&gt; 123&lt;body&gt; &lt;p&gt;这是index13.html&lt;/p&gt; &lt;/body&gt; 跳到13以后再回到11去测试按钮 前进或者后退多步 语法：history.go（-n） 功能：回到历史记录的前n步 语法：history.go（n） 功能：回到历史记录的后n步","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-09-15T14:22:54.206Z","updated":"2019-09-15T14:22:54.206Z","comments":true,"path":"2019/09/15/hello-world/","link":"","permalink":"http://yoursite.com/2019/09/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"BOM window对象","slug":"BOM window对象","date":"2019-09-13T15:20:25.000Z","updated":"2020-03-31T13:30:42.764Z","comments":true,"path":"2019/09/13/BOM window对象/","link":"","permalink":"http://yoursite.com/2019/09/13/BOM window对象/","excerpt":"注意 敲代码时一定要注意，&lt;script&gt;中用到的属性值要加引号！（style中不用）","text":"注意 敲代码时一定要注意，&lt;script&gt;中用到的属性值要加引号！（style中不用） Window对象的方法 window 对象表示浏览器中打开的窗口。 注意： 弹框中的文本需要 换行 使用 \\n alert()消息+确认按钮的警告框 语法：window.alert（&quot;content&quot;) 功能：显示带有一段消息和一个确认按钮的警告框 confirm()消息+OK+取消按钮的对话框 语法：window.confirm（“你想要显示的提示消息&quot;） 功能：显示一个带有指定消息和OK及取消按钮的对话 返回值 （布尔型）： 如果用户点击确定按钮，则confirm（）返回true 如果用户点击取消按钮，则confirm（）返回false 举例：1234567891011121314151617&lt;body&gt; &lt;div id=\"box\"&gt; &lt;span&gt;iphone6s&lt;/span&gt; &lt;input type=\"button\" value=\"删除\" id=\"btn\"&gt; &lt;/div&gt; &lt;script&gt; // 获取按钮,绑定事件 var btn=document.getElementById(\"btn\"); btn.onclick=function()&#123; // 弹出确认对话框 var result=window.confirm(\"您确定要删除吗？删除之后该信息\\n将不可恢复！\"); if(result)&#123; document.getElementById(\"box\").style.display=\"none\"; &#125; &#125; &lt;/script&gt;&lt;/body&gt; prompt()消息+输入框+OK+取消按钮的对话框 语法：window.prompt（&quot;text，defaultText&quot;） text：要在对话框中显示的纯文本（而不是HTML格式的文本） defaultText：默认的输入文本 返回值 （字符串）： 如果用户单击提示框的取消按钮，则返回null 如果用户单击确认按钮，则返回输入字段当前显示的文本 举例：刷新页面时就会弹出提示框，点击“取消”发现打印出null，点击“确认”，发现返回默认的输入文本”天蝎座”，输入“金牛座”再点击“确认”，返回的是“金牛座”。123456&lt;body&gt; &lt;script&gt; var message=prompt(\"请输入您的星座\",\"天蝎座\"); console.log(message); &lt;/script&gt;&lt;/body&gt; 编程练习点击页面上的“删除”按钮，弹出确认框（1）当点击确认框上的“确定“时，按钮上的字变为红色；（2）当点击确认框上的“取消“时，按钮上的字变为绿色。 123456789101112131415161718&lt;body&gt; &lt;input type=\"button\" value=\"删除\" id=\"btn\"&gt; &lt;script type=\"text/javascript\"&gt; // 获取按钮 var btn=document.getElementById(\"btn\"); // 绑定鼠标单击事件 btn.onclick=function()&#123; // 弹框 var result=window.confirm(\"确定要删除吗？\") if(result)&#123; // 一定要注意，属性值要加引号！ btn.style.color=\"red\"; &#125;else&#123; btn.style.color=\"green\"; &#125; &#125; &lt;/script&gt;&lt;/body&gt; 地址：E:\\慕课网 前端小白入门系列课程完整版\\JavaScript\\7.javascriptBOM对象\\test1.html open()打开新的浏览器窗口或查找一个已命名的窗口 语法：window.open（pageURL，name，parameters） pageURL：子窗口路径（同一目录下可以直接写文件名称）。 name：子窗口句柄。（name声明了新窗口的名称，方便后期通过name对子窗口进行引用） parameters：窗口参数（各参数用逗号分隔） 功能：打开一个新的浏览器窗口或查找一个已命名的窗口 窗口参数包括： width：窗口宽度 height：窗口高度 left：窗口X轴坐标 top：窗口Y轴坐标 toolbar：是否显示浏览器的工具栏 menubar：是否显示菜单栏 scrollbars：是否显示滚动条 location：是否显示地址字段 status：是否添加状态栏 close()关闭浏览器窗口 语法：window.close（） 功能：关闭浏览器窗口 合并举例同目录下两个页面 1234567891011121314&lt;body&gt; &lt;input type=\"button\" value=\"退 出\" id=\"quit\"&gt; &lt;script&gt; window.onload = function()&#123; // 打开子窗口，显示newwindow.html window.open(\"newwindow.html\",\"width=400,height=200,left=0,top=0,toolbar=no,menubar=no,scrollbars=no,location=no,status=no\"); var quit = document.getElementById(\"quit\"); // 点击关闭当前窗口（子窗口是不会关的，可以在子窗口内做一个退出按钮） quit.onclick = function()&#123; window.close(); &#125; &#125; &lt;/script&gt;&lt;/body&gt; 第二个页面（newwindow.html） 123&lt;body&gt; &lt;h1&gt;hello window.open&lt;/h1&gt;&lt;/body&gt; 超时调用与间歇调用注意 首先要明确JavaScript是单线程语言，单线程就是所执行的代码必须按照顺序。 【1秒等于1000毫秒】 setTimeout()超时调用 语法：setTimeout（code，millisec） code：要调用的函数或要执行的JavaScript代码串【注意：并不建议写代码串，最好是用匿名函数或者自定义函数】 millisec：在执行代码前需等待的毫秒数 功能：在指定的毫秒数后调用函数或计算表达式 ,即延长多少时间以后再发生这个事。 说明：setTimeout（）只执行code一次。如果要多次调用，请使用setlnterval（）或者让code自身再次调用setTimeout（）【例子在下面】 使用超时调用实现多次调用的例子让setTimeout（）自身再次调用setTimeout（）实现间隔一秒输出数字1-10： 函数inCreamentNum调用时先打印num（1） 递增（num=2），然后判断是否小于max（10） 如果小于则再次调用setTimeout（），输出num（2） 一直到num为11时清除延时调用。 补充：timer之所以给null而不是空字符是因为超时调用的id是个对象，建议给null来释放内存是因为空字符就指定了这个对象实例的值是一个长度为0的空字符串。123456789101112131415161718&lt;body&gt; &lt;script&gt; var num=1, max=10, timer=null; // 使用超时调用实现间隔一秒输出数字1-10 function inCreamentNum()&#123; console.log(num); // 1 2 3 ... 10 num++; if(num&lt;=max)&#123; setTimeout(inCreamentNum,1000); &#125;else&#123; clearTimeout(timer); &#125; &#125; timer=setTimeout(inCreamentNum,1000); &lt;/script&gt;&lt;/body&gt; clearTimeout()清除（取消）超时调用 SetTimeout方法返回一个ID值，我们可以通过它取消超时调用。 语法：clearTimeout（id_of settimeout） id of settimeout：由setTimeout（）返回的ID值，该值标识要取消的延迟执行代码块。 功能：取消由setTimeout（）方法设置的timeout 合并举例1234567891011121314151617181920&lt;body&gt; &lt;script&gt; //setTimeout(\"alert('hello')\",4000);不推荐 // 自定义函数1 var fnCall = function () &#123; alert(\"world\"); &#125; // 自定义函数2，调用 //setTimeout(fnCall,5000); // 匿名函数 var timeout1 = setTimeout(function () &#123; alert(\"hello\"); &#125;, 2000) // 清除超时调用 clearTimeout(timeout1); &lt;/script&gt;&lt;/body&gt; setinterval()间歇调用 语法：setinterval（code，millisec） code：要调用的函数或要执行的代码串。 millisec：周期性执行或调用code之间的时间间隔，以毫秒计 功能：每隔指定的时间执行一次代码 clearIntervall()清除间歇调用 语法：clearIntervall（id of setinterval） id_of_setinterval：由setinterval（）返回的ID值 功能：取消由setInterval（）方法设置的interval 合并举例打印10次”您好”： 利用间歇调用打印”您好” 延时调用使得10秒之后执行“清除间歇调用”停止打印12345678910111213&lt;body&gt; &lt;script&gt; // 打印10次\"您好\" var intervalId=setInterval(function()&#123; console.log(\"您好\"); &#125;,1000) // 10秒之后停止打印 setTimeout(function()&#123; clearInterval(intervalId); &#125;,10000); &lt;/script&gt;&lt;/body&gt; 间隔1秒输出1-10： 利用间歇调用与递增打印 每一次递增后都判断是否到达10，到达则清除间歇调用123456789101112131415&lt;body&gt; &lt;script&gt; var num=1, max=10, timer=null; // 每隔1秒针num递增一次，直到num的值等于max清除 timer=setInterval(function()&#123; console.log(num); num++; if(num&gt;max)&#123; clearInterval(timer); &#125; &#125;,1000) &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"DOM事件","slug":"JS_DOM事件","date":"2019-09-11T06:38:27.000Z","updated":"2020-07-27T05:31:13.248Z","comments":true,"path":"2019/09/11/JS_DOM事件/","link":"","permalink":"http://yoursite.com/2019/09/11/JS_DOM事件/","excerpt":"事件类型注意：代码从上往下执行，在DOM事件中，如果先在&lt;script&gt;里获取对象再通过&lt;div&gt;定义对象会报错，因为这个对象的定义是出现在了获取的后面，你想要获取的时候还没定义。此时可以在&lt;script&gt;里使用鼠标事件中的onload（例子在下方）","text":"事件类型注意：代码从上往下执行，在DOM事件中，如果先在&lt;script&gt;里获取对象再通过&lt;div&gt;定义对象会报错，因为这个对象的定义是出现在了获取的后面，你想要获取的时候还没定义。此时可以在&lt;script&gt;里使用鼠标事件中的onload（例子在下方） 关于this指向 在事件触发的（function）函数中，this是对该DOM对象的引用。 可以通过console.log(this)来看this在这个函数中指的是什么。 onload 事件 页面或图像加载完成后立即发生。 onload 通常用于 &lt;body&gt; 元素，在页面完全载入后(包括图片、css文件等等。)执行脚本代码。 该事件可作用于以下 HTML 标签：&lt;body&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;iframe&gt;,&lt;img&gt;, &lt;input type=&quot;image&quot;&gt;, &lt;link&gt;, &lt;script&gt;,&lt;style&gt; 例子 语法：在 HTML 中: 1&lt;body onload=\"SomeJavaScriptCode\"&gt; 在 JavaScript 中: 1window.onload=function()&#123;SomeJavaScriptCode&#125;; 鼠标事件 onclick：鼠标点击时触发 onmousedown：鼠标按钮在元素上按下时触发 onmousemove：每次鼠标指针移动时都会触发 onmouseover：鼠标滑过指定对象上时触发 onmouseout：鼠标离开时触发 onmouseenter：类似onmouseover，唯一的区别是 onmouseenter 事件不支持冒泡 onmouseleave：类似onmouseout，唯一的区别是 onmouseleave 事件不支持冒泡 onmouseup：在元素上松开鼠标按钮时触发 onfoucs：获得焦点时触发 （只能用于：input标签type为text、passwordtextarea标签） onblur：失去焦点时触发（blur v.使……模糊不清） onchange：域的内容改变时发生 （一般作用于（下拉框）select或checkbox或radio） onsubmit：表单中的确认按钮被点击时发生 （onsubmit事件不是加在按钮上，而是表单上） onresize：当调整浏览器窗口的大小时触发 onscroll：拖动滚动条滚动时触发 需要知道： onmousedown（按下鼠标）与onmouseup（松开鼠标）组成了onclick（鼠标点击）事件。 onmouseover或onmousemove都必须和onmouseout结合才能实现移入移出不同效果的功能。（onmouseover的例子、onmousemove的例子） onmousemove与onmouseover的区别 时间上 onmousemove 事件触发后，再触发 onmouseover 事件。 动作上 onmouseover 只在刚进入区域时触发。onmousemove 除了刚进入区域触发外，在区域内移动鼠标，也会触发该事件。（当鼠标移动很快时，可能不会触发这两个事件。） onmouseover 与 onmousemove 的区别是： onmousemove在每次鼠标移动时，都会触发，以此获得当前坐标值，用来判断这个点是否落在指定元素内。onmouseover，则会在进入对象时就触发，且仅会触发这一次。当鼠标移过当前对象时就产生了onmouseover事件（onmouseover有个移入移出的过程）,当鼠标在当前对象上移动时就产生了onmousemove事件，只要是在对象上移动而且没有移出对象的，就是onmousemove事件。 例子用canvas标签，创建了一个画布，并画了一个小矩形，我想让鼠标悬停到矩形区域时改变矩形填充色，这里只能监听整个画布，看起来应该用over，实际上用的却是move。因为，move在每次鼠标移动时，都会触发，会获得当前坐标值，用来判断这个点是否落在矩形内。若是用over，则会在进入画布时就触发，且仅会触发这一次，之后鼠标在画布内移动，一直都处于over状态，就不会触发，直到鼠标离开这个画布区域，失效。 HTML事件中调用JS函数时不加括号 加括号就是直接执行函数了，不加括号则是指向函数地址，当发生事件时才去调用函数。 事件=function(){}或者事件=函数名都是可以的，不能使用事件=(function(){})(参数)或事件=函数名()。 如果事件绑定函数想要传参可以使用xx.onclick=function(){函数名(参数);}，也就是绑定一个函数，函数在触发onclick时执行，函数内容是执行你想传参的那个函数。 对window使用onload的例子12345678910111213141516&lt;head&gt; &lt;script&gt; // 页面加载完成后才执行 window.onload=function()&#123; // 获取box var box =document.getElementById(\"box\"); var clicked=function()&#123; alert(\"我被点击了！\"); &#125; box.onclick=clicked; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt;这是一个box&lt;/div&gt;&lt;/body&gt; onfocus事件 只能用于：input标签type为text、password textarea标签 onfocus和onblur事件的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box&#123; padding:50px; &#125; .left,.tip&#123; float:left; &#125; .left&#123;margin-right:10px;&#125; .tip&#123;display:none;font-size:14px;&#125; &lt;/style&gt; &lt;script&gt; window.onload=function()&#123; // 获取文本框和提示框 var phone=document.getElementById(\"phone\"), tip=document.getElementById(\"tip\"); // 给文本框绑定激活的事件 phone.onfocus=function()&#123; // 让tip显示出来 tip.style.display='block'; &#125; // 给文本框绑定失去焦点的事件 phone.onblur=function()&#123; // 获取文本框的值,value用于获取表单元素的值 var phoneVal=this.value; // 判断手机号码是否是11位的数字 // 如果输入正确，则显示对号图标，否则显示错号图标 if(phoneVal.length**11 &amp;&amp; isNaN(phoneVal)**false)&#123; tip.innerHTML='&lt;img src=\"E:/慕课网 前端小白入门系列课程完整版/JavaScript/6.javascriptDoM事件/img/right.png\"&gt;'; &#125;else&#123; tip.innerHTML='&lt;img src=\"E:/慕课网 前端小白入门系列课程完整版/JavaScript/6.javascriptDoM事件/img/error.png\"&gt;'; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt; &lt;input type=\"text\" id=\"phone\" placeholder=\"请输入手机号码\"&gt; &lt;/div&gt; &lt;div class=\"tip\" id=\"tip\"&gt; 请输入有效的手机号码 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 实现效果可以看E:\\慕课网 前端小白入门系列课程完整版\\JavaScript\\6.javascriptDoM事件\\index4.html “onchange：域的内容改变时发生”的例子change事件,一般作用域（下拉框）select或checkbox或radio。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script&gt; // 页面加载（注意这是对DOM0级事件的命名函数调用，不要括号） window.onload=init; // 初始化 function init()&#123; // 获取下拉菜单 var menu=document.getElementById(\"menu\"); // 给菜单绑定change事件,一般作用域select或checkbox或radio menu.onchange=function()&#123; // 获取当前选中的值 var bgcolor=this.value; // var bgcolor=menu.options[menu.selectedIndex].value; // 可以先打印出来看看选中选项以后得到的value是什么 // console.log(bgcolor); // 设置body的背景色 //如果bgcolor为空，则下面的脚本将不执行，否则是选择的颜色 if(bgcolor**\"\")&#123; return; &#125;else&#123; document.body.style.background=bgcolor; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; 请选择您喜欢的背景色： &lt;select name=\"\" id=\"menu\"&gt; &lt;option value=\"\"&gt;请选择&lt;/option&gt; &lt;option value=\"#f00\"&gt;红色&lt;/option&gt; &lt;option value=\"#0f0\"&gt;绿色&lt;/option&gt; &lt;option value=\"#00f\"&gt;蓝色&lt;/option&gt; &lt;option value=\"#ff0\"&gt;黄色&lt;/option&gt; &lt;option value=\"#ccc\"&gt;灰色&lt;/option&gt; &lt;/select&gt; &lt;/div&gt;&lt;/body&gt; html中使用js中的onchange注意：事件函数中调用函数都不用括号。不建议使用html事件，建议使用DOM事件。 123456789101112131415161718&lt;html&gt;&lt;head&gt;&lt;script type=\"text/javascript\"&gt;function upperCase(x)&#123;var y=document.getElementById(x).valuedocument.getElementById(x).value=y.toUpperCase()&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;Enter your name: &lt;input type=\"text\" id=\"fname\" onchange=\"upperCase(this.id)\"&gt;&lt;/body&gt;&lt;/html&gt; 效果 onchange事件编程练习注意： if的条件判断一定要注意是两个等号！！ 要求实现下列功能: 选择下拉列表中不同的选项，页面中的d iv就设置成不同的背景颜色，div中的内容也发生变化。 比如：选择黄色选项，div的背景颜色就变为黄色，文本内容就变为“我的背景颜色变成了yellow色” 当选择下拉列表中的“请选择”时，div的背累颜色变成白色，文本变为“我没有发生任何变化” 实现: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;head&gt; &lt;style type=\"text/css\"&gt; #div &#123; width: 300px; height: 300px; border: 2px solid gray; margin: 100px 0 0 200px; display: none; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; // 页面加载完成后才执行 window.onload = function () &#123; // 获取下拉框与文字 var colorSelect = document.getElementById(\"color\"); var bgText=document.getElementById(\"div\"); // console.log(bgText.innerHTML) // 绑定事件 colorSelect.onchange = choose; function choose() &#123; // console.log(this.value); var bgColor=this.value; // 选择颜色时让下方文字框可见 bgText.style.display=\"block\"; // 一定要注意是两个等号！ if(bgColor**\"0\")&#123; bgText.innerHTML=\"我没有变化呀\"; &#125;else&#123; bgText.innerHTML=\"我变成\"+bgColor+\"色了诶\"; document.body.style.background=bgColor; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;span&gt;请选择您喜欢的颜色：&lt;/span&gt; &lt;select name=\"\" id=\"color\"&gt; &lt;option value=\"0\"&gt;请选择&lt;/option&gt; &lt;option value=\"yellow\"&gt;黄色&lt;/option&gt; &lt;option value=\"orange\"&gt;橘色&lt;/option&gt; &lt;option value=\"pink\"&gt;粉色&lt;/option&gt; &lt;option value=\"purple\"&gt;紫色&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div id=\"div\"&gt;我是下方文字&lt;/div&gt;&lt;/body&gt; 地址：E:\\慕课网 前端小白入门系列课程完整版\\JavaScript\\6.javascriptDoM事件\\test.html onsubmit事件注意： onsubmit事件不是加在按钮上，而是form表单上。 例子： 1234567891011121314151617&lt;body&gt; &lt;!-- 表单中的确认按钮被点击时发生 --&gt; &lt;p&gt;当提交表单是，触发函数并弹出提示信息。&lt;/p&gt; &lt;form action=\"demo-form.php\" id=\"form_ok\"&gt; 输入名字: &lt;input type=\"text\" name=\"fname\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt; &lt;script&gt; // 获取表单（不是确认按钮！） var ok=document.getElementById(\"form_ok\"); // 绑定事件 ok.onsubmit=myFunction; function myFunction() &#123; alert(\"表单已提交\"); &#125; &lt;/script&gt;&lt;/body&gt; E:\\慕课网 前端小白入门系列课程完整版\\JavaScript\\6.javascriptDoM事件\\onsubmit.html 三个比较简单的鼠标事件想了解可以看index6.html onmousedown：鼠标按钮在元素上按下时触发 onmousemove：在鼠标指针移动时发生 onmouseup：在元素上松开鼠标按钮时触发 经常作用于window对象的两个事件 onresize：当调整浏览器窗口的大小时触发 onscroll：拖动滚动条滚动时触发 事件处理HTML 事件处理 DOM事件写在html中不符合 行为、结构、样式 相分离的原则 尽量不要把DOM事件写在HTML中。 多元素绑定相同事件时，效率低。 不建议在HTML元素中写JavaScript代码。（将页面元素写在HTML内，JS代码写在&lt;script&gt;内会更好） HTML中的语法：&lt;element onclick=&quot;SomeJavaScriptCode&quot;&gt; 以onclick举例：12345// html中&lt;button onclick=\"activateLasers()\"&gt; 激活按钮&lt;/button&gt;// activateLasers()写在JS代码中 JS 事件处理 注意：JS代码要在HTML代码加载完成后执行 获取DOM元素=&gt;绑定事件函数 DOM 0级事件处理 优点：符合 行为、结构、样式 相分离的原则。还可以选出DOM元素集合通过for循环统一操作。 缺点：每个DOM元素只能绑定一个同类事件。例如绑定onclick，当你想再绑定onclick会发现他被覆盖了。 语法（以onclick举例）：object.onclick=function(){SomeJavaScriptCode}; 以onclick举例：12345678910111213// html中&lt;body&gt; &lt;p&gt;单击按钮触发函数。&lt;/p&gt; &lt;button id=\"btn\"&gt;点我&lt;/button&gt; &lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;/body&gt;// js中&lt;script&gt; document.getElementById(\"btn\").onclick=function()&#123; document.getElementById(\"demo\").innerHTML=\"Hello World\"; &#125;&lt;/script&gt; DOM 2级事件处理（事件监听） addEventListener(&quot;事件名&quot; , &quot;事件处理函数&quot; , &quot;布尔值&quot;); false 事件冒泡;true 事件捕获 优点相比前两个就多了。可以选择是事件流。可绑定多个同类事件。事件名可以组成字符串。 注意：使用addEventListener绑定事件，等结束后及时使用removeEventListener移除监听 React事件处理 React 元素的事件处理和 DOM 元素类似。但是有一点语法上的不同: React 事件绑定函数的命名采用驼峰式写法，而不是小写。 在类中书写时注意在构造函数中使用bind()绑定事件函数的this指向。 以onClick举例： 123456// JSX语法中&lt;button onClick=&#123;activateLasers&#125;&gt; 激活按钮&lt;/button&gt;// activateLasers函数另写 具体事例：当使用 ES6 class 语法来定义一个组件的时候，事件处理函数会成为类的一个方法。例如，Toggle 组件渲染一个让用户切换开关状态的按钮的例子","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS中修改/创建/移动/删除 HTML DOM元素","slug":"JS中修改创建HTML DOM元素的方法","date":"2019-09-06T06:45:14.000Z","updated":"2020-03-15T04:56:09.531Z","comments":true,"path":"2019/09/06/JS中修改创建HTML DOM元素的方法/","link":"","permalink":"http://yoursite.com/2019/09/06/JS中修改创建HTML DOM元素的方法/","excerpt":"JS往HTML中添加节点的流程总结HTML元素 通常是由 元素节点 和 文本节点 组成。 使用createElement()创建 元素节点 使用createTextNode() 创建 文本节点 使用appendChild() 将节点添加到另一个节点列表的末尾","text":"JS往HTML中添加节点的流程总结HTML元素 通常是由 元素节点 和 文本节点 组成。 使用createElement()创建 元素节点 使用createTextNode() 创建 文本节点 使用appendChild() 将节点添加到另一个节点列表的末尾 例子创建一个标题 (H1), 你必须创建 “H1” 元素 和 文本节点 : 12345678// 创建元素名称为H1的元素节点hvar h=document.createElement(\"H1\")// 创建内容为Hello World的文本节点tvar t=document.createTextNode(\"Hello World\");// 将文本节点t添加到元素节点h的末尾h.appendChild(t);// 将元素节点h添加到document对象的body列表末尾document.body.appendChild(h); 完整例子以及效果 HTML DOM Document 对象 每个载入浏览器的 HTML 文档都会成为 Document 对象。 Document 对象使我们可以从脚本中对 HTML 页面中的所有元素进行访问。 Node.appendChild() 添加/移动 子节点 语法：node1.appendChild(node2) appendChild()方法可向节点（node1）的子节点列表的末尾添加新的子节点（node2）。 注意： node2是添加到node1内部的！ 如果node2已存在于js文件中，则appendChild()会将node2 移动 到node1之中 参数node2：（节点对象）必须，你要添加的节点对象。 返回值：（节点对象）添加的节点。 例子 document.createElement()创建元素节点 createElement() 方法通过指定名称创建一个元素。 语法:document.createElement(nodename) 参数nodename：（String）必须，创建元素的名称。（注意不是自定义的！！） &quot;BUTTON&quot;/&quot;button&quot;：创建按钮元素 &quot;H1&quot;/&quot;h1&quot;:创建H1标题 &quot;div&quot;等，以此类推。 返回值：（元素对象）创建的元素节点。 注意：createElement()要与appendChild()结合起来使用才能使创建的元素显示在页面上。例子：HTML元素经常包含文本。创建指定文本的按钮你需要在按钮元素后添加文本节点 document.createTextNode() 创建 文本节点HTML元素 通常是由 元素节点 和 文本节点 组成。 createTextNode() 可创建文本节点。 语法:document.createTextNode(text) 参数text：（String）必须。文本节点的文本。 返回值：（文本节点对象）创建的文本节点。 例子 Node.removeChild() 删除子节点 removeChild() 方法删除子节点。 语法：let oldChild = node.removeChild(child);或element.removeChild(child); child:是要移除的那个子节点. node:是child的父节点. oldChild保存对删除的子节点的引用. oldChild === child. 返回值：成功该函数返回被删除的节点，如果失败则返回 NULL。 被移除的这个子节点仍然存在于内存中,只是没有添加到当前文档的DOM树中,因此,你还可以把这个节点重新添加回文档中,当然,实现要用另外一个变量比如上例中的oldChild来保存这个节点的引用. 如果使用上述语法中的第二种方法, 即没有使用 oldChild 来保存对这个节点的引用,则认为被移除的节点已经是无用的,在短时间内将会被内存管理回收. 如果上例中的child节点不是node节点的子节点,则该方法会抛出异常. MDN参考 例子 使用let实现面试常见小例子代码解析： 先在HTML文档中创建一个按钮节点btn 再改变节点文字 然后给节点btn设置一个点击事件 最后将节点btn添加到body中 原因：执行事件时，alert（）首先需要i，但是当前作用域找不到，它就会到上一级找，上一级通过自调用时有传进来的i，这个i是随着函数的调用而产生，随着函数调用结束而释放的，不是作用在一开始的var i身上的，所以每一个函数都对应不同的数字。 变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所以每一次循环中btn的innerText所指向的i其实都是同一个，循环到最后时前面的i全部被最后的结果覆盖了。而局部变量的话就是每循环一次产生一个新的i，所以不会被覆盖。 原因：执行事件时，alert（）首先需要i，但是当前作用域找不到，它就会到上一级找，上一级直接就是var i了，所有的代码都作用在它身上，所以他会是11。 可以发现，使用let以后就不需要额外放一个自调用函数把他们框起来了。变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"DOM基础","slug":"DOM基础","date":"2019-09-05T13:27:50.000Z","updated":"2020-08-05T04:15:20.383Z","comments":true,"path":"2019/09/05/DOM基础/","link":"","permalink":"http://yoursite.com/2019/09/05/DOM基础/","excerpt":"DOM元素的获取方法DOM元素可以理解为html文件中的元素（但实际上DOM由HTML解析而来），可以通过DOM查找（获取）方法获取在js文件（script）中对应的html文件中的元素。","text":"DOM元素的获取方法DOM元素可以理解为html文件中的元素（但实际上DOM由HTML解析而来），可以通过DOM查找（获取）方法获取在js文件（script）中对应的html文件中的元素。 注意： document.xxx来获取DOM元素是在document内部获取匹配的元素，替换成DOM元素A.xxx则表示在DOM元素A内部获取匹配的元素，所以只要知道父元素的限定条件，就可以通过DOM元素的获取方法轻松获取该父元素内部的各个子元素 获取1个DOM元素getElementByld()根据id得到一个元素/对象 语法:document.getElementByld(&quot;id&quot;) 功能:返回对拥有指定ID的第一个对象的引用 返回值:DOM对象 说明:id为DOM元素上id属性的值12345678910&lt;body&gt; &lt;div class=\"box\" id=\"box\"&gt; 元素1 &lt;/div&gt; &lt;script&gt; //获取id为box的这个元素 var box = document.getElementById(\"box\"); console.log(box); &lt;/script&gt;&lt;/body&gt; lastChild与lastElementChild 他们都是获取元素的最后一个 子元素 lastChild是IE8之前旧版本写法，可获取的包括注释节点。 随着更新，出现新方法选取子节点，同时可以进行过滤，lastElementChild就只获取元素节点。 Element.lastElementChild lastChild例子：123456789101112&lt;body&gt;&lt;ul id=\"myList1\"&gt;&lt;li&gt;Coffee&lt;/li&gt;&lt;li&gt;Tea&lt;/li&gt;&lt;/ul&gt;&lt;ul id=\"myList2\"&gt;&lt;li&gt;Water&lt;/li&gt;&lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt;&lt;p id=\"demo\"&gt;单击按钮将项目从一个列表移动到另一个列表中&lt;/p&gt;&lt;button onclick=\"myFunction()\"&gt;点我&lt;/button&gt;&lt;script&gt;function myFunction()&#123; var node=document.getElementById(\"myList2\").lastChild; document.getElementById(\"myList1\").appendChild(node);&#125;&lt;/script&gt; 最终效果 firstChild与firstElementChild 同上，他们都是获取元素的第一个 子元素 firstChild是IE8之前旧版本写法，可获取的包括注释节点。Element.firstElementChild返回对象的第一个子元素 querySelector() querySelector() 方法返回文档中匹配指定 CSS 选择器的第一个元素。 如果需要返回所有的元素，请使用 querySelectorAll() 方法。 语法：document.querySelector(CSS selectors) CSS selectors:字符串，需要引号。 指定一个或多个用于匹配元素的 CSS 选择器。 可以使用它们的 id, 类, 类型, 属性, 属性值等来选取元素。 对于多个选择器，使用逗号隔开。 最终只返回第一个匹配的元素。 例子：获取文档中 id=”demo” 的元素： 1document.querySelector(\"#demo\"); 完整例子 获取多个DOM元素（集合） 注意：通过以下方法得到的都是DOM元素的集合，也就是NodeList 对象，是一个类数组。 返回值： NodeList 对象。 node：节点，即DOM元素。=&gt; NodeList:节点组成的数组。 可以通过索引访问指定DOM元素，索引值从 0 开始。 NodeList 对象的 length 属性：获取匹配选择器的元素属性，然后你可以遍历所有元素，从而获取你想要的信息。 getElementsByTagName()和getElementsByClassName()都有s！！要和getElementById()区分开！！ getElementsByTagName() 注意： 前面是document就会获取整个body中的“tag”，如果想要获取指定id下的“tag”可以和上面的语法叠加使用。 getElementsByTagName() 有s！！ 语法:document.getElementsByTagName(&quot;tag&quot;) tag为要获取的标签名称 功能:返回一个对所有tag标签引用的集合 返回值:类数组 通过标签名选取的元素是一个类数组对象，如果你要获取到特定的元素，那么就要像数组一样，下标从0开始算起，找到这个元素，比如：要找第三个li，要找lis[2]。 12345678910111213141516171819202122&lt;body&gt; &lt;ul id=\"list1\"&gt; &lt;li&gt;啦啦啦&lt;/li&gt; &lt;li&gt;黄女士&lt;/li&gt; &lt;li&gt;困困&lt;/li&gt; &lt;/ul&gt; &lt;ol id=\"list2\"&gt; &lt;li&gt;醒醒&lt;/li&gt; &lt;li&gt;臭臭&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; //获取页面中所有的li var lis=document.getElementsByTagName(\"li\"); console.log(lis.length);//5，注意会获取整个body中的“li” //获取id为list1下的所有的1i var lis2 = document.getElementById(\"list1\").getElementsByTagName(\"li\"); console.log(lis2.length);//3 // 找第三个li var li3=lis[2]; console.log(li3);//困困 &lt;/script&gt;&lt;/body&gt; 注意：前面是document就会获取整个body中的“tag”，如果想要获取指定id下的“tag”可以和上面的语法叠加使用。 12document.getElementsByTagName(\"li\");//获取整个body中的“li”document.getElementById(\"list1\").getElementsByTagName(\"li\");//获取id为\"list1\"这个对象中的“li” getElementsByClassName() getElementsByClassName() 方法返回文档中所有指定类名的元素集合，作为 NodeList 对象。 返回值：类数组 语法：element.getElementsByClassName(classname) classname：（String）必须。你需要获取的元素类名。多个类名使用空格分隔，如 “test demo”。 例子 querySelectorAll() querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的所有元素组成的集合。 返回值：类数组 语法：elementList = document.querySelectorAll(selectors); elementList 是一个静态的 NodeList 类型的对象。 selectors 是一个由逗号连接的包含一个或多个 CSS 选择器的字符串。 例子 innerHTML 标签之间的文本和html内容innerHTML可用于获取/设置/增加标签之间的文本和html内容 语法：ele.innerHTML 功能：返回ele元素（DOM元素）开始和结束标签（tag）之间的文本和HTML内容 （倾斜标签&lt;i&gt;与粗体标签&lt;b&gt;都是HTML内容） 语法：ele.innerHTML=&quot;html&quot; 功能：设置ele元素（DOM元素）开始和结束标签之间的HTML内容为html 扩展：想要增加 DOM元素 开始和结束标签之间的HTML内容可使用ele.innerHTML+=&quot;增加的HTML内容&quot;即ele.innerHTML=ele.innerHTML+&quot;增加的HTML内容&quot;1234567891011121314151617&lt;body&gt; &lt;ul id=\"list1\"&gt; &lt;li style=\"color:blueviolet;font-size:18px\"&gt;啦啦啦&lt;/li&gt; &lt;li&gt;&lt;i&gt;黄女士&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;困困&lt;/b&gt;&lt;/li&gt; &lt;li&gt;醒醒&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //获取id为list1下的所有的1i,得到的是数组 var lis = document.getElementById(\"list1\").getElementsByTagName(\"li\"); for (var i = 0, len = lis.length; i &lt; len; i++) &#123; console.log(lis[i]);//可以发现每个li都被打印,&lt;li&gt;&lt;i&gt;黄女士&lt;/i&gt;&lt;/li&gt;... console.log(lis[i].innerHTML);//打印每一条li内的文本内容,&lt;i&gt;黄女士&lt;/i&gt;... lis[i].innerHTML+=\"程序\";//页面显示会变成：啦啦啦程序...每一条li都加上了“程序” &#125; &lt;/script&gt;&lt;/body&gt; 用innerHTML插入带有标签的html内容我们希望在js中插入连同div标签和style样式的html内容： 123&lt;div style=\"background: red;\" &gt; lalal &lt;/div&gt; 在innerHTML中要注意将后面的代码用单引号括起来，且去掉html代码中的tab和空格！ 123456789&lt;body&gt; &lt;!-- &lt;div style=\"background: red;\" &gt; lalal &lt;/div&gt; --&gt; &lt;div id=\"la\"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(\"la\").innerHTML = '&lt;div style=\"background: red;\"&gt;lalal&lt;/div&gt;'; &lt;/script&gt;&lt;/body&gt; 当然我们的代码可读性也是非常重要的，所以我们可以使用\\帮助我们进行换行，注意：我们在需要换行的位置加上\\即可。 123456789101112&lt;body&gt; &lt;!-- &lt;div style=\"background: red;\" &gt; lalal &lt;/div&gt; --&gt; &lt;div id=\"la\"&gt;&lt;/div&gt; &lt;script&gt; document.getElementById(\"la\").innerHTML = '\\ &lt;div style=\"background: red;\" &gt;\\ lalal\\ &lt;/div&gt;'; &lt;/script&gt;&lt;/body&gt; className className 获取和设置（替换） ele元素的class属性 注意：有=就是设置，没有就是获取。 返回class属性名 语法：ele.className 功能：返回ele元素（DOM元素）的class属性 如果元素有2个以上的class属性值，那么获取这个元素的className属性时，会将它的class属性值都打印出来（实际操作没发现会） 给元素添加类 语法：ele.className=&quot;cls&quot; 功能：设置ele元素（DOM元素）的class属性为cls 注意：ele.className是重新设置类，替换元素本身的class1234567891011121314151617181920212223242526272829&lt;head&gt; &lt;style&gt; .on&#123; border-bottom: 1px solid #0f0; &#125; .current &#123; background: #ccc; color: #f00; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul id=\"list1\"&gt; &lt;li style=\"color:blueviolet;font-size:18px\"&gt;啦啦啦&lt;/li&gt; &lt;!-- 一开始“黄女士”的标签是on的样式，但lis[1].className=\"current\";会替换掉on的样式 --&gt; &lt;li class=\"on\"&gt;&lt;i&gt;黄女士&lt;/i&gt;&lt;/li&gt; &lt;li&gt;&lt;b&gt;困困&lt;/b&gt;&lt;/li&gt; &lt;li&gt;醒醒&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //获取id为list1下的所有的1i,得到的是数组 var lis = document.getElementById(\"list1\").getElementsByTagName(\"li\"); for (var i = 0, len = lis.length; i &lt; len; i++) &#123; lis[1].className=\"current\"; &#125; console.log(lis[1].className);//current &lt;/script&gt;&lt;/body&gt; DOM节点的property和attribute property和attribute都是“属性”的意思，但修改property只影响页面效果，并不修改HTML/DOM结构。而修改attribute是同时修改页面效果和HTML/DOM结构的。 property是对DOM元素的JS对象的属性进行修改，不会修改HTML结构。 attribute是直接对DOM元素的属性进行修改，会改变HTML结构。 建议使用property，以减少不必要的DOM重新渲染。 property和attribute之间互不影响。 property 经过浏览器解析后，每个元素会有自己的property（特性）【可以理解为一个JS对象】。 通过获取DOM元素的property（属性）可以获取/修改DOM元素的样式属性。 property是对DOM元素的JS对象的属性进行修改，不会修改HTML结构。 nodeName：DOM元素的标签名（比如p、a、div） nodeType：DOM元素的类型（一般是1） 动态设置元素样式 语法：ele.style.styleName=styleValue 功能：设置ele元素（DOM对象）的CSS样式 说明： ele为要设置样式的DOM对象 注意：必须是DOM对象 ，而getElementsByTagName取出的是“数组”，数组需要遍历才能动态设置CSS样式 styleName为要设置的样式名称 注意：不能使用”-”连字符形式 font-size，使用驼峰命名形式 fontSize styleValue为设置的样式值123456789101112131415161718192021222324252627282930313233&lt;body&gt; &lt;div class=\"box\" id=\"box\"&gt; 元素1 &lt;/div&gt; &lt;ul id=\"list1\"&gt; &lt;li style=\"color:blueviolet;font-size:18px\"&gt;啦啦啦&lt;/li&gt; &lt;li&gt;黄女士&lt;/li&gt; &lt;li&gt;困困&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; //设置id为box的这个元素的文字颜色，属性是减号连接的复合形式时 //必需要转换为驼峰形式 var box = document.getElementById(\"box\"); box.style.color=\"#f00\"; box.style.fontWeight=\"bold\"; //获取id为list1下的所有的1i,得到的是数组，需要遍历才能动态设置CSS样式 var lis = document.getElementById(\"list1\").getElementsByTagName(\"li\"); for (var i = 0, len = lis.length; i &lt; len; i++) &#123; // console.log(lis[i]);//可以发现每个li都被打印 lis[i].style.color = \"#00f\";//li全部变蓝色 // 设置不同背景色 if (i == 0) &#123; lis[i].style.backgroundColor = \"#ccc\"; &#125; else if (i == 1) &#123; lis[i].style.backgroundColor = \"#666\"; &#125; else if (i == 2) &#123; lis[i].style.backgroundColor = \"#999\"; &#125; else &#123; lis[i].style.backgroundColor = \"#333\"; &#125; &#125; &lt;/script&gt;&lt;/body&gt; attribute 通过getAttribute()和setAttribute()可获取、修改html/DOM的结构。 attribute是直接对DOM元素的属性进行修改，会改变HTML结构。 getAttribute()获取属性 语法：ele.getAttribute（&quot;attribute&quot;） 功能：获取ele元素（DOM元素）的attribute属性 说明： ele是要操作的dom对象 attribute是要获取的html属性（如：id、tpye） 注意： 对于class以外的标准属性都可以直接通过p.id/p.align这种形式来获得属性名。 而class名字则需要通过p.className而不是p.class data-type这种自定义的属性则需通过p.getAttribute(“自定义属性类型”)来获取属性名1234567891011121314&lt;body&gt; &lt;p id=\"text\" class=\"text\" align=\"center\" data-type=\"title\"&gt;文本&lt;/p&gt; &lt;script&gt; var p=document.getElementById(\"text\"); // 对于class以外的标准属性都可以直接通过p.id/p.align这种形式来获得属性名 console.log(p.id);//text console.log(p.align);//center // 而class名字则需要通过p.className而不是p.class console.log(p.className);//text console.log(p.getAttribute(\"class\"));//text，等价的 // data-type这种自定义的属性则需通过p.getAttribute(\"自定义属性类型\")来获取属性名 console.log(p.getAttribute(\"data-type\"));//title &lt;/script&gt;&lt;/body&gt; setAttribute()设置/增加属性 语法:ele.setAttribute(&quot;attribute&quot;,value) setAttribute方法必须要有两个参数 如果value是字符串，需加引号 setAttribute（）有兼容性问题 功能:在ele元素（DOM元素）上设置属性 说明: ele是要操作的dom对象 attribute为要设置的属性名称 value为设置的attribute属性的值12345678&lt;body&gt; &lt;p id=\"hello\" class=\"text\" align=\"center\" data-type=\"title\"&gt;文本&lt;/p&gt; &lt;script&gt; var p=document.getElementById(\"hello\"); // 给p增加一个isRead的属性 p.setAttribute(\"isRead\",\"false\"); &lt;/script&gt;&lt;/body&gt; removeAttribute()删除属性 语法:ele.removeAttribute(&quot;attribute&quot;) 功能:删除ele上的attribute属性 说明: ele是要操作的dom对象 attribute是要删除的属性名称12345678&lt;body&gt; &lt;p id=\"hello\" class=\"text\" align=\"center\" data-type=\"title\"&gt;文本&lt;/p&gt; &lt;script&gt; var p=document.getElementById(\"hello\"); // 删除p的align属性 p.removeAttribute(\"align\");//删除后文本靠左对齐 &lt;/script&gt;&lt;/body&gt; addEventListener() 添加事件句柄 addEventListener() 方法用于向指定元素添加事件句柄。 提示： 使用 removeEventListener() 方法来移除 addEventListener() 方法添加的事件句柄。 语法：element.addEventListener(event, function, useCapture) 注意：当给window对象绑定事件时，一定要注意用完后移除该绑定事件！ 事件绑定函数可接受的第一个参数是事件对象。（事件对象.target就是事件绑定函数对应的事件触发的DOM元素） 事件对象的preventDefault()可取消事件的默认动作，比如：如果 type 属性是 “submit”，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。注意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。 参数 描述 event 必须。字符串，指定事件名。注意: 不要使用 “on” 前缀。 例如，使用 “click” ,而不是使用 “onclick”。 提示： 所有 HTML DOM 事件，可以查看完整的 HTML DOM Event 对象参考手册 function 必须。指定要事件触发时执行的函数。 事件绑定函数可接受的第一个参数是事件对象。（事件对象.target就是事件绑定函数对应的事件触发的DOM元素） 事件对象的类型取决于特定的事件。例如， “click” 事件属于 MouseEvent(鼠标事件) 对象 useCapture 可选。布尔值，指定事件是否在捕获或冒泡阶段执行。可能值:true - 事件句柄在捕获阶段执行false- 默认。事件句柄在冒泡阶段执行 123456789&lt;button id=\"myBtn\"&gt;点我&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;script&gt;document.getElementById(\"myBtn\").addEventListener(\"click\", myFunction);function myFunction() &#123; document.getElementById(\"demo\").innerHTML = \"Hello World\";&#125;&lt;/script&gt; 或者 12345678&lt;button id=\"myBtn\"&gt;点我&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;script&gt;document.getElementById(\"myBtn\").addEventListener(\"click\", function () &#123; document.getElementById(\"demo\").innerHTML = \"Hello World\";&#125;);&lt;/script&gt; 完整例子","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"HTML DOM Image 对象","slug":"HTML DOM Image 对象","date":"2019-09-04T02:37:24.000Z","updated":"2020-02-18T03:22:03.692Z","comments":true,"path":"2019/09/04/HTML DOM Image 对象/","link":"","permalink":"http://yoursite.com/2019/09/04/HTML DOM Image 对象/","excerpt":"","text":"Image 对象 Image 对象代表嵌入的图像,可以通过Image()新建一个Image对象。 &lt;img&gt; 标签每出现一次，一个 Image 对象就会被创建。 语法：const img = new Image(); 属性更多属性可参考这里 src 属性（设置后自动获取并显示图片） src 属性可设置或返回图像的 URL，src 属性值更新时浏览器就会自动装载并显示出新图像。（当我们给Image对象设置一个src属性值时，浏览器就会自动发起一个HTTP请求，根据这个src的路径去取图片。） 注释：该属性可在任意时间被更改。不过新图像会继承原始图像的 height 和 width 属性。 该属性的初始值由标记&lt;img&gt;的 src 属性来设置。当把该属性设置为新图像的 URL 时，浏览器就会把那幅新图像装载并显示出来。这对于更新网页的图像外观以响应用户的动作非常有用。 语法：imageObject.src=URL 例子 事件onload 事件（加载完成立即执行） 页面或图像加载完成后立即发生。 onload 通常用于 &lt;body&gt; 元素，在页面完全载入后(包括图片、css文件等等)执行脚本代码。 该事件可作用于以下 HTML 标签：&lt;body&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;iframe&gt;,&lt;img&gt;, &lt;input type=&quot;image&quot;&gt;, &lt;link&gt;, &lt;script&gt;,&lt;style&gt; 对Image对象使用onload事件的例子 语法（推荐写在JS中）：在 HTML 中: 1&lt;body onload=\"SomeJavaScriptCode\"&gt; 在 JavaScript 中: 1window.onload=function()&#123;SomeJavaScriptCode&#125;; 注意代码从上往下执行，在DOM事件中，如果先在&lt;script&gt;里获取对象再通过&lt;div&gt;定义对象会报错，因为这个对象的定义是出现在了获取的后面，你想要获取的时候还没定义。此时可以在&lt;script&gt;里对window使用onload事件（如下例子） 对window使用onload的例子12345678910111213141516&lt;head&gt; &lt;script&gt; // 页面加载完成后才执行 window.onload=function()&#123; // 获取box var box =document.getElementById(\"box\"); var clicked=function()&#123; alert(\"我被点击了！\"); &#125; box.onclick=clicked; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box\"&gt;这是一个box&lt;/div&gt;&lt;/body&gt; onerror 事件(数据加载错误时执行) onerror 事件在 文档/图像/视频/音频（audio/video） 数据加载期间发生错误时触发 装载图像时发生错误的例子 语法（推荐写在JS中）:HTML 中(myScript()写在JS中)： 1&lt;element onerror=\"myScript\"&gt; JavaScript 中： 1object.onerror=function()&#123;myScript&#125;; JavaScript 中, 使用 addEventListener() 方法添加事件句柄(myScript()写在JS中): 1object.addEventListener(\"error\", myScript); 参数通过onerror绑定在img上的函数接收一个参数，该参数可传递错误信息： 123img.onerror = (e) =&gt; &#123; return e;&#125;","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"},{"name":"HTML学习","slug":"HTML学习","permalink":"http://yoursite.com/categories/HTML学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"},{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"JS对象之string","slug":"JS对象之string","date":"2019-08-13T03:40:52.000Z","updated":"2020-06-27T12:35:53.057Z","comments":true,"path":"2019/08/13/JS对象之string/","link":"","permalink":"http://yoursite.com/2019/08/13/JS对象之string/","excerpt":"","text":"查找字符（串）的4种方法charAt()查找字符 语法:stringObject.charAt(index) 功能:返回stringObject中index位置的字符. 12var str=\"hello world\"; console. log(str. charAt(4));//o ES6中可以直接使用str[index]，与str.charAt(index)效果一样 charCodeAt()查找字符的编码 语法:stringObject.charCodeAt(index) 功能:返回stringObject中index位置字符的字符编码. 说明：ECMAScript5中可使用“方括号加字符索引”来访问字符串中特定的字符，但是IE7及更早的浏览器会返回undefined。12var str=\"hello world\"; console. log(str. charCodeAt(4));//111 indexOf()与lastIndexOf（） 和数组中的indexOf()与lastIndexOf（）类似 都可以查字符串的位置，不过返回的是第一个字符的位置 indexOf()返回字符（串）的位置和数组中的indexOf()类似 语法:stringObject.indexOf(&quot;o&quot;) 功能:从一个字符串中搜索给定的子字符串,返回子字符串的位置. 返回值:数值 说明:如果没有找到该子字符串,则返回-1. lastIndexOf()倒着查，返回字符（串）的位置 语法:stringObject.lastIndexOf(&quot;o&quot;) o是你想查找的字符 功能:倒着查，从一个字符串中搜索给定的子字符串,返回子字符串的位置 返回值:数值 说明:如果没有找到该子字符串,则返回-1123456var email = \"marry.mail@sohu.com\";//检测@在emai1中出现的位置console.log(email.indexOf(\"o\")); //12console.log(email.indexOf(\"ar\")); //1，可以查字符串的位置，不过返回的是第一个字符的位置console.log(email.lastIndexOf(\".\"));//15console.log(email.lastIndexOf(\"ma\"));//6 截取字符串的3种方法slice()和数组的slice()类似 语法：stringValue.slice(start,end) 功能:截取子字符串. 参数说明: start:必需,指定子字符串的开始位置. end:可选,表示子字符串到哪里结束,end本身不在截取范围之内,省略时截取至字符串的未尾. 当参数为负数时 (注意：两个参数都适用),会将传入的负值与字符串的长度相加来得到起始位置 （参数值=字符串长度+负值）.1234567var str = \"hello world\";//截取orl console.log(str.slice(7, 10));// 11-3=8，相當於str.slice(8)console.log(str.slice(-3));//rld// 11-7=4,11-2=9console.log(str.slice(-7,-2));//o wor substring() 语法及功能同slice()完全一样. 区别: 当参数为负数时,自动将参数转换为0. substring()会将较小的数作为开始位置,将较大的数作为结束位置.12345var str = \"hello world\";//11位//自动将参数转换为0.console.log(str.substring(-7,5));//(0,5),hello//将较小的数作为开始位置,将较大的数作为结束位置.console.log(str.substring(2,-5));//(0,2),he substr() 语法:stringValue.substr(start,len) 功能:截取子字符串. 参数说明: start:必需,指定子字符串的开始位置. len:可选,表示截取的字符总数,省略时截取至字符串的未尾. 当start为负数时,会将传入的负值与字符串的长度相加.（start参数值=字符串长度+负值） 【注意这里和以往不一样，不是两个参数了】 当len为负数时,返回空字符串.1234var str = \"hello world\";//11位console.log(str.substr(6, 3)); //worconsole.log(str.substr(-5, 4));//相當於(6,4),worlconsole.log(str.substr(3, -4));//空 获取扩展名实例12345678910// 获取扩展名function getFileFormat(url)&#123; // 获取.在url中出现的位置 var pos=url.lastIndexOf(\".\"); return url.substr(pos+1);&#125;var baidu=\"http://baidu.com/index.txt\";var formatName=getFileFormat(baidu);var picFormat=getFileFormat(\"1231212.jpg\");console.log(formatName,picFormat);//txt png 编程练习12345678910111213141516// 编程练习：用户输入登录的邮箱，对邮箱进行解析，解析出邮箱的用户名和邮箱的域名var email=prompt(\"请输入登录邮箱\");function getName(email)&#123; // 获取@在email中的位置 var at=email.indexOf(\"@\"); // 截取@前的字符串得到用户名 return email.substring(0,at);&#125;function getDomainName(email)&#123; // 获取@在email中的位置 var at=email.indexOf(\"@\"); // 截取@后的字符串得到域名 return email.substring(at+1);&#125;// 要注意换行符\"&lt;br/&gt;\"在双引号里面document.write(\"邮箱的用户名是：\"+getName(email)+\"&lt;br/&gt;\"+\"登录的邮箱域名是：\"+getDomainName(email)); split()字符串转换为数组 正好相反，数组中的join()方法是将数组转换为字符串 语法:stringObject.split(separator) separator:必需,分隔符。分隔符可以是字符串 功能:把一个字符串分割成字符串数组. 返回值:Array. replace()替换字符串 注意：它不会影响原来的字符串，它是产生新的字符串。 语法:stringObject.replace(regexp/substr,replacement) 即：stringObject.replace(替换前字符（串）,替换后字符（串）) regexp:必需.规定子字符串或要替换的模式的RegExp对象. 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 replacement:必需.一个字符串值. 功能:在字符串中用一些字符替换另一些字符,或替换一个与正则表达式匹配的子串. 返回值:String 123456789101112131415161718192021222324var str = 'welcome-to-beijing';//使用split将str转换为数组var arr = str.split(\"-\");console.log(arr);//[\"welcome\", \"to\", \"beijing\"]var date = '2016/05/05';var dateArr = date.split(\"/\");console.log(dateArr);//[\"2016\", \"05\", \"05\"]// 看来分隔符可以是字符串var date2 = '2016//05//05';var dateArr2 = date2.split(\"//\");//替换var tel = '010-62971268,400-100-9098,010-867898891';//newTel:被替换之后的字符串var newTel = tel.replace(',', \" \");console.log(tel);//010-62971268,400-100-9098,010-867898891console.log(newTel);//010-62971268 400-100-9098,010-867898891//newTel2:被替换之后的字符串,只替换第一个匹配子串var tel2 = '010-62971268,,400-100-9098,,010-867898891';var newTel2 = tel2.replace(',,', \" \");console.log(newTel2);//010-62971268 400-100-9098,,010-867898891// 使用正则，加上全局标志 g，则替换所有匹配子串var tel3 = '010-62971268,,400-100-9098,,010-867898891';var newTel3 = tel3.replace(/,,/g, \" \");console.log(newTel3);//010-62971268 400-100-9098 010-867898891 字符串转换大小写toUpperCase()转大写 语法:stringValue.toUpperCase() 功能:把字符串转换为大写.123var str=\"hello world\";var upper=str.charAt(6).toUpperCase();console.log(upper);//W toLowerCase()转小写 语法:stringValue.toLowerCase() 功能:把字符串转换为小写.12var str2=\"WELCOME\";console.log(str2.toLowerCase());//welcome 案例：将字符串 border-left-color转换成borderLeftColor（驼峰形式）1234567891011function camelBack(str)&#123; // 通过“-”将字符串str拆分为数组 var arr=str.split(\"-\"), newStr=arr[0];//数组第一项不用变大写所以一开始就可以指定arr[0]为newStr // console.log(arr);// [\"border\", \"left\", \"color\"] for(var i=1,len=arr.length;i&lt;len;i++)&#123;//i从1开始，因为数组第一项不用变大写 // 遍历数组,改变除第一个单词之外的所有单词的首字母并连接剩余字符 newStr += arr[i].charAt(0).toUpperCase()+arr[i].substr(1); &#125;console.log(newStr);//borderLeftColor&#125;var camelFormat=camelBack(\"border-left-color\"); 编程练习小伙伴们,我们学习了string的转化大小写的方法,那么接下来任务来了,将字符串”Never deter till tomorrow that which you can do today”的”tomorrow”转化为大写. 1234567891011// 将字符串\"Never deter till tomorrow that which you can do today\"的\"tomorrow\"转化为大写var str=\"Never deter till tomorrow that which you can do today\";// 获取tomorrow位置var t=str.indexOf(\"tomorrow\");// console.log(t,str.indexOf(\"w\"));//17 24// 截取var tm=str.substring(17,25);// console.log(tm);// 改为大写并替换var newStr=str.replace(str.substring(17,25),tm.toUpperCase());console.log(newStr);//Never deter till TOMORROW that which you can do today trim()删除头尾空格 trim() 方法用于删除字符串的头尾空格。 语法：string.trim() trim() 方法不会改变原始字符串。 例子 正则表达式删除头尾空格如果你的浏览器不支持 trim() 方法，你可以使用正则表达式来实现: 12345678function myTrim(x) &#123; return x.replace(/^\\s+|\\s+$/gm,'');&#125; function myFunction() &#123; var str = myTrim(\" Runoob \"); alert(str);&#125; (完整例子) 生成正则表达式对象：const regexp1=/规则/修饰符; 修饰符：g表示全局匹配，m表示多行匹配。 规则： 定位符：^ 输入字符串开始的位置，$ 输入字符串结尾的位置。 \\s匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 |指明两项之间的一个选择。要匹配 |，请使用 \\|。 +匹配前面的子表达式一次或多次。例如，zo+ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+等价于 {1,}。 总结：也就是说，如果x以一个或多个空格开始，替换全部空格为空（^\\s+）；或者(|)，如果x以一个或多个空格结束(\\s+$)，替换全部空格为空。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"Math对象","slug":"Math 对象","date":"2019-08-12T13:38:57.000Z","updated":"2020-03-09T08:27:48.400Z","comments":true,"path":"2019/08/12/Math 对象/","link":"","permalink":"http://yoursite.com/2019/08/12/Math 对象/","excerpt":"Math 对象 Math 对象用于执行数学任务。","text":"Math 对象 Math 对象用于执行数学任务。 注释：Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。 Math 是全局对象。new 关键词不可用于 Math。 与其他对象的对比： 12345678var x1 = &#123;&#125;; // 新对象var x2 = \"\"; // 新的原始字符串var x3 = 0; // 新的原始数值var x4 = false; // 新的原始逻辑值var x5 = []; // 新的数组对象var x6 = /()/ // 新的正则表达式对象var x7 = function()&#123;&#125;; // 新的函数对象var x8 = new Date(); // 一个新的 Date 对象 Math.round()返回最接近的整数Math.round(）函数返回一个数字四舍五入后最接近的整数如果参数的小数部分大于0.5，四舍五入到相邻的绝对值更大的整数如果参数的小数部分小于0.5，四舍五入到相邻的绝对值更小的整数如果参数的小数部分等于0.5，四舍五入到相邻的在正无穷（+∞）方向上的整数。 例： 1234x=Math.round(2019.49) ; //2019x=Math.round(2019.5); //2020x=Math.round(-2019.5); //-2019x=Math.round(-2019.51); //-2020 Math.abs() 返回数的绝对值 定义：abs() 方法可返回数的绝对值。 语法：Math.abs(x) 参数：必需。必须是一个数值。 Math.random() 返回随机小数 random() 方法可返回介于 0（包含） ~ 1（不包含） 之间的一个随机数。（小数位数不确定） 例子1、例子2 用作清除缓存在前端，Math.random()一般用于清除缓存。 在项目中，有时改完js文件之后怎么也不能生效，只有清除浏览器缓存或者CTRL+F5强制刷新之后才能出现最新的版本，这样调试起来十分的不方便，此时可以在请求地址之后加上: 1\"?ran=\" + Math.random(); //当然这里参数 ran可以任意取了 采用随机数的方式，使每一次的请求都是一个新请求，从而防止浏览器从缓存中读取旧版本。注意：因为Math.random() 只能在Javascript 下起作用，故只能通过Javascript的调用才可以。 当前时间用作清除缓存除了加入随机数还可以加入当前时间： 1\"?time=\" + new Date().getTime(); 同样可以使每次请求的地址都是不一样的，从而防止浏览器使用缓存。 ajax中的使用在ajax的url后加上随机串来避免浏览缓存： 123456$.ajax(&#123; url:\"./test.json\"+\"?ran=\" + Math.random(), success:function(result)&#123; console.log(result); &#125;&#125;) Math.ceil()返回&gt;=的最小整数 Math.ceil() 函数返回大于或等于一个给定数字的最小整数。 语法：Math.ceil(x) x:一个数值 返回值：大于或等于给定数字的最小整数。 详细用法可参考MDN文档","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS对象之数组(2)","slug":"JS对象之数组（2）","date":"2019-08-11T03:40:52.000Z","updated":"2020-03-14T08:36:47.958Z","comments":true,"path":"2019/08/11/JS对象之数组（2）/","link":"","permalink":"http://yoursite.com/2019/08/11/JS对象之数组（2）/","excerpt":"ES6增加的方法Array.prototype.filter()数组过滤方法 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 原理： filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值的元素创建一个新数组。","text":"ES6增加的方法Array.prototype.filter()数组过滤方法 filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。 原理： filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值的元素创建一个新数组。 语法：array.filter(function(currentValue,index,arr), thisValue) function(currentValue, index,arr):必须。函数，数组中的每个元素都会执行这个函数 currentValue:必须。当前元素的值 index:可选。当前元素的索引值 arr:可选。当前元素属于的数组对象 thisValue:可选。对象作为该执行回调时使用，传递给函数，用作 “this” 的值。 如果省略了 thisValue ，”this” 的值为 “undefined” 返回值：数组，包含了符合条件的所有元素。如果没有符合条件的元素则返回空数组。 注意： filter() 不会对空数组进行检测。 filter() 不会改变原始数组。 MDN参考 例子：下例使用 filter 创建了一个新数组，该数组的元素由原数组中值大于 10 的元素组成: 12345function isBigEnough(element) &#123; return element &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] 比如：12作为element传入isBigEnough，函数返回12&gt;=10,也就是返回true，那么元素12就会成为新数组filtered的一项。 Array.from() Array.from() 方法从一个类似数组或可迭代对象创建一个新的、浅拷贝的数组实例。 语法：Array.from(arrayLike[, mapFn[, thisArg]]) arrayLike:想要转换成数组的伪数组对象或可迭代对象。 mapFn:可选,如果指定了该参数，新数组中的每个元素会执行该回调函数。 thisArg:可选,执行回调函数 mapFn 时 this 对象。 返回值：一个新的数组实例。 MDN参考 12345678910console.log(Array.from('foo'));// Array [\"f\", \"o\", \"o\"]console.log(Array.from([1, 2, 3], x =&gt; x + x));// Array [2, 4, 6]//从类数组对象（arguments）生成数组function f() &#123; return Array.from(arguments);&#125;f(1, 2, 3);// [ 1, 2, 3 ] 面试题1234567891011121314//完成以下代码段，实现b数组对a数组的拷贝，方法越多越好var a = [1,\"yes\",3], b;// 方法1，数组遍历，push// 首先需要将新建为数组,注意不要重复var，也可以写作b=[];b =new Array();for (i=0;i&lt;a.length;i++)&#123; b.push(a[i]);&#125;// 方法2，concatb=a.concat([]);//或者b=[].concat(a);// 方法3，sliceb=a.slice(0);console.log(b); IE9以下的浏览器使用封装方法进行位置查找12345678910111213var nums = [1, 7, 5, 7, 8, 1, 6, 9];//封装一个方法实现indexof的功能function ArrayIndexOf(arr, value) &#123; //检测value在arr中出现的位置 for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] **= value) &#123; return i; &#125; &#125; return -1;&#125;var pos5=ArrayIndexOf(nums, 8);//调用封装的方法console.log(pos5);//4 map() 遍历数组并进行操作(返回新数组) ES5中提供的map() 方法返回一个新数组，数组中的元素为原始数组元素按顺序执行回调函数处理后的值。 map() 方法按照原始数组元素顺序依次处理元素。 注意： map() 不会对空数组进行检测。 注意： map() 不会改变原始数组。 例子 forEach()遍历数组的每个元素 forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。 注意: forEach() 对于空数组是不会执行回调函数的。 语法：array.forEach(function(currentValue, index, arr), thisValue) 返回值:undefined12345678910111213141516&lt;body&gt;&lt;p&gt;点击按钮列出数组的每个元素。&lt;/p&gt;&lt;button onclick=\"numbers.forEach(myFunction)\"&gt;点我&lt;/button&gt;&lt;p id=\"demo\"&gt;&lt;/p&gt;&lt;script&gt;demoP = document.getElementById(\"demo\");var numbers = [4, 9, 16, 25];function myFunction(item, index) &#123; demoP.innerHTML = demoP.innerHTML + \"index[\" + index + \"]: \" + item + \"&lt;br&gt;\"; &#125;&lt;/script&gt;&lt;/body&gt; 使用3个参数的例子 补充：in运算符（可参考MDN的in运算符） 如果指定的 属性 在指定的对象或其原型链中，则in 运算符返回true。 如果指定的 数组索引 在数组中，则in 运算符返回true。 注意：不是数组元素，是数组下标！ 语法：prop in object prop一个字符串类型或者 symbol 类型的属性名或者数组索引（非symbol类型将会强制转为字符串）。 objectName检查它（或其原型链）是否包含具有指定名称的属性的对象。 例子： 12345678// 数组var trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\");0 in trees // 返回true3 in trees // 返回true6 in trees // 返回false\"bay\" in trees // 返回false (必须使用索引号,而不是数组元素的值)\"length\" in trees // 返回true (length是一个数组属性) 数组的reduce()方法【累加数组元素】 reduce()方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。即，对数组每个元素执行回调函数，返回值用于下一次计算参数 reduce()方法的参数由回调函数和一个初始值参数组成。 语法：array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 语法理解： 1234reduce( function( 回调函数返回的值,数组当前元素,当前元素索引,调用reduce的数组 ) ,回调函数第一个参数的初始值); 返回值：返回计算结果(不改变原数组) 例子： 12345678const array1 = [1, 2, 3, 4];const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue;// 1 + 2 + 3 + 4console.log(array1.reduce(reducer));// 10// 5 + 1 + 2 + 3 + 4console.log(array1.reduce(reducer, 5));// 15","categories":[{"name":"ES6学习","slug":"ES6学习","permalink":"http://yoursite.com/categories/ES6学习/"},{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS对象之数组(1)","slug":"JS对象之数组（1）","date":"2019-08-10T13:38:57.000Z","updated":"2020-06-27T09:17:18.506Z","comments":true,"path":"2019/08/10/JS对象之数组（1）/","link":"","permalink":"http://yoursite.com/2019/08/10/JS对象之数组（1）/","excerpt":"Array 数组： 数组中每一项都可以存放不同类型的数据，比如：第一个数是字符串，第二个数是数字，第三个数是布尔型。 数组大小可随着数据的添加自动增长。","text":"Array 数组： 数组中每一项都可以存放不同类型的数据，比如：第一个数是字符串，第二个数是数字，第三个数是布尔型。 数组大小可随着数据的添加自动增长。 创建数组 使用Array构造函数语法：new Array() 小括号()说明： 预先知道数组要保存的项目数量 向Array构造函数中传递数组应包含的项 123456789101112131415//创建一个保存颜色的数组var color = new Array();console.log(color);//[]// 往color数组中写入值color[0]=\"#f00\";color[1]=\"#0f0\";color[2]=\"#00f\";console.log(color);//[\"#f00\", \"#0f0\", \"#00f\"]//索引console.log(color[2]);//#00fvar colors=new Array(3);console.log(colors);//(3) [empty × 3] 使用数组字面量表示法由一对包含数组项的方括号[]表示，多个数组项之间以逗号隔开。 123456var nums=new Array(1,3,6,9);console.log(nums);//[1,3,6,9]var cols=[\"red\",\"yellow\",\"green\"];console.log(cols);//[\"red\",\"yellow\",\"green\"]var infos=[6,\"marry\",true];console.log(infos);//[6,\"marry\",true] 数组元素的读写读取和设置值时，使用方括号并提供相应的索引。说明：索引是从0开始的正整数。 1234567var color = new Array();// 往color数组中写入值color[0]=\"#f00\";color[1]=\"#0f0\";color[2]=\"#00f\";//索引console.log(color[2]);//#00f 数组长度 语法：array.length 功能：获取数组array的长度 返回值：number 说明：1、通过设置length可以从数组的末尾移除项或向数组中添加新项。123456var arr=[\"a\",\"b\",\"c\",\"d\"]console.log(arr.length);//4//通过设置length可以从数组的末尾移除项arr.length=2;console.log(arr);//[\"a\", \"b\"] 2、把一个值放在超出当前数组大小的位置上时，会重新计算数组长度值，长度值等于最后一项索引加1。**【注意：4个数加一个最后数组长度并不是5，要看这一个数加到哪个位置，加到下标为99的位置则这个数组的数组长度改为100。】** 123//接上面代码，原本数组长度为4，但是加了一个数到下标为99的位置则这个数组的数组长度改为100arr[99]=\"z\";console.log(arr.length);//100 数组的方法 方法 作用 是否直接修改原数组 返回值 备注 push() 数组尾部添加元素 是 数组的新长度 unshift() 数组开头添加元素 是 数组的新长度 pop() 删除最后一个元素 是 被删除的元素 1.如果数组已经为空，则返回 undefined2.先进后出（栈） shift() 删除第一个元素 是 被删除的元素 1.如果数组已经为空，则返回 undefined2.先进先出（队列） join() 数组转换为字符串 否 字符串 reverse() 颠倒顺序 是 颠倒顺序后的数组的引用 sort() 升序/降序排序 是 排序后的数组的引用 concat() 连接两个或多个数组 否 连接后的数组 需要提前新建连接后的数组 slice() 截取部分元素 否 截取元素组成的数组 想要修改原数组请使用splice splice() 删除、插入、替换部分元素 是 被删除的元素组成的数组 插入元素时没有删除，则返回空数组 push()：在尾部添加元素 语法:arrayObject.push(newele1,newele2...…,neweX) newelement1：必需。要添加到数组的第一个元素。 newelement2：可选。要添加到数组的第二个元素。 newelementX：可选。可添加多个元素。 功能:把它的参数顺序添加到arrayObject的尾部. 返回值:把指定的值添加到数组后的新长度. 该方法直接修改 arrayObject，而不是创建一个新的数组。 push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。123456//push var colors=new Array(\"red\",\"green\"); var len=colors.push(\"blue\",\"yellow\",\"blank\"); console.log(len);//5,要注意添加以后的返回值是长度，数组名的返回值才是所有的数组元素console.log(colors[4]);//blankconsole.log(colors);// [\"red\", \"green\", \"blue\", \"yellow\", \"blank\"] unshift()：在开头添加元素 语法:arrayObject.unshift(newele1,newele 2...…,neweX) newelement1：必需。向数组添加的第一个元素。 newelement2：可选。向数组添加的第二个元素。 newelementX：可选。可添加若干个元素。 功能:把它的参数顺序添加到arrayObject的 开头 . 返回值:arrayObject的新长度. 注意，该方法不创建新的创建，而是直接修改原有的数组。12345//unshift var nums=[2,7,8,6]; var size=nums.unshift(99,66); console.log(size);//6console.log(nums);//[99, 66, 2, 7, 8, 6] pop()：删除最后一个元素 语法:arrayObject.pop() 功能:删除arrayObject的最后一个元素 返回值:被删除的那个元素 如果数组已经为空，则 pop() 不改变数组，并返回 undefined。 该方法不产生新数组，直接改变原有数组。1234//popvar n =nums.pop();console.log(n);//6,是我们被删除的那个元素console.log(nums);//[99, 66, 2, 7, 8],删完以后的nums数组所有元素 shift()：删除第一个元素 语法:arrayObject.shift() 功能:删除 arrayObject中的第一个元素 返回值:被删除的那个元素 如果是空数组的，那么 shift() 方法将不进行任何操作，返回 undefined。 注意，该方法不创建新数组，而是直接修改原有的 arrayObject。1234//shiftvar m=colors.shift();console.log(m);//redconsole.log(colors);//[\"green\", \"blue\", \"yellow\", \"blank\"] 转换方法：join()数组转换为字符串 语法:arrayObject.join(separator) separator:分隔符，也可以为空。参数为空是默认使用逗号隔开，如果不想要逗号可以使用&quot;&quot;作为参数。 功能:用于把数组中的所有元素放入一个字符串. 返回值：字符串12345678910//join var nums=[2,4,5]; var str=nums. join();//2,4,5var words=[\"border\",\"left\",\"color\"];var wordstr=words. join(\"-\"); console.log(wordstr);//border-left-color var wordstr=words. join(\"\"); console.log(wordstr);//borderleftcolor 重排序方法reverse()颠倒顺序 语法:arrayObject.reverse() 功能:用于颠倒数组中元素的顺序. 返回值:颠倒顺序后的数组的引用. 该方法直接改变原来的数组，而不会创建新的数组。1234567891011const array1 = ['one', 'two', 'three'];console.log('array1:', array1);// expected output: \"array1:\" Array [\"one\", \"two\", \"three\"]const reversed = array1.reverse();console.log('reversed:', reversed);// expected output: \"reversed:\" Array [\"three\", \"two\", \"one\"]// Careful: reverse is destructive -- it changes the original array.console.log('array1:', array1);// expected output: \"array1:\" Array [\"three\", \"two\", \"one\"] sort()升序/降序排序 语法:arrayObject.sort(sortby) sortby:可选。规定排序顺序。必须是函数。 sortby如果为空则按照字符串的大小来排序（也就是每个元素都先比较第一位的大小来排，再比较第二位），哪怕是数字也是如此。 所以要放置一个匿名函数(排序函数)才能用于数字的升降序排序。 功能:用于对数组的元素进行排序(升序/降序),参数决定排序的顺序。 返回值:对数组的引用。 注意，数组在原数组上进行排序，不生成副本。 说明: 即使数组中的每一项都是数值,sort()方法比较的也是字符串. sort()方法可以接收一个比较函数作为参数.(该比较函数为含有两个参数的匿名函数) 原理： 如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。 比较函数应具有两个参数 a 和 b，根据返回值大小可判断ab的排序位置： 返回值小于 0，则排序后的数组中 a 在 b 之前。【升序】 返回 0。 返回值大于 0，则排序后的数组中 a 在 b 之后。【降序】 注意：不管是b-a还是a-b还是别的计算式，我们只关注返回值来确定a在b的前面还是后面。 例子： 1234567var arr=[9,23,15,-99,88,12,-2];//降序arr.sort(function(a,b)&#123;return b-a&#125;);console.log(arr);//[88, 23, 15, 12, 9, -2, -99]//升序arr.sort(function(a,b)&#123;return a-b&#125;);console.log(arr);//[-99, -2, 9, 12, 15, 23, 88] 例子原理：排序思想应该是类似于冒泡排序思想的，通过前后相邻的两个数进行比较。例如9与23，这时将9作为方法函数function(a,b)参数列表中的a，23作为b，通过语句return b - a;返回一个数值，23-9=24, 若返回值&gt;0，则表示 a在排序后的序列中出现在 b 之后,所以9会在排序后出现在23之后。也就是说数组将被由大到小排序。此时，新的数据序列为23,9,15,-99,88,12，-2，再将9作为a，15作为b进行上述的做法。 关于返回值： 1234const array1 = [1, 30, 4, 21, 100000];array2 = array1.sort();console.log(array2);// expected output: Array [1, 100000, 21, 30, 4] 操作方法concat()连接两个或多个数组 语法:arrayObject.concat(arrayX,arrayX....…arrayX) 功能:用于连接两个或多个数组. 返回值:数组.123456var arrl=[\"a\",\"b\",\"c\"], arr2=[\"d\",\"e\",1,3], arr3;//concat arr3=arrl.concat(arr2,[\"m\",99,8]); console.log(arr3);// [\"a\", \"b\", \"c\", \"d\", \"e\", 1, 3, \"m\", 99, 8] 注意：要事先定义一个新的数组用于存放合并以后形成的数组。 slice()截取部分元素 slice：截取 语法:arrayObject.slice(start,end) start (可省去)，规定从何处开始选取。 如果是负数,那么它规定从数组尾部开始算起的位置。 如果省略则 slice 从索引 0 开始。 如果start大于原数组的长度，则会返回空数组。 end (可省去)，规定从何处结束选取.该参数是数组片断结束处的数组下标.（不包含该元素） 也就是说，arr.slice(1,2);中只arr[1]，没有arr[2]。 返回值:截取部分的元素组成的数组 功能:从已有的数组中返回选定的元素. 注意: 如果没有指定end,那么切分的数组包含从start到数组结束的所有元素. 如果slice()方法的参数中有一个负数,则用数组长度加上该数来确定开始的位置. 【两个参数都适用】 （即：数组长度+负数=参数数值） 截取从start到 end-1的元素。 该方法并不会修改原数组，而是返回一个子数组。如果想删除数组中的一段元素，应该使用方法 Array.splice()（使用splice则原数组会变成被删除以后的数组）12345678//slice(start,end)var colors=[\"red\",\"green\",\"blue\",\"yellow\",\"orange\"];var newColors=colors.slice(1,3);console.log(newColors);// [\"green\", \"blue\"]var newColors2=colors.slice(-2,4);//5-2=3,也就是从3开始到4结束（不包括4）console.log(newColors2);//[\"yellow\"]// 5-4=1,5-2=3,相當於colors.slice(1,3)console.log(colors.slice(-4,-2));//[\"green\", \"blue\"] splice()删除、插入、替换注意：不管是删除还是插入还是替换，返回值都是从原数组中删除的元素组成的数组。插入的时候不需要删除，所以返回值是空数组。 删除 语法:arrayObject.splice(index,count) index：开始删除的数组下标 count：要删除的项目数量 如果设置为0,则不会删除项目. 如果不设置,则删除从index开始的所有值. 功能:删除从index处开始的零个或多个元素. 返回值:含有删除部分的元素的数组. 注意：原数组会变成被删除以后的数组。12345678var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];//删除var delArr = arr.splice(5);//从数组下标为5的元素开始，包括5【注意是数组下标】console.log(arr);// [\"a\", \"b\", \"c\", \"d\", \"e\"]console.log(delArr);//[\"f\"]var delArr = arr.splice(2, 2);console.log(arr);// [\"a\", \"b\", \"e\"]console.log(delArr);//[\"c\", \"d\"] 插入 语法:arrayObject.splice(index,0,item.1...….itemX) Index:起始位置 0:要删除的项数 item1…itemX:要插入的项 功能:在指定位置插入值 返回值:插入的时候不需要删除，所以返回值是空数组。 注意：“起始位置” 指想要放进去的位置，比如想要在第3个和第4个元素中插入元素，即在[2]和[3]中间要插入元素，则应该在[3]的位置放置新元素，3就是起始位置。12345var arr = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];// 插入var insertArr=arr.splice(3,0,\"m\",\"n\");console.log(arr);// [\"a\", \"b\", \"c\", \"m\", \"n\", \"d\", \"e\", \"f\"]console.log(insertArr);//[]，插入的时候不需要删除，所以返回值是空数组。 替换 语法:arrayObject.splice(index,count,item 1...……itemX) Index:起始位置 count:要删除的项数 item1…itemX:要插入的项 功能:在指定位置插入值,且同时删除任意数量的项 返回值:从原始数组中删除的项组成的数组(如果没有删除任何项,则返回空数组)1234//替换【从下标为1的元素开始删除2个元素并插入3个新元素】var relaceArr=arr.splice(1,2,\"x\",\"y\",\"z\");console.log(arr);//[\"a\", \"x\", \"y\", \"z\", \"d\", \"e\", \"f\"]console.log(relaceArr);//[\"b\", \"c\"] 位置查找方法注意： 需要严格相等（===）才能查找位置。 这两个方法都只能用于IE9以上的浏览器，以下的则需要我们封装一个方法来使用。（将其补充在下一篇笔记的题目中） indexOf()从头开始找 语法:arrayObject.indexOf(searchvalue,startindex) searchvalue:必需,要查找的项; startlndex:可选,起点位置的索引. 功能:从数组的开头(位置0)开始向后查找. 返回值:number,查找的项在数组中的位置。 如果有多个就返回第一个的位置 没有找到的情况下返回-11234var nums=[1,7,5,7,8,1,6,9];var pos=nums. indexOf(7,2);//3var pos2 = nums.indexOf(7);//1console.log(pos,pos2);//3 1 lastIndexOf()从尾开始找 从数组的末尾开始向前查找。 其余与indexOf()一样。1234var nums=[1,7,5,7,8,1,6,9];var pos3 = nums.lastIndexOf(1);//5var pos4 = nums.lastIndexOf(1,3);//0console.log(pos3,pos4);//5 0","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ES6与JS、nodejs之间的关系","slug":"ES6与JS、nodejs之间的关系","date":"2019-08-01T08:10:44.000Z","updated":"2020-02-09T12:20:30.742Z","comments":true,"path":"2019/08/01/ES6与JS、nodejs之间的关系/","link":"","permalink":"http://yoursite.com/2019/08/01/ES6与JS、nodejs之间的关系/","excerpt":"总结：可以粗浅地理解ES6是一种标准，JavaScript是ES6的一种实现。","text":"总结：可以粗浅地理解ES6是一种标准，JavaScript是ES6的一种实现。 js与node.jsJS是由ES(ECMAScript)、DOM(浏览器文档对象)、BOM(浏览器对象模型)组成。 其中Node.Js就只有ES，目前浏览器比较流行的版本就是ES6(ES2015)，老浏览器的版本基本上都是ES5。所以alert和document不能在Node运行(因为Node没有dom和bom)。 ECMAScript 6简介ECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"JS数据类型","slug":"JS数据类型","date":"2019-07-01T10:55:12.000Z","updated":"2020-03-10T04:05:55.631Z","comments":true,"path":"2019/07/01/JS数据类型/","link":"","permalink":"http://yoursite.com/2019/07/01/JS数据类型/","excerpt":"很好的验证方法：在控制台中打印1console.log(变量名); 打印出的内容需要到网页F12中的console部分查看","text":"很好的验证方法：在控制台中打印1console.log(变量名); 打印出的内容需要到网页F12中的console部分查看 举例： 12345&lt;script&gt; var name_01=\"marry\",age=18,email=\"marry@qq.com\",address; // 在控制台中打印 console.log(name_01); &lt;/script&gt; 在网页F12中看到的就是marry typeof检测变量类型 功能 检测变量类型 语法 typeof 变量 或 typeof（变量） 返回值 类型，有可能是：string、number、 boolean、 object、undefined、function typeof能得到的6种类型：undefined、string、number、object、function。(注意：null 空指针，也是一个对象) 但是，typeof运算符 只能区分 值类型： 1234typeof undefined;//undefinedtypeof \"hlz\";//stringtypeof 123;//numbertypeof true;//boolean 对于 引用类型 ，typeof运算符只能区分出 函数 ： 1234typeof &#123;&#125;;//objecttypeof [];//objecttypeof null;//objecttypeof console.log;//function 注意：typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。准确判断可以从构造函数（instanceof）、原型链（prototype.isPrototypeOf）上下手，具体可以看下面的“如何判断一个对象是不是数组类型”中的例子。 null空对象指针 null值表示一个空对象指针 如果定义的变量准备在将来用于保存对象，那么最好将改变量初始化为null而不是其他值。（如果将来用于保存字符串，则可以使用“”，意为空字符串。） 举例: 1234//如果setting将来打算存储一个对象，最好初始化设置为nullvar setting=null;//如果setting将来打算存储一个字符串，最好初始化设置为\"\"var setting=\"\"; 说明：undefined值是派生自null值的，所以undefined= = null的返回结果是true。 undefined尚未赋值 undefined，一个特殊值，通常用于指示变量尚未赋值。 在高级程序设计语言设计应用程序时，用于指示变量尚未用单等号进行赋值（常量未定义）。 null(对象)与undefined(变量) null的类型是一个对象，用来表示一个变量没有任何数值，而undefined是指变量没有定义任何值（没有赋值）。 在JavaScript中，关键字null表示空值的意思，它表示对象为空，或者变量没有引用任何对象。如果当一个变量的值为null，则表明它的值不是有效的对象、数组、数值、字符串和布尔型等。如果使用alert(typeof(null))来检测null值的类型，则返回object，说明它是一个对象类型。 而undefined与null不同，它表示无值的意思，并且具有独一无二的类型，它区别任何对象、数组、数值、字符串和布尔型。alert(typeof(undefined))的返回值为undefined。 总的来说，null是不限于类型的空对象指针，而undefined是限于类型的变量还没有赋值。 Number整数和浮点数 Number ：表示整数和浮点数 NaN ：即非数值（ Not a Number ）是一个特殊的数值面试常考！ 说明： 任何涉及NaN的操作（例如NaN/10 ）都会返回NaN。 NaN与任何值都不相等，包括NaN本身。 如果typeof一个NaN，你会在F12中看到number，因为NaN是特殊的number isNaN（）判断是否“非数值” 语法：isNaN（n） 功能：检测n是否是“非数值” 返回值：boolean 参数：参数n可以是任何类型 说明 ：isNaN（）对接收的数值，先尝试转换为数值，再检测是否为非数值。（”16”虽然是字符串,但”16”可以转换为16，所以还是false） 注意：只有遇到Nan他才会返回true，其他不管是什么类型，包括true与false都被算作是数值，返回false！ 举例： 123456789&lt;script&gt; var name_01=\"marry\",age=18,email=\"marry@qq.com\",address; var id=\"16\" // 在控制台中打印 console.log(typeof(age));//得到的是false console.log(typeof(age-\"abc\"));//得到的是true console.log(typeof(email));//得到的是false console.log(typeof(id));//id虽然是字符串，但得到的是false,因为isNaN（）会对接收的数值先尝试转换为数值，再检测是否为非数值。而\"16\"可以转换为16。 &lt;/script&gt; 注意：true与false都被算作是数值！ 1234567//isNaN 判断是否“非数值”，遇到字符串会看能不能将其转换为数值再进行判断console.log(Number.isNaN(NaN));//trueconsole.log(Number.isNaN(-NaN));//trueconsole.log(Number.isNaN(1)); //falseconsole.log(Number.isNaN('1'));//falseconsole.log(Number.isNaN(true));//falseconsole.log(Number.isNaN(false));//false 把非数值转换为数值 有3个函数可以把非数值转换为数值： Number（） parseInt（） parseFloat（） 说明： Number（）可以用于任何数据类型 parseInt（）和parseFloat（）则专门用于把字符串转换成数值。 但是最好少用Number（） 只有数字开头的字符串可以使用parseInt（）和parseFloat（），非数字开头的只能使用Number（）【实际上非数字开头用Number（）也没用】 parseInt（） parseInt() 函数可解析一个字符串，并返回一个整数。 语法：parseInt(string, radix) string:必需。要被解析的字符串。（空则返回Nan） radix:可选。表示要解析的数字的基数(即多少进制)。【面试常考】 该值介于 2 ~ 36 之间。如果radix小于 2 或者大于 36，则 parseInt() 将返回 NaN。 省略radix或其值为 0，parseInt() 会根据 string 来判断数字的基数。 如果 string 以 1 ~ 9 的数字开头，则数字将以 10 为基础来解析。(即解析为十进制的整数) 如果string以 “0x” 或 “0X” 开头，将以 16 为基数。(即把 string 的其余部分解析为十六进制的整数) parseInt（）会忽略字符串前面的空格，直至找到第一个非空格字符。如果字符串的第一个字符不能被转换为数字，那么 parseFloat() 会返回 NaN。 也就是说，要想让parseInt（）提取数字，字符串必须是数字开头，比如”18px”，不能是”abc18”。parseInt(“abc18”)会得到NaN 注意：转换空字符串返回NaN。 举例： 123456parseInt(\"10\"); //返回 10parseInt(\"19\",10); //返回 19 (10+9)parseInt(\"11\",2); //返回 3 (2+1)parseInt(\"17\",8); //返回 15 (8+7)parseInt(\"1f\",16); //返回 31 (16+15)parseInt(\"010\"); //未定：返回 10 或 8 针对参数2举例：123&lt;script&gt; console.log(parseInt(\"0xf\"));//得到的是15，并不是取0，而是把16进制转换过来了.也可以写成console.log(parseInt(\"0xf\",16)); &lt;/script&gt; parseFloat（） parseFloat ：从第一个字符开始解析每个字符，直至遇见一个无效的浮点数字符为止。 说明：除了第一个小数点有效外，parseFloat（）与parseInt（）的第二个区别在于它始终都会忽略前导的零。 举例： 123456789&lt;script&gt; var d=parseFloat(\"12.34px\"); // 在控制台中打印 console.log(d);//得到的是12.34 console.log(parseFloat(\"12.34.56px\"));//得到的还是12.34，第二个小数点不会被截取出来 console.log(parseInt(\"0123\"));//得到的是123 console.log(parseFLoat(\"0123\"));//得到的还是123，他们都会忽略前面的0 &lt;/script&gt; Number（） 返回值：如果参数是 Date 对象，Number() 返回从 1970 年 1 月 1 日至今的毫秒数。如果对象的值无法转换为数字，那么 Number() 函数返回 NaN。 null与空字符, number 默认把其转化为0 面试题1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;script&gt; var x; console.log(x);//undefined var y = null; console.log(y);//null console.log(null == 0);//false,null值表示一个空对象指针 console.log(undefined == 0);//false,undefined表示未赋值 console.log(undefined == null);//true,undefined值是派生自null值的 console.log(Number(\"\"));//0 console.log(Number(null));//0 console.log(Number(undefined));//NaN console.log(Number(\"2\"));//2 console.log(Number(\"a2\"));//NaN console.log(Number(\"222 333\"));//NaN console.log(parseInt(\"\"));//NaN console.log(parseInt(null));//NaN console.log(parseInt(undefined));//NaN console.log(parseInt(\"22\"));//22 console.log(parseInt(\"a22\"));//NaN,要想让parseInt（）提取数字，字符串必须是数字开头 console.log(parseInt(22));//22 console.log(parseInt(\" 22\"));//22 console.log(parseInt(\"22 33\"));//22 &lt;/script&gt;&lt;/body&gt; （面试题）如何判断一个对象是不是数组类型首先我们需要知道：在 JavaScript 中，几乎“所有事物”都是对象。（具体可以看笔记“js对象 学习笔记（1）”）typeof {}和typeof []的结果都是object：使用typeof来判断数据类型其实并不准确，数组、正则、日期、对象的typeof返回值都是object。 obj instanceof Array从构造函数入手，typeof 和 instanceof 都可以用来判断变量，typeof方法返回一个字符串，来表示数据的类型。 但是typeof来判断数据类型其实并不准确。比如数组、正则、日期、对象的typeof返回值都是object，这就会造成一些误差。而 instanceof运算符 用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性，返回一个布尔值，如果左侧的对象是右侧对象的实例，返回true，否则返回false。 Array.prototype.isPrototypeOf(obj);从原型入手，利用isPrototypeOf()方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。 12Array.prototype.isPrototypeOf([]);//trueArray.prototype.isPrototypeOf(&#123;&#125;);//false Array.isArray()方法这是js提供的方法，用于判断对象是不是数组类型，如下： 1234Array.isArray([1, 2, 3]); // trueArray.isArray(&#123;foo: 123&#125;); // falseArray.isArray('foobar'); // falseArray.isArray(undefined); // false MDN中比较了isArray和instanceof的区别，当Array.isArray()不可用的使用，MDN做了补丁，说明还是比较推荐使用前面讲的方法 Object.prototype.toString.call(obj)。","categories":[{"name":"JavaScript学习","slug":"JavaScript学习","permalink":"http://yoursite.com/categories/JavaScript学习/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"ReactNative API","slug":"ReactNative API","date":"2019-06-01T05:16:04.000Z","updated":"2020-02-21T05:17:03.996Z","comments":true,"path":"2019/06/01/ReactNative API/","link":"","permalink":"http://yoursite.com/2019/06/01/ReactNative API/","excerpt":"Alert 提示框 Alert启动一个提示对话框，包含对应的标题和信息。 你还可以指定一系列的按钮，点击对应的按钮会调用对应的 onPress 回调并且关闭提示框。默认情况下，对话框会仅有一个’确定’按钮。 可以参考文档","text":"Alert 提示框 Alert启动一个提示对话框，包含对应的标题和信息。 你还可以指定一系列的按钮，点击对应的按钮会调用对应的 onPress 回调并且关闭提示框。默认情况下，对话框会仅有一个’确定’按钮。 可以参考文档 语法： 12345Alert.alert( title, message, [button1,button2...], &#123;cancelable:&#125; )button:&#123;text:title,onPress:()=&gt;&#123;&#125;&#125; 例子eg：判断输入框中的内容是否为空，若为空，弹出提示对话框： AsyncStorage 异步存储AsyncStorage是React Native提供的一个异步、未加密、持久的、全局的键值对(key-value)存储模块 方法 描述 setItem(key,value) 通过key-value（键值对） 存储数据 getItem(key) 通过key 读取数据 value removeItem(key) 删除 key对应的那条数据 clear() 清除全部数据 例子将登录页账号密码做异步存储，再次进入时读取账号密码进行回显： 将readUserData中读取到的account和pass赋给TextInput的value属性值： BackHandler①退出程序: 1BackHandler.exitApp() ②处理实体返回键： 组件生命周期可以参考React的生命周期函数 地理位置信息Geolocation API为React Native框架下的App提供获取定位坐标的功能 首先获取权限，Android下修改AndroidMenifest.xml文件，添加如下代码： 1&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt; android文件夹中内容修改需要重新安装应用才能生效给App开启定位权限，设置模拟器虚拟定位getCurrentPosition([callback]) 获取当前位置信息watchPosition([callback]) 监控位置变更时进行函数回调","categories":[{"name":"React Native学习","slug":"React-Native学习","permalink":"http://yoursite.com/categories/React-Native学习/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"ReactNative 导航器实例","slug":"ReactNative 导航器实例","date":"2019-05-11T03:41:26.000Z","updated":"2020-02-21T03:43:04.778Z","comments":true,"path":"2019/05/11/ReactNative 导航器实例/","link":"","permalink":"http://yoursite.com/2019/05/11/ReactNative 导航器实例/","excerpt":"准备工作使用第三方库React Navigation实现界面导航与跳转 1.打开项目中package.json文件，查看react-native版本。若react-native版本号不是0.58.6，手动修改过来。","text":"准备工作使用第三方库React Navigation实现界面导航与跳转 1.打开项目中package.json文件，查看react-native版本。若react-native版本号不是0.58.6，手动修改过来。 执行命令“npm install”。再检查项目能否成功运行。 2.在项目中运行命令： 12npm install --save react-navigation@2.18.3npm install --save @types/react-navigation 3.再次查看package.json文件，三者版本号 顶部导航栏createStackNavigator()createStackNavigator()返回的是一个组件，可以在createStackNavigator()定义组件后在页面中通过调用该组件显示出导航栏。 页面跳转createStackNavigator 参数1通过createStackNavigator()的 第一个参数 定义两个路由（Login和Main），screen是他们对应的页面： createStackNavigator对象可以看做一个组件，在你需要使用的地方渲染该组件： navigation.navigate()页面跳转3.编写LoginScreen页面：当导航器中的屏幕被打开时，它会收到一个navigation属性，navigation的作用有很多，其中navigate()可以跳转到其他界面。 4.编写MainScreen页面：navigation的state：屏幕的当前state。 顶部导航栏的返回按钮每个界面的顶部导航栏左边默认设置了一个返回按钮，通过它可以返回到之前一个页面。如果想要取消某个页面的头部导航栏，需要在该页面组件中定义： createStackNavigator 参数2 navigationOptions若要取消所有页面的头部导航栏，需要在路由中定义第 二个参数navigationOptions： 手动返回 this.props.navigation.goBack()eg:MainScreen中添加按钮，点击该按钮，回到LoginScreen： 向上一个页面返回数据this.props.navigation.state.params.refresh（）返回数据MainScreen：调用this.props.navigation.state.params.refresh方法返回数据 refresh中事件函数的形参 接受数据LoginScreen：refresh中事件函数的 形参 data 接收MainScreen返回回来的数据若是将数据显示在ToastAndroid中，则直接show。若是显示在界面控件中，需用state处理，因为此时界面状态发生了改变。 通过state将界面重新渲染①初始化state ②设置state属性值 ③获取state属性值 底部导航栏createBottomTabNavigator()还有一个类似的createMaterialTopTabNavigator()是顶部导航。 创建含有两个页面的底部导航创建含有MessageScreen和ContactsScreen两个页面的底部导航 1.定义MessageScreen和ContactsScreen页面： createBottomTabNavigator()参数12.定义页面的路由名称Message和Contacts：注意：“设置”中可配置的参数放在下面“参数2”中列出。 3.渲染路由组件： createBottomTabNavigator()参数2 navigationOptions渲染底部图标和文字（其中renderTabBar()是自己另外定义的作为判断使用）： 对导航和tabBar的设置，定义在路由组件参数2中：","categories":[{"name":"React Native学习","slug":"React-Native学习","permalink":"http://yoursite.com/categories/React-Native学习/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"ReactNative导航器","slug":"ReactNative 导航器","date":"2019-05-03T02:17:21.000Z","updated":"2020-02-21T05:12:45.965Z","comments":true,"path":"2019/05/03/ReactNative 导航器/","link":"","permalink":"http://yoursite.com/2019/05/03/ReactNative 导航器/","excerpt":"Android 独有的组件ReactNative组件和API参考文档","text":"Android 独有的组件ReactNative组件和API参考文档 ToastAndroid 弹出一个Toast提示框。 更多信息可参考文档 方法 描述 show(String message,int duration) String message: 一个字符串，表示将要显示的文本内容。int duration: 提示信息持续显示的时间。可以是ToastAndroid.SHORT或者ToastAndroid.LONG showWithGravity() 指定弹出的位置。参数值可以是ToastAndroid.TOP, ToastAndroid.BOTTOM, ToastAndroid.CENTER 例子： 12345678import &#123; ToastAndroid &#125; from 'react-native'; ToastAndroid.show(\"A pikachu appeared nearby !\", ToastAndroid.SHORT);ToastAndroid.showWithGravity( \"All Your Base Are Belong To Us\", ToastAndroid.SHORT, ToastAndroid.CENTER); 使用导航器跳转页面（React Navigation） 移动应用基本不会只由一个页面组成。管理多个页面的呈现、跳转的组件就是我们通常所说的导航器（navigator）。 React Native 有几个导航组件。刚开始接触直接选择React Navigation就好。 React Navigation 提供了简单易用的跨平台导航方案，在 iOS 和 Android 上都可以进行翻页式、tab 选项卡式和抽屉式的导航布局。 如果你想同时在iOS和Android上达到看起来像原生，或者你想把RN整合到一个已经有原生导航管理的APP里, 下面这个库提供了在两个平台都适用的原生导航: react-native-navigation. 可以参考React Navigation使用指南，也可以在慕课这个视频教程中学习到React Navigation。 什么是导航器 导航器也可以看成是一个普通的React组件，你可以通过导航器来定义你的App的导航结构。 导航器还可以渲染通用元素，例如可以配置的标题栏和选项卡栏。 在react-navigation中有以下5种类型的导航器： 导航器 描述 createStackNavigator 屏幕上方导航栏，类似于普通的Navigator createBottomTabNavigator 屏幕底部的导航栏，相当于iOS里面的TabBarController createMaterialTopTabNavigator 屏幕顶部的材料设计主题导航栏 createDrawerNavigator 抽屉效果，侧边滑出 createSwitchNavigator SwitchNavigator 的用途是一次只显示一个页面 导航器的属性 属性 描述 ref 可以通过ref属性获取到Navigation onNavigationStateChange（prevState，newState，action） 顶级节点除了ref 属性之外，还接受onNav igat ionStateChange（prevState，newState，action）属性，每次当导航器所管理的state发生改变时，都会回调该方法。prevState：变化之前的state；。newState：新的state；。导致state变化的action screenProps 向子屏幕传递额外的数据，子屏幕可以通过this.props.screenProps获取到该数据 导航器相关的两个概念在开始学习导航器之前，我们需要先了解两个和导航相关的概念： 概念 描述 Screen navigation prop（屏幕导航属性） 通过navigatioh可以完成屏幕之间的调度操作，例如打开另一个屏幕 Screen navigationOptions（屏幕导航选项） 通过navigationOptions可以定制导航器显示的方式（例如：头部标题，选项卡标签等） navigation（屏幕导航属性）当导航器中的屏幕被打开时，它会收到一个navigation 属性，navigation 属性 是整个导航环节的关键一员，接下来就详细讲解一下navigation的作用。 navigation的作用 navigate()：跳转到其他界面 state：屏幕的当前state setParams()：改变路由的 params（参数） goBack：关闭当前屏幕 dispatch()：向路由发送一个action addListener：订阅导航生命周期的更新 isFocused：true 标识屏幕获取了焦点 getParam：获取具有回退的特定参数 dangerouslyGetParent：返回父导航器 注意：一个navigation有可能没有navigate、setParams 以及goBack，只有state与dispatch，所以在使用navigate时要进行判断，如果没有navigate可以使用navigation去dispatch一个新的action。如：提示：这里的reset在2.0及以后版本中被从NavigationActions中移到了StackActions中，使用时记得留意。 StackNavigator的navigation的额外功能 当且仅当 当前navigator 是 stack navigator（顶部导航）时，this.props.navigation上有一些附加功能。 这些函数是navigate和goBack的替代方法，你可以使用任何你喜 欢的方法。这些功能是： this.props.navigation的属性 描述 push 导航到堆栈中的一个新的路由 pop 返回堆栈中的上一个页面 popToTop 跳转到堆栈中最顶层的页面 replace 用新路由替换当前路由 reset 擦除导航器状态并将其替换为多个操作的结果 dismiss 关闭当前栈 navigationOptions（屏幕导航选项）支持以下参数： title: 可以作为headerTitle的备选字段(当没设置headerTitle时会用该字段作为标题)，也可以作为TabNavigator的tabBarLabel以及DrawerNavigator的drawerLabel。 header: 自定义导航条，可以通过设置null来隐藏导航条； headerTitle: 标题； headerTitleAllowFontScaling: 标题是否允许缩放，默认true； headerBackTitle: 定义在iOS上当前页面进入到下一页面的回退标题，可以通过设置null来禁用它； headerTruncatedBackTitle: 当回退标题不能显示的时候显示此属性的标题，比如回退标题太长了； headerBackImage：React 元素或组件在标题的后退按钮中显示自定义图片（回退图标）。 当组件被调用时，它会在渲染时收到许多 props 如：（tintColor，title）。 默认为带有 react-navigation/views/assets/back-icon.png 这张图片的组件，后者是平台的默认后图标图像（iOS上为向左的符号，Android上为箭头）。 headerRight: 定义导航栏右边视图； headerLeft: 定义导航栏左边视图； headerStyle: 定义导航栏的样式，比如背景色等； headerTitleStyle: 定义标题的样式； headerLeftContainerStyle：自定义 headerLeft 组件(导航栏左边视图)容器的样式，例如，增加 padding。 headerRightContainerStyle：自定义 headerRight 组件(导航栏右边视图)容器的样式,例如，增加 padding。 headerTitleContainerStyle：自定义 headerTitle 组件容器的样式, 例如，增加 padding。 headerBackTitleStyle: 定义返回标题的样式； headerPressColorAndroid：颜色为材料波纹 (Android &gt;= 5.0)； headerTintColor: 定义导航条的tintColor，会覆盖headerTitleStyle中的颜色； headerTransparent：默认为 false。如果 true, 则标头将不会有背景, 除非您显式提供 headerStyle 或 headerBackground。 headerBackground：与headerTransparent一起使用，以提供在标题后台呈现的组件。 例如，您可以使用模糊视图来创建半透明标题。 gesturesEnabled: 定义是否能侧滑返回，iOS默认true，Android默认false； gestureResponseDistance: 定义滑动返回的有效距离，水平状态下默认：25，垂直状态默认135； gestureDirection: 设置关闭手势的方向。默认从左向右，可以设置从右到左的滑动操作。 使用navigate进行界面之间的跳转语法： 123navigation.navigate（&#123;routeName，params，action，key&#125;）//或navigation.navigate（routeName，params，action） 参数 描述 routeName 要跳转到的界面的路由名，也就是在导航其中配置的路由名 params 要传递给下一个界面的参数 action (可选) 如果该界面是一个navigator的话，将运行这个sub-action key (可选) 要导航到的路由的可选标识符。如果已存在，将后退到此路由 例子：页面跳转HomeScreen跳转到Page1： 使用state的params可以通过this.props.state.params来获取通过setParams（），或navigat ion.navigate（）传递的参数。 使用setParams()改变路由的paramssetParams：function setParams（params）：我们可以借助setParams来改变route params。比如，通过setParams来更新页面顶部的标题，返回按钮等。注意：navigation.setParams改变的是当前页面的Params，如果要改变其他页面的Params可以通过NavigationActions.setParams完成，下文会讲到。 屏幕上方导航栏createStackNavigator（定义路由）组件createStackNavigator提供APP屏幕之间切换的能力，它是以栈的形式还管理屏幕之间的切换，新切换到的屏幕会放在栈的顶部。 屏幕转场风格默认情况下，createStackNavigator提供了转场过渡效果，在Android和iOS上过渡效果是不同的，这也是React Native重平台性的一个体现，在Android上从屏幕底部淡入，在iOS上是从屏幕的右侧划入，当然你也可以通过配置让StackNavigator支持屏幕从底部滑入的效果。 createStackNavigator API createStackNavigator是一个函数，它返回一个包含两个属性的对象:Screen和Navigator。 Screen组件 指定路由。 Screen组件接受一个name属性，它对应于我们将用于导航的路由的名称。 Screen组件还有一个component属性，它对应于它将渲染的组件。 Screen和Navigator都是用于配置导航器的React组件。导航器应该将屏幕元素作为其子元素来定义路由配置。 路由名称开头字母的大小写无关紧要，可以使用小写字母home或大写字母Home，这取决于你的喜好。 我们更喜欢将路由名称大写。 NavigationContainer是一个组件，它管理导航树并包含导航状态。此组件必须包装所有导航器结构。通常，我们会在app的根目录下呈现这个组件，这个根目录通常是app .js导出的组件。 1createStackNavigator(RouteConfigs, StackNavigatorConfig); 参数RouteConfigs(必选)RouteConfigs：路由配置对象是从路由名称到路由配置的映射，告诉导航器该路由呈现什么。RouteConfigs 支持三个参数screen、path以及navigationOptions。 参数 描述 screen (必选) 指定一个 React 组件作为屏幕的主要显示内容，当这个组件被createStackNavigator加载时，它会被分配一个navigation prop path(可选) 用来设置支持schema跳转时使用，具体使用会在下文的有关Schema章节中讲到 navigationOptions(可选) 用以配置全局的屏幕导航选项如：title、headerRight、headerLeft等 参数StackNavigatorConfig(可选) StackNavigatorConfig：配置导航器的路由(如：默认首屏，navigationOptions，paths等)、样式(如，转场模式mode、头部模式等)。 从react-navigation源码中可以看出StackNavigatorConfig支持配置的参数有10个:12345678910function createStackNavigator(routeConfigMap, stackConfig = &#123;&#125;) &#123; const &#123; initialRouteKey, initialRouteName, initialRouteParams, paths, navigationOptions, disableKeyboardHandling, getCustomActionCreators &#125; = stackConfig; 这7个参数可以根据作用不同分为路由配置、视图样式配置两类。 用于路由配置的参数 initialRouteName: 设置默认的页面组件，必须是上面已注册的页面组件(也就是说必须是RouteConfigs中配置过的页面组件)。 initialRouteParams: 初始化路由的参数。 navigationOptions: 屏幕导航的默认选项，下文会详细讲解。 initialRouteKey - 初始路由的可选标识符。 paths: 用来设置支持schema跳转时使用，具体使用会在下文的有关Schema章节中讲到。 用于导航样式配置的参数 mode: 页面切换模式。 card: 普通app常用的左右切换(相当于iOS中的push效果)。 modal: 上下切换(相当于iOS中的modal效果) 。 headerMode: 导航栏的显示模式。 float: 无透明效果, 默认。 screen: 有渐变透明效果, 如微信QQ的一样。 none: 隐藏导航栏。 headerBackTitleVisible : 提供合理的默认值以确定后退按钮标题是否可见，但如果要覆盖它，则可以使用true或 false 在此选项中。 fade-in-place（默认值）: 标题组件交叉淡入淡出而不移动，类似于iOS的Twitter，Instagram和Facebook应用程序。 uikit: iOS的默认行为的近似值。 headerTransitionPreset: 指定在启用headerMode：float时header应如何从一个屏幕转换到另一个屏幕。 cardStyle: 样式（iOS上页面切换会有白色渐变蒙层，想去掉则可以这样设置cardStyle: { opacity: null },切换页面时的页面边框也在这里可以设置）。 onTransitionStart: 页面切换开始时的回调函数 (我们可以在这里注册一些通知，告知我们切面切换的状态，方便后面处理页面切换事件)。 onTransitionEnd: 页面切换结束时的回调函数。 案例创建一个StackNavigator类型的导航器123456789101112131415161718192021222324252627282930313233343536373839404142434445//使用createStackNavigator()创建StackNavigator类型的导航器export const AppStackNavigator = createStackNavigator(&#123; //配置4个页面 HomePage: &#123; screen: HomePage &#125;, Page1: &#123; screen: Page1, navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; //动态设置navigationOptions title: `$&#123;navigation.state.params.name&#125;页面名` &#125;) &#125;, Page2: &#123; screen: Page2, navigationOptions: &#123; //在这里定义每个页面的导航属性，静态配置 title: \"This is Page2.\", &#125; &#125;, Page3: &#123; screen: Page3, navigationOptions: (props) =&gt; &#123; //在这里定义每个页面的导航属性，动态配置 const &#123;navigation&#125; = props; const &#123;state, setParams&#125; = navigation; const &#123;params&#125; = state; return &#123; title: params.title ? params.title : 'This is Page3', headerRight: ( &lt;Button title=&#123;params.mode === 'edit' ? '保存' : '编辑'&#125; onPress=&#123;() =&gt; setParams(&#123;mode: params.mode === 'edit' ? '' : 'edit'&#125;)&#125; /&gt; ), &#125; &#125; &#125;,&#125;, &#123; defaultNavigationOptions: &#123; // 可以通过将header设为null 来禁用StackNavigator的Navigation Bar // header: null, &#125;&#125;);","categories":[{"name":"React Native学习","slug":"React-Native学习","permalink":"http://yoursite.com/categories/React-Native学习/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"ReactNative入门基础(2)","slug":"ReactNative入门基础(2)","date":"2019-04-01T14:03:36.000Z","updated":"2020-02-21T06:38:40.903Z","comments":true,"path":"2019/04/01/ReactNative入门基础(2)/","link":"","permalink":"http://yoursite.com/2019/04/01/ReactNative入门基础(2)/","excerpt":"props和state 我们使用两种数据来控制一个组件：props和state。 props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用state。","text":"props和state 我们使用两种数据来控制一个组件：props和state。 props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用state。 Props（属性） 大多数组件在创建时就可以使用各种参数来进行定制，用于定制的这些参数就称为props（属性）。 以常见的基础组件Image为例：在创建一个图片时，可以传入一个名为source的 prop 来指定要显示的图片的地址，以及使用名为style的 prop 来控制其样式。 例子（自定义组件）自定义的组件也可以使用props:通过在不同的场景使用不同的属性定制，可以尽量提高自定义组件的复用范畴。只需在render函数中引用this.props，然后按需处理即可。【可以联想一下react中的父子组件传值方式】 下面例子中，我们在Greeting组件中将name作为一个属性来定制，这样可以复用这一组件来制作各种不同的“问候语”：【从react的角度理解， 父组件LotsOfGreetings1 在调用 子组件Greeting 时将name作为属性传值给子组件，在子组件中通过this.props.name获取到父组件传递过来的属性值，最终显示在父组件中】 State（状态） props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用state。 一般来说，你需要在class的 constructor（构造函数） 中初始化中一个state对象，然后在需要修改时调用setState方法。 在React中，状态(state)一旦发生变化，就会触发界面的重新渲染。一切界面变化都是状态state变化。 state的修改必须通过setState()方法，this.state.num = 100; 这样的直接赋值修改无效！ setState() 是异步操作，修改不会马上生效。 State 的工作原理和 React.js 完全一致，所以对于处理 state 的一些更深入的细节，你可以参考react的笔记。 例子假如我们需要制作一段不停闪烁的文字。文字内容本身在组件创建时就已经指定好了，所以文字内容应该是一个prop。而文字的显示或隐藏的状态（快速的显隐切换就产生了闪烁的效果）则是随着时间变化的，因此这一状态应该写到state中: 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';class Blink extends Component &#123; // 声明state对象 state = &#123; isShowingText: true &#125;; componentDidMount() &#123; // 每1000毫秒对showText状态做一次取反操作 setInterval(() =&gt; &#123; this.setState(&#123; isShowingText: !this.state.isShowingText &#125;); &#125;, 1000); &#125; render() &#123; // 根据当前showText的值决定是否显示text内容 if (!this.state.isShowingText) &#123; return null; &#125; return ( &lt;Text&gt;&#123;this.props.text&#125;&lt;/Text&gt; ); &#125;&#125;export default class BlinkApp extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Blink text='I love to blink' /&gt; &lt;Blink text='Yes blinking is so great' /&gt; &lt;Blink text='Why did they ever take this out of HTML' /&gt; &lt;Blink text='Look at me look at me look at me' /&gt; &lt;/View&gt; ); &#125;&#125; ref 获取某个子组件 React 支持一种非常特殊的属性 Ref ，你可以用来绑定到 render() 输出的任何组件上。 例子 关于ref的理解：ref : 指向某个子组件this : 指向当前export的组件本身this.refs : 指向当前export的组件的所有子组件this.refs.ref_phoneInput : 指向当前import的自定义封装组件this.refs.ref_phoneInput.refs : 指向当前import的自定义封装组件的所有子组件this.refs.ref_phoneInput.refs.PhoneNumberInput : 指向当前import的自定义封装组件的其中一个子组件 例子：注意：这里的this.refs.myInput就是组件实例，可以获取到实例的属性和方法。 基础组件ScrollView 滚动 ScrollView 是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。 ScrollView 不仅可以垂直滚动，还能水平滚动（通过horizontal属性来设置。） 属性值：当horizontal属性为true的时候，所有的子视图会在水平方向上排成一行，而不是默认的在垂直方向上排成一列。默认值为false。（更多属性可查看文档） ScrollView 适合用来显示数量不多的滚动元素。放置在ScrollView 中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了屏幕外。如果你需要显示较长的滚动列表，那么应该使用功能差不多但性能更好的FlatList组件。 列表视图组件和一般化用途的ScrollView不同，下面的列表组件只会渲染当前屏幕可见的元素，这样有利于显示大量的数据。 FlatList 长列表组件 React Native 提供了几个适用于展示长列表数据的组件，一般而言我们会选用FlatList或是SectionList。（如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择） FlatList组件用于显示一个垂直的滚动列表，其中的元素之间结构近似而仅数据不同。 区别于ScrollView： FlatList更适于长列表数据，且元素个数可以增删。和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素。 必须的两个属性：data（数组）和renderItem(事件)。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。【事件：是指发生在该组件上的事情。】 属性 值 data 为了简化起见，data 属性目前只支持普通数组。如果需要使用其他特殊数据结构，例如 immutable 数组，请直接使用更底层的VirtualizedList组件 renderItem(事件) 函数，可接受3个参数。renderItem({item, index, separators});item：data中的各个数据项index：与数据数组中该项对应的索引separators：参考文档作用：从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染各个数据 例子：下面的例子创建了一个简单的FlatList，并预设了一些模拟数据data。首先是初始化FlatList所需的data，其中的每一项（行）数据之后都在renderItem中被渲染成了Text组件，最后构成整个FlatList： SectionList 【分组】长列表组件 如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择。 列表的一个常用场景就是从服务器端取回列表数据然后显示，要实现这一过程还需要学习React Native 的网络相关用法。 必须的属性:sections（数组）、renderItem（事件）。（更多属性可参考文档） 属性 值 sections 数组，用来渲染的数据，类似于FlatList中的data属性 renderItem 函数，用来渲染每一个section中的每一个列表项的默认渲染器。必须返回一个react组件。可以在section级别上进行覆盖重写。 renderSectionHeader 函数，在每个section的头部渲染。在iOS上，这些headers是默认粘接在ScrollView的顶部的 renderSectionFooter 每个组的尾部组件 注意 当某行滑出渲染区域之外后，其内部状态将不会保留。请确保你在行组件以外的地方保留了数据。 本组件继承自PureComponent而非通常的Component，这意味着如果其props在浅比较中是相等的，则不会重新渲染。所以请先检查你的 renderItem函数 所依赖的 props数据（包括 data属性 以及可能用到的 父组件的state ）。如果是一个引用类型（Object或者数组都是引用类型），则需要先修改其引用地址（比如先复制到一个新的Object或者数组中【深拷贝】），然后再修改其值，否则界面很可能不会刷新。（这一段不了解的朋友建议先学习下js中的基本类型和引用类型。） 为了优化内存占用同时保持滑动的流畅，列表内容会在屏幕外异步绘制。这意味着如果用户滑动的速度超过渲染的速度，则会先看到空白的内容。这是为了优化不得不作出的妥协，而我们也在设法持续改进。 默认情况下每行都需要提供一个不重复的key属性。你也可以提供一个keyExtractor函数来生成key。 其他组件WebView 加载网页内容WebView组件可以实现直接加载网页内容在React Native框架中显示。 更多组件：更多组件可查询文档 网络很多移动应用都需要从远程地址中获取数据或资源。你可能需要给某个 REST API 发起 POST 请求以提交用户数据，又或者可能仅仅需要从某个服务器上获取一些静态内容。 fetch的基本用法 React Native 提供了和 web 标准一致的Fetch API，用于满足开发者访问网络的需求。 这篇文章只会列出 Fetch 的基本用法，并不会讲述太多细节，你可以使用你喜欢的搜索引擎去搜索fetch api关键字以了解更多信息。 可以参考视频教程 发起请求要从任意地址获取内容的话，只需简单地将网址作为参数传递给 fetch 方法即可（fetch 这个词本身也就是获取的意思）： 1fetch('https://mywebsite.com/mydata.json');//获取该网址中mydata.json的内容 fetch() 还有可选的第二个参数，可以用来定制 HTTP 请求一些参数。你可以指定 header 参数，或是指定使用 POST 方法，又或是提交数据等等： 123456789101112fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST',//GET请求数据，POST修改数据 headers: &#123; Accept: 'application/json',//要求获取json格式的数据 'Content-Type': 'application/json',//表示发送的实体数据为json类型 &#125;, //使用POST请求需要把body部分以字符串或者FormData对象传过去 body: JSON.stringify(&#123; firstParam: 'yourValue', secondParam: 'yourOtherValue', &#125;),&#125;); 提交数据的格式关键取决于 headers 中的Content-Type。Content-Type有很多种，对应 body 的格式也有区别。到底应该采用什么样的Content-Type取决于服务器端，所以请和服务器端的开发人员沟通确定清楚。常用的’Content-Type’除了上面的’application/json’，还有传统的网页表单形式，示例如下： 1234567fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', &#125;, body: 'key1=value1&amp;key2=value2',&#125;); 可以参考Fetch 请求文档来查看所有可用的参数。 注意：使用 Chrome 调试目前无法观测到 React Native 中的网络请求，可以使用第三方的react-native-debugger来进行观测。 补充：json() json() 方法接收一个 Response对象，读取 Response 对象并且将它设置为已读（因为 Responses 对象被设置为了 stream 的方式，所以它们只能被读取一次），并返回一个被解析为 JSON 格式的 Promise 对象。 MDN文档 处理服务器的响应数据上面的例子演示了如何发起请求。很多情况下，你还需要处理服务器回复的数据。 网络请求天然是一种异步操作（异步的意思是你应该趁这个时间去做点别的事情，比如显示 loading，而不是让界面卡住傻等）。无论请求成功与否，fetch()都返回一个 promise 对象，请求成功时 resolve 对应请求的 Response对象（如果数据获取失败就会到进入catch），这种模式可以简化异步风格的代码（别忘了 catch 住fetch可能抛出的异常，否则出错时你可能看不到任何提示）： 123456789101112function getMoviesFromApiAsync() &#123; return fetch('https://facebook.github.io/react-native/movies.json') //成功获取到的数据（Response对象）作为参数response传入then() .then((response) =&gt; response.json())//解析为 JSON 格式的 Promise 对象 .then((responseJson) =&gt; &#123;//responseJson为上一个then()返回的数据 return responseJson.movies;//返回响应数据中的movies &#125;) .catch((error) =&gt; &#123; //catch 住fetch可能抛出的异常，否则出错时你可能看不到任何提示 console.error(error); &#125;);&#125; fetch()返回的是promise 对象，请求成功时将获取到的数据（Response对象）传入并执行then(),response是Response对象，包含Header、status、statusText等属性。Response对象 要获得具体数据需要使用.json()（解析为JSON格式）、.text()（解析为 USVString 格式）、.formData()（用于FormData对象）等方法。response.json()返回的是一个Promise对象，所以只能先return为下一个then()中的参数responseJson，再在下一层处理。【Promise 对象用于表示一个异步操作的最终完成 (或失败), 及其结果值。所以我们不能直接操作Promise对象，需要等异步操作成功以后使用then()取到成功后返回的数据，在then()中对数据进行操作】 注意 默认情况下，iOS 会阻止所有 http 的请求，以督促开发者使用 https。如果你仍然需要使用 http 协议，那么首先需要添加一个 App Transport Security 的例外，详细可参考这篇帖子。 从 Android9 开始，也会默认阻止 http 请求，请参考相关配置。 使用其他的网络库 React Native 中已经内置了XMLHttpRequest API(也就是俗称的 ajax)。 一些基于 XMLHttpRequest 封装的第三方库也可以使用，例如frisbee或axios等。但注意不能使用 jQuery，因为 jQuery 中还使用了很多浏览器中才有而 RN 中没有的东西（所以也不是所有 web 中的 ajax 库都可以直接使用）。【想要使用其他的网络库可以参考这个文档】 但是不推荐使用第三方库，建议React Native中使用fetch()。 需要注意的是，安全机制与网页环境有所不同：在应用中你可以访问任何网站，没有跨域的限制。 fetch和axios相比 使用fetch()多了一步，axios通过get()获取到的直接是数据，而fetch()获取到的是Promise对象，还要通过.json()解析为JSON格式才能获取到数据。 axios可参考笔记","categories":[{"name":"React Native学习","slug":"React-Native学习","permalink":"http://yoursite.com/categories/React-Native学习/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"ReactNative入门基础(1)","slug":"ReactNative入门基础(1)","date":"2019-03-11T03:35:11.000Z","updated":"2020-02-19T14:15:34.278Z","comments":true,"path":"2019/03/11/ReactNative入门基础(1)/","link":"","permalink":"http://yoursite.com/2019/03/11/ReactNative入门基础(1)/","excerpt":"React Native是facebook开源的用于开发移动端跨平台App的技术框架，其代码托管在GitHub上。 React Native中文文档","text":"React Native是facebook开源的用于开发移动端跨平台App的技术框架，其代码托管在GitHub上。 React Native中文文档 React Native 优点 代码复用率高，可以使用ReactNative跑在 安卓/ios 上 跨平台，可以用它开发安卓/ios 具有本地能力，App占用体积小 性能高，更新快 可以发布，且支持动态更新（直接在用户设备上更新，不需要通过app store） 开发成本低 运行命令 新建项目 react-native init xxx 运行项目 react-native run-android 检验雷电模拟器连接 adb devices（连接成功会显示：daemon started successfully） 热重载 进入app-“更多”-“摇一摇”打开开发者菜单-点击热重载Enable Hot Reloading（修改App.js，保存即可看见修改后的效果）【或者可以在终端输入adb shell input keyevent 82来打开开发者菜单】 页面布局 React Native是一个专注于UI构建的框架， 设计的初衷是为了屏蔽平台的差异化显示。 所以界面是React Native开发中的一个重要的组成部分。 flexbox布局可参考笔记CSS flexbox 注意 默认情况下，flex的方向是column，即从上往下的。（这个与移动端与web页面不同，在web页面用CSS设置flex布局，默认的fiex-direction是row，即水平从左往右）。 如果父容器的尺寸为零（即没有设置宽高，或者没有设定flex），即使子组件如果使用了flex，也是无法显示的。所以可以给父组件设置flex:1，表示让它占据了垂直的整个空间。 长度的单位 首先需要知道，在写React Native组件样式时，长度的不带单位的，它表示“与设备像素密度无关的逻辑像素点”。 在React Native中，拥有一个类似于dp的长度单位。 理解px如果我们以像素为单位来设置一个界面元素的大小，比如说2px的高度，那么这2px的长度在不同的设备中就会是下面这个样子：可以发现：它们真实显示出的长度是不一样的。 理解dp在同样物理尺寸大小的屏幕上（不论分辨率谁高谁低，只要物理尺寸大小一样即可），1个单位的长度所代表的物理尺寸是一样的。这种单位就应该是独立于分辨率的，把它起一个名字叫做 density-independent pixels，简称dp。这其实就是Android系统中所使用的长度单位。 例子：2dp宽，2dp高的内容，在不同分辨率但屏幕尺寸一样的设备上所显示出的物理大小是一样的（一个题外话：有些Android开发者建议所有可点击的按钮，宽高都不应该少于48dp。）： 基础组件组件的引用需要从&#39;react-native&#39;库进行引用,比如： 1import &#123; Alert, StyleSheet, View, Text, StatusBar, Image, ImageBackground, TextInput, TouchableOpacity, ToastAndroid, BackHandler, AsyncStorage &#125; from 'react-native'; View 类似div用于布局的最基础组件，是所有组件布局的基本、底层元素。类似于&lt;div&gt;。每一个View都可以当成是一个FlexBox Image 显示图片React Native提供了多种方式加载图片，如加载网络图片、静态资源、本地图片、或读取用户相册中的图片。 Text 显示文本Text放在View中Text中嵌套Text，只有一行显示不下才会换行。应用于动态文本内容： TextInput 文本输入框注意： rn 中的 onChangeText对应的是react 中的 onChange 属性 含义 placehoder 提示文本 placehoderTextColor 提示文本颜色 defaultValue 默认值 editable 是否可以编辑。默认值为true，如果为false则文本框是不可编辑的 secureTextEntry 设置是否为密码组件。如果为true，文本框会遮住之前输入的文字，这样类似密码之类的敏感文字可以更加安全。默认值为false。multiline={true}时不可用 underlineColorAndroid 设置Android下的文本框下划线颜色(如果要去掉文本框的边框，请将此属性设为透明transparent) clearTextOnFocus 组件获得焦点开始编辑时自动清空内容。如果为true，每次开始输入的时候都会清除文本框的内容 onChangeText 属性值是方法。当文本框内容变化时调用此回调函数。改变后的文字内容会作为参数传递。(rn 中的 onChangeText对应的是react 中的 onChange ) onSubmitEditing 属性值是方法。在文本被用户按下软键盘上的提交键后调用此回调函数，所传参数为{nativeEvent: {text, eventCount, target}} 方法 含义 clear() 清空输入框中内容 onChangeText的例子假如我们要实现当用户输入时，实时将其以单词为单位翻译为另一种文字。我们假设这另一种文字来自某个吃货星球，只有一个单词： 🍕。 123456789101112131415161718192021222324import React, &#123; Component &#125; from 'react';import &#123; Text, TextInput, View &#125; from 'react-native';export default class PizzaTranslator extends Component &#123; state = &#123; text: '' &#125; render() &#123; return ( &lt;View style=&#123;&#123;padding: 10&#125;&#125;&gt; &lt;TextInput style=&#123;&#123;height: 40&#125;&#125; placeholder=\"Type here to translate!\" onChangeText=&#123;(text) =&gt; this.setState(&#123;text&#125;)&#125; value=&#123;this.state.text&#125; /&gt; &lt;Text style=&#123;&#123;padding: 10, fontSize: 42&#125;&#125;&gt; &#123;this.state.text.split(' ').map((word) =&gt; word &amp;&amp; '🍕').join(' ')&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 如果你想要在用户输入的时候进行验证，需要学习 React中的受限组件 。 StyleSheet CSS样式StyleSheet 提供了一种类似 CSS 样式表的抽象。 从代码质量角度：从 render 函数中移除具体的样式内容，可以使代码更清晰易懂。给样式命名也可以对 render 函数中的组件增加语义化的描述。 例子：创建一个样式表： 1234567891011121314const styles = StyleSheet.create(&#123; container: &#123; borderRadius: 4, borderWidth: 0.5, borderColor: '#d6d7da', &#125;, title: &#123; fontSize: 19, fontWeight: 'bold', &#125;, activeTitle: &#123; color: 'red', &#125;,&#125;); 使用一个样式表： 123&lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;[styles.title, this.props.isActive &amp;&amp; styles.activeTitle]&#125; /&gt;&lt;/View&gt; 触摸处理类组件（Touchable 系列组件） 移动应用上的用户交互基本靠“摸”。当然，“摸”也是有各种姿势的：在一个按钮上点击，在一个列表上滑动，或是在一个地图上缩放。 React Native 提供了可以处理常见触摸手势（例如点击或滑动）的组件， 以及可用于识别更复杂的手势的完整的手势响应系统。 Button（交互控件） Button 是一个简单的跨平台的按钮组件。 Button组件的样式是固定的，如果想要修改外观就需要使用TouchableOpacity或是TouchableNativeFeedback组件来定制自己所需要的按钮，视频教程讲述了完整的按钮制作过程。【当我们希望简单的拥有自己样式的按钮时可以使用 TouchableOpacity 包裹 Text 组件 来做一个自己的按钮。（利用触摸类事件的onPress属性）】12345678&lt;Button onPress=&#123;() =&gt; &#123; Alert.alert(\"你点击了按钮！\"); &#125;&#125; title=\"点我！\" color=\"#841584\" accessibilityLabel=\"点击我了解更多信息\"/&gt; 属性 含义 onPress 属性值是函数。用户点击此按钮时所调用的处理函数 title 按钮内显示的文本 accessibilityLabel 用于给残障人士显示的文本（比如读屏应用可能会读取这一内容） disabled 设置为 true 时此按钮将不可点击 TouchableHighlight【按下变暗】 TouchableHighlight 组件的背景 会在用户手指按下时变暗。 该组件可以包含View组件、Image、Text等等。但只能包裹一个层级的子元素。如果有很多组件需要包裹其中，那就需要使用 View组件 将其中所有的元素包裹起来，再放置在 TouchableHighlight组件 下。 属性 | 含义underlayColor | 有触摸操作时显示出来的底层的颜色style | 属性值为样式，如style={styles.button}。包装被点击后显示的样式onPress | 属性值为点击时执行的回调函数onLongPress | 属性值为长按时执行的回调函数 TouchableNativeFeedback【Android平台】TouchableNativeFeedback组件只能在Android平台下使用，提供了原生级别的组件渲染体验。它会在用户手指按下时形成类似墨水涟漪的视觉效果。 TouchableOpacity【按下降低透明度】 TouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。 当触摸点击的时候，被TouchableOpacity包裹的View会进行透明化处理，所以包裹的View可以不需要设置背景色。这样的组件样式可以使用在一些单纯的文字点击上，并提供一个简单的反馈效果。 可参考文档 例子： 12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from 'react'import &#123; StyleSheet, TouchableOpacity, Text, View,&#125; from 'react-native'export default class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;TouchableOpacity style=&#123;styles.button&#125; &gt; &lt;Text&gt; Touch Here &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ) &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', paddingHorizontal: 10 &#125;, button: &#123; alignItems: 'center', backgroundColor: '#DDDDDD', padding: 10 &#125;&#125;) CSS样式注意：在RN中，css样式表不要独立出来放在另一个文件中，应采用CSS in JS写法.(可以参考阮一峰的博客) 内联样式 外部样式同一个js文件中：","categories":[{"name":"React Native学习","slug":"React-Native学习","permalink":"http://yoursite.com/categories/React-Native学习/"}],"tags":[{"name":"React Native","slug":"React-Native","permalink":"http://yoursite.com/tags/React-Native/"}]},{"title":"HTTP报头Accept与Content-Type的区别","slug":"HTTP报头Accept与Content-Type的区别","date":"2018-10-19T13:49:38.000Z","updated":"2020-02-23T04:13:32.074Z","comments":true,"path":"2018/10/19/HTTP报头Accept与Content-Type的区别/","link":"","permalink":"http://yoursite.com/2018/10/19/HTTP报头Accept与Content-Type的区别/","excerpt":"对比 请求报文、响应报文 Accept属于请求头， Content-Type属于实体头 Accept属于 请求首部字段，只有HTTP请求有。 Content-Type属于 实体首部字段，HTTP请求和响应 都拥有该字段。","text":"对比 请求报文、响应报文 Accept属于请求头， Content-Type属于实体头 Accept属于 请求首部字段，只有HTTP请求有。 Content-Type属于 实体首部字段，HTTP请求和响应 都拥有该字段。 Accept代表发送端（客户端）希望接受的数据类型比如： 12//代表客户端希望接受的数据类型是json类型Accept：\"application/json\"; “Content-Type”代表发送端（客户端/服务器）发送的实体数据的数据类型比如： 12//代表发送端发送的数据格式是json\"Content-Type\"：\"application/json\"; 二者结合二者合起来,代表希望接受的数据类型是json格式，本次请求发送的数据的数据格式是json: 12Accept:\"application/json\"； \"Content-Type\":\"application/json\"","categories":[{"name":"计算机网络 学习","slug":"计算机网络-学习","permalink":"http://yoursite.com/categories/计算机网络-学习/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]}]}