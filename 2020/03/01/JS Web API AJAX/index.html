<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JS Web API AJAX | 珠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="前端,程序员,软件开发,面试,CSS,JavaScript,JS,ES6,HTML,Node.js,React,Vue" />
  
  
  
  
  <meta name="description" content="ajax原理和常用插件库">
<meta property="og:type" content="article">
<meta property="og:title" content="JS Web API AJAX">
<meta property="og:url" content="https://huanglizhu.github.io/2020/03/01/JS%20Web%20API%20AJAX/index.html">
<meta property="og:site_name" content="珠">
<meta property="og:description" content="ajax原理和常用插件库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_get.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_post.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_jsonp.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_jsonp_result.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_data.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_func_name.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_jquery_jsonp.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_CORS.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_easy.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_result.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_bindEvent_404.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_404_result.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfjy85d78fj30uc0r9kcn.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_fetch.jpg">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_fetch_post.jpg">
<meta property="article:published_time" content="2020-03-01T04:56:45.000Z">
<meta property="article:modified_time" content="2024-08-08T07:32:30.043Z">
<meta property="article:author" content="黄丽珠">
<meta property="article:tag" content="AJAX">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_get.jpg">
  
    <link rel="alternate" href="/atom.xml" title="珠" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/sx.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 6.3.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


        <header id="allheader" class="site-header" role="banner"  >
                <div class="clearfix container">
                    <div class="site-branding">

                        <h1 class="site-title">
                            
                                    <a href="/" title="珠" rel="home">
                                        珠
                                    </a>
                                    
                        </h1>

                        
                            <div class="site-description">
                                Record every bit of front-end learning.
                            </div>
                            

                                <nav id="main-navigation" class="main-navigation" role="navigation">
                                    <a class="nav-open">Menu</a>
                                    <a class="nav-close">Close</a>

                                    <div class="clearfix sf-menu">
                                        <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                                            
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/">
                                                        主页
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/archives">
                                                        归档
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/categories">
                                                        分类
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/tags">
                                                        标签
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/about">
                                                        关于
                                                    </a>
                                                </li>
                                                
                                        </ul>
                                    </div>
                                </nav>

                    </div>
                </div>
        </header>

  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-JS Web API AJAX" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      JS Web API AJAX
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/03/01/JS%20Web%20API%20AJAX/" class="article-date">
	  <time datetime="2020-03-01T04:56:45.000Z" itemprop="datePublished">三月 1, 2020</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/AJAX%E5%AD%A6%E4%B9%A0/">AJAX学习</a>, <a class="article-category-link" href="/categories/JavaScript%E5%AD%A6%E4%B9%A0/">JavaScript学习</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>ajax原理和常用插件库</p>
<span id="more"></span>

<h1 id="XMLHttpRequest（ajax核心API）"><a href="#XMLHttpRequest（ajax核心API）" class="headerlink" title="XMLHttpRequest（ajax核心API）"></a>XMLHttpRequest（ajax核心API）</h1><ul>
<li><strong>XMLHttpRequest()</strong>:用于<strong>创建 XMLHttpRequest 对象</strong>，XMLHttpRequest 对象用于和服务器交换数据</li>
</ul>
<h2 id="onreadystatechange事件"><a href="#onreadystatechange事件" class="headerlink" title="onreadystatechange事件"></a>onreadystatechange事件</h2><ul>
<li><strong>onreadystatechange事件</strong>：和image对象的onload&#x2F;onerror类似，都是<strong>对象状态发生改变时触发</strong>。</li>
</ul>
<h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><ul>
<li><strong>open():初始化一个请求</strong>，规定请求的类型、URL 以及是否异步处理请求。<ul>
<li>参数1：请求的类型，”GET”或者”POST”</li>
<li>参数2：url，文件在服务器上的位置</li>
<li><strong>参数3默认为true</strong>，表示服务器请求是<strong>异步</strong>进行的，也就是脚本<strong>执行send（）方法后不等待服务器的执行结果</strong>，而是继续执行脚本代码；当参数3为false时，服务器请求是同步进行的，也就是脚本执行send（）方法后等待服务器的执行结果的返回，若在等待过程中超时，则不再等待，继续执行后面的脚本代码！</li>
</ul>
</li>
</ul>
<h2 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h2><ul>
<li><strong>send():将请求发送到服务器</strong>。如果请求是异步的（默认），那么该方法将在请求发送后立即返回。<ul>
<li><strong>参数string</strong>：仅用于 POST 请求</li>
</ul>
</li>
</ul>
<h2 id="readyState属性"><a href="#readyState属性" class="headerlink" title="readyState属性"></a>readyState属性</h2><ul>
<li>XMLHttpRequest对象的readyState属性<strong>存有 XMLHttpRequest对象 的状态</strong></li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>（请求未初始化）还没有调用send（）方法</td>
</tr>
<tr>
<td>1</td>
<td>（载入，服务器连接已建立）已调用send（）方法，正在发送请求</td>
</tr>
<tr>
<td>2</td>
<td>（载入完成，请求已接收）send（）方法执行完成，已经接收到全部响应内容</td>
</tr>
<tr>
<td>3</td>
<td>（交互，请求处理中）正在解析响应内容</td>
</tr>
<tr>
<td>4</td>
<td>（完成，请求已完成，且响应已就绪）<strong>响应内容解析完成</strong>，可以在客户端调用</td>
</tr>
</tbody></table>
<h2 id="status属性"><a href="#status属性" class="headerlink" title="status属性"></a>status属性</h2><ul>
<li>XMLHttpRequest对象的status属性，其实就是http响应的状态码</li>
<li><strong>必须在readyState属性值为4时才能去判断status属性</strong>，否则拿不到status属性值</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>2xx</td>
<td>表示成功处理请求，如200</td>
</tr>
<tr>
<td>3xx</td>
<td>需要重定向，浏览器直接跳转，如301 302 304</td>
</tr>
<tr>
<td>4xx</td>
<td>客户端请求错误，如404 403</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器端错误</td>
</tr>
</tbody></table>
<h2 id="responseText-与-responseXML-属性"><a href="#responseText-与-responseXML-属性" class="headerlink" title="responseText 与 responseXML 属性"></a>responseText 与 responseXML 属性</h2><ul>
<li>使用 XMLHttpRequest 对象的 responseText 或 responseXML 属性 可获得来自服务器的响应数据。<ul>
<li>responseText	获得<strong>字符串形式</strong>的<strong>响应数据</strong>(如果请求未成功或尚未发送，则返回 null)</li>
<li>responseXML	获得 <strong>XML 形式</strong>的<strong>响应数据</strong></li>
</ul>
</li>
</ul>
<h1 id="AJAX例子"><a href="#AJAX例子" class="headerlink" title="AJAX例子"></a>AJAX例子</h1><ol>
<li><strong>创建XMLHttpRequest对象</strong>：使用XMLHttpRequest()来new一个XMLHttpRequest对象</li>
<li><strong>判断对象状态</strong>：通过XMLHttpRequest对象的<strong>onreadystatechange事件（readyState还有status属性）</strong>判断对象状态（请求是否初始化、服务器连接是否建立、请求是否接收、请求是否处理中、请求是否已完成且响应已就绪）。</li>
<li><strong>获取响应数据</strong>：判断到“请求已完成且响应已就绪”时可使用XMLHttpRequest 对象的 <strong>responseText 或 responseXML 属性</strong>来<strong>获得响应数据</strong>。</li>
<li><strong>向服务器发送请求</strong>：使用XMLHttpRequest 对象的 <strong>open() 和 send()</strong> 方法向服务器发送请求。<br><a href="https://huanglizhu.github.io/2019/10/02/AJAX%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0/#%E6%AD%A5%E9%AA%A4">可参考这篇博客</a></li>
</ol>
<h2 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h2><ul>
<li>一般将open()和send()都放到onreadystatechange事件之后来写。<br><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_get.jpg" alt="get请求例子" title="get请求例子"></li>
</ul>
<h2 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h2><p><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_post.jpg" alt="post请求例子" title="post请求例子"></p>
<hr>
<h1 id="浏览器的同源策略"><a href="#浏览器的同源策略" class="headerlink" title="浏览器的同源策略"></a>浏览器的同源策略</h1><ul>
<li><strong>同源策略</strong>：<strong>发送ajax请求</strong>时，<strong>浏览器</strong>要求当前网页和server必须同源（为了安全）<ul>
<li><strong>注意：</strong>同源是<strong>浏览器</strong>规定的，<strong>在服务端是可以发起跨域攻击的</strong>，比如爬虫，因为<strong>server端并无同源策略</strong></li>
<li><strong>同源</strong>：协议、域名、端口，三者必须一致<ul>
<li>比如：前端<code>http://a.com：8080/</code>；server：<code>https://b.com/api/xxx</code>（默认443端口）<strong>那么这前后端是三者都不一致</strong></li>
</ul>
</li>
</ul>
</li>
<li>同源策略<strong>限制</strong>了跨域时的以下行为：<ul>
<li>Cookie、LocalStorage 和 IndexDB 跨域无法读取，只有同源才能获取他们</li>
<li>DOM 和 JS 对象跨域无法获取</li>
<li>Ajax请求跨域时无效，可发送，但浏览器会拒绝接受响应</li>
</ul>
</li>
<li>为什么要有同源与不同源？<a target="_blank" rel="noopener" href="https://blog.csdn.net/zheshihuahua/article/details/125793405">这个作者写的非常好</a>：<ul>
<li>出于安全考虑，浏览器不允许页面向不同源的接口请求数据，因为如果 接口 和 网页不同源，浏览器认为是2个不同的 服务器</li>
<li>总结说人话： <strong>不同的服务器中内容是不可控的，不允许访问是浏览器为了保护你的电脑安全</strong></li>
<li>举个栗子： 你去肯德基店里点餐，店员只允许你点肯德基的产品（炸鸡，可乐，上校鸡块），如果此时你在肯德基店里面点麦当劳的产品，浏览器会认为你是坏人，就会让保安把你赶出去</li>
</ul>
</li>
</ul>
<h2 id="加载图片-CSS-js可无视同源策略"><a href="#加载图片-CSS-js可无视同源策略" class="headerlink" title="加载图片 CSS js可无视同源策略"></a>加载图片 CSS js可无视同源策略</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">跨域的图片地址/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">跨域的css地址/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">跨域的js地址</span>&gt;</span> <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>比如我们经常引用的js&#x2F;CSS的库，<code>&lt;link/&gt; </code>、<code>&lt;script&gt;</code>直接使用cdn地址就是<strong>跨域</strong>的。</li>
<li><code>&lt;script&gt;</code>可实现<strong>JSONP</strong></li>
<li>而图片比较特殊，如果该图片做了<strong>防盗链</strong>，则无法显示（比如百度）</li>
<li><strong><code>&lt;img/&gt;</code>可用于使用第三方统计服务来统计打点（比如统计访问次数）</strong>，也就是把需要的参数放入img，在地址处使用第三方统计服务，这样就<strong>可以避免跨域问题</strong></li>
</ul>
<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><ul>
<li>跨域，是指<strong>浏览器不能执行其他网站的脚本</strong>，即，<strong>跨域名，跨端口，跨协议</strong>。它是由<strong>浏览器的同源策略</strong>造成的，是<strong>浏览器对JavaScript实施的安全限制</strong>。</li>
<li>可通过<strong>jsonp、CORS、nginx反向代理</strong>实现跨域</li>
<li>关于<strong>为什么会有跨域问题</strong>可参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/98d4bc7565b2">这里</a>和上面提到的“为什么要有同源与不同源”，跨域问题 是<strong>浏览器对于ajax请求的一种安全限制</strong>：一个页面发起的<strong>ajax请求</strong>，只能是于当前页同域名的路径，这能<strong>有效的阻止跨站攻击</strong><ul>
<li><strong>注意：</strong>浏览器<strong>只有使用 ajax发送请求 才会出现跨域，href属性与src属性不会出现跨域</strong>，所以如果你通过改变<code>window.location.href</code>跳转新页面并不会造成跨域问题</li>
</ul>
</li>
</ul>
<h2 id="实现跨域的前提"><a href="#实现跨域的前提" class="headerlink" title="实现跨域的前提"></a>实现跨域的前提</h2><ul>
<li>所有的跨域，都<strong>必须经过server端允许和配合（包括前端jsonp）</strong></li>
<li>未经server端允许就实现跨域，说明浏览器有漏洞，危险信号</li>
<li><strong>需要服务端如何配合：</strong><ul>
<li><strong>jsonp：</strong> <ul>
<li>服务器端需要根据客户端（浏览器）传递的回调函数名，将数据包装在回调函数中返回给客户端（浏览器）</li>
<li>设置响应头的 Content-Type 为 application&#x2F;javascript</li>
</ul>
</li>
<li><strong>CORS：</strong> <ul>
<li>服务端需要设置响应头：服务端需要在响应中返回特定的响应头来允许跨域请求</li>
<li>处理<a href="https://huanglizhu.github.io/2020/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%883%EF%BC%89/#ajax-x2F-fetch-x2F-axios%E5%8F%91%E9%80%812%E6%AC%A1%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0">预检请求</a>：服务端需要响应这个预检请求并设置相应的响应头<ul>
<li>注意：jsonp发送的是get请求，自然不会触发预检请求（这就是CORS造成的多发请求）</li>
</ul>
</li>
<li>处理实际请求：服务端需要处理实际的跨域请求，并根据情况设置适当的响应头</li>
</ul>
</li>
<li><strong>nginx反向代理：</strong> （proxy反向代理类似）<ul>
<li>服务器端需要配置 Nginx 反向代理规则，将客户端请求转发到目标服务器的相应位置</li>
<li>需要处理跨域请求头，允许指定的域名访问资源</li>
<li>可选：配置 SSL 证书，以及根据需求进行其他代理参数的配置</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="实现跨域的常见方式"><a href="#实现跨域的常见方式" class="headerlink" title="实现跨域的常见方式"></a>实现跨域的常见方式</h2><p><strong>注意：如果是协议和端口造成的跨域问题，前端代码无法直接解决协议和端口造成的跨域问题。需要在服务器端进行相应的配置或使用其他后端技术来解决跨域请求的限制</strong></p>
<h3 id="如何选择处理方式"><a href="#如何选择处理方式" class="headerlink" title="如何选择处理方式"></a>如何选择处理方式</h3><ul>
<li><strong>jsonp：</strong> 曾经的跨域杀手，专治各种跨域问题。现在慢慢的淡出历史舞台<ul>
<li>毕竟操作复杂且没CORS安全</li>
</ul>
</li>
<li><strong>CORS：</strong> 目前的主流方案，也是最简单的方案<ul>
<li>不用前端操作，全部后端处理</li>
</ul>
</li>
<li><strong>nginx &#x2F; proxy 反向代理：</strong> 一般不使用代理来解决跨域问题<ul>
<li>使用反向代理需要额外的服务器配置和维护，因此在决定使用反向代理时需要权衡复杂性和可维护性。在许多情况下，CORS是更简单和直接的解决方案，但反向代理可以处理一些更复杂的情况和需求</li>
<li>适用场景：<ul>
<li>访问受限的外部API：当您的前端应用需要访问受限的外部API时，而该API不支持CORS或需要特定的安全控制，您可以设置反向代理来处理请求。代理服务器将前端请求发送到API，然后将响应返回给前端，充当前端和API之间的中介。</li>
<li>多个前端应用与单个后端服务：如果您有多个独立的前端应用，它们需要与单个后端服务进行通信，但这些前端应用部署在不同的域上，可以使用反向代理来统一处理这些前端应用的请求，以确保它们可以访问后端服务。</li>
<li>安全和认证控制：反向代理可以用于添加额外的安全和认证控制。它可以在请求到达后端之前执行身份验证、授权和其他安全控制，以确保请求是合法的并且具备适当的权限。</li>
<li>负载均衡：反向代理还可以用于负载均衡。多个后端服务器可以部署在后代理服务器的后面，并且代理服务器可以根据负载均衡算法将请求分发到这些后端服务器上，以提高性能和可伸缩性。</li>
<li>复杂路由和请求重定向：反向代理可以实现复杂的路由和请求重定向逻辑，将前端请求重定向到不同的后端服务或资源。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="JSONP与CORS区别"><a href="#JSONP与CORS区别" class="headerlink" title="JSONP与CORS区别"></a>JSONP与CORS区别</h4><ul>
<li>CORS:<ul>
<li>服务器返回响应头，前端无需任何处理</li>
<li>简单快捷，支持所有请求方式</li>
</ul>
</li>
<li>JSONP:<ul>
<li>浏览器：自定义响应回调函数，使用script标签的src请求</li>
<li>利用浏览器的src属性没有跨域这一限制特点</li>
<li>服务器：接收callback参数(函数名)，返回函数调用</li>
<li>处理步骤复杂，并且只支持get请求</li>
<li>原因：get请求参数直接在url后面拼接，而post请求参数是放在请求体中</li>
</ul>
</li>
</ul>
<hr>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><ul>
<li>访问<code>https://imooc.com/</code>，服务端一定返回一个html文件吗？<br>并不是，<strong>服务器可以任意动态拼接数据返回，只要符合html格式要求</strong><br>同理，<code>&lt;script src=&quot;https://imooc.com/getData.js&quot;&gt;</code>也不一定返回一个js文件，<strong>服务器可以任意动态拼接数据返回，只要符合js格式要求即可</strong>【详细见例子】</li>
<li><strong>注意：</strong> jsonp <strong>只能发起GET请求</strong>且<strong>需要服务的支持</strong><ul>
<li>因为JSONP通过添加<code>&lt;script&gt;</code>标签来获取数据，而<code>&lt;script&gt;</code>标签通常只支持GET请求。浏览器会根据<code>&lt;script&gt;</code>标签的src属性来发送GET请求，并下载相应的资源</li>
</ul>
</li>
<li>要了解jsonp原理，首先一定要明白<strong>script标签的src属性做了什么事情</strong><ul>
<li>scr属性会给服务器发送请求, 请求一个js文件</li>
<li>浏览器会解析执行这个js文件里面的代码</li>
<li>如果浏览器直接返回js代码,浏览器会立即执行</li>
</ul>
</li>
<li><strong>jsonp的核心原理：</strong><ul>
<li>如果script标签的src属性的请求，服务器返回的是一个函数调用，则浏览器会执行这个函数</li>
<li>这是浏览器script标签的一个的漏洞（历史遗留问题）</li>
</ul>
</li>
<li><strong>jsonp原理</strong>：<ul>
<li><strong><code>&lt;script&gt;</code><strong>可</strong>绕过跨域限制</strong>，所以script中src地址可以是跨域地址<strong>服务器</strong>可以<strong>任意动态拼接数据返回</strong>。所以**<code>&lt;script&gt;</code>就可以获得跨域的数据，只要服务端愿意返回**</li>
</ul>
</li>
<li>实际开发中jsonp的<strong>工作流程：</strong><ul>
<li>设置script标签的src属性，向一个不同源的接口发送一个get请求</li>
<li>src属性发送请求时，在参数中额外携带一个callback的参数，参数值是一个在页面中预先定于好的函数名<ul>
<li>callback: 这是发明jsonp技术的人提出的一个君子之约，只要是jsonp前端程序员都统一将参数名定义为callback  （PS：别的参数也行，只要和服务器协商好 ）</li>
<li>callback属性值: 预先定义的函数名，这个函数必须要在script标签之前定义</li>
</ul>
</li>
<li>服务器接收到请求之后，获取callback的参数值</li>
<li>服务器将要响应的数据拼接成 函数调用格式，通过传参的方式将响应数据返回给浏览器</li>
</ul>
</li>
<li><strong>例子（原理）</strong>：<ul>
<li>在这用一<strong>简单例子讲解jsonp原理，真实使用可用jquery</strong>：</li>
<li><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_jsonp.jpg" alt="简单例子" title="简单例子"></li>
<li>先定义一个<strong>全局函数callback</strong>用于打印跨域返回的内容，此函数已定义，可随时调用</li>
<li>然后<strong>在引入的script中设置src为跨域地址</strong>，该地址将<strong>返回一个执行callback函数</strong></li>
<li>那么<strong>返回的代码会立即执行callback函数，并将相应内容打印</strong></li>
<li><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_jsonp_result.jpg" alt="结果" title="结果"></li>
</ul>
</li>
<li><strong>【扩展例子】：</strong><ul>
<li><strong>跨域动态传递数据</strong>：<img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_data.jpg" alt="跨域动态传递数据" title="跨域动态传递数据"></li>
<li><strong>函数名可两域不同</strong>：我们可将callback定义为abc后传给跨域文件<img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_func_name.jpg" alt="函数名可两域不同" title="函数名可两域不同"></li>
<li><strong>动态插入script标签</strong>：现在是静态插入的，也可以和其他标签一样动态插入</li>
</ul>
</li>
</ul>
<h4 id="jquery实现jsonp"><a href="#jquery实现jsonp" class="headerlink" title="jquery实现jsonp"></a>jquery实现jsonp</h4><p>和发ajax非常类似<br><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_jquery_jsonp.jpg" alt="jquery实现jsonp" title="jquery实现jsonp"></p>
<hr>
<h3 id="CORS（纯服务端）"><a href="#CORS（纯服务端）" class="headerlink" title="CORS（纯服务端）"></a>CORS（纯服务端）</h3><ul>
<li><strong>总结：</strong>前端不需要额外设置，后端需要在响应头中设置 CORS 相关字段</li>
<li><blockquote>
<p><strong>工作原理:</strong> 服务器 在返回响应报文的时候，在响应头中 设置允许的header，使得服务器对浏览器说: “老铁我是个好人，不要拒绝我！”————(<a target="_blank" rel="noopener" href="https://blog.csdn.net/zheshihuahua/article/details/125793405">原帖</a>)</p>
</blockquote>
</li>
<li>可参考<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">阮一峰的跨域资源共享 CORS 详解</a></li>
<li>CORS是一个<strong>W3C标准</strong>，全称是”<strong>跨域资源共享</strong>“（Cross-origin resource sharing）。它<strong>规范化的跨域请求解决方案，安全可靠。</strong></li>
<li>它<strong>允许浏览器向跨源服务器发出XMLHttpRequest请求</strong>，从而克服了AJAX只能同源使用的限制。</li>
<li>CORS <strong>需要浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。<ul>
<li><strong>浏览器端</strong>：目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是<strong>浏览器自动完成，不需要用户参与</strong>。</li>
<li><strong>服务端</strong>：CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，<strong>浏览器会在请求中携带一些头信息，我们需要以此判断是否运行其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。</strong></li>
</ul>
</li>
<li><strong>优势</strong>：在<strong>服务端</strong>进行控制是否允许跨域，可自定义规则，支持各种请求方式</li>
<li><strong>缺点</strong>：会产生额外的请求<ul>
<li>对于某些跨域请求，浏览器会首先发送一个<strong>预检请求</strong>，以确定是否允许实际请求。这个预检请求会产生额外的网络开销</li>
</ul>
</li>
<li><strong>实现方法：</strong> cors是<strong>纯服务端</strong>的操作，通过服务端设置http header可实现允许跨域：<img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_CORS.jpg" alt="cors" title="cors"></li>
<li><strong>如果使用cors允许跨域，则跨域请求和发送ajax请求时完全一样的，不需要再考虑跨域问题</strong></li>
<li>CORS是一种<strong>新标准</strong>，支持<strong>同源通信</strong>，也支持<strong>跨域通信</strong>。<strong>fetch</strong>是实现CORS通信的</li>
<li><strong>虽然原理比较复杂，但是使用可以比较简单。</strong>浏览器端都有浏览器自动完成，我们无需操心。服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。所以<strong>可直接使用SpringMVC写好的CORS的跨域过滤器：CorsFilter</strong> ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</li>
</ul>
<hr>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul>
<li><strong>思路：</strong>把跨域变为不跨域</li>
<li><strong>常用场景：</strong>前后端分离的项目，前端请求后端服务时属于跨域，会出现无法访问接口的情况，当a域名访问a域名下某个接口时通过反向代理转发到b域名下某个对应接口</li>
<li><strong>优点：</strong><ul>
<li>集中处理跨域问题：反向代理可以统一处理前端应用程序发出的跨域请求。这意味着前端应用程序不必担心跨域问题，代理服务器负责处理请求并将响应返回给前端。</li>
<li>隐藏后端API的细节：反向代理可以隐藏后端API的实际细节，例如后端服务器的域名和端口。这有助于增加项目的安全性，并简化前端应用程序的配置。</li>
<li>路由和负载均衡：反向代理可以实现路由和负载均衡，将前端请求路由到不同的后端服务器上，以提高性能和可伸缩性。</li>
<li>安全性控制：反向代理可以实施额外的安全性控制，例如认证、授权和请求筛选，以确保请求是合法的并具备适当的权限。<ul>
<li>前端的主要任务是将必要的安全信息和标识（如认证令牌、用户权限、会话标识等）添加到请求中，并将这些请求发送到反向代理服务器。前端不需要实施安全性控制的具体逻辑，而是依赖于反向代理服务器来执行这些安全性控制</li>
</ul>
</li>
<li>缓存和优化：代理服务器可以缓存响应，以减少对后端服务器的重复请求，从而提高性能。</li>
</ul>
</li>
<li><strong>缺点：</strong><ul>
<li>虽然反向代理在前后端分离项目中有许多优点，但它也需要额外的服务器配置和维护。因此，在选择是否使用反向代理时，团队需要综合考虑项目的需求和复杂性</li>
</ul>
</li>
</ul>
<hr>
<h4 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h4><ul>
<li>可参考博客<a href="https://huanglizhu.github.io/2020/02/28/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88%E5%89%8D%E7%AB%AF%E8%81%94%E8%B0%83%EF%BC%89/#nginx%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%81%94%E8%B0%83%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">“博客项目登录（前端联调）”</a>中的“nginx的反向代理配置”</li>
<li><strong>思路</strong>：利用nginx反向代理<strong>把跨域变为不跨域</strong></li>
<li><strong>优点：</strong>支持各种请求方式</li>
<li><strong>缺点</strong>：需要<strong>在nginx进行额外配置</strong>，语义不清晰</li>
<li><strong>例子：</strong>前后端分离的项目，当有前端部署在自己的服务器上，后端也部署在自己的服务器上的情况就会造成<strong>前端无法访问后端接口的情况</strong>，这时就需要Nginx做一个代理的配置。<strong>当a域名访问b域名下某一个接口的时候，先让a域名访问a域名下的某一个url在通过Nginx转发到b域名下的某个接口</strong>，这样就让浏览器感觉好像都是在请求同一个服务器下的资源。</li>
</ul>
<hr>
<h4 id="proxy反向代理"><a href="#proxy反向代理" class="headerlink" title="proxy反向代理"></a>proxy反向代理</h4><ul>
<li>可参考博客<a href="https://huanglizhu.github.io/2022/12/19/axios%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/#baseURL%E5%8F%8A%E4%B8%8D%E5%90%8C%E7%8E%AF%E5%A2%83%E5%88%86%E5%8F%91%E4%BB%A3%E7%90%86">《axios使用和简单封装》</a></li>
<li><strong>例子：</strong><br>  开发环境中，假设<strong>前端服务是<code>http://localhost:8089/</code>，后端接口是存在<code>http://test01.7debao.com/</code>服务上的</strong><br>  那么前端打开页面时打开的就是<code>http://localhost:8089/</code>，前端页面中使用ajax请求获取数据时就会去获取<code>http://localhost:8089/</code>下的对应路径的数据<br>  而后端接口是存在<code>http://test01.7debao.com/</code>服务上的，所以数据其实保存在<code>http://test01.7debao.com/</code>下的对应路径中，<strong>这就导致无法获取数据</strong><br>  <strong>此时使用proxy进行反向代理，结合axios配置给接口加前缀<code>/api</code>，遇到<code>/api</code>开头的url时就通过proxy分配到后端服务请求数据，遇到<code>/</code>开头的url时就分配到前端服务显示页面，这样就没问题了</strong></li>
<li><strong>注意：</strong>生产和测试环境一般前后端代码部署在同一服务器同一域名下，接口请求不存在跨域问题，自然不需要设置分发代理</li>
</ul>
<hr>
<h1 id="ajax相关面试题"><a href="#ajax相关面试题" class="headerlink" title="ajax相关面试题"></a>ajax相关面试题</h1><h2 id="手写简易ajax"><a href="#手写简易ajax" class="headerlink" title="手写简易ajax"></a>手写简易ajax</h2><p><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_easy.jpg" alt="手写简易ajax" title="手写简易ajax"><br><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_result.jpg" alt="运行结果" title="运行结果"></p>
<p>模拟404情况，换成不存在的地址：<br><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_bindEvent_404.jpg" alt="模拟404情况" title="模拟404情况"><br><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_404_result.jpg" alt="运行结果" title="运行结果"></p>
<h2 id="跨域的实现方式"><a href="#跨域的实现方式" class="headerlink" title="跨域的实现方式"></a>跨域的实现方式</h2><ol>
<li><strong>jsonp原理</strong></li>
<li><strong>cors（纯服务端）</strong><ul>
<li>可参考<a href="https://huanglizhu.github.io/2020/02/28/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88%E5%89%8D%E7%AB%AF%E8%81%94%E8%B0%83%EF%BC%89/#nginx%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%81%94%E8%B0%83%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8">博客项目登录（前端联调）</a></li>
</ul>
</li>
<li><strong>nginx反向代理</strong></li>
</ol>
<hr>
<h1 id="实际项目中-ajax-的常用插件"><a href="#实际项目中-ajax-的常用插件" class="headerlink" title="实际项目中 ajax 的常用插件"></a>实际项目中 ajax 的常用插件</h1><ul>
<li><strong>jquery</strong>：老旧，未使用Promise，容易回调地狱<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfjy85d78fj30uc0r9kcn.jpg" alt="jquery"></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch"><strong>fetch</strong></a>：比XMLHttpRequest更加简洁，但兼容性不好<ul>
<li><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_fetch.jpg" alt="简单的fetch请求" title="简单的fetch请求"></li>
<li><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/JS_Web_API_AJAX_fetch_post.jpg" alt="使用fetch发送POST请求" title="使用fetch发送POST请求"></li>
<li><strong>注意：</strong>从 fetch() 返回的 Promise <strong>不会被标记为 reject</strong>， 即使响应的 HTTP 状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ），<strong>仅当网络故障时或请求被阻止时，才会标记为 reject。</strong></li>
<li>不用了解太细，知道大概和去哪查就行</li>
</ul>
</li>
<li>axios可参考<a href="https://huanglizhu.github.io/2022/12/19/axios%E4%BD%BF%E7%94%A8%E5%92%8C%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/">《axios使用和简单封装》</a></li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/AJAX%E5%AD%A6%E4%B9%A0/">AJAX学习</a>, <a class="article-category-link" href="/categories/JavaScript%E5%AD%A6%E4%B9%A0/">JavaScript学习</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AJAX/" rel="tag">AJAX</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/03/02/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E6%97%A5%E5%BF%97/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          博客项目日志
        
      </div>
    </a>
  
  
    <a href="/2020/02/29/JS%20Web%20API%20%E4%BA%8B%E4%BB%B6/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">JS Web API 事件</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#XMLHttpRequest%EF%BC%88ajax%E6%A0%B8%E5%BF%83API%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">XMLHttpRequest（ajax核心API）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#onreadystatechange%E4%BA%8B%E4%BB%B6"><span class="nav-number">1.1.</span> <span class="nav-text">onreadystatechange事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#open"><span class="nav-number">1.2.</span> <span class="nav-text">open()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#send"><span class="nav-number">1.3.</span> <span class="nav-text">send()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#readyState%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">readyState属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#status%E5%B1%9E%E6%80%A7"><span class="nav-number">1.5.</span> <span class="nav-text">status属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#responseText-%E4%B8%8E-responseXML-%E5%B1%9E%E6%80%A7"><span class="nav-number">1.6.</span> <span class="nav-text">responseText 与 responseXML 属性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AJAX%E4%BE%8B%E5%AD%90"><span class="nav-number">2.</span> <span class="nav-text">AJAX例子</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#get%E8%AF%B7%E6%B1%82"><span class="nav-number">2.1.</span> <span class="nav-text">get请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#post%E8%AF%B7%E6%B1%82"><span class="nav-number">2.2.</span> <span class="nav-text">post请求</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">浏览器的同源策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E5%9B%BE%E7%89%87-CSS-js%E5%8F%AF%E6%97%A0%E8%A7%86%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5"><span class="nav-number">3.1.</span> <span class="nav-text">加载图片 CSS js可无视同源策略</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F"><span class="nav-number">4.</span> <span class="nav-text">跨域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%89%8D%E6%8F%90"><span class="nav-number">4.1.</span> <span class="nav-text">实现跨域的前提</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">实现跨域的常见方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.1.</span> <span class="nav-text">如何选择处理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JSONP%E4%B8%8ECORS%E5%8C%BA%E5%88%AB"><span class="nav-number">4.2.1.1.</span> <span class="nav-text">JSONP与CORS区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsonp"><span class="nav-number">4.2.2.</span> <span class="nav-text">jsonp</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#jquery%E5%AE%9E%E7%8E%B0jsonp"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">jquery实现jsonp</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CORS%EF%BC%88%E7%BA%AF%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%89"><span class="nav-number">4.2.3.</span> <span class="nav-text">CORS（纯服务端）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">4.2.4.</span> <span class="nav-text">反向代理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">nginx反向代理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#proxy%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">proxy反向代理</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ajax%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">ajax相关面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%8B%E5%86%99%E7%AE%80%E6%98%93ajax"><span class="nav-number">5.1.</span> <span class="nav-text">手写简易ajax</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">跨域的实现方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE%E4%B8%AD-ajax-%E7%9A%84%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6"><span class="nav-number">6.</span> <span class="nav-text">实际项目中 ajax 的常用插件</span></a></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
    

                <div class="clearfix container">
                    <div class="site-info">
                        &copy;
                        2025
                            珠 All Rights Reserved.
                                
                                    <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量
                                    <span id="busuanzi_value_site_pv"></span>次
                                    </span>
                                    
                    </div>
                    <div class="site-credit">
                        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
                    </div>
                </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
