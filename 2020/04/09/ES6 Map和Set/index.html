<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES6 Map和Set | 珠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="前端,程序员,软件开发,面试,CSS,JavaScript,JS,ES6,HTML,Node.js,React,Vue" />
  
  
  
  
  <meta name="description" content="ES6规范引入了新的数据类型Map和Set">
<meta property="og:type" content="article">
<meta property="og:title" content="ES6 Map和Set">
<meta property="og:url" content="https://huanglizhu.github.io/2020/04/09/ES6%20Map%E5%92%8CSet/index.html">
<meta property="og:site_name" content="珠">
<meta property="og:description" content="ES6规范引入了新的数据类型Map和Set">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-09T04:21:51.000Z">
<meta property="article:modified_time" content="2024-08-08T07:32:29.925Z">
<meta property="article:author" content="黄丽珠">
<meta property="article:tag" content="ES6">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="珠" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/sx.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 6.3.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


        <header id="allheader" class="site-header" role="banner"  >
                <div class="clearfix container">
                    <div class="site-branding">

                        <h1 class="site-title">
                            
                                    <a href="/" title="珠" rel="home">
                                        珠
                                    </a>
                                    
                        </h1>

                        
                            <div class="site-description">
                                Record every bit of front-end learning.
                            </div>
                            

                                <nav id="main-navigation" class="main-navigation" role="navigation">
                                    <a class="nav-open">Menu</a>
                                    <a class="nav-close">Close</a>

                                    <div class="clearfix sf-menu">
                                        <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                                            
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/">
                                                        主页
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/archives">
                                                        归档
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/categories">
                                                        分类
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/tags">
                                                        标签
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/about">
                                                        关于
                                                    </a>
                                                </li>
                                                
                                        </ul>
                                    </div>
                                </nav>

                    </div>
                </div>
        </header>

  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-ES6 Map和Set" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      ES6 Map和Set
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/04/09/ES6%20Map%E5%92%8CSet/" class="article-date">
	  <time datetime="2020-04-09T04:21:51.000Z" itemprop="datePublished">四月 9, 2020</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6%E5%AD%A6%E4%B9%A0/">ES6学习</a>, <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>ES6规范引入了<strong>新的数据类型Map和Set</strong></p>
<span id="more"></span>

<h1 id="Map-和-Objects-的区别"><a href="#Map-和-Objects-的区别" class="headerlink" title="Map 和 Objects 的区别"></a>Map 和 Objects 的区别</h1><ul>
<li>一个 Object 的<strong>键只能是字符串或者 Symbols</strong>，但一个 Map 的<strong>键可以是任意值</strong>。</li>
<li>Map 中的<strong>键值是有序的（FIFO 原则）</strong>，而添加到对象中的键则不是。</li>
<li>Map 的<strong>键值对个数可以从 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size">size 属性</a>获取</strong>，而 Object 的键值对个数只能手动计算。</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
<li><strong>Map 是 iterable 的，所以可以直接被迭代</strong>，而迭代一个Object需要以某种方式获取它的键然后才能迭代。</li>
<li><strong>在频繁增删键值对的场景下，Map表现更好。</strong></li>
</ul>
<hr>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul>
<li><strong>查阅方法推荐<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map MDN</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">Set MDN</a></strong></li>
<li><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024181109440">廖雪峰的博客</a></li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/es6-map-set.html">菜鸟教程</a></li>
</ul>
<h2 id="关于可迭代对象"><a href="#关于可迭代对象" class="headerlink" title="关于可迭代对象"></a>关于可迭代对象</h2><ul>
<li>可参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1">可迭代对象 MDN</a>，非常详细</li>
<li>Javascript中<strong>最常见的迭代器是Array</strong>，<strong>String、Array、TypedArray、Map 和 Set 都是内置可迭代对象</strong>，因为它们的原型对象都拥有一个 <code>Symbol.iterator</code> 方法</li>
<li>Iterator 对象的**next()**：<ul>
<li>返回<strong>具有两个属性的对象</strong>： <strong>value</strong>，这是序列中的 next 值；和 <strong>done</strong> ，如果已经迭代到序列中的最后一个值，则它为 <strong>true</strong>（<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/entries">例子</a>）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Map-键值对二维数组"><a href="#Map-键值对二维数组" class="headerlink" title="Map 键值对二维数组"></a>Map 键值对二维数组</h1><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map">Map MDN</a>很全面，可以直接看！</li>
<li>Map是一组<strong>键值对的结构</strong>，具有极快的查找速度。 <ul>
<li><strong>任何值(对象或者原始值) 都可以作为一个键或一个值</strong>。</li>
</ul>
</li>
<li><strong>使用场景：在频繁增删键值对的场景下，Map表现比普通obj更好</strong></li>
<li><strong>【创建方法】</strong>用Map实现，只需要一个<strong>“名字”-“成绩”的对照表</strong>，可直接根据名字查找成绩：<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> m1 = <span class="keyword">new</span> Map() ; <span class="comment">// 创建方法1</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Map([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]); <span class="comment">// 创建方法2</span></span><br><span class="line">m.<span class="keyword">get</span>(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 查询 95</span></span><br><span class="line">m.<span class="keyword">set</span>(<span class="string">&#x27;Lily&#x27;</span>, <span class="number">100</span>); <span class="comment">// 添加</span></span><br><span class="line">m.delete(<span class="string">&#x27;Bob&#x27;</span>);	<span class="comment">// 删除</span></span><br></pre></td></tr></table></figure></li>
<li>初始化Map需要一个<strong>二维数组</strong>，或者直接初始化一个<strong>空Map</strong></li>
<li>该二维数组中<strong>一个key只能对应一个value</strong>，所以，多次对一个key放入value，<strong>后面的值会把前面的值冲掉</strong></li>
</ul>
<hr>
<h2 id="键的比较"><a href="#键的比较" class="headerlink" title="键的比较"></a>键的比较</h2><ul>
<li><strong>NaN 是与 NaN 相等的</strong>（虽然 <code>NaN !== NaN</code>），<strong>剩下所有其它的值是根据 <code>===</code> 运算符的结果判断</strong>是否相等</li>
<li>在目前的ECMAScript规范中，** <code>-0</code>和<code>+0</code>被认为是相等的**</li>
</ul>
<h2 id="Map对象的方法"><a href="#Map对象的方法" class="headerlink" title="Map对象的方法"></a>Map对象的方法</h2><ul>
<li><p>mapObj.entries()</p>
<ul>
<li>entries 方法返回一个新的 Iterator 对象，它按<strong>插入顺序</strong>包含了 Map 对象中每个元素的 [key, value] 数组</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/entries">MDN</a></li>
</ul>
</li>
<li><p>mapObj.keys()</p>
<ul>
<li>keys 方法返回一个新的 Iterator 对象， 它<strong>按插入顺序包含了 Map 对象中每个元素的键</strong></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/keys">MDN</a></li>
</ul>
</li>
<li><p>mapObj.values()</p>
<ul>
<li>values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/values">MDN</a></li>
</ul>
</li>
<li><p>mapObj.clear()</p>
<ul>
<li>移除Map对象中的所有元素</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/clear">MDN</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h2><h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">myMap.<span class="title function_">set</span>(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [key, value] <span class="keyword">of</span> myMap.<span class="title function_">entries</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> myMap.<span class="title function_">keys</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> myMap.<span class="title function_">values</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */</span></span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach">MDN 详细讲解</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">myMap.<span class="title function_">set</span>(<span class="number">0</span>, <span class="string">&quot;zero&quot;</span>);</span><br><span class="line">myMap.<span class="title function_">set</span>(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span></span><br><span class="line">myMap.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">value, key</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key + <span class="string">&quot; = &quot;</span> + value);</span><br><span class="line">&#125;, myMap)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Map对象的操作"><a href="#Map对象的操作" class="headerlink" title="Map对象的操作"></a>Map对象的操作</h2><h3 id="Map-与-Array的转换"><a href="#Map-与-Array的转换" class="headerlink" title="Map 与 Array的转换"></a>Map 与 Array的转换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> kvArray = [[<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>], [<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>]];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span></span><br><span class="line"><span class="keyword">let</span> myMap = <span class="keyword">new</span> <span class="title class_">Map</span>(kvArray);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(myMap)); <span class="comment">// 输出和kvArray相同的数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 更简洁的方法来做如上同样的事情，使用展开运算符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...myMap]);</span><br></pre></td></tr></table></figure>

<h3 id="Map-的克隆"><a href="#Map-的克隆" class="headerlink" title="Map 的克隆"></a>Map 的克隆</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> original = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clone = <span class="keyword">new</span> <span class="title class_">Map</span>(original); <span class="comment">// false. 浅比较 不为同一个对象的引用</span></span><br></pre></td></tr></table></figure>

<h3 id="Map-的合并"><a href="#Map-的合并" class="headerlink" title="Map 的合并"></a>Map 的合并</h3><ul>
<li><strong>Map对象间可以进行合并</strong>，但是会<strong>保持键的唯一性</strong><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">first</span> = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let <span class="built_in">second</span> = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span></span><br><span class="line"><span class="comment">// 展开运算符本质上是将Map对象转换成数组。</span></span><br><span class="line">let merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...<span class="built_in">first</span>, ...<span class="built_in">second</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(merged.get(<span class="number">1</span>)); <span class="comment">// uno</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(merged.get(<span class="number">2</span>)); <span class="comment">// dos</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(merged.get(<span class="number">3</span>)); <span class="comment">// three</span></span><br></pre></td></tr></table></figure></li>
<li><strong>Map对象也能与数组合并:</strong><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">first</span> = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;one&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;two&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;three&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let <span class="built_in">second</span> = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;uno&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;dos&#x27;</span>]</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。</span></span><br><span class="line">let merged = <span class="keyword">new</span> <span class="built_in">Map</span>([...<span class="built_in">first</span>, ...<span class="built_in">second</span>, [<span class="number">1</span>, <span class="string">&#x27;eins&#x27;</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(merged.get(<span class="number">1</span>)); <span class="comment">// eins</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(merged.get(<span class="number">2</span>)); <span class="comment">// dos</span></span><br><span class="line"><span class="built_in">console</span>.<span class="built_in">log</span>(merged.get(<span class="number">3</span>)); <span class="comment">// three</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="Set-唯一值数据集合"><a href="#Set-唯一值数据集合" class="headerlink" title="Set 唯一值数据集合"></a>Set 唯一值数据集合</h1><ul>
<li>可参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set">MDN</a></li>
<li>Set和Map类似，也是一组key的集合，但不存储value。由于key不能重复，所以，<strong>在Set中，没有重复的key</strong></li>
<li><strong>注意：</strong> <ul>
<li>加入 Set 的值不会发生类型转化，所以1和”1”是两个不同的值</li>
<li>在Set内部是通过 <code>===</code> 来判断，即，两个对象永远不可能相同，因为地址不同<ul>
<li>除了NaN，虽然<code>NaN !== NaN</code> 但是Set可以针对NaN去重</li>
</ul>
</li>
</ul>
</li>
<li>Set 的三个<strong>基本操作</strong>：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 【创建方法】直接创建一个空Set/提供一个Array作为输入</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 创建方法1 空Set </span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 创建方法2 含1, 2, 3</span></span><br><span class="line"></span><br><span class="line">s.<span class="title function_">add</span>(<span class="string">&#x27;a&#x27;</span>);	<span class="comment">// 添加</span></span><br><span class="line">s.<span class="title function_">has</span>(<span class="string">&#x27;a&#x27;</span>);	<span class="comment">// 查询</span></span><br><span class="line">s.<span class="title function_">delete</span>(<span class="string">&#x27;a&#x27;</span>);	<span class="comment">// 删除</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Set对象的属性-方法"><a href="#Set对象的属性-方法" class="headerlink" title="Set对象的属性 方法"></a>Set对象的属性 方法</h2><ul>
<li>可参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/add">MDN</a>，非常直观</li>
<li>基本上除了key相关以及增加的方法，其他都和Map的非常相似<ul>
<li>声明：<code>const set = new Set()</code></li>
<li>size属性：返回 Set 对象中值的个数</li>
<li>add(): 在Set对象尾部添加一个元素。返回该Set对象</li>
<li>delete(): 移除Set的中与这个值相等的元素，有则返回true,无则返回false</li>
<li>clear(): 清楚Set的所有元素</li>
<li>has(): 是否存在这个值，如果存在为 true，否则为false</li>
<li>keys()：以属性值遍历器的对象</li>
<li>values()：以属性值遍历器的对象</li>
<li>entries()：以属性值和属性值遍历器的对象</li>
<li>forEach()：<strong>遍历</strong>每个元素</li>
</ul>
</li>
</ul>
<h2 id="遍历Set"><a href="#遍历Set" class="headerlink" title="遍历Set"></a>遍历Set</h2><ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set/forEach">forEach()</a></li>
<li>虽然Set只能用forEach()遍历，但可以通过转为数组进行更多操作，比如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...set].<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span>))) <span class="comment">// Set(3) &#123;2, 4, 6&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>当要进行<strong>高频的添加、删除、查询操作</strong>时，比起顺序存储的 Array ，使用哈希表的 Set 更加适合，因为它充分利用了哈希函数的特性，具有较低的平均时间复杂度<ul>
<li>前提是不需要保持顺序，需要保持元素顺序时数组更合适</li>
</ul>
</li>
<li>Set更快的原因：<ul>
<li><strong>避免重复元素：</strong>  Set 数据结构保证了其中<strong>不会有重复的元素</strong>，这在高频的添加操作场景下是非常有用的，可以快速判断一个元素是否已经存在于 Set 中，避免了重复添加</li>
<li><strong>无需保持顺序：</strong> 在高频的添加、删除操作场景下，哈希表的 Set 数据结构<strong>不需要保持元素的顺序</strong>，这使得插入和删除操作更加高效。而<strong>数组需要保持元素的顺序</strong>，所以在插入和删除操作时可能需要移动其他元素</li>
<li><strong>快速的插入和删除操作：</strong> 哈希表的插入和删除操作通常具有较快的平均时间复杂度，通常为 O(1)。这是因为哈希表使用哈希函数将元素映射到索引，所以在插入和删除时，通过计算哈希值可以快速定位到元素的位置。而<strong>数组在插入和删除操作时可能需要移动其他元素，导致平均复杂度更高</strong></li>
<li><strong>高效的查询操作：</strong> 哈希表的查询操作也具有较快的平均时间复杂度，通常为 O(1)。通过哈希函数，可以迅速定位到元素的索引，从而实现高效的查询。而<strong>在数组中，进行查询操作可能需要线性扫描，导致平均复杂度更高</strong></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Set-数组去重"><a href="#Set-数组去重" class="headerlink" title="Set 数组去重"></a>Set 数组去重</h2><ul>
<li><strong>注意：</strong> Set内部是通过<code>===</code>判断的，对引用类型判断依据的是引用地址<ul>
<li>注意NaN，虽然<code>NaN !== NaN</code> 但是Set可以针对NaN去重</li>
</ul>
</li>
<li><strong>重复元素在Set中自动被过滤</strong> (注意 数字3 和 字符串<code>3</code> 是不同的元素)：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="title class_">Set</span>(arr);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际工作中还是需要转为数组而不是Set，所以可以如下操作：</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]) <span class="comment">// [1, 2, 3, &#x27;3&#x27;]</span></span><br><span class="line"><span class="comment">//或 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(arr))) <span class="comment">// [1, 2, 3, &#x27;3&#x27;]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="数组相关的面试题"><a href="#数组相关的面试题" class="headerlink" title="数组相关的面试题"></a>数组相关的面试题</h3><p><strong>问题</strong>：给定一个有序数组，数组里有重复元素，要求<strong>原地操作</strong>数组，删除重复元素。<br><strong>答案：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">// 原地操作数组，删除重复元素</span></span><br><span class="line">  <span class="keyword">let</span> len = <span class="number">0</span>; <span class="comment">// len为不重复数的index，结果数组长度len+1</span></span><br><span class="line">  <span class="comment">// 遍历原数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = len; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 原数组中第一次找到的数组项放入数组前方，len长度+1</span></span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="title function_">indexOf</span>(arr[i]) === i) &#123;</span><br><span class="line">      arr[len] = arr[i];</span><br><span class="line">      len++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 相同的i+1继续查</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 去重后，删除数组后方多余数据项</span></span><br><span class="line">  arr.<span class="title function_">splice</span>(len);</span><br><span class="line">  <span class="comment">// 原地修改，不需要返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 针对 原地修改，不返回数组 的打印</span></span><br><span class="line"><span class="title function_">unique</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);<span class="comment">// [1, 2, 3, 4, 5, 11, 22, 33]</span></span><br></pre></td></tr></table></figure>

<ol>
<li>设置<strong>len为不重复数组项的index</strong>（也就是将不重复数替换到 <code>原数组[len]</code> 位置上，这样就不用新开一个数组了）</li>
<li>在<strong>原数组上循环</strong>，<strong>i为循环的index</strong></li>
<li><strong>原数组中找<code>arr[i]</code>比对是否是该数组项的第一个位置</strong>，是则<strong>将<code>arr[i]</code>赋给<code>arr[len]</code>(也就是将不同的这个数放到原数组靠前的位置上)，再<code>len++</code>（使得下一次替换的原数组index+1）</strong>，不是就不管，i++进行下一次循环</li>
<li>全部去重后，<strong>使用splice(len)将len后面的多余数据删掉</strong><ul>
<li><strong>注意</strong>，最后一次符合if条件时len+1的位置还没用，所以删除时len最末尾也还属于 重复数组 ，一并删去</li>
</ul>
</li>
</ol>
<hr>
<h2 id="求并集，交集和差集"><a href="#求并集，交集和差集" class="headerlink" title="求并集，交集和差集"></a>求并集，交集和差集</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//并集</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a, ...b])) <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交集</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> b.<span class="title function_">has</span>(v)))) <span class="comment">// Set(2) &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//差集</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Set</span>([...a].<span class="title function_">filter</span>(<span class="function"><span class="params">v</span> =&gt;</span> !b.<span class="title function_">has</span>(v))) <span class="comment">//  Set(1) &#123;1&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="WeakMap和WeakSet"><a href="#WeakMap和WeakSet" class="headerlink" title="WeakMap和WeakSet"></a>WeakMap和WeakSet</h1><ul>
<li><strong>重要理解：</strong> <ul>
<li><strong>WeakMap成员键、WeakSet成员值只能为对象</strong></li>
<li>它们都<strong>是”弱引用”集合,WeakMap中键没有其他强引用时（例如将变量赋值为 <code>null</code> 或者离开了作用域，或者整个对象被替换&#x3D;&gt;引用地址发生变化，对应键值对会被自动删除</strong></li>
</ul>
</li>
<li>定义： 同Set、Map的结构，<strong>WeakMap成员键、WeakSet成员值只能为对象</strong></li>
<li>声明： <code>const set = new WeakSet()</code>、<code>const set = new WeakMap()</code></li>
<li>WeakMap方法：<ul>
<li>set(): 添加键值对，返回实例</li>
<li>get(): 返回键值对</li>
<li>delete(): 删除键值对，如果存在为 true，否则为false</li>
<li>has(): 是否存在这个值，如果存在为 true，否则为false</li>
</ul>
</li>
<li>WeakSet方法：<ul>
<li>add(): 在WeakSet对象尾部添加一个元素。返回该实例</li>
<li>delete(): 移除WeakSet的中与这个值相等的元素</li>
<li>has(): 判断是否存在这个值，如果存在为 true，否则为false</li>
</ul>
</li>
</ul>
<h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>WeakMap和WeakSet是ES6（ECMAScript 2015）中引入的两种新的数据结构，它们在某些场景下具有独特的优势。它们都<strong>是”弱引用”集合,WeakMap中键没有其他强引用时（例如将变量赋值为 <code>null</code> 或者离开了作用域，或者整个对象被替换&#x3D;&gt;引用地址发生变化），对应键值对会被删除</strong>，意味着它们中存储的对象不会阻止垃圾回收器回收这些对象，从而在一些特定情况下非常有用</li>
<li><strong>WeakMap:</strong><ol>
<li><strong>弱引用键关联的数据：</strong> WeakMap允许您将<strong>弱引用的键</strong>与相应的值关联起来。这意味着，<strong>如果一个对象作为WeakMap的键，而这个对象没有其他强引用，垃圾回收器可以自由地回收这个对象，同时WeakMap中的对应键值对也会被移除</strong></li>
<li><strong>防止内存泄漏：</strong> 当您需要在不再需要时确保对象被垃圾回收，但又不想手动删除键值对时，WeakMap非常有用。这可以防止由于保留对不再需要的对象的引用而导致的内存泄漏问题。</li>
<li><strong>隐私性和安全性：</strong> 如果您希望存储的数据不能被外部访问或篡改，WeakMap可以用于存储私有数据，因为WeakMap的键是弱引用，外部无法直接获取键来访问值。</li>
</ol>
</li>
<li><strong>WeakSet:</strong><ol>
<li><strong>弱引用的值集合：</strong> WeakSet允许您存储一组值，这些值都是<strong>弱引用</strong>的。与WeakMap类似，如果一个对象作为WeakSet中的值，但没有其他强引用，那么这个对象可以被垃圾回收，同时WeakSet中的该值也会被移除。</li>
<li><strong>不能避免重复值：</strong> 在一个 WeakSet 中可以多次存储同一个对象的弱引用。WeakSet 并不能自动去重</li>
</ol>
</li>
<li><strong>使用场景：</strong><ol>
<li><strong>缓存：</strong> WeakMap可以用于实现一种缓存机制，其中对象被用作键，而值是计算得到的结果。一旦这些<strong>对象（键）不再被其他部分强引用&#x2F;强引用发生变化（例如将变量赋值为 <code>null</code> 或者离开了作用域，或者整个对象被替换&#x3D;&gt;引用地址发生变化）</strong>，垃圾回收器可以自由地<strong>回收这些对象（键），缓存中的对应键值对也会被自动从WeakMap中移除</strong>，从而节省内存（例子见下）<ul>
<li><strong>普通数组是强引用</strong>，可以用于缓存，但需要更多的手动管理，包括在不需要时手动从数组中移除缓存对象等</li>
</ul>
</li>
<li><strong>DOM元素关联数据：</strong> 在处理DOM元素时，可以使用WeakMap来存储元素与相关数据之间的关联，当元素被从DOM中移除时，垃圾回收器会自动清理这些数据。</li>
<li><strong>事件处理程序：</strong> 在为DOM元素添加事件处理程序时，可以使用WeakMap来存储事件处理函数，以避免内存泄漏。</li>
<li><strong>防止内存泄漏：</strong> 当您需要在不再需要对象时确保对象被垃圾回收，而又不想手动清除相关数据时，WeakMap和WeakSet都是有用的选择。</li>
</ol>
</li>
<li><strong>注意:</strong> 由于WeakMap和WeakSet的特性，它们并不适合所有场景。如果需要强引用并且确保对象不会被垃圾回收，那么应该使用Map和Set</li>
</ul>
<hr>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>当使用 WeakMap 来实现缓存机制时，通常是将某些昂贵的计算结果关联到特定的对象上，并且只要这些对象还有其他的强引用，那么计算结果就会被保留在缓存中。<br>其中对象被用作键，而值是计算得到的结果。<br>一旦这些对象（键）不再被其他部分强引用&#x2F;强引用发生变化（例如将变量赋值为 <code>null</code> 或者离开了作用域，或者整个对象被替换&#x3D;&gt;引用地址发生变化），垃圾回收器可以自由地回收这些对象（键），从而自动清理缓存。</p>
<p>以下是一个使用 WeakMap 实现缓存机制的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">calculateExpensiveResult</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.<span class="title function_">has</span>(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.<span class="title function_">get</span>(obj);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟一个耗时的计算过程</span></span><br><span class="line">  <span class="keyword">const</span> result = obj.<span class="property">value</span> * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  cache.<span class="title function_">set</span>(obj, result);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keyObject = &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;; <span class="comment">// 在全局作用域中定义对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result1 = <span class="title function_">calculateExpensiveResult</span>(keyObject);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result1); <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改了value，但对象的引用地址没有改变，所以在Map中算相同的对象作为键</span></span><br><span class="line"><span class="comment">// 这个计算结果会从缓存中获取，而不是重新计算</span></span><br><span class="line">keyObject.<span class="property">value</span> = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> result2 = <span class="title function_">calculateExpensiveResult</span>(keyObject);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2); <span class="comment">// 输出: 20，读的缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变对象引用地址，之前的 keyObject 失去引用</span></span><br><span class="line">keyObject = &#123; <span class="attr">value</span>: <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 垃圾回收器可以清理之前的 keyObject，cache 中的项也会被自动清理</span></span><br><span class="line"><span class="keyword">const</span> result3 = <span class="title function_">calculateExpensiveResult</span>(keyObject);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result3); <span class="comment">// 输出: 60，重新计算，因为 keyObject 已失去引用</span></span><br></pre></td></tr></table></figure>

<p><strong>补充了解：普通数组是强引用</strong>，可以用于缓存，但需要更多的手动管理，包括在不需要时手动从数组中移除对象等</p>
<hr>
<h3 id="DOM元素关联数据-防止内存泄漏"><a href="#DOM元素关联数据-防止内存泄漏" class="headerlink" title="DOM元素关联数据 防止内存泄漏"></a>DOM元素关联数据 防止内存泄漏</h3><p>没有缓存的好理解啊，找了个例子，但没懂绑定handlers是为啥，以后有空回来再看看。</p>
<p><code>WeakMap</code> 判断元素不再被引用是基于 JavaScript 垃圾回收机制中的弱引用概念。当一个对象不再有强引用指向它时，它会成为垃圾回收的候选对象，可以被垃圾回收器回收。</p>
<p>当使用 <code>WeakMap</code> 关联元素与数据时，在 <code>WeakMap</code> 中<strong>使用某个元素作为键，如果您不再有强引用指向这些元素（例如将变量赋值为 <code>null</code> 或者离开了作用域），那么这些元素将成为弱引用，<code>WeakMap</code> 将自动移除该键值对，从而触发与该元素关联的数据的清理，一旦垃圾回收器执行，与这些元素关联的数据也会被清理</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventHandlers = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将给定的事件处理程序与特定的 DOM 元素关联起来，并确保事件处理程序能够在点击元素时被触发。同时，这个关联是通过 WeakMap 来建立的，因此在元素不再被引用时，事件处理程序数组会被自动清理，从而防止内存泄漏。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addClickHandler</span>(<span class="params">element, handler</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查 `eventHandlers` 中是否已经存在与给定元素关联的数组。如果不存在，就创建一个新的数组，并将元素作为键，数组作为值，使用 `eventHandlers.set(element, [])` 将它们关联起来。这是使用 WeakMap 来建立元素和事件处理程序数组的关联</span></span><br><span class="line">  <span class="keyword">if</span> (!eventHandlers.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">    eventHandlers.<span class="title function_">set</span>(element, []);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handlers = eventHandlers.<span class="title function_">get</span>(element); <span class="comment">// 使用 `eventHandlers.get(element)` 来获取与元素关联的事件处理程序数组</span></span><br><span class="line">  handlers.<span class="title function_">push</span>(handler); <span class="comment">// 将新的事件处理程序 `handler` 添加到获取到的事件处理程序数组中</span></span><br><span class="line"></span><br><span class="line">  element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler); <span class="comment">// 使用 `element.addEventListener(&#x27;click&#x27;, handler)` 将事件处理程序绑定到 DOM 元素的 `click` 事件上，以便在点击元素时触发这个处理程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeClickHandler</span>(<span class="params">element, handler</span>) &#123;</span><br><span class="line">  <span class="comment">// 检查是否存在与元素关联的事件处理程序数组</span></span><br><span class="line">  <span class="keyword">if</span> (eventHandlers.<span class="title function_">has</span>(element)) &#123;</span><br><span class="line">    <span class="comment">// 获取元素关联的事件处理程序数组</span></span><br><span class="line">    <span class="keyword">const</span> handlers = eventHandlers.<span class="title function_">get</span>(element);</span><br><span class="line">    <span class="comment">// 在数组中查找要移除的事件处理程序</span></span><br><span class="line">    <span class="keyword">const</span> index = handlers.<span class="title function_">indexOf</span>(handler);</span><br><span class="line">    <span class="comment">// 如果找到了要移除的事件处理程序</span></span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 从数组中移除该事件处理程序</span></span><br><span class="line">      handlers.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 从 DOM 元素的 &#x27;click&#x27; 事件中移除该处理程序</span></span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 不需要手动delete，WeakMap 会在元素不再被引用时自动触发数据清理</span></span><br><span class="line"><span class="comment">      if (handlers.length === 0) &#123;</span></span><br><span class="line"><span class="comment">        // 从 WeakMap 中删除与元素关联的数据。这样在元素不再被引用时，WeakMap 会自动将键值对从中移除，同时我们也手动保证了数据的清理</span></span><br><span class="line"><span class="comment">        eventHandlers.delete(element);</span></span><br><span class="line"><span class="comment">      &#125; */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getElementById 返回对拥有指定 ID 的第一个元素对象的引用</span></span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clickHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addClickHandler</span>(button, clickHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在点击按钮后，会输出 &#x27;Button clicked&#x27;</span></span><br><span class="line">button.<span class="title function_">click</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件处理程序，此时关联的数据会被自动清理</span></span><br><span class="line"><span class="title function_">removeClickHandler</span>(button, clickHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击按钮后不再触发事件处理程序</span></span><br><span class="line">button.<span class="title function_">click</span>();</span><br></pre></td></tr></table></figure>

<p>要注意的是，垃圾回收的执行时机由 JavaScript 引擎控制，不是立即发生的。这意味着在一个元素不再被引用之后，数据不会立即被清理。垃圾回收会在适当的时间点执行，清理不再有引用的对象和数据。</p>
<hr>
<h4 id="如果使用普通对象"><a href="#如果使用普通对象" class="headerlink" title="如果使用普通对象"></a>如果使用普通对象</h4><p>如果不使用 WeakMap 而是使用<strong>普通的对象</strong>来关联 DOM 元素与其相关数据，可能会导致内存泄漏。这是因为<strong>普通的对象是强引用</strong>，当对象作为键时，即使元素被从 DOM 中移除，该对象仍然会保持对元素的引用，从而阻止垃圾回收器回收元素。</p>
<p>以下是一个示例，展示如果不使用 WeakMap 而是使用普通对象来存储关联的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventHandlers = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addClickHandler</span>(<span class="params">element, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!eventHandlers[element]) &#123;</span><br><span class="line">    eventHandlers[element] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handlers = eventHandlers[element];</span><br><span class="line">  handlers.<span class="title function_">push</span>(handler);</span><br><span class="line"></span><br><span class="line">  element.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">removeClickHandler</span>(<span class="params">element, handler</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (eventHandlers[element]) &#123;</span><br><span class="line">    <span class="keyword">const</span> handlers = eventHandlers[element];</span><br><span class="line">    <span class="keyword">const</span> index = handlers.<span class="title function_">indexOf</span>(handler);</span><br><span class="line">    <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">      handlers.<span class="title function_">splice</span>(index, <span class="number">1</span>);</span><br><span class="line">      element.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handler);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 使用普通对象来手动关联数据，当不再需要这些数据时，可通过 delete 来手动清理关联的数据，以防止内存泄漏</span></span><br><span class="line"><span class="comment">      // 检查是否还有剩余的事件处理程序在数组中</span></span><br><span class="line"><span class="comment">      if (handlers.length === 0) &#123;</span></span><br><span class="line"><span class="comment">        delete eventHandlers[element]; // 手动删除关联的数据</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> button = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;myButton&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clickHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Button clicked&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">addClickHandler</span>(button, clickHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在点击按钮后，会输出 &#x27;Button clicked&#x27;</span></span><br><span class="line">button.<span class="title function_">click</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除事件处理程序，但相关数据并没有被清理</span></span><br><span class="line"><span class="title function_">removeClickHandler</span>(button, clickHandler);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击按钮后不再触发事件处理程序</span></span><br><span class="line">button.<span class="title function_">click</span>();</span><br></pre></td></tr></table></figure>

<p>在这个示例中，当我们<strong>通过 <code>removeClickHandler</code> 移除事件处理程序时，对象 <code>eventHandlers</code> 中的引用仍然存在，即使数组为空，仍然会保留对空数组的引用，从而阻止垃圾回收器清理该对象。这可能会导致内存泄漏，因为无法回收与元素相关的数据</strong></p>
<p>具体来说，<code>eventHandlers</code> 对象本身是一个普通的对象，它保持对所有关联事件处理程序数组的引用。如果不手动调用 <code>delete eventHandlers[element]</code>，即使关联的数组为空，<code>eventHandlers</code> 对象仍然会保留对这些数组的引用。这就会阻止这些数组及其关联的元素被垃圾回收器清理。</p>
<p>换句话说，即使事件处理程序数组为空，只要 <code>eventHandlers</code> 对象本身还存在，与之关联的元素以及数组就不会被垃圾回收。这可能导致内存泄漏，因为即使不再需要这些数据，它们仍然会占用内存。</p>
<p>所以，在使用普通对象时，确保在不再需要关联数据时，通过 <code>delete eventHandlers[element]</code> 来手动清理对象中的关联数据，以防止内存泄漏。</p>
<p>总之，使用 WeakMap 来关联 DOM 元素与其相关数据可以有效避免内存泄漏，因为 WeakMap 的键是弱引用，当元素被移除时，相关数据会被自动清理。</p>
<hr>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/ES6%E5%AD%A6%E4%B9%A0/">ES6学习</a>, <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ES6/" rel="tag">ES6</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/10/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%88%E9%A1%B9%E7%9B%AE%EF%BC%89/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          React知识点汇总（项目）
        
      </div>
    </a>
  
  
    <a href="/2020/04/08/CSS%E5%8A%A8%E7%94%BB/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">CSS动画</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Map-%E5%92%8C-Objects-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.</span> <span class="nav-text">Map 和 Objects 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">2.</span> <span class="nav-text">参考文章</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.1.</span> <span class="nav-text">关于可迭代对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Map-%E9%94%AE%E5%80%BC%E5%AF%B9%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">3.</span> <span class="nav-text">Map 键值对二维数组</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%AE%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">3.1.</span> <span class="nav-text">键的比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">Map对象的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86Map"><span class="nav-number">3.3.</span> <span class="nav-text">遍历Map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#for%E2%80%A6of"><span class="nav-number">3.3.1.</span> <span class="nav-text">for…of</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach"><span class="nav-number">3.3.2.</span> <span class="nav-text">forEach()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">3.4.</span> <span class="nav-text">Map对象的操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E4%B8%8E-Array%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">3.4.1.</span> <span class="nav-text">Map 与 Array的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E7%9A%84%E5%85%8B%E9%9A%86"><span class="nav-number">3.4.2.</span> <span class="nav-text">Map 的克隆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-%E7%9A%84%E5%90%88%E5%B9%B6"><span class="nav-number">3.4.3.</span> <span class="nav-text">Map 的合并</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Set-%E5%94%AF%E4%B8%80%E5%80%BC%E6%95%B0%E6%8D%AE%E9%9B%86%E5%90%88"><span class="nav-number">4.</span> <span class="nav-text">Set 唯一值数据集合</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7-%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">Set对象的属性 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%81%8D%E5%8E%86Set"><span class="nav-number">4.2.</span> <span class="nav-text">遍历Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.3.</span> <span class="nav-text">使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="nav-number">4.4.</span> <span class="nav-text">Set 数组去重</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-number">4.4.1.</span> <span class="nav-text">数组相关的面试题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%82%E5%B9%B6%E9%9B%86%EF%BC%8C%E4%BA%A4%E9%9B%86%E5%92%8C%E5%B7%AE%E9%9B%86"><span class="nav-number">4.5.</span> <span class="nav-text">求并集，交集和差集</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WeakMap%E5%92%8CWeakSet"><span class="nav-number">5.</span> <span class="nav-text">WeakMap和WeakSet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">5.1.</span> <span class="nav-text">使用场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">5.1.1.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DOM%E5%85%83%E7%B4%A0%E5%85%B3%E8%81%94%E6%95%B0%E6%8D%AE-%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="nav-number">5.1.2.</span> <span class="nav-text">DOM元素关联数据 防止内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.1.2.1.</span> <span class="nav-text">如果使用普通对象</span></a></li></ol></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
    

                <div class="clearfix container">
                    <div class="site-info">
                        &copy;
                        2025
                            珠 All Rights Reserved.
                                
                                    <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量
                                    <span id="busuanzi_value_site_pv"></span>次
                                    </span>
                                    
                    </div>
                    <div class="site-credit">
                        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
                    </div>
                </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
