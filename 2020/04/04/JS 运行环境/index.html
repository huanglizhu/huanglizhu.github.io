<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JS 运行环境 | 珠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="前端,程序员,软件开发,面试,CSS,JavaScript,JS,ES6,HTML,Node.js,React,Vue" />
  
  
  
  
  <meta name="description" content="运行环境介绍 运行环境即浏览器（server端有nodejs，移动端在app&#x2F;微信上） 下载网页代码，渲染出页面，期间会执行若干JS 要保证代码在浏览器中：稳定且高效 网页加载过程 性能优化 安全">
<meta property="og:type" content="article">
<meta property="og:title" content="JS 运行环境">
<meta property="og:url" content="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/index.html">
<meta property="og:site_name" content="珠">
<meta property="og:description" content="运行环境介绍 运行环境即浏览器（server端有nodejs，移动端在app&#x2F;微信上） 下载网页代码，渲染出页面，期间会执行若干JS 要保证代码在浏览器中：稳定且高效 网页加载过程 性能优化 安全">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpbptqwimj30gf0cujxc.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpg6bcx3mj30rg06dgsa.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpl3ao4twj30rl0hn150.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpldyd6vgj30ui0g07kf.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqqryxq6aj30tl05z10m.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqqxobq9dj30xi0dzam1.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqqy8fuzyj30lw0fwtk9.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqr43b8v6j30tf06gahc.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfrlpsejmhj30g5070jtv.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfrlsfhqmsj30hx06wdii.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfsrtsx9nuj30hx0d179w.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfss23y3lyj30hw0clgqy.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfv55egm0xj30ql05yn01.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfv57hfkgyj30oz067ju3.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb4suzlej30oh05uaeb.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb58vn0lj30fa08bjt9.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwbfb4srkj30u30al0u0.jpg">
<meta property="article:published_time" content="2020-04-04T04:41:32.000Z">
<meta property="article:modified_time" content="2024-08-08T07:32:30.072Z">
<meta property="article:author" content="黄丽珠">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpbptqwimj30gf0cujxc.jpg">
  
    <link rel="alternate" href="/atom.xml" title="珠" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/sx.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 6.3.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


        <header id="allheader" class="site-header" role="banner"  >
                <div class="clearfix container">
                    <div class="site-branding">

                        <h1 class="site-title">
                            
                                    <a href="/" title="珠" rel="home">
                                        珠
                                    </a>
                                    
                        </h1>

                        
                            <div class="site-description">
                                Record every bit of front-end learning.
                            </div>
                            

                                <nav id="main-navigation" class="main-navigation" role="navigation">
                                    <a class="nav-open">Menu</a>
                                    <a class="nav-close">Close</a>

                                    <div class="clearfix sf-menu">
                                        <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                                            
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/">
                                                        主页
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/archives">
                                                        归档
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/categories">
                                                        分类
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/tags">
                                                        标签
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/about">
                                                        关于
                                                    </a>
                                                </li>
                                                
                                        </ul>
                                    </div>
                                </nav>

                    </div>
                </div>
        </header>

  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-JS 运行环境" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      JS 运行环境
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" class="article-date">
	  <time datetime="2020-04-04T04:41:32.000Z" itemprop="datePublished">四月 4, 2020</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JavaScript%E5%AD%A6%E4%B9%A0/">JavaScript学习</a>, <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="运行环境介绍"><a href="#运行环境介绍" class="headerlink" title="运行环境介绍"></a>运行环境介绍</h1><ul>
<li>运行环境即<strong>浏览器</strong>（server端有<strong>nodejs</strong>，移动端在app&#x2F;微信上）</li>
<li>下载网页代码，渲染出页面，期间会执行若干JS</li>
<li>要<strong>保证代码在浏览器中：稳定且高效</strong></li>
<li>网页加载过程</li>
<li>性能优化</li>
<li>安全<span id="more"></span></li>
</ul>
<h1 id="页面加载和渲染过程"><a href="#页面加载和渲染过程" class="headerlink" title="页面加载和渲染过程"></a>页面加载和渲染过程</h1><ul>
<li><strong>资源的形式</strong><ul>
<li>html代码</li>
<li>媒体文件，如图片、视频等</li>
<li>javascript CSS</li>
</ul>
</li>
<li><strong>加载过程</strong>：<ol>
<li><strong>DNS解析</strong>（Domain Name Server）：<strong>域名-&gt;IP地址</strong>（不直接使用IP是因为不同区域IP地址不同，域名更好记）</li>
<li><strong>建立TCP连接</strong>，浏览器根据IP地址向服务器发起<strong>http请求</strong></li>
<li>服务器处理http请求，并<strong>返回html</strong>给浏览器</li>
</ol>
</li>
<li><strong>渲染过程</strong>：<ol>
<li>根据HTML代码生成<strong>DOM Tree</strong>（Document Object Model）</li>
<li>根据CSS代码生成<strong>CSSOM</strong>（CSS Object Model，CSS对象模型）</li>
<li>将DOM Tree和CSSOM<strong>整合形成Render Tree</strong>（渲染树）</li>
<li>根据Render Tree<strong>渲染页面</strong></li>
<li><strong>遇到<code>&lt;script&gt;</code>则暂停渲染</strong>（因为JS有可能修改DOM结构），优先加载并执行JS代码，完成再继续</li>
<li>直至把Render Tree<strong>渲染完成</strong></li>
</ol>
</li>
<li>例子：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpbptqwimj30gf0cujxc.jpg" alt="例子"><strong>渲染到img时如果太大还未加载完成也不会阻塞DOM树的渲染</strong>，直接往下渲染，等图片加载完成再插入</li>
</ul>
<hr>
<h1 id="window-onload和DOMContentLoaded"><a href="#window-onload和DOMContentLoaded" class="headerlink" title="window.onload和DOMContentLoaded"></a>window.onload和DOMContentLoaded</h1><ul>
<li><strong>window.onload</strong>：页面的<strong>全部资源加载完才会执行</strong>，包括图片、视频等</li>
<li><strong>DOMContentLoaded</strong>：<strong>DOM渲染完即可执行</strong>，此时图片、视频还可能没有加载完</li>
<li><strong>注意：使用DOMContentLoaded来触发JS比window.onload更好</strong>，不需要等图片、视频都加载完成才触发JS的加载，这样页面渲染会更快。<br><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpg6bcx3mj30rg06dgsa.jpg" alt="window.onload和DOMContentLoaded"></li>
</ul>
<hr>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><ul>
<li><strong>原则</strong>:<ul>
<li>多使用<strong>内存、缓存</strong>或其他方法</li>
<li><strong>减少CPU计算量</strong>，减少网络加载耗时</li>
<li>（适用于所有编程的性能优化一<strong>空间换时间</strong>）</li>
</ul>
</li>
<li><strong>从何入手</strong>:<ul>
<li>让<strong>加载</strong>更快</li>
<li>让<strong>渲染</strong>更快</li>
<li><strong>减少回流、重绘：</strong><ul>
<li>**<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E5%A4%9A%E4%B8%AADOM%E6%93%8D%E4%BD%9C%E5%90%88%E5%B9%B6">合并DOM操作</a>**：比如我们要向页面添加多个img元素，如果单独加进去就会频繁的回流+重绘，此时我们就可以使用<code>document.createDocumentFragment()</code>将多个img合并到Fragment中再统一加入。</li>
<li><strong>避免频繁读取会引发回流&#x2F;重绘的属性(见上)<strong>，如果确实需要多次使用，就用一个</strong>变量缓存</strong>起来。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上，对具有<strong>复杂动画的元素</strong>使用<strong>绝对定位</strong>，使它<strong>脱离文档流</strong>，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="让加载更快"><a href="#让加载更快" class="headerlink" title="让加载更快"></a>让加载更快</h2><ol>
<li><strong>减少资源体积：压缩代码</strong><ul>
<li>比如使用<strong>webpack在production环境下</strong>进行打包时，就会<strong>自动压缩代码</strong>至1&#x2F;3的大小，在浏览器上进行反解析再进行渲染。</li>
</ul>
</li>
<li><strong>减少访问次数</strong>：<ul>
<li><strong>合并代码</strong>：比如webpack中，在index.js中引入a.js、b.js，打包后只生成一个bundle.js，这就是合并代码。（加载3次3kb的文件不如加载1次9kb快，这<strong>和网络请求有关系</strong>）</li>
<li><strong>SSR服务器端渲染</strong>：不需要通过ajax发送请求。</li>
<li><strong>缓存</strong>：原本需要发送多个请求的数据直接在缓存中获取即可减少访问次数。</li>
</ul>
</li>
<li><strong>使用更快的网络：CDN</strong><ul>
<li>CDN是<strong>分区域</strong>的，也就是使用CDN的时候上海和北京对同一个网站的IP地址是不同的。<strong>CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求</strong>，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了</li>
<li><strong>图片、js等静态资源</strong>采用CDN是很快的，我们经常使用的<strong>bootstrap就是使用的CDN</strong></li>
</ul>
</li>
</ol>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li>静态资源加<strong>hash后缀</strong>，<strong>根据文件内容计算hash</strong></li>
<li>文件内容不变，则hash不变，则<strong>url不变</strong></li>
<li>url和文件不变，则会<strong>自动触发http缓存机制，返回304</strong>（提示用户资源未更新，到缓存中获取）【大部分web服务器都默认开启协商缓存】</li>
<li><strong>例子</strong>：在使用webpack的例子webpack-demo中，<strong>配置webpack的输出文件名时采用的内容哈希值<code>[contenthash]</code>就会根据文件内容来生成哈希值</strong>（每一次生成的文件不会覆盖之前的文件，且只要内容变化名字就会发生改变）<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpl3ao4twj30rl0hn150.jpg" alt="webpack-demo中配置文件"></li>
<li>后续引用webpack生成过哈希命名的文件的方法可参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_34007886/article/details/89009033">“引用带hash的文件”</a></li>
<li>可参考<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%89">强缓存与协商缓存</a></li>
</ul>
<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ul>
<li>CDN，Content Delivery Network，即内容分发网络。是<strong>根据地域做静态服务</strong>的，我们经常使用的<strong>bootstrap就是使用的CDN</strong>，他会<strong>加快加载速度</strong>。（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73345909">CDN缓存</a>）</li>
<li>CDN不变且文件不变时，也会自动触发http缓存机制，返回304。</li>
<li>而百度这里用的bdstatic就不是CDN：<br><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpldyd6vgj30ui0g07kf.jpg" alt="CDN"></li>
</ul>
<h3 id="SSR"><a href="#SSR" class="headerlink" title="SSR"></a>SSR</h3><ul>
<li><strong>SSR（服务器端渲染）</strong>：server side render，将网页和数据一起加载，一起渲染</li>
<li><strong>非SSR</strong>：先加载网页，再加载数据，再渲染数据</li>
<li><strong>早先的JSP ASP PHP 都是SSR，现在的 vue 和 react 默认下不是ssr，但可以在配置下成为ssr</strong></li>
<li>如果右键查看源码看不到input等元素标签，则为非ssr。</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/10b6074d772c">SSR与非SSR</a></li>
</ul>
<hr>
<h2 id="让渲染更快"><a href="#让渲染更快" class="headerlink" title="让渲染更快"></a>让渲染更快</h2><ul>
<li><strong>CSS放在head中，JS放在body最下面</strong></li>
<li><strong>尽早开始执行JS</strong>，用DOMContentLoaded触发</li>
<li><strong>懒加载</strong>（图片懒加载，上滑加载更多）</li>
<li>对<strong>DOM查询进行缓存</strong>（DOM操作很耗性能）</li>
<li><strong>频繁DOM操作，合并</strong>到一起插入DOM结构</li>
<li>让渲染更流畅：<strong>节流throttle防抖debounce</strong></li>
</ul>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><ul>
<li><strong>懒加载：常见图片懒加载</strong>，也就是我们希望先加载第一张图片，后面的图片没显示在屏幕上的就先不加载，等到滑动到图片位置时再进行该图片的加载。</li>
<li><strong>例子</strong>：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqqryxq6aj30tl05z10m.jpg" alt="例子">一开始加载src地址下的图片，等到滑动到下一图片位置时将data-realsrc的属性值赋给src，此时即为加载图片abc（本例子中不进行图片位置的判断，实际根据DOM元素距离顶部的值来计算）</li>
</ul>
<h3 id="缓存DOM的查询"><a href="#缓存DOM的查询" class="headerlink" title="缓存DOM的查询"></a>缓存DOM的查询</h3><p>js的操作和DOM的操作完全不是一个数量级的，尽量避免多次操作DOM：<br><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqqxobq9dj30xi0dzam1.jpg" alt="缓存DOM的查询"></p>
<h3 id="多个DOM操作合并"><a href="#多个DOM操作合并" class="headerlink" title="多个DOM操作合并"></a>多个DOM操作合并</h3><p><a href="https://huanglizhu.github.io/2020/02/14/JS%20Web%20API%20DOM(2)/#%E5%B0%86%E9%A2%91%E7%B9%81%E6%93%8D%E4%BD%9C%E6%94%B9%E4%B8%BA%E4%B8%80%E6%AC%A1%E6%80%A7%E6%93%8D%E4%BD%9C">多个DOM操作一起插入到DOM结构</a>时注意可通过<strong>createDocumentFragment()先创建一个文档片段</strong>，这个文档片段是<strong>保存在JS中的（不是在DOM树中）</strong>：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqqy8fuzyj30lw0fwtk9.jpg" alt="多个DOM操作合并"></p>
<h3 id="尽早开始执行JS"><a href="#尽早开始执行JS" class="headerlink" title="尽早开始执行JS"></a>尽早开始执行JS</h3><p><strong>使用DOMContentLoaded来触发JS比window.onload更好</strong>，不需要等图片、视频都加载完成才触发JS的加载，这样页面渲染会更快。<br><strong>DOMContentLoaded是当DOM树渲染完即可执行</strong>，此时图片、视频还可能没有加载完（注意是DOM渲染完成而不是页面渲染完成）<br><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfqr43b8v6j30tf06gahc.jpg" alt="尽早开始执行JS"></p>
<hr>
<h1 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h1><ul>
<li><strong>防抖和节流的区别</strong>：<strong>防抖</strong>是在<strong>最后一次触发结束后</strong>n秒<strong>都没触发了</strong>才会执行事件函数，在此之前的调用都会被忽略；<strong>节流</strong>则是<strong>以第一次触发为准</strong>，在指定时间内最多执行一次，多余的调用都会被忽略<ul>
<li><strong>防抖</strong>是一段时间内重复触发则清空重算，永远<strong>只管最后一次</strong>触发；<strong>节流</strong>是一段时间内<strong>只管第一次</strong>触发</li>
<li>例子见下“节流”的事例</li>
</ul>
</li>
<li><strong>防抖</strong>：指定时间内连续多次触发事件时以最后一次触发为标准重新计算函数执行时间，直到最后一次触发n秒内没有再次触发才执行</li>
<li><strong>比如：</strong><ul>
<li>监听一个输入框的文字变化后触发change事件，直接用keyup事件，则会频发触发change事件。如果使用<strong>防抖</strong>，则用户<strong>输入结束或暂停时</strong>，才会触发change事件。（防抖不仅限于change事件）</li>
<li>对某个按钮进行高频操作时，防止连续点击</li>
</ul>
</li>
<li><strong>使用场景：</strong><ul>
<li>search搜索联想，用户在不断输入值时，用防抖来节约请求资源</li>
<li>window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次</li>
</ul>
</li>
<li>防抖实际上是对<strong>定时器<a href="https://huanglizhu.github.io/2019/12/08/setTimeout%E4%B8%8EsetInterval/#setTimeout">setTimeout</a><strong>的使用，但我们通常将其</strong>封装为debounce函数</strong>来使用</li>
<li><strong>例子</strong>：<ul>
<li>原本设定是输入框中<strong>每输入一个字符就触发一个打印</strong>，将输入框中的值打印出来  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./debounce.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;input1&#x27;</span>)</span><br><span class="line">input1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(input1.<span class="property">value</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfrlpsejmhj30g5070jtv.jpg" alt="原本的效果"></li>
<li>采用<strong>防抖</strong>后，每次<strong>输入结束的半秒后</strong>才会触发事件进行打印（半秒是自己设置的）：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input1 = <span class="title function_">documentgetElementById</span>(<span class="string">&#x27;input1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  防抖思路：</span></span><br><span class="line"><span class="comment">  创建一个定时器timer，如果再次触发了同样的事件(timer存在)，</span></span><br><span class="line"><span class="comment">  则会清除之前的定时器并设置一个新的定时器给timer，延迟执行函数</span></span><br><span class="line"><span class="comment">  最后定时器回调函数执行完毕后timer设为null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">input1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    初始为空，则不执行清除定时器操作</span></span><br><span class="line"><span class="comment">    后续500ms内timer有值，则清除未执行的定时器后新建定时器</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// setTimeout返回定时器id</span></span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟触发 change 事件</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(input1.<span class="property">value</span>)</span><br><span class="line">    <span class="comment">/* </span></span><br><span class="line"><span class="comment">      清空定时器引用，确保释放定时器，表示上一次的</span></span><br><span class="line"><span class="comment">      延时执行已经完成，可以创建一个新的定时器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;,<span class="number">500</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfrlsfhqmsj30hx06wdii.jpg" alt="防抖后的效果"><strong>逻辑梳理：</strong></li>
</ul>
<ol>
<li>timer用于存储定时器id，<strong>输入a时</strong>，通过<a href="https://huanglizhu.github.io/2019/12/08/setTimeout%E4%B8%8EsetInterval/#setTimeout">setTimeout</a>给timer赋值，准备500毫秒后触发打印</li>
<li><strong>紧接着输入s时</strong>,由于此时timer不为空，所以<strong>执行clearTimerout将之前的定时器清除，重新创建setTimeout</strong>给timer赋值，准备500毫秒后触发打印</li>
<li><strong>依旧紧接着输入d时</strong>，一直到s都重复上一步逻辑</li>
<li><strong>直到输入最后一个f时</strong>，清除了上一个timer后创建了新的timer，且500毫秒后未被清除，故<strong>打印asdfasdfasf</strong>，并将timer清空</li>
</ol>
</li>
</ul>
<h2 id="封装debounce函数"><a href="#封装debounce函数" class="headerlink" title="封装debounce函数"></a>封装debounce函数</h2><p><strong>封装为debounce函数</strong>，避免每次使用都要创建setTimeout：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input1&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./debounce.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">debounce</span>(<span class="params">fn, delay = <span class="number">500</span></span>) &#123;</span><br><span class="line">  <span class="comment">// timer 是闭包中的 这样外界就获取不到timer</span></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">input1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>, <span class="title function_">debounce</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(input1.<span class="property">value</span>)</span><br><span class="line">&#125;), <span class="number">600</span>)</span><br></pre></td></tr></table></figure>
<p><strong>其中<code>fn.apply(this，arguments)</code>直接使用fn()也可以</strong>，使用**<a href="https://huanglizhu.github.io/2019/10/08/call()%E4%B8%8Eapply()/#JavaScript-%E5%87%BD%E6%95%B0-Apply"><code>apply</code></a><strong>是为了防止fn有this或者参数（</strong><a href="https://huanglizhu.github.io/2019/12/07/%E7%B1%BB%E6%95%B0%E7%BB%84/#arguments%E5%AF%B9%E8%B1%A1">arguments对象</a>**）需要传入debounce函数（如果要传入this，则需注意传入的fn，即例子中的箭头函数不能是箭头函数） <strong>【可参考下面“节流”中的apply解释】</strong></p>
<h2 id="Lodash内置的防抖函数"><a href="#Lodash内置的防抖函数" class="headerlink" title="Lodash内置的防抖函数"></a>Lodash内置的防抖函数</h2><ul>
<li>系统中一般自己封装是为了添加适配自己的参数，可以自定义</li>
<li>可以直接<a target="_blank" rel="noopener" href="https://www.lodashjs.com/docs/lodash.debounce/">使用 Lodash 的防抖函数</a>，不用自己上手写，该函数会返回一个新函数，会在最后一次调用时延迟指定时间再执行，而在此之前的调用都会被忽略。<ul>
<li>提供一个 cancel 方法取消延迟的函数调用，以及 flush 方法立即调用</li>
<li>参数1：执行函数func</li>
<li>参数2：需要延迟的毫秒数wait</li>
<li>参数3：配置对象 决定如何调用 func 方法<ul>
<li>leading：指定在延迟开始前调用（默认false）也就是延迟触发前就先调用一次</li>
<li>maxWait：设置 func 允许被延迟的最大值，也就是多次触发在maxWait时间内一定会执行一次，就算maxWait内没有停止连续触发也还是会触发func</li>
<li>trailing：指定在延迟结束后调用（默认true）</li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/7220274775913496613">掘金有使用例子</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Lodash 的防抖函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash-es&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用 Lodash 的防抖函数</span></span><br><span class="line">    <span class="attr">click</span>: <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ... 对点击的响应 ...</span></span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a target="_blank" rel="noopener" href="https://cn.vuejs.org/guide/quick-start.html#creating-a-vue-application">vue文档</a>中有提到，<strong>但要注意：对于被重用的组件，需要特殊处理（改为在 created 生命周期钩子中创建这个预置防抖的函数），避免共享该函数后互相影响</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个预置防抖的函数是 有状态的：它在运行时维护着一个内部状态。</span></span><br><span class="line"><span class="comment">// 如果多个组件实例都共享这同一个预置防抖的函数，那么它们之间将会互相影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lodash 的防抖函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; debounce &#125; <span class="keyword">from</span> <span class="string">&#x27;lodash-es&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用 Lodash 的防抖函数</span></span><br><span class="line">    <span class="attr">click</span>: <span class="title function_">debounce</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ... 对点击的响应 ...</span></span><br><span class="line">    &#125;, <span class="number">500</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多个组件实例都共享这同一个预置防抖的函数的解决方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 每个实例都有了自己的预置防抖的处理函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">debouncedClick</span> = _.<span class="title function_">debounce</span>(<span class="variable language_">this</span>.<span class="property">click</span>, <span class="number">500</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">unmounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 最好是在组件卸载时</span></span><br><span class="line">    <span class="comment">// 清除掉防抖计时器</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">debouncedClick</span>.<span class="title function_">cancel</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="title function_">click</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// ... 对点击的响应 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h1><ul>
<li>下面的代码效果可在<a target="_blank" rel="noopener" href="https://codepen.io/huanglizhu/pen/OJdRweQ">codepen</a>查看</li>
<li><strong>节流：</strong>一段时间内连续触发事件以<strong>第一次触发为准</strong>， n 秒中只执行一次函数</li>
<li>比如：<ul>
<li>拖拽一个元素时，要随时拿到该元素被拖拽的位置。这里直接用drag事件则会频发触发，很容易导致卡顿。而使用<strong>节流</strong>，则<strong>无论拖拽速度多快，都会每隔100ms触发一次（时间自定义）</strong><ul>
<li><strong>注意</strong>：如果用<strong>防抖</strong>的话，就会出现<strong>卡顿</strong>的感觉，因为<strong>只在停止的时候执行了一次</strong>，这个时候就应该用<strong>节流</strong>，在<strong>一定时间内多次执行</strong>，会<strong>流畅</strong>很多（具体原因可见上方“防抖”中“防抖与节流的区别”）</li>
</ul>
</li>
<li>监听滚动事件，比如是否滑到底部自动加载更多，用节流比防抖更合适<ul>
<li>防抖会在事件触发后等待一段时间，然后执行事件处理函数。在滚动加载更多数据的情况下，使用防抖可能会导致用户滚动结束后一段时间才触发加载，这可能会让用户感到加载响应有延迟</li>
</ul>
</li>
</ul>
</li>
<li><strong>例子：</strong><ul>
<li>设置一个可拖拽元素并<strong>直接用drag事件</strong>，拖拽时实时打印元素位置：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- draggable 设置为可拖拽元素 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;div1&quot;</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>可拖拽<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./throttle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>)</span><br><span class="line"><span class="comment">// 拖拽时打印坐标</span></span><br><span class="line">div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drag&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfsrtsx9nuj30hx0d179w.jpg" alt="效果"></li>
<li>采取<strong>节流</strong>后：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;div1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drag&#x27;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>)</span><br><span class="line">    timer = <span class="literal">null</span></span><br><span class="line">  &#125;,<span class="number">100</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfss23y3lyj30hw0clgqy.jpg" alt="效果"><strong>逻辑梳理：</strong><ol>
<li>和节流相似，都设置一个定时器，初始为空</li>
<li>元素开始拖拽时触发事件，根据setTimeout返回的id赋给timer，此时需要等待100毫秒才打印位置</li>
<li>由于快速拖动元素，100毫秒内再次出发drag事件，但此时<strong>timer有值，直接退出drag事件，直到100毫秒位置打印后timer清空才会再走第二步</strong>。以此实现无论拖拽速度多快，都会每隔100ms触发一次drag事件</li>
</ol>
</li>
<li><strong>封装为throttle函数</strong>：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 封装通用的节流函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay = <span class="number">100</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/* </span></span><br><span class="line"><span class="comment">        console.log(&#x27;---this&#x27;, this)</span></span><br><span class="line"><span class="comment">        this指向&lt;div id=&quot;div1&quot; draggable=&quot;true&quot;&gt;可拖拽&lt;/div&gt;</span></span><br><span class="line"><span class="comment">        因为箭头函数没有自己的this，指向throttle函数的this</span></span><br><span class="line"><span class="comment">        而throttle函数被绑定为div1的drag事件函数触发</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  注意：使用 throttle() 时参数1必须不能为箭头函数，否则参数1中 this 指向 window</span></span><br><span class="line"><span class="comment">  因为箭头函数的 this 只和定义时的作用域 this 有关，和调用者/调用环境无关，也永远不会改变</span></span><br><span class="line"><span class="comment">  call, apply, bind 也不能改变箭头函数中的 this 指向</span></span><br><span class="line"><span class="comment">  所以就算用上 apply ，遇到箭头函数结局是 this 依旧指向 window</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drag&#x27;</span>, <span class="title function_">throttle</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    如果不用 apply ，就算参数1用的不是箭头函数，这里 this 还是指向 window</span></span><br><span class="line"><span class="comment">    因为回调函数 this 默认指向 window ，使用 apply 后，这里 this 指向绑定好的div1元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;----this&#x27;</span>, <span class="variable language_">this</span>) </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>)</span><br><span class="line">&#125;, <span class="number">100</span>))</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="使用apply的原因"><a href="#使用apply的原因" class="headerlink" title="使用apply的原因"></a>使用apply的原因</h2><ul>
<li><strong>总结：</strong> 使用 apply 将 throttle() 内部的事件对象e传到 fn() 内部，以便在回调函数fn()中处理更多事情</li>
<li>需要了解的两个要点：<ul>
<li><strong>注意：父级作用域是在 函数定义时 规定的，不需要管执行顺序。</strong>所以这里很特殊的是，fn() 是在使用 throttle() 时才定义的，所以<strong>fn() 内部的函数体的 父级作用域 是 全局作用域 而不是 throttle()</strong></li>
<li>drag事件的e是传给 throttle() 的，如果不特殊处理，fn() 内部并不能获取到e，毕竟父级作用域不是 throttle()</li>
</ul>
</li>
<li><strong><a href="https://huanglizhu.github.io/2019/10/08/call()%E4%B8%8Eapply()/#JavaScript-%E5%87%BD%E6%95%B0-Apply">apply</a>的作用：参数1绑定this指向，参数2绑定调用该函数时传入的参数（即：将参数传入fn）</strong>(<a href="https://huanglizhu.github.io/2019/12/07/%E7%B1%BB%E6%95%B0%E7%BB%84/#arguments%E5%AF%B9%E8%B1%A1">arguments对象</a>)。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按数字顺序理解用apply而不是直接fn()的原因：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle</span>(<span class="params">fn, delay = <span class="number">100</span></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3.throttle函数中可以获取到e，但fn()的函数定义位置在“2”，父级作用域是window</span></span><br><span class="line"><span class="comment">        所以fn()内部函数体是无法获取到e的，需要借助apply将e传到fn()内部</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, <span class="variable language_">arguments</span>)</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注意：arguments 是一个类数组对象，它包含了函数调用时传递的所有参数</span></span><br><span class="line"><span class="comment">        如果使用 fn(arguments)，实际上将传递一个参数，即包含所有参数的</span></span><br><span class="line"><span class="comment">        单个对象，而不是将参数逐个传递给 fn</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4.如果使用fn()而不是apply，则e不会传到fn()内部，e.offsetX会undefined</span></span><br><span class="line">div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drag&#x27;</span>, <span class="title function_">throttle</span>(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    2.而这e是传给throttle函数的，打印语句位于throttle()的参数1回调函数fn中</span></span><br><span class="line"><span class="comment">    注意：父级作用域在函数定义时就规定好了，所以这里e.offsetX如果不特殊处理</span></span><br><span class="line"><span class="comment">    则父级作用域是全局作用域，不是函数throttle，自然找不到e</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">div1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drag&#x27;</span>, <span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.和常规的事件函数对比理解，这里的event会传到匿名函数中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接传event则好理解，如下，但使用起来需要多传一个event，不太好</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">throttle3</span>(<span class="params">fn, delay = <span class="number">100</span>, event</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [event])</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">div3.<span class="title function_">addEventListener</span>(<span class="string">&#x27;drag&#x27;</span>, <span class="title function_">throttle3</span>(<span class="keyword">function</span>(<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">offsetX</span>, e.<span class="property">offsetY</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>), event)</span><br></pre></td></tr></table></figure>

<h2 id="arguments-不包括fn、delay，只有事件对象"><a href="#arguments-不包括fn、delay，只有事件对象" class="headerlink" title="arguments 不包括fn、delay，只有事件对象"></a>arguments 不包括fn、delay，只有事件对象</h2><ul>
<li>注意：为啥arguments并不会包括fn、delay，只有事件对象？</li>
<li>原因：<ul>
<li>arguments 对象在这里指的是返回函数内部的参数，不包括外部 throttle 函数的参数（fn 和 delay）</li>
<li>而箭头函数没有 arguments ，所以指的是父级函数（即 throttle 返回的函数）的 arguments</li>
<li>所以返回函数中 arguments 包含了传递给 throttle 返回的函数的参数，而不包括 fn 和 delay 这两个参数</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Lodash内置的节流函数"><a href="#Lodash内置的节流函数" class="headerlink" title="Lodash内置的节流函数"></a>Lodash内置的节流函数</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.lodashjs.com/docs/lodash.throttle/">lodash文档 节流函数</a>，该函数会返回一个新函数，以第一次触发事件为准，在指定时间内最多执行一次，多余的调用都会被忽略<ul>
<li>提供一个 cancel 方法取消延迟的函数调用，以及 flush 方法立即调用</li>
<li>参数1：执行函数func</li>
<li>参数2：需要节流的毫秒wait</li>
<li>参数3：配置对象 决定如何调用 func 方法<ul>
<li>leading：指定调用在节流开始前（默认true）也就是wait前就先执行一次</li>
<li>trailing：指定调用在节流结束后（默认true）也就是wait后也先执行一次</li>
</ul>
</li>
</ul>
</li>
<li>可参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/7220274775913496613">掘金使用例子</a></li>
</ul>
<h3 id="throttle踩雷"><a href="#throttle踩雷" class="headerlink" title="throttle踩雷"></a>throttle踩雷</h3><ul>
<li>需要使用event的函数都要谨慎使用节流，容易出现问题，节流应该关注函数和时间而不是事件对象</li>
<li>拖拽事件中ondragover不要使用节流，阻止默认行为<code>event.preventDefault()</code>这个动作会不生效，<strong>会导致目标元素不允许放置被拖动的数据</strong><ul>
<li>且在处理拖拽操作时，特别是在dragover事件中，阻止默认处理方式并设置允许放置是非常重要的（<a target="_blank" rel="noopener" href="https://www.runoob.com/html/html5-draganddrop.html">例子</a>），它保证拖放操作的正确性和流畅性。由于dragover事件在拖拽过程中会频繁触发，使用节流可能会导致延迟和不准确的拖放效果。</li>
<li>ondragover事件是在拖动对象在某个元素上悬停时触发的。通常，它绑定在目标元素上，表示允许将拖动对象放置在这个目标元素上。在这个事件中，你可以阻止默认的拖动行为，以控制允许或拒绝拖放操作</li>
<li>使用节流通常<strong>更适合在 drag 事件上</strong>而不是 ondragover 事件上。 drag 事件是指元素在拖动期间触发的事件</li>
</ul>
</li>
</ul>
<hr>
<h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><ul>
<li><strong>CSRF又称XSRF</strong>，前端Cookie如何防范XSS攻击可参考博客<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#XSS%E5%92%8Ccsrf%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E8%8C%83">XSS和XSRF网络攻击及防范</a></li>
</ul>
<h2 id="XSS跨站请求攻击"><a href="#XSS跨站请求攻击" class="headerlink" title="XSS跨站请求攻击"></a>XSS跨站请求攻击</h2><ul>
<li><strong>XSS</strong>：一个博客网站，我发表一篇博客，其中<strong>嵌入<code>&lt;script&gt;</code>脚本，脚本内容用以获取cookie，发送到我的服务器</strong>（只要我将自己的服务器设置好配合<a href="https://huanglizhu.github.io/2020/03/01/JS%20Web%20API%20AJAX/#%E8%B7%A8%E5%9F%9F">跨域</a>，那么点击我的链接我就可以解决cookie跨域的问题）。那么只要我发布这篇博客，有人查看它，我就能轻松收割访问者的cookie。</li>
<li><strong>例子</strong>：攻击者在博客中嵌入<code>&lt;script&gt;</code>脚本来获取访问者的cookie（cookie只要获取到，那么script中还可加入ajax等跨域方式（比如jsonp）将cookie发送出去，此时只要攻击者的服务器设置为支持跨域，那攻击者就能轻松获取数据）：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfv55egm0xj30ql05yn01.jpg" alt="XSS例子">!其他用户访问该博客时，cookie被带出：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfv57hfkgyj30oz067ju3.jpg" alt="用户访问该博客">假设script中还有ajax等跨域方式（比如jsonp）将cookie发送出去，此时只要攻击者的服务器设置为支持跨域，则敏感信息也会被送出。</li>
<li><strong>XSS预防</strong> : <strong>前端在显示时替换，后端在存储时替换</strong>，都做总不会有错(可参考<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#Cookie%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83XSS%E6%94%BB%E5%87%BB">XSS网络攻击及防范</a>)<ol>
<li><strong>替换特殊字符</strong>，如<code>&lt;</code>变为<code>&amp;lt；</code> <code>&gt;</code>变为<code>&amp;gt</code>,<code>&lt;script&gt;</code>变为<code>&amp;lt；script&amp;gt；</code>直接显示，而<strong>不会作为脚本执行</strong>(实际工作中可使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/xss">XSS工具</a>)<ul>
<li>例子：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb4suzlej30oh05uaeb.jpg" alt="前端在显示时替换特殊字符"><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb58vn0lj30fa08bjt9.jpg" alt="显示效果">特殊字符在html中会<strong>被浏览器解析</strong>显示为相应的符号，<strong>故script以字符串形式显示，不会作为脚本执行</strong></li>
</ul>
</li>
<li>在<strong>HTTP头部配上HttpOnly</strong>（后端通过<code>set-cookie:httponly</code>，前端通过<code>document.cookie = &quot;cookieName=cookieValue; HttpOnly&quot;;</code>这样设置）,禁止javascript脚本来访问cookie。严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。（在node中的设置方法可参考<a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#%E7%BB%99cookie%E5%81%9A%E9%99%90%E5%88%B6">博客项目登录（cookie）</a>）</li>
<li><strong>设置cookie的secure属性为<code>secure:true</code></strong>,告诉浏览器<strong>仅在请求为https的时候发送cookie</strong></li>
</ol>
</li>
<li><strong>XSS工具</strong>：替换特殊字符可使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/xss">XSS工具</a><ul>
<li><strong>node使用XSS</strong>的方法可参考博客：<a href="https://huanglizhu.github.io/2020/03/03/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%AE%89%E5%85%A8/#xss%E6%94%BB%E5%87%BB%EF%BC%88xss%E5%BA%93%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%EF%BC%89%EF%BC%89">博客项目安全</a></li>
<li><strong>前端使用XSS</strong>的方法可参考官方例子：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwbfb4srkj30u30al0u0.jpg" alt="参考官方例子"></li>
</ul>
</li>
</ul>
<h2 id="XSRF跨站请求伪造"><a href="#XSRF跨站请求伪造" class="headerlink" title="XSRF跨站请求伪造"></a>XSRF跨站请求伪造</h2><ul>
<li><strong>XSRF（CSRF）例子：</strong><ol>
<li>你正在购物，看中了某个商品，商品id是100，付费接口是<code>xxx.com/pay？id=100</code>，但没有任何验证（此时你已经登录了该网站）。</li>
<li>我是攻击者，我看中了一个商品，id是200（我现在想让你来帮我买单）</li>
<li>此时我向你发送一封电子邮件，邮件标题很吸引人但邮件正文隐藏着<code>&lt;img src=xxx.com/pay？id=200/&gt;</code>你一查看邮件，就帮我购买了id是200的商品。（注意img是支持跨域的，此时你的cookie会被带着）</li>
</ol>
</li>
<li><strong>预防XSRF：</strong>（更多防御方式可参考<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#XSS%E5%92%8Ccsrf%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E8%8C%83">csrf网络攻击及防范</a>）<ol>
<li><strong>使用post接口</strong>，img这些跨域只能接收get请求，设计post请求的需要server端的允许</li>
<li><strong>增加验证</strong>，例如密码、短信验证码、指纹等。验证码会强制用户必须与应用进行交互，才能完成最终请求，但是也不能给网站所有的操作都加上验证码，所以只能作为防御 CSRF 的一种辅助手段，而不能作为最终的解决方案。</li>
<li><strong>使用token验证</strong>：在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，若请求无 token 或者 token 不正确，则认为可能是 CSRF 攻击而拒绝该请求。(<a href="https://huanglizhu.github.io/2020/03/01/JS%20Web%20API%20AJAX/#%E6%8B%A6%E6%88%AA%E5%99%A8%E8%AE%BE%E7%BD%AEtoken">例子</a>)</li>
<li><strong>检查https头部的Referer</strong>：在HTTP头中有一个字段叫做Referer,它记录了该HTTP请求的来源地址。通过Referer Check,可以检查是否来自合法的”源”。<br>例如：从<code>www.user.com</code>发起的删帖请求，那么Referer值是<code>http://www.user.com</code>, 删帖请求应该被允许；而如果是从CSRF攻击者构造的页面<code>www.attack.com</code>发起删帖请求， 那么Referer值是<code>http://www.attack.com</code>, 删帖请求应该被阻止。</li>
</ol>
</li>
</ul>
<hr>
<h1 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h1><p>下面几个题都涉及解构问题，太长时间不看原生js或者借助vscode一键生成模板可能会有点模糊，复习下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM Content Loaded Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里可以包含你的样式表和其他头部资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;styles.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 在DOM已解析并可操作时执行的JavaScript代码</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">const</span> heading = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;h1&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            heading.<span class="property">textContent</span> = <span class="string">&quot;DOM Content Loaded Example&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="为什么建议CSS写在head中"><a href="#为什么建议CSS写在head中" class="headerlink" title="为什么建议CSS写在head中"></a>为什么建议CSS写在head中</h2><p>因为页面是<strong>边解析边渲染的</strong>，如果把CSS写在body内（HTML规范允许在 <code>&lt;body&gt;</code> 中使用 <code>&lt;link&gt;</code>标签），则先解析DOM树渲染在页面上，再生成CSSOM合成渲染树重新渲染在页面上，这样会有一个过程，用户可能会看到一个过程变化。<br><strong>所以在DOM树生成之前就先生成CSSOM会更好</strong>，这样当DOM树生成时就可<strong>直接和所有CSSOM进行合并，一步渲染完成</strong>。</p>
<hr>
<h2 id="为什么建议JS写在body最后"><a href="#为什么建议JS写在body最后" class="headerlink" title="为什么建议JS写在body最后"></a>为什么建议JS写在body最后</h2><p>因为页面是<strong>边解析边渲染的</strong>，如果把JS写在body中，虽然JS有异步的处理机制，但极端情况会出现前面已经渲染了一半就卡住的情况。<strong>渲染时间会拖长</strong>。</p>
<hr>
<h2 id="从输入url到页面显示都经历了什么"><a href="#从输入url到页面显示都经历了什么" class="headerlink" title="从输入url到页面显示都经历了什么"></a>从输入url到页面显示都经历了什么</h2><ul>
<li><strong>下载资源</strong>：各个资源类型，下载过程</li>
<li><strong>渲染页面</strong>：结合html Css javascript图片等</li>
<li>详细过程可参考博客<a href="https://huanglizhu.github.io/2019/09/27/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/">从输入url到页面显示都经历了什么</a></li>
</ul>
<hr>
<h2 id="window-onload和DOMContentLoaded的区别"><a href="#window-onload和DOMContentLoaded的区别" class="headerlink" title="window.onload和DOMContentLoaded的区别"></a>window.onload和DOMContentLoaded的区别</h2><ul>
<li><strong>window.onload</strong>：页面的<strong>全部资源加载完才会执行</strong>，包括图片、视频等</li>
<li><strong>DOMContentLoaded</strong>：<strong>DOM渲染完即可执行</strong>，此时图片、视频还可能没有加载完</li>
<li><strong>注意：使用DOMContentLoaded来触发JS比window.onload更好</strong>，不需要等图片、视频都加载完成才触发JS的加载，这样页面渲染会更快。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;load&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 页面的全部资源加载完才会执行，包括图片、视频等</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// DOM 渲染完即可执行，此时图片、视频还可能没有加载完</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<!--![window.onload和DOMContentLoaded](https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfpg6bcx3mj30rg06dgsa.jpg)-->
<ul>
<li>什么操作可以放 DOMContentLoaded 中？<ul>
<li>修改文档元素：您可以使用JavaScript来操作文档中的DOM元素，例如更改文本内容、样式、属性或结构。这通常用于更新页面的初始状态。</li>
<li>绑定事件处理程序：您可以在 DOMContentLoaded 事件处理函数中绑定其他事件处理程序，以便用户与页面进行交互。例如，您可以添加点击事件处理程序、表单提交事件处理程序等</li>
<li>发起异步请求：如果您需要在页面加载后从服务器获取数据，可以在 DOMContentLoaded 事件处理函数中发起异步请求，以确保数据获取发生在用户与页面交互之前</li>
<li>设置初始状态：您可以在这里设置页面的初始状态，例如填充表单字段、初始化UI组件、或执行其他与用户界面相关的初始化工作</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JavaScript%E5%AD%A6%E4%B9%A0/">JavaScript学习</a>, <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%883%EF%BC%89/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          前端基础-HTTP/HTML/浏览器（3）
        
      </div>
    </a>
  
  
    <a href="/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">前端基础-HTTP/HTML/浏览器（2）</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">运行环境介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B"><span class="nav-number">2.</span> <span class="nav-text">页面加载和渲染过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#window-onload%E5%92%8CDOMContentLoaded"><span class="nav-number">3.</span> <span class="nav-text">window.onload和DOMContentLoaded</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">4.</span> <span class="nav-text">性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A9%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%BF%AB"><span class="nav-number">4.1.</span> <span class="nav-text">让加载更快</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">4.1.1.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CDN"><span class="nav-number">4.1.2.</span> <span class="nav-text">CDN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SSR"><span class="nav-number">4.1.3.</span> <span class="nav-text">SSR</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A9%E6%B8%B2%E6%9F%93%E6%9B%B4%E5%BF%AB"><span class="nav-number">4.2.</span> <span class="nav-text">让渲染更快</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="nav-number">4.2.1.</span> <span class="nav-text">懒加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98DOM%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">4.2.2.</span> <span class="nav-text">缓存DOM的查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AADOM%E6%93%8D%E4%BD%9C%E5%90%88%E5%B9%B6"><span class="nav-number">4.2.3.</span> <span class="nav-text">多个DOM操作合并</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%BD%E6%97%A9%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8CJS"><span class="nav-number">4.2.4.</span> <span class="nav-text">尽早开始执行JS</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%98%B2%E6%8A%96-debounce"><span class="nav-number">5.</span> <span class="nav-text">防抖 debounce</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%81%E8%A3%85debounce%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">封装debounce函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lodash%E5%86%85%E7%BD%AE%E7%9A%84%E9%98%B2%E6%8A%96%E5%87%BD%E6%95%B0"><span class="nav-number">5.2.</span> <span class="nav-text">Lodash内置的防抖函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%8A%82%E6%B5%81-throttle"><span class="nav-number">6.</span> <span class="nav-text">节流 throttle</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8apply%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-number">6.1.</span> <span class="nav-text">使用apply的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arguments-%E4%B8%8D%E5%8C%85%E6%8B%ACfn%E3%80%81delay%EF%BC%8C%E5%8F%AA%E6%9C%89%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.2.</span> <span class="nav-text">arguments 不包括fn、delay，只有事件对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lodash%E5%86%85%E7%BD%AE%E7%9A%84%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0"><span class="nav-number">6.3.</span> <span class="nav-text">Lodash内置的节流函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#throttle%E8%B8%A9%E9%9B%B7"><span class="nav-number">6.3.1.</span> <span class="nav-text">throttle踩雷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E5%85%A8"><span class="nav-number">7.</span> <span class="nav-text">安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#XSS%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E6%94%BB%E5%87%BB"><span class="nav-number">7.1.</span> <span class="nav-text">XSS跨站请求攻击</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#XSRF%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0"><span class="nav-number">7.2.</span> <span class="nav-text">XSRF跨站请求伪造</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE"><span class="nav-number">8.</span> <span class="nav-text">相关题目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AECSS%E5%86%99%E5%9C%A8head%E4%B8%AD"><span class="nav-number">8.1.</span> <span class="nav-text">为什么建议CSS写在head中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AEJS%E5%86%99%E5%9C%A8body%E6%9C%80%E5%90%8E"><span class="nav-number">8.2.</span> <span class="nav-text">为什么建议JS写在body最后</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88"><span class="nav-number">8.3.</span> <span class="nav-text">从输入url到页面显示都经历了什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#window-onload%E5%92%8CDOMContentLoaded%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">8.4.</span> <span class="nav-text">window.onload和DOMContentLoaded的区别</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
    

                <div class="clearfix container">
                    <div class="site-info">
                        &copy;
                        2025
                            珠 All Rights Reserved.
                                
                                    <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量
                                    <span id="busuanzi_value_site_pv"></span>次
                                    </span>
                                    
                    </div>
                    <div class="site-credit">
                        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
                    </div>
                </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
