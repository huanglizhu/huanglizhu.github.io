<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>React知识点汇总（高级特性） | 珠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="前端,程序员,软件开发,面试,CSS,JavaScript,JS,ES6,HTML,Node.js,React,Vue">
  
  
  
  
  <meta name="description" content="不是每个都很常用，但用到的时候必须要知道 考察候选人对React的掌握是否全面，且有深度 考察做过的项目是否有深度和复杂度（至少能用到高级特性）">
<meta name="keywords" content="React.js">
<meta property="og:type" content="article">
<meta property="og:title" content="React知识点汇总（高级特性）">
<meta property="og:url" content="http://yoursite.com/2020/04/14/React知识点汇总（高级特性）/index.html">
<meta property="og:site_name" content="珠">
<meta property="og:description" content="不是每个都很常用，但用到的时候必须要知道 考察候选人对React的掌握是否全面，且有深度 考察做过的项目是否有深度和复杂度（至少能用到高级特性）">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/react_func_elem.png">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh5nlbf2aqj30tw0nigse.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6ozx24ajj30mt071q3l.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6p8pl601j30wb0nxwhj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q4fq02vj31ar0eygq4.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q5cxj6zj313h06h77i.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q93ic8xj30sv0hraco.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q9fu4ipj313j05z0yt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6rnwj60kj30p3026t9j.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6rmuvdjgj30ur0k8q6e.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6rqdsd0sj30ju08zwf6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6s8nfcqbj31at0cw0wi.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6scyniqjj30wr08sq5o.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7nxs0s57j30u10mvn0n.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7nxwnizej315z0etndc.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7pt9y28xj30bh02tdh0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7pmhbp21j30sp08y7c2.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7vyrddshj31870hwn2x.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7x7kv55xj30px0d3dq7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8tssz9fjj30u10630y8.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh91p1jppaj30vk0g5h11.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8uros2dpj30kx067q4l.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8veb0u4kj30yg0o07cc.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8vipknn8j30zy0bw416.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh91su6xvfj30kl0c4aj6.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh93fdu82uj31450c714l.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8uros2dpj30kx067q4l.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh957vxc3pj30zk0ri7as.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gh9a4x6g29j30zp0g3jxf.jpg">
<meta property="og:updated_time" content="2021-04-16T07:55:38.344Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="React知识点汇总（高级特性）">
<meta name="twitter:description" content="不是每个都很常用，但用到的时候必须要知道 考察候选人对React的掌握是否全面，且有深度 考察做过的项目是否有深度和复杂度（至少能用到高级特性）">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/react_func_elem.png">
  
    <link rel="alternate" href="/atom.xml" title="珠" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/sx.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


        <header id="allheader" class="site-header" role="banner"  >
                <div class="clearfix container">
                    <div class="site-branding">

                        <h1 class="site-title">
                            
                                    <a href="/" title="珠" rel="home">
                                        珠
                                    </a>
                                    
                        </h1>

                        
                            <div class="site-description">
                                Record every bit of front-end learning.
                            </div>
                            

                                <nav id="main-navigation" class="main-navigation" role="navigation">
                                    <a class="nav-open">Menu</a>
                                    <a class="nav-close">Close</a>

                                    <div class="clearfix sf-menu">
                                        <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                                            
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/">
                                                        主页
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/archives">
                                                        归档
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/categories">
                                                        分类
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/tags">
                                                        标签
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/about">
                                                        关于
                                                    </a>
                                                </li>
                                                
                                        </ul>
                                    </div>
                                </nav>

                    </div>
                </div>
        </header>

  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-React知识点汇总（高级特性）" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      React知识点汇总（高级特性）
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/04/14/React知识点汇总（高级特性）/" class="article-date">
	  <time datetime="2020-04-14T09:57:59.000Z" itemprop="datePublished">四月 14, 2020</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React-js学习/">React.js学习</a>, <a class="article-category-link" href="/categories/面试题/">面试题</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>不是每个都很常用，但用到的时候必须要知道</li>
<li>考察候选人对React的掌握是否全面，且有深度</li>
<li>考察做过的项目是否有深度和复杂度（至少能用到高级特性）<a id="more"></a>

</li>
</ul>
<h1 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h1><p><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/react_func_elem.png" alt="函数组件" title="函数组件"></p>
<ul>
<li>函数组件是 <strong>纯函数，输入props，输出JSX</strong></li>
<li><strong>没有实例（自然也没有this）</strong>，<strong>没有生命周期函数与state</strong>，所以性能好</li>
<li>不能扩展其他方法</li>
<li><strong>函数组件，即 无状态组件</strong>，更多知识可参考<a href="https://huanglizhu.github.io/2020/01/18/Redux%E8%BF%9B%E9%98%B6(1)UI%E7%BB%84%E4%BB%B6%E3%80%81%E5%AE%B9%E5%99%A8%E7%BB%84%E4%BB%B6%E3%80%81%E6%97%A0%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6/#无状态组件（性能优化）" target="_blank" rel="noopener">“Redux进阶(1)UI组件、容器组件、无状态组件”</a></li>
<li>当一个组件中只有render函数时，我们可以使用 无状态组件 替换 它。</li>
<li><strong>使用方法</strong>：使用常量const定义一个箭头函数，<strong>该函数接收一个参数props（来自父组件的变量、方法），返回原本render函数中的内容（记得输出）</strong></li>
</ul>
<hr>
<h1 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h1><ul>
<li>ref可参考<a href="https://huanglizhu.github.io/2020/01/08/React%E9%AB%98%E7%BA%A7%E5%86%85%E5%AE%B9%EF%BC%882%EF%BC%89/#使用ref引用对应的DOM元素" target="_blank" rel="noopener">“React高级内容（2）”</a></li>
<li><strong>ref属性值 必须是通过<code>React.create()</code>创建的对象</strong></li>
<li><strong>三个地方名字(refName)一致才能获取DOM节点</strong><ul>
<li><strong>创建ref：</strong><code>this.refName = React.createRef()</code>(构造函数中)</li>
<li><strong>使用ref：</strong><code>&lt;input defaultValue={this.state.name} ref={this.refName}/&gt;</code>（render函数中）</li>
<li><strong>通过 ref 获取 DOM 节点(elem):</strong><code>const elem = this.refName.current</code>（事件函数中）</li>
</ul>
</li>
<li>具体例子在下方“非受控组件”中</li>
</ul>
<hr>
<h1 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h1><ul>
<li><strong>非受控组件：组件值不受state控制（比如：input的值不受state控制），只是使用state给组件赋予了初始值（比如：input的defaultValue属性）</strong>，由于赋予初始值以后组件值就和state无关了，<strong>所以后面想获取 组件值 就只能 通过ref获取DOM元素 的值的方式来操作了</strong>。（可回顾<a href="https://huanglizhu.github.io/2020/04/11/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%88%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A81%EF%BC%89/#表单（受控组件）" target="_blank" rel="noopener">“React知识点汇总（基础使用1）”中的 受控组件（value/checked）</a>）</li>
<li><strong>使用场景：</strong>由于非受控组件需要搭配ref去操作DOM来获取值，所以按照react设计初衷是不推荐使用的，<strong>但是特殊时候只能使用 非受控组件，比如</strong>：<ul>
<li><strong>必须手动操作DOM元素，setState实现不了</strong>的时候</li>
<li><strong>文件上传</strong><code>&lt;input type=file&gt;</code></li>
<li>某些<strong>富文本编辑器，需要传入DOM元素</strong>（做加粗、加下划线等操作 ）</li>
</ul>
</li>
<li><strong>受控组件vs非受控组件</strong>：<strong>优先使用受控组件</strong>，这样符合React设计原则。<strong>必须操作DOM时，再使用非受控组件</strong>。</li>
</ul>
<h2 id="input的-defaultValue属性"><a href="#input的-defaultValue属性" class="headerlink" title="input的 defaultValue属性"></a>input的 defaultValue属性</h2><ul>
<li><strong>注意：<a href="https://blog.csdn.net/weixin_43851769/article/details/88100078" target="_blank" rel="noopener">区别react中input的 defaultValue属性 和 value属性</a></strong><ul>
<li>react中input的<strong>defaultValue就相当于原生DOM中的value属性</strong>，这样写出来的组件，其<strong>value值就是用户输入的内容，和react没有关系</strong>，完全不管输入的过程。</li>
<li>而react中input的<strong>value属性必须使用onChange来监听这个input，使state和input关联（即 受控组件）</strong></li>
<li>如果在<strong>使用input时只需要获取model里的值</strong>时，<strong>使用 defaultValue</strong>就可以了。如果<strong>需要获取model的值并且还需要改变它</strong>的时候，就需要<strong>使用value结合onChange事件与state联系</strong>就可以了。（但还是<strong>尽量使用value</strong>，毕竟defaultValue需要结合ref来获取DOM元素，而react的设计初衷就是尽量不要操作DOM，通过state来带动DOM）</li>
</ul>
</li>
<li><strong>例子：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh5nlbf2aqj30tw0nigse.jpg" alt="非受控组件例子"></li>
</ul>
<h2 id="checkbox的defaultChecked属性"><a href="#checkbox的defaultChecked属性" class="headerlink" title="checkbox的defaultChecked属性"></a>checkbox的defaultChecked属性</h2><p><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6ozx24ajj30mt071q3l.jpg" alt="非受控组件例子"></p>
<h2 id="上传文件【必须使用非受控组件】"><a href="#上传文件【必须使用非受控组件】" class="headerlink" title="上传文件【必须使用非受控组件】"></a>上传文件【必须使用非受控组件】</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input/file" target="_blank" rel="noopener">MDN input file使用方法</a><br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6p8pl601j30wb0nxwhj.jpg" alt="上传文件【必须使用非受控组件】"></p>
<hr>
<h1 id="Protals（传送门-让组件渲染到父组件以外）"><a href="#Protals（传送门-让组件渲染到父组件以外）" class="headerlink" title="Protals（传送门 让组件渲染到父组件以外）"></a>Protals（传送门 让组件渲染到父组件以外）</h1><ul>
<li>组件默认会按照既定层次嵌套渲染，但我们可以使用Protals让<strong>组件渲染到父组件以外</strong>。</li>
<li><strong>在react中的组件排布位置是不变的（不会改变组件解构）</strong>，只是在渲染的时候做了一个hack使相关组件渲染到我们指定的地方。</li>
<li><strong>Portals使用场景：</strong><ol>
<li><strong>父组件是BFC时，会限制子组件的布局，此时可使用Protals将子组件脱离BFC父组件</strong>（比如<code>overflow：hidden</code>）</li>
<li>父组件z-index值太小时</li>
<li><strong>fixed元素需要放在body第一层级（DOM树最外层）</strong>，有更好的浏览器兼容性<ul>
<li>总之，Protals一般在<strong>CSS布局方面</strong>使用</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="例子（fixed元素放在body第一层级）"><a href="#例子（fixed元素放在body第一层级）" class="headerlink" title="例子（fixed元素放在body第一层级）"></a>例子（fixed元素放在body第一层级）</h2><ul>
<li><strong>正常渲染时：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q4fq02vj31ar0eygq4.jpg" alt="正常渲染时">（注意：<code>this.props.children</code>可获取的内容）<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q5cxj6zj313h06h77i.jpg" alt="正常渲染时的结果">可以看到<strong>固定定位的元素位于DOM树内层</strong></li>
<li><strong>使用 Portals 渲染到 body 上：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q93ic8xj30sv0hraco.jpg" alt="使用 Portals 渲染到 body 上"><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6q9fu4ipj313j05z0yt.jpg" alt="使用 Portals 结果"></li>
</ul>
<hr>
<h1 id="context（传递公共信息）"><a href="#context（传递公共信息）" class="headerlink" title="context（传递公共信息）"></a>context（传递公共信息）</h1><ul>
<li>公共信息（语言、主题）如何传递给每个组件？用props太繁琐，用redux小题大做，<strong>使用context将 公共信息（语言、主题）如何传递给每个组件</strong>。</li>
<li><strong>例子：</strong>在这里只是<strong>假设theme为需要使用的主题</strong>，在这个例子中，从外向内是<strong>App组件（最外层组件）=》Toolbar组件（中间组件）=》ThemedButton组件（class 组件）、ThemeLink组件（函数组件）</strong></li>
</ul>
<ol>
<li><strong>父组件做context生产方，创建context，并使用context包裹子组件给子组件获取context的能力：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6rnwj60kj30p3026t9j.jpg" alt="创建context"><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6rmuvdjgj30ur0k8q6e.jpg" alt="父组件App中给子组件获取context的能力"></li>
<li>中间的组件不需要指明往下传递 theme ：<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6rqdsd0sj30ju08zwf6.jpg" alt="中间的组件"></li>
<li><strong>子组件做context消费方，可以获取到父组件中传递的context。</strong> <ul>
<li><strong>class子组件 直接使用<code>this.context</code>可获取父组件设置的context：</strong> <img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6s8nfcqbj31at0cw0wi.jpg" alt="class子组件 使用父组件context的方法"></li>
<li><strong>函数子组件 由于没有实例导致没有this，所以：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh6scyniqjj30wr08sq5o.jpg" alt="函数子组件 使用父组件context的方法"></li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Context 填入默认值（任何一个 js 变量，这里用字符串）</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层组件 - 函数是组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeLink</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// const theme = this.context // 会报错。函数式组件没有实例，即没有 this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数式组件可以使用 Consumer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123; value =&gt; <span class="tag">&lt;<span class="name">p</span>&gt;</span>link's theme is &#123;value&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> &#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底层组件 - class 组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemedButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 指定 contextType 读取当前的 theme context。</span></span><br><span class="line">    <span class="comment">// static contextType = ThemeContext // 可用ES6 static，也可用 ThemedButton.contextType = ThemeContext</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> theme = <span class="keyword">this</span>.context <span class="comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>button's theme is &#123;theme&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ThemedButton.contextType = ThemeContext <span class="comment">// 指定 contextType 读取当前的 theme context。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间的组件再也不必指明往下传递 theme 了。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ThemedButton /&gt;</span><br><span class="line">            &lt;ThemeLink /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">    constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">        super(props)</span></span><br><span class="line"><span class="regexp">        this.state = &#123;</span></span><br><span class="line"><span class="regexp">            theme: 'light'</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    render() &#123;</span></span><br><span class="line"><span class="regexp">        return &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt;</span></span><br><span class="line"><span class="regexp">            &lt;Toolbar /</span>&gt;</span><br><span class="line">            &lt;hr/&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.changeTheme&#125;&gt;change theme&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>ThemeContext.Provider&gt;</span><br><span class="line">    &#125;</span><br><span class="line">    changeTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            theme: <span class="keyword">this</span>.state.theme === <span class="string">'light'</span> ? <span class="string">'dark'</span> : <span class="string">'light'</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="异步组件（懒加载）"><a href="#异步组件（懒加载）" class="headerlink" title="异步组件（懒加载）"></a>异步组件（懒加载）</h1><ul>
<li><strong>使用场景</strong>：<strong>组件比较大</strong> 或者需要 <strong>懒加载</strong> 时，我们可以使用 <strong>异步组件</strong>来做（<strong>性能优化</strong>）</li>
<li>vue中可用import()，react中可用<strong>React.lazy+React.Suspense(见下方例子)或者使用<a href="https://huanglizhu.github.io/2020/02/21/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%EF%BC%882%EF%BC%89%E3%80%81%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B/#异步组件（懒加载）及withRouter路由方法" target="_blank" rel="noopener">react-loadable模块</a></strong></li>
<li><strong>例子：</strong><ul>
<li><strong>使用React.lazy+React.Suspense实现异步组件</strong>：<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7nxs0s57j30u10mvn0n.jpg" alt="使用React.lazy+React.Suspense实现异步组件"><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7nxwnizej315z0etndc.jpg" alt="测试"></li>
<li>使用<a href="https://huanglizhu.github.io/2020/02/21/%E7%99%BB%E5%BD%95%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%EF%BC%882%EF%BC%89%E3%80%81%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E9%A1%B9%E7%9B%AE%E4%B8%8A%E7%BA%BF%E6%B5%81%E7%A8%8B/#异步组件（懒加载）及withRouter路由方法" target="_blank" rel="noopener">react-loadable模块 实现异步组件 的例子</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="【重点】性能优化"><a href="#【重点】性能优化" class="headerlink" title="【重点】性能优化"></a>【重点】性能优化</h1><ul>
<li>比起vue，<strong>性能优化对于React更加重要</strong>。因为react本身设计的shouldComponentUpdate默认是返回true的，也就是说父组件一更新就会带着所有子组件重新渲染，不管子组件是否有数据变化（是否需要重新渲染）。</li>
<li>回顾讲setState时重点强调的<a href="https://huanglizhu.github.io/2020/04/12/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%88%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A82%EF%BC%89/#不能直接修改-state-，使用-不可变值" target="_blank" rel="noopener">不可变值</a></li>
<li><strong>措施：</strong><ol>
<li><strong>使用shouldComponentUpdate()避免不必要的子组件渲染</strong>（注意搭配state不可变值）</li>
<li><strong>state数据设计为浅层</strong>（不要出现二维数组之类的），<strong>避免深拷贝或者深度比较</strong>（他们需要一次性递归，很消耗性能）</li>
<li><strong>class组件 使用 PureComponent ，它自带浅比较，不需要我们手写shouldComponentUpdate()【需要将state数据设计为浅层】；函数组件 使用 React.memo，可用函数代替shouldComponentUpdate()，解决函数组件没有生命周期函数的问题</strong></li>
<li><strong>immutable.js可生成不可变的对象，</strong>它<strong>基于共享数据（不是深拷贝）</strong>，速度快性能好，<strong>但有一定学习和迁移成本</strong>，按需使用。（<strong>补充：</strong><a href="https://huanglizhu.github.io/2020/01/27/%E7%AE%80%E4%B9%A6Header%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%BD%BF%E7%94%A8immutable.js%E5%BA%93%E3%80%81redux-immutable%E5%BA%93%EF%BC%89/#redux-immutable库-生成不可改变的对象" target="_blank" rel="noopener">redux-immutable库</a>的combineReducers()可使合成各个组件的reducer得到的就是immutable对象）</li>
</ol>
</li>
</ul>
<h2 id="shouldComponentUpdate（简称SCU）"><a href="#shouldComponentUpdate（简称SCU）" class="headerlink" title="shouldComponentUpdate（简称SCU）"></a>shouldComponentUpdate（简称SCU）</h2><ul>
<li>React默认机制：<strong>父组件有更新，（不管子组件是否有改变）子组件也无条件也更新</strong>！！！所以我们<strong>需要优化react，避免不必要重复渲染的子组件被带着渲染来影响性能。</strong></li>
<li>如不设置shouldComponentUpdate <strong>则默认返回true，代表可以渲染</strong>：<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7pt9y28xj30bh02tdh0.jpg" alt="shouldComponentUpdate默认返回true，代表可以渲染"></li>
<li><strong>使用shouldComponentUpdate做 性能优化：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7pmhbp21j30sp08y7c2.jpg" alt="shouldComponentUpdate基本用法">shouldComponentUpdate()会接收<strong>新的Props和State值作为参数</strong>，并且给了我们权利去决定什么时候返回false来拒绝重复渲染</li>
<li><strong>SCU优化一定要每次都用吗</strong>？其实不是，需要的时候才优化，如果页面不卡顿就可以不用，一切以开发为主</li>
</ul>
<h3 id="SCU一定要配合state不可变值"><a href="#SCU一定要配合state不可变值" class="headerlink" title="SCU一定要配合state不可变值"></a>SCU一定要配合state不可变值</h3><ul>
<li><strong>原因：</strong>如果state不是不可变值，即它在setState前被改变了，则SCU中拿到的nextState和state是相同的，<strong>导致该重新渲染时被判断为不可重新渲染</strong>。<br>（<a href="https://www.lodashjs.com/docs/lodash.isEqual" target="_blank" rel="noopener">lodash库的isEqual</a>可进行<a href="https://huanglizhu.github.io/2020/04/13/JS%20%E6%B7%B1%E5%BA%A6%E6%AF%94%E8%BE%83%20%E4%B8%8E%20===/" target="_blank" rel="noopener">深度比较</a>，对于引用类型，<strong><code>===</code>是会比较地址的</strong>，而 lodash库的isEqual 则只是比较内容物是否相等）</li>
<li><strong>例子：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7vyrddshj31870hwn2x.jpg" alt="例子"></li>
<li><strong>总结：所以SCU一定要配合state不可变值才能保证不会出错</strong></li>
<li><strong>注意：深度比较 很耗费性能</strong>，需要进行一次性递归到底，<strong>设计state时设计的浅一些来避免使用深度比较</strong>会好一些<strong>（React的PureComponent和 React.memo就实现了自带浅比较来决定是否重新渲染）</strong></li>
</ul>
<h2 id="PureComponent-和-React-memo"><a href="#PureComponent-和-React-memo" class="headerlink" title="PureComponent 和 React.memo"></a>PureComponent 和 React.memo</h2><ul>
<li>React的<a href="https://huanglizhu.github.io/2020/02/15/%E9%A6%96%E9%A1%B5%E5%BC%80%E5%8F%91%EF%BC%883%EF%BC%89/#首页性能优化（PureComponent）" target="_blank" rel="noopener"><strong>PureComponent（纯组件）</strong></a>实现了自带<strong>浅比较</strong>，它<strong>只对比state和props数据的第一层</strong>，比起 深度比较 性能更好。</li>
<li><strong>注意：PureComponent也要搭配state不可变值（即不能改变state本身）</strong></li>
<li>让 <strong>class组件 继承PureComponent</strong>，不需要手写SCU，它<strong>自带SCU并实现了浅比较</strong>（<a href="https://huanglizhu.github.io/2020/02/15/%E9%A6%96%E9%A1%B5%E5%BC%80%E5%8F%91%EF%BC%883%EF%BC%89/#首页性能优化（PureComponent）" target="_blank" rel="noopener">PureComponent的例子</a>）</li>
<li><strong>memo，即 函数组件 中的PureComponent</strong>：<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh7x7kv55xj30px0d3dq7.jpg" alt="memo的使用方法"><strong>可用函数代替shouldComponentUpdate()，解决函数组件没有生命周期函数的问题</strong></li>
<li>浅比较已适用大部分情况（尽量不要做深度比较），这就需要我们在react中<strong>设计state时尽量扁平</strong>，不要一层套一层</li>
</ul>
<h2 id="不可变值immutable-js"><a href="#不可变值immutable-js" class="headerlink" title="不可变值immutable.js"></a>不可变值immutable.js</h2><ul>
<li><strong>immutable.js</strong>彻底拥抱“不可变值”，它<strong>基于共享数据（不是深拷贝）</strong>，速度快性能好，<strong>但有一定学习和迁移成本</strong>，按需使用。<ul>
<li>深拷贝的性能差</li>
</ul>
</li>
<li>具体使用可参考博客<a href="https://huanglizhu.github.io/2020/01/27/%E7%AE%80%E4%B9%A6Header%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%EF%BC%88%E4%BD%BF%E7%94%A8immutable.js%E5%BA%93%E3%80%81redux-immutable%E5%BA%93%EF%BC%89/#immutable-js库-生成不可改变的对象" target="_blank" rel="noopener">“简书Header组件开发（使用immutable.js库、redux-immutable库）”</a></li>
<li><strong>例子：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8tssz9fjj30u10630y8.jpg" alt="例子"></li>
</ul>
<h2 id="按需使用-amp-state层级"><a href="#按需使用-amp-state层级" class="headerlink" title="按需使用 &amp; state层级"></a>按需使用 &amp; state层级</h2><ul>
<li>不是任何时候都需要使用性能优化，不卡顿可不用</li>
<li>state层级设计的浅一些可避免深拷贝/深度比较等耗费性能的操作</li>
</ul>
<hr>
<h1 id="组件公共逻辑的抽离"><a href="#组件公共逻辑的抽离" class="headerlink" title="组件公共逻辑的抽离"></a>组件公共逻辑的抽离</h1><ul>
<li>mixin已被React弃用</li>
<li>高阶组件HOC Vs Render Props <strong>按需使用即可</strong><ul>
<li><strong>高阶组件HOC</strong>：模式简单，<strong>但会增加组件层级</strong>（需要考虑透传props以及是否会被覆盖的问题）</li>
<li><strong>Render Props</strong>：<strong>代码简洁</strong>，学习成本较高</li>
</ul>
</li>
</ul>
<h2 id="高阶组件HOC"><a href="#高阶组件HOC" class="headerlink" title="高阶组件HOC"></a>高阶组件HOC</h2><p><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh91p1jppaj30vk0g5h11.jpg" alt="简单示例"></p>
<ul>
<li><strong>高阶组件</strong>不是一种功能，是<strong>一种模式</strong>，他是一个函数，<strong>这个函数接受一个组件并返回一个新组件</strong><ul>
<li><strong>高阶组件负责公共逻辑</strong>，传入的组件 传出后 生成的新组件 就会带上这部分逻辑</li>
<li><strong>定义高阶组件时 需要向 传入的组件 传递自己的所有props（包括别人传过来的），这样传入的组件才能获取使用（详情见下面例子）</strong></li>
</ul>
</li>
<li><strong>高阶组件的定义：</strong>创建一个函数，接受一个组件A，在函数内创建组件B将组件A包裹并给他逻辑，最后返回组件B。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul>
<li><strong>实现效果：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8uros2dpj30kx067q4l.jpg" alt="实现效果">鼠标划过时显示鼠标位置</li>
<li><strong>思路：</strong>假设很多组件都要使用这个逻辑，那么怎么将这个逻辑抽离出来？<strong>在 高阶组件 的函数中实现鼠标滑动的逻辑，App组件（函数组件）只需要负责渲染，最终返回的是 App组件通过高阶组件来返回的新组件（已经包含了逻辑的App组件）</strong></li>
<li><strong>代码：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8veb0u4kj30yg0o07cc.jpg" alt="定义高阶组件"><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8vipknn8j30zy0bw416.jpg" alt="使用高阶组件"></li>
</ul>
<h3 id="react-redux-connect"><a href="#react-redux-connect" class="headerlink" title="react-redux connect"></a>react-redux connect</h3><p><a href="https://huanglizhu.github.io/2020/01/22/Redux%E8%BF%9B%E9%98%B6(3)React-Redux%E7%9A%84%E4%BD%BF%E7%94%A8/#connect方法" target="_blank" rel="noopener">react-redux connect</a>也是高阶组件<br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh91su6xvfj30kl0c4aj6.jpg" alt="redux connect"></p>
<ol>
<li><code>connect(函数1，函数2)</code>返回的是<strong>高阶组件的函数</strong>（回顾：redux-thunk中间件使action可以为函数）</li>
<li>在调用1返回的函数并将组件TodoList传入，得到的就是新的组件</li>
</ol>
<hr>
<h2 id="render-props"><a href="#render-props" class="headerlink" title="render props"></a>render props</h2><ul>
<li><strong>高阶组件</strong> 是<strong>高阶组件（负责逻辑）包含组件A（负责渲染）</strong>（即 逻辑包含渲染）；<strong>render props</strong> 是 <strong>组件A包含class组件，class组件（负责逻辑）中包含函数组件（负责渲染</strong>（即 逻辑包含渲染）。</li>
<li><strong>区分 高阶组件 和 render props 的包裹关系：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh93fdu82uj31450c714l.jpg" alt="区分高阶组件和render props的包裹关系"><ul>
<li><strong>思路：</strong><ol>
<li>左图<strong>定义一个class组件Factory</strong>，在class组件中<strong>将state作为参数传给 函数（组件）render</strong>（<strong>注意：class组件需要设置propTypes来规定必须接收一个 render 属性，而且是函数</strong>（具体见下方例子））</li>
<li>右图是<strong>调用class组件Factory时，在render属性上定义一个函数组件render，该组件通过参数获取到父组件Factory中传过来的数据（state）</strong></li>
</ol>
</li>
</ul>
</li>
<li><strong>例子：</strong><ul>
<li><strong>实现效果：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh8uros2dpj30kx067q4l.jpg" alt="实现效果">鼠标划过时显示鼠标位置</li>
</ul>
</li>
<li><strong>代码：</strong><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh957vxc3pj30zk0ri7as.jpg" alt="render props例子代码1"><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gh9a4x6g29j30zp0g3jxf.jpg" alt="render props例子代码2">获取App的父组件的值的方法比使用 高阶组件 要简单，毕竟App组件就是最外层，<strong>不需要透传所有props</strong>。</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/React-js学习/">React.js学习</a>, <a class="article-category-link" href="/categories/面试题/">面试题</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/React-js/">React.js</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/15/Redux、React-router知识点汇总/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Redux、React-router知识点汇总
        
      </div>
    </a>
  
  
    <a href="/2020/04/13/JS 深度比较 与 ===/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">JS 深度比较 与 `===`</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#函数组件"><span class="nav-number">1.</span> <span class="nav-text">函数组件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ref属性"><span class="nav-number">2.</span> <span class="nav-text">ref属性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#非受控组件"><span class="nav-number">3.</span> <span class="nav-text">非受控组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#input的-defaultValue属性"><span class="nav-number">3.1.</span> <span class="nav-text">input的 defaultValue属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#checkbox的defaultChecked属性"><span class="nav-number">3.2.</span> <span class="nav-text">checkbox的defaultChecked属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上传文件【必须使用非受控组件】"><span class="nav-number">3.3.</span> <span class="nav-text">上传文件【必须使用非受控组件】</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Protals（传送门-让组件渲染到父组件以外）"><span class="nav-number">4.</span> <span class="nav-text">Protals（传送门 让组件渲染到父组件以外）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#例子（fixed元素放在body第一层级）"><span class="nav-number">4.1.</span> <span class="nav-text">例子（fixed元素放在body第一层级）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#context（传递公共信息）"><span class="nav-number">5.</span> <span class="nav-text">context（传递公共信息）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#异步组件（懒加载）"><span class="nav-number">6.</span> <span class="nav-text">异步组件（懒加载）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#【重点】性能优化"><span class="nav-number">7.</span> <span class="nav-text">【重点】性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#shouldComponentUpdate（简称SCU）"><span class="nav-number">7.1.</span> <span class="nav-text">shouldComponentUpdate（简称SCU）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SCU一定要配合state不可变值"><span class="nav-number">7.1.1.</span> <span class="nav-text">SCU一定要配合state不可变值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PureComponent-和-React-memo"><span class="nav-number">7.2.</span> <span class="nav-text">PureComponent 和 React.memo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不可变值immutable-js"><span class="nav-number">7.3.</span> <span class="nav-text">不可变值immutable.js</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#按需使用-amp-state层级"><span class="nav-number">7.4.</span> <span class="nav-text">按需使用 &amp; state层级</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#组件公共逻辑的抽离"><span class="nav-number">8.</span> <span class="nav-text">组件公共逻辑的抽离</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#高阶组件HOC"><span class="nav-number">8.1.</span> <span class="nav-text">高阶组件HOC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">8.1.1.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#react-redux-connect"><span class="nav-number">8.1.2.</span> <span class="nav-text">react-redux connect</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#render-props"><span class="nav-number">8.2.</span> <span class="nav-text">render props</span></a></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
    

                <div class="clearfix container">
                    <div class="site-info">
                        &copy;
                        2021
                            珠 All Rights Reserved.
                                
                                    <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量
                                    <span id="busuanzi_value_site_pv"></span>次
                                    </span>
                                    
                    </div>
                    <div class="site-credit">
                        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
                    </div>
                </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
