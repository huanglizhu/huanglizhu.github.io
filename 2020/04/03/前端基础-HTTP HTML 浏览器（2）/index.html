<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>前端基础-HTTP/HTML/浏览器（2） | 珠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="前端,程序员,软件开发,面试,CSS,JavaScript,JS,ES6,HTML,Node.js,React,Vue" />
  
  
  
  
  <meta name="description" content="记录一些重要的知识点">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础-HTTP&#x2F;HTML&#x2F;浏览器（2）">
<meta property="og:url" content="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/index.html">
<meta property="og:site_name" content="珠">
<meta property="og:description" content="记录一些重要的知识点">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/tcpThreeTimesHandshake.png">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfijoy3cg6j30k005s436.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb4suzlej30oh05uaeb.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb58vn0lj30fa08bjt9.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwbfb4srkj30u30al0u0.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfgcemkhr3j30m80h1q73.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfg5rybbgxj30q108paaj.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfgaikdwasj30kv0i112g.jpg">
<meta property="og:image" content="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gkup59bjmvj30u009igmt.jpg">
<meta property="article:published_time" content="2020-04-03T04:29:23.000Z">
<meta property="article:modified_time" content="2025-04-28T02:06:28.066Z">
<meta property="article:author" content="黄丽珠">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/tcpThreeTimesHandshake.png">
  
    <link rel="alternate" href="/atom.xml" title="珠" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/sx.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 6.3.0"></head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


        <header id="allheader" class="site-header" role="banner"  >
                <div class="clearfix container">
                    <div class="site-branding">

                        <h1 class="site-title">
                            
                                    <a href="/" title="珠" rel="home">
                                        珠
                                    </a>
                                    
                        </h1>

                        
                            <div class="site-description">
                                Record every bit of front-end learning.
                            </div>
                            

                                <nav id="main-navigation" class="main-navigation" role="navigation">
                                    <a class="nav-open">Menu</a>
                                    <a class="nav-close">Close</a>

                                    <div class="clearfix sf-menu">
                                        <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                                            
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/">
                                                        主页
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/archives">
                                                        归档
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/categories">
                                                        分类
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/tags">
                                                        标签
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/about">
                                                        关于
                                                    </a>
                                                </li>
                                                
                                        </ul>
                                    </div>
                                </nav>

                    </div>
                </div>
        </header>

  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-前端基础-HTTP HTML 浏览器（2）" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      前端基础-HTTP/HTML/浏览器（2）
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/" class="article-date">
	  <time datetime="2020-04-03T04:29:23.000Z" itemprop="datePublished">四月 3, 2020</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JavaScript%E5%AD%A6%E4%B9%A0/">JavaScript学习</a>, <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <p>记录一些重要的知识点</p>
<span id="more"></span>

<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="tcp三次握手，一句话概括"><a href="#tcp三次握手，一句话概括" class="headerlink" title="tcp三次握手，一句话概括"></a>tcp三次握手，一句话概括</h2><p><img src="https://cdn.jsdelivr.net/gh/huanglizhu/huanglizhu.github.io/images/tcpThreeTimesHandshake.png" alt="tcp三次握手" title="tcp三次握手"></p>
<ul>
<li>三次握手可以简化为：<strong>C发起 请求连接SYN，S确认 发送给确认响应ACK+请求连接SYN，C确认发回ACk。双工连接建立成功</strong><ul>
<li>syn、ack&#x2F;syn、ack</li>
</ul>
</li>
<li>每次握手的作用：<ol>
<li>第一次握手：客户端向服务端发送 SYN 报文，表示请求建立一个从客户端到服务端的连接</li>
<li>第二次握手：服务端收到 SYN 报文后，根据确认机制，如果向客户端回复一个 ACK 报文，则表示同意建立连接，这样客户端通过syn建立好了客户端到服务器的连接，此时服务器如果也想建立到客户端的连接，咋整?简单，服务器也发送syn到客户端，<strong>所以最后实际发的是SYN&#x2F;ACK 报文</strong></li>
<li>第三次握手：客户端收到 SYN&#x2F;ACK 报文后，向服务端发送一个 ACK 报文，表示服务端到客户端的连接已经建立，那么服务端就可通过连接发送数据给客户端了</li>
</ol>
</li>
</ul>
<h2 id="tcp握手为什么是三次不是四次"><a href="#tcp握手为什么是三次不是四次" class="headerlink" title="tcp握手为什么是三次不是四次"></a>tcp握手为什么是三次不是四次</h2><ul>
<li><strong>总结：因为tcp的连接是双工的，即双方都可以同时发送和接收数据，因此在建立连接时需要进行双向确认，所以是三次，</strong>如果采用四次握手，会增加连接的建立时间和资源开销，因此 TCP 协议采用三次握手来尽可能地减少连接的建立时间和网络资源的占用<ul>
<li><strong>补充：</strong>http协议是单工的，所以http请求的数据传输是单向的。websocket是建立在tcp协议上的，所以是全双工通信，服务端可以主动向客户端推送数据。</li>
</ul>
</li>
</ul>
<h2 id="为什么tcp挥手可以是三次-四次"><a href="#为什么tcp挥手可以是三次-四次" class="headerlink" title="为什么tcp挥手可以是三次&#x2F;四次"></a>为什么tcp挥手可以是三次&#x2F;四次</h2><ul>
<li>四次的情况：<ul>
<li>首先fin是用于关闭从客户端到服务器的连接表示客户端没有数据给服务器了</li>
<li>服务器收到该fin后，会回复ack，这是TCP确认机制的要求。这时候，客户端是不能发送数据给服务器，但服务器仍然可以发数据给客户端</li>
<li>等服务器没数据给客户端时，也发送给fin给客户端，关闭从服务器到客户端的连接</li>
<li>客户端收到对端的fin后，回复ack</li>
</ul>
</li>
<li>到这里，经过四次挥手，双工的TCP连接才完全关闭</li>
<li>三次的情况：<ul>
<li>客户端要关闭到服务器连接发送fin给到服务器时，刚好服务器也没数据给客户端，服务器就回复fin&#x2F;ack了</li>
<li>这样，四次挥手变成三次啦!</li>
<li>这也好理解，你没话跟我说(没数据给我)，我既可以有话跟你讲(有数据给你)，也可以对你无言(无数据给你)，选择权在我(回复ack还是fin&#x2F;ack，我说了算)</li>
</ul>
</li>
<li>综上，握手一定是三次，挥手既可以是三次也可以是四次，这两种情况都能保证关闭连接后对方的数据已经接收完成从而不会导致数据的丢失，当然一般都是说四次挥手</li>
</ul>
<h2 id="tcp三次握手和tcp协议和http协议的关系"><a href="#tcp三次握手和tcp协议和http协议的关系" class="headerlink" title="tcp三次握手和tcp协议和http协议的关系"></a>tcp三次握手和tcp协议和http协议的关系</h2><ul>
<li>一定要注意区分，<strong>TCP 三次握手 和 TCP 协议 是 HTTP 协议 能够建立可靠的数据传输通道的前提条件。</strong>在 HTTP 协议中，数据的传输使用了 TCP 协议提供的可靠的数据传输服务</li>
<li><strong>TCP 三次握手</strong>是<strong>建立 TCP 连接的过程</strong>，它在 <strong>TCP 协议层面</strong>进行。在<strong>客户端发送 HTTP 请求之前，它需要先与服务器建立 TCP 连接</strong>。TCP 三次握手的过程是客户端和服务器之间进行的，用于建立 TCP 连接并确认连接可用性。<strong>只有在建立好 TCP 连接后，客户端和服务器之间才能进行数据的传输，才能发送和接收 HTTP 请求和响应</strong></li>
<li><strong>TCP 协议</strong>是一种<strong>传输层协议，属于全双工协议，它支持双向通信。</strong>用于在网络中传输数据。TCP 提供了可靠的、面向连接的数据传输服务，确保数据能够按照一定顺序和完整性传输。在 TCP 中，数据被分成一个个数据包进行传输，每个数据包都包含了源 IP 地址、目标 IP 地址、源端口号、目标端口号、序号、确认号、窗口大小等信息，用于保证数据传输的可靠性</li>
<li><strong>HTTP 协议</strong>是一种<strong>应用层协议，属于单工协议，</strong>用于在 Web 中传输数据。<strong>HTTP 协议建立在 TCP 协议之上，使用 TCP 提供的可靠的数据传输服务。</strong>当客户端需要从服务器获取数据时，它会发送一个 HTTP 请求，服务器会将请求的数据打包成 <strong>TCP 数据包</strong>进行传输。当数据传输完毕后，服务器会返回一个 HTTP 响应，响应数据也会被打包成 <strong>TCP 数据包</strong>进行传输</li>
</ul>
<hr>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td><strong>面向连接</strong>的<strong>可靠性传输</strong>（三次握手）</td>
<td><strong>无连接</strong>，即发送数据前不需要先建立链接。</td>
</tr>
<tr>
<td><strong>提供可靠的服务</strong>。通过TCP连接传送的数据，<strong>无差错，不丢失，不重复，且按序到达</strong><br/>(因为tcp可靠，面向连接，不会丢失数据因此<strong>适合大数据量的交换</strong>。)</td>
<td>尽最大努力交付，即<strong>不保证可靠交付</strong></td>
</tr>
<tr>
<td>面向<strong>字节流</strong></td>
<td>面向<strong>报文</strong>，且<strong>网络出现拥塞不会使得发送速率降低</strong>（因此会出现丢包，对<strong>实时的应用比如IP电话和视频会议</strong>等）</td>
</tr>
<tr>
<td><strong>TCP只能是1对1</strong></td>
<td>UDP <strong>支持1对1,1对多</strong></td>
</tr>
<tr>
<td>TCP的<strong>首部较大</strong>，为20字节</td>
<td>UDP只有8字节</td>
</tr>
</tbody></table>
<hr>
<h2 id="一个图片url访问后直接下载怎样实现"><a href="#一个图片url访问后直接下载怎样实现" class="headerlink" title="一个图片url访问后直接下载怎样实现"></a>一个图片url访问后直接下载怎样实现</h2><ul>
<li><strong>重点：<a target="_blank" rel="noopener" href="https://www.runoob.com/tags/att-a-download.html"><code>&lt;a&gt;</code>的download 属性</a>定义了下载链接的地址</strong></li>
<li>设置<strong>请求的返回头（HTTP响应报文首部的content-type）</strong>，用于<strong>浏览器解析</strong>的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。</li>
</ul>
<h3 id="使用HTML5实现"><a href="#使用HTML5实现" class="headerlink" title="使用HTML5实现"></a>使用HTML5实现</h3><ul>
<li>HTML5提供的<a target="_blank" rel="noopener" href="https://www.runoob.com/html/html5-canvas.html">Canvas</a>以</li>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/tags/att-a-download.html"><code>&lt;a&gt;</code>的download 属性</a>定义了下载链接的地址</li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent">MouseEvent()构造器</a>、<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent">MouseEvent事件</a></li>
<li><strong>注意：如希望 自动触发事件 应使用<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/5f9027722204">dispatchEvent(event)</a>，比<code>xxx.onclick();</code>或<code>xxx.click();</code>好</strong></li>
</ul>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">downloadIamge</span>(imgsrc, name) &#123;<span class="comment">//下载图片地址和图片名  </span></span><br><span class="line">  let image = <span class="keyword">new</span> <span class="built_in">Image</span>();  </span><br><span class="line">  <span class="comment">// 解决跨域 Canvas 污染问题（允许跨域）  </span></span><br><span class="line">  image.<span class="built_in">setAttribute</span>(<span class="string">&quot;crossOrigin&quot;</span>, <span class="string">&quot;anonymous&quot;</span>);  </span><br><span class="line">  <span class="comment">// onload 事件在图片加载完成后立即执行</span></span><br><span class="line">  image.onload = <span class="built_in">function</span>() &#123;  </span><br><span class="line">    let canvas = document.<span class="built_in">createElement</span>(<span class="string">&quot;canvas&quot;</span>);  </span><br><span class="line">    canvas.width = image.width;  </span><br><span class="line">    canvas.height = image.height;  </span><br><span class="line">    let context = canvas.<span class="built_in">getContext</span>(<span class="string">&quot;2d&quot;</span>);  <span class="comment">//创建canvas对象</span></span><br><span class="line">    context.<span class="built_in">drawImage</span>(image, <span class="number">0</span>, <span class="number">0</span>, image.width, image.height);  </span><br><span class="line">    let url = canvas.<span class="built_in">toDataURL</span>(<span class="string">&quot;image/png&quot;</span>); <span class="comment">//得到图片的base64编码数据  </span></span><br><span class="line">    let a = document.<span class="built_in">createElement</span>(<span class="string">&quot;a&quot;</span>); <span class="comment">// 生成一个a元素  </span></span><br><span class="line">    let event = <span class="keyword">new</span> <span class="built_in">MouseEvent</span>(<span class="string">&quot;click&quot;</span>); <span class="comment">// 创建一个单击事件  </span></span><br><span class="line">    a.download = name || <span class="string">&quot;photo&quot;</span>; <span class="comment">// 设置图片名称  </span></span><br><span class="line">    a.href = url; <span class="comment">// 将生成的URL设置为a.href属性  </span></span><br><span class="line">    a.<span class="built_in">dispatchEvent</span>(event); <span class="comment">// 触发a的单击事件  </span></span><br><span class="line">  &#125;;  </span><br><span class="line">  image.src = imgsrc;  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure>

<hr>
<h2 id="地址栏输入URL到页面呈现的过程"><a href="#地址栏输入URL到页面呈现的过程" class="headerlink" title="地址栏输入URL到页面呈现的过程"></a>地址栏输入URL到页面呈现的过程</h2><p>这是一个必考的面试问题，输入url后，</p>
<ol>
<li><strong>客户端</strong> 建立连接 发送请求：<ul>
<li><strong>DNS解析：</strong><ul>
<li>首先需要<strong>找到这个url域名的服务器ip</strong>,为了寻找这个ip，先搜索<strong>浏览器自身的DNS缓存</strong>,如果存在，则域名解析到此完成。</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试<strong>读取操作系统的hosts文件</strong>看是否存在对应的映射关系,如果存在，则域名解析到此完成。</li>
<li>如果本地hosts文件不存在映射关系，则查找<strong>本地DNS服务器</strong>(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。</li>
<li>如果本地DNS服务器还没找到的话,它就会<strong>向根服务器发出请求,进行递归查询</strong>。</li>
</ul>
</li>
<li><strong>建立TCP连接</strong>（三次握手）：<ul>
<li>客户机发送一个<strong>TCP连接请求报文</strong>-》服务器回送一个<strong>TCP确认响应报文</strong>-》客户机向服务器发送一个 <strong>“TCP确认”的报文</strong></li>
</ul>
</li>
<li><strong>发送http请求</strong>：<ul>
<li>浏览器根据这个ip以及相应的端口号，<strong>构造一个http请求</strong>，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并<strong>将这个http请求封装在一个tcp包中</strong>，这个tcp包会依次经过<strong>传输层，网络层，数据链路层，物理层</strong>到达服务器。（ISO 模型中的第五个层次应用层就是http请求这一层，就不会经过了）</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务端</strong> 处理请求 发出响应：<ul>
<li>过三次握手建立了可靠的tcp连接后就可以进行是数据传输了。服务器收到 TCP 数据包后，会将 TCP 数据包中的 HTTP 请求报文解析出来，并发送 HTTP 响应给客户端，即<strong>返回相应的html</strong>给浏览器。</li>
</ul>
</li>
<li><strong>客户端</strong> 解析数据 渲染页面 断开连接：<ul>
<li><strong>构建DOM树：</strong>浏览器<strong>根据这个html来构建DOM树</strong>，在dom树的构建过程中如果<strong>遇到JS脚本和外部JS连接</strong>，则会<strong>停止构建DOM树和css解析（因为JS有可能修改DOM结构，或者通过改变html元素的字体大小改变css的<a href="https://huanglizhu.github.io/2020/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%883%EF%BC%89/#viewport%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80">rem</a>）来执行和下载相应的代码</strong>，这会造成<strong>阻塞</strong>，这就是为什么<strong>推荐JS代码应该放在html代码的后面</strong>。<ul>
<li>js的解析涉及<strong>同步、异步（宏任务与微任务）</strong>，<a href="https://huanglizhu.github.io/2019/09/27/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/#JS%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88%E5%90%8C%E6%AD%A5%E3%80%81%E5%BC%82%E6%AD%A5%EF%BC%89">事件循环</a></li>
</ul>
</li>
<li><strong>构建CSS对象模型树CSSOM树：</strong>解析html过程中遇到引入了css，则会在解析html的同时解析css，根据外部样式，内部样式，内联样式<strong>构建一个CSS对象模型树CSSOM树</strong></li>
<li><strong>合并为渲染树：</strong> CSSOM树构建完成后<strong>CSSOM树和DOM树合并为渲染树</strong>，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点。</li>
<li>最后浏览器<strong>回流后将渲染树绘制到屏幕上显示</strong>。这个过程比较复杂，涉及到两个概念: <strong>reflow(回流)和repain(重绘)</strong><ul>
<li><strong><a href="https://huanglizhu.github.io/2019/09/27/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/#%E6%B5%8F%E8%A7%88%E5%99%A8-reflow-%E5%9B%9E%E6%B5%81-%E5%92%8Crepain-%E9%87%8D%E7%BB%98">回流</a>：</strong>会引起<strong>元素位置&#x2F;内容变化、布局、隐藏</strong>的就会**reflow(回流)**，如：窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置。</li>
<li><strong><a href="https://huanglizhu.github.io/2019/09/27/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/#%E6%B5%8F%E8%A7%88%E5%99%A8-reflow-%E5%9B%9E%E6%B5%81-%E5%92%8Crepain-%E9%87%8D%E7%BB%98">重绘</a>：不会引起位置、布局变化，只是影响元素的外观的</strong>，比如改变背景颜色等，只会**repaint(重绘)**。</li>
</ul>
</li>
<li><strong>注意:<strong>在dom树的构建过程&#x2F;渲染树的</strong>渲染过程中</strong>如果<strong>遇到JS脚本和外部JS连接</strong>，则会<strong>停止渲染（因为JS有可能修改DOM结构，或者通过改变html元素的字体大小改变css的<a href="https://huanglizhu.github.io/2020/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%883%EF%BC%89/#viewport%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80">rem</a>）来执行和下载相应的代码</strong>，这会造成<strong>阻塞</strong>，这就是为什么<strong>推荐JS代码应该放在html代码的后面</strong>。<ul>
<li>总结代码放置顺序：CSS HTML JS</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>另外的HTTP请求：</strong> html文件中会含有 图片、视频、音频、js、jquery、css等其他资源，这些又是另外的HTTP请求。在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，可能会通过一个网页产生很多的HTTP请求，<strong>请求越少性能越好</strong>。</li>
<li>为提高性能要关注<strong>缓存</strong>（强缓存和协商缓存），缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 <ul>
<li>Cache-Control和Expires的区别在于Cache-Control使用<strong>相对时间</strong>，Expires使用的是基于服务器 端的<strong>绝对时间</strong>，因为存在时差问题，一般采用Cache-Control。</li>
<li>在请求这些有设置了缓存的数据时，如是<strong>强缓存，则不发送请求，直接从缓存中获取数据</strong>。</li>
<li>如是<strong>协商缓存</strong>，则会<strong>发送请求到服务器</strong>，如果上一次 响应设置了ETag值，则会在这次请求的时候作为If-None-Match的值交给服务器<strong>校验</strong>，如果一致，继续校验客户端发送的IF-Modified-Since与服务端的 Last-Modified是否一致，没有设置ETag则直接验证Last-Modified，<strong>都一致则返回304（Not Changed）告知浏览器可以直接从缓存获取，否则返回最新的资源内容</strong>。</li>
</ul>
</li>
<li><strong>连接结束：</strong><ul>
<li>浏览器请求的资源已经被服务器完全发送给浏览器时，浏览器会进行 <strong>TCP 四次挥手，释放 TCP 连接</strong><ol>
<li>客户端向服务器发送 FIN 报文，表示客户端不再发送数据。</li>
<li>服务器收到 FIN 报文，向客户端发送 ACK 报文，表示服务器已经接收到客户端的 FIN 报文。</li>
<li>服务器向客户端发送 FIN 报文，表示服务器不再发送数据。</li>
<li>客户端收到 FIN 报文，向服务器发送 ACK 报文，表示客户端已经接收到服务器的 FIN 报文。</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="cookie相关"><a href="#cookie相关" class="headerlink" title="cookie相关"></a>cookie相关</h1><ul>
<li>cookie有哪些编码方式：encodeURI（）</li>
<li><strong>补充说明一下cookie的作用</strong>：<ul>
<li><strong>保存用户登录状态</strong>。例如将<strong>用户id</strong>存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。</li>
<li>cookie还可以<strong>设置过期时间</strong>，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户<strong>保持登录状态的时间</strong>：常见选项有一个月、三个 月、一年等。</li>
<li><strong>跟踪用户行为</strong>。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够<strong>记住上一次访问的地区</strong>，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。</li>
<li>如果网站提供了换肤或更换布局的功能，那么<strong>可以使用cookie来记录用户的选项，例如：背景色、分辨率等</strong>。当用户下次访问时，仍然可以<strong>保存上一次访问的界面风格</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="cookie有哪些字段可以设置"><a href="#cookie有哪些字段可以设置" class="headerlink" title="cookie有哪些字段可以设置"></a>cookie有哪些字段可以设置</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-cookies.html">例子</a></li>
<li><strong>name字段</strong>：一个<strong>cookie的名称</strong>。</li>
<li><strong>value字段</strong>：一个<strong>cookie的值</strong>。</li>
<li><strong>Size字段</strong>：此<strong>cookie大小</strong>。</li>
<li><strong>domain字段</strong>：可以访问此cookie的<strong>域名</strong>。<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfijoy3cg6j30k005s436.jpg" alt="域名图示"><ul>
<li><strong>非顶级域名</strong>，如二级域名或者三级域名，设置的cookie的domain <strong>只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie</strong>，否则cookie无法生成。<ul>
<li><strong>二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie</strong>。所以要想cookie在多个二级域名中共享，需要<strong>设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值</strong>了。</li>
</ul>
</li>
<li><strong>顶级域名：只能设置domain为顶级域名</strong>，不能设置为二级域名或者三级域名，否则cookie无法生成。<ul>
<li><strong>顶级域名只能获取到domain设置为顶级域名的cookie</strong>，其他domain设置为二级域名的无法获取。</li>
</ul>
</li>
</ul>
</li>
<li><strong>path字段</strong>：可以访问此cookie的<strong>页面路径</strong>。比如domain是abc.com,path是&#x2F;test，那么只有&#x2F;test路径下的页面可以读取此cookie。</li>
<li><strong><a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-cookies.html">expires</a>&#x2F;Max-Age 字段</strong>：此<strong>cookie超时时间</strong>。若设置其值为一个时间，那么当到达此时间后，此cookie失效。<strong>不设置的话默认值是Session，意思是cookie会和session一起失效</strong>。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。<ul>
<li><strong>注意：</strong>其实在浏览器关闭后，session并没有失效，正常来说一个session的存活时间是30分钟，也就是在不操作这个session的情况下，30分钟自动清除。可是实际中浏览器关闭，设置的session也会随之消失，<strong>这里的消失是指你找不到这个session</strong>，不是他没有了，因为<strong>在浏览器重新打开时，浏览器总会自动给你创建一个的新的session</strong>。session并不是唯一的，<strong>每个session都有自己的一个专属sessionId，这个sessionId在浏览器打开时创建，保存在浏览器的cookie中，浏览器关闭，cookie自动清除，sessionId丢失，之前的session找寻不到</strong>！</li>
</ul>
</li>
<li><strong>http字段</strong>：cookie的<strong>httponly属性</strong>。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。（即禁止javascript脚本来访问cookie）</li>
<li><strong>secure 字段</strong>：设置是否<strong>仅在请求为https的时候传递此条cookie</strong></li>
</ul>
<hr>
<h2 id="cookie如何防范XSS攻击"><a href="#cookie如何防范XSS攻击" class="headerlink" title="cookie如何防范XSS攻击"></a>cookie如何防范XSS攻击</h2><ul>
<li>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本</li>
<li>在<strong>HTTP头部配上HttpOnly</strong>（后端通过<code>set-cookie:httponly</code>，前端通过<code>document.cookie = &quot;cookieName=cookieValue; HttpOnly&quot;;</code>这样设置），禁止javascript脚本来访问cookie。严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。（在node中的设置方法可参考<a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#%E7%BB%99cookie%E5%81%9A%E9%99%90%E5%88%B6">博客项目登录（cookie）</a>）</li>
<li><strong>设置cookie的secure属性为<code>secure:true</code></strong>,告诉浏览器<strong>仅在请求为https的时候发送cookie</strong></li>
</ul>
<hr>
<h3 id="XSS和csrf网络攻击"><a href="#XSS和csrf网络攻击" class="headerlink" title="XSS和csrf网络攻击"></a>XSS和csrf网络攻击</h3><ul>
<li><strong>区别：</strong> XSS是利用用户对指定网站的信任，CSRF是利用网站对用户的信任。</li>
</ul>
<h4 id="XSS与防范"><a href="#XSS与防范" class="headerlink" title="XSS与防范"></a>XSS与防范</h4><ul>
<li><strong>XSS</strong>：<strong>跨站脚本攻击</strong>，攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息。<ul>
<li><strong>存储性</strong>（持久型）：用户输入的带有恶意脚本的数据存储在<strong>服务器端</strong>。当浏览器请求数据时，服务器返回脚本并执行。主要是通过html标签注入，篡改网页，插入恶意的脚本，<strong>前端可能没有经过严格的校验直接就进到数据库</strong>，数据库又通过前端程序又回显到浏览器。<ul>
<li>比如：攻击者在社区或论坛上写下一篇包含恶意 Js代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</li>
</ul>
</li>
<li><strong>反射型</strong>（非持久型）：把用户输入的数据”反射”给<strong>浏览器</strong>。通常是，用户点击链接或提交表单时，攻击者向用户访问的网站注入恶意脚本。<ul>
<li>比如：在正常页面上添加一个恶意链接。恶意链接的地址指向localhost:8080。然后攻击者有一个node服务来处理对localhost:8080的请求:当用户点击恶意链接时，页面跳转到攻击者预先准备的localhost:8080页面，执行了 恶意的js 脚本，产生攻击。</li>
</ul>
</li>
</ul>
</li>
<li><strong>XSS预防</strong> : <strong>前端在显示时替换，后端在存储时替换</strong>，都做总不会有错(可参考<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#Cookie%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83XSS%E6%94%BB%E5%87%BB">XSS网络攻击及防范</a>)<ol>
<li><strong>替换特殊字符</strong>，如<code>&lt;</code>变为<code>&amp;lt；</code> <code>&gt;</code>变为<code>&amp;gt</code>,<code>&lt;script&gt;</code>变为<code>&amp;lt；script&amp;gt；</code>直接显示，而<strong>不会作为脚本执行</strong>(实际工作中可使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/xss">XSS工具</a>)<ul>
<li>例子：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb4suzlej30oh05uaeb.jpg" alt="前端在显示时替换特殊字符"><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwb58vn0lj30fa08bjt9.jpg" alt="显示效果">特殊字符在html中会<strong>被浏览器解析</strong>显示为相应的符号，<strong>故script以字符串形式显示，不会作为脚本执行</strong></li>
</ul>
</li>
<li>在<strong>HTTP头部配上HttpOnly</strong>（后端通过<code>set-cookie:httponly</code>，前端通过<code>document.cookie = &quot;cookieName=cookieValue; HttpOnly&quot;;</code>这样设置）,禁止javascript脚本来访问cookie。严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。（在node中的设置方法可参考<a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#%E7%BB%99cookie%E5%81%9A%E9%99%90%E5%88%B6">博客项目登录（cookie）</a>）</li>
<li><strong>设置cookie的secure属性为<code>secure:true</code></strong>,告诉浏览器<strong>仅在请求为https的时候发送cookie</strong></li>
</ol>
</li>
<li><strong>XSS工具</strong>：替换特殊字符可使用<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/xss">XSS工具</a><ul>
<li><strong>node使用XSS</strong>的方法可参考博客：<a href="https://huanglizhu.github.io/2020/03/03/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%AE%89%E5%85%A8/#xss%E6%94%BB%E5%87%BB%EF%BC%88xss%E5%BA%93%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%EF%BC%89%EF%BC%89">博客项目安全</a></li>
<li><strong>前端使用XSS</strong>的方法可参考官方例子：<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfwbfb4srkj30u30al0u0.jpg" alt="参考官方例子"></li>
</ul>
</li>
</ul>
<h4 id="CSRF与防范"><a href="#CSRF与防范" class="headerlink" title="CSRF与防范"></a>CSRF与防范</h4><ul>
<li><strong>CSRF</strong>：<strong>跨站请求伪造</strong>，攻击者借助用户的 Cookie 骗取服务器的信任，以用户名义伪造请求发送给服务器。如：在请求的url后加入一些恶意的参数。换句话说，<strong>CSRF就是利用用户的登录态发起恶意请求</strong>。</li>
<li>比如：你登录网站，并在本地存下了cookie，如果在没退出该网站的时候不小心访问了恶意网站，而且这个网站需要你发一些请求等，此时，你是携带cookie进行访问的，那么你的存在cookie里的信息就会被恶意网站捕捉到，那么你的信息就被盗用，导致一些不法分子做一些事情。</li>
<li>假设某银行网站A以GET请求来发起转账操作，转账的地址为<code>www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000</code>，参数accountNum表示转账的账户，参数money表示转账金额。而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：<code>&lt;img src=&quot;http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000&quot;&gt;</code></li>
<li>当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块…（上述只是举例，转账怎么可能是get请求，为了保险，肯定是post请求，更何况银行的交易付款会有登录密码和支付密码等一系列屏障，流程复杂得多，安全系数也高得多）</li>
<li><strong>防御</strong>：<ol>
<li><strong>使用token验证</strong>：在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，若请求无 token 或者 token 不正确，则认为可能是 CSRF 攻击而拒绝该请求。<ul>
<li>每次请求时 CSRF Token 都是不同的，一般由后端生成后set-cookie设置到cookie中，前端就会在请求时通过cookie带上。(<a target="_blank" rel="noopener" href="http://www.manongjc.com/detail/9-aymgksshxqyawjp.html">例子</a>)</li>
<li><strong>例子：</strong><ul>
<li>比如有个网站，点赞是 get 方式请求：<code>http://www.xxxx.com/like?id=12365</code></li>
<li>如果没有验证 token 的话，我只要随便在某个网页发个图，图片地址设置这个 url，对方只要访问这个页面，加载这个图，对方就会自动给 id 为 12365 的帖子点赞了。</li>
<li>如果验证 token，点赞的 get 的可能就是这种：<code>http://www.xxxx.com/like?id=12365&amp;token=A23F267AE65</code>，由于每个人的 token 是变化的，你无法预先知道对方的 token，对方加载了 <code>http://www.xxxx.com/like?id=12365  </code>，也不会成功</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查https头部的Referer</strong>：在HTTP头中有一个字段叫做Referer,它记录了该HTTP请求的来源地址。通过Referer Check,可以检查是否来自合法的”源”。<ul>
<li>例如：从<code>www.user.com</code>发起的删帖请求，那么Referer值是<code>http://www.user.com</code>, 删帖请求应该被允许；而如果是从CSRF攻击者构造的页面<code>www.attack.com</code>发起删帖请求， 那么Referer值是<code>http://www.attack.com</code>, 删帖请求应该被阻止。</li>
</ul>
</li>
<li><strong>验证码</strong>：验证码会强制用户必须与应用进行交互，才能完成最终请求，但是也不能给网站所有的操作都加上验证码，所以只能作为防御 CSRF 的一种辅助手段，而不能作为最终的解决方案。</li>
<li><strong>使用post接口</strong>：img这些跨域只能接收get请求，设计post请求的需要server端的允许</li>
</ol>
</li>
</ul>
<hr>
<h2 id="cookie之外的存储方式"><a href="#cookie之外的存储方式" class="headerlink" title="cookie之外的存储方式"></a>cookie之外的存储方式</h2><p>还有localStorage，sessionStorage，indexdDB等</p>
<hr>
<h3 id="cookie、sessionStorage、localStorage区别"><a href="#cookie、sessionStorage、localStorage区别" class="headerlink" title="cookie、sessionStorage、localStorage区别"></a>cookie、sessionStorage、localStorage区别</h3><ul>
<li><strong>共同点</strong>：都<strong>保存在浏览器端</strong>。</li>
<li><strong>区别：</strong><ol>
<li><strong>生命周期</strong>：<ul>
<li>Cookie：<strong>设置的cookie过期时间之前一直有效</strong>，即使窗口或浏览器关闭。未设置则<strong>默认为关闭浏览器后失效</strong>。(<strong>不是浏览器标签页</strong>，而是整个浏览器)</li>
<li>Localstorage:除非被手动清除，否则<strong>永久保存</strong>，窗口或浏览器关闭也一直保存，因此<strong>用作持久数据</strong>。</li>
<li>Sessionstorage：<strong>仅在当前网页会话下有效</strong>，关闭<strong>页面或浏览器</strong>后就会被清除（刷新页面不会被清除），自然也就不可能持久保持。</li>
</ul>
</li>
<li><strong>存放数据</strong>：<ul>
<li>Cookie：4k左右（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下）</li>
<li>Localstorage和sessionstorage：可以保存5M的信息</li>
</ul>
</li>
<li><strong>是否跟随http请求发送出去</strong>：<ul>
<li>Cookie：<strong>每次都会携带在http头中</strong>，如果使用cookie保存过多数据会带来性能问题</li>
<li>其他两个：<strong>不会自动把数据发给服务器，仅在客户端即浏览器中保存</strong>，不参与和服务器的通信</li>
</ul>
</li>
<li><strong>API易用性</strong>：<ul>
<li>Cookie：需要程序员自己封装（<a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-cookies.html">例子</a>），原生的cookie接口不友好（<a target="_blank" rel="noopener" href="https://www.runoob.com/js/js-cookies.html">document.cookie</a>）</li>
<li>其他两个：即可采用原生接口（<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/prop-win-sessionstorage.html">getItem、setItem、removeItem、clear</a>），亦可再次封装</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>从安全性来说，因为每次http请求都回携带cookie信息，这样子浪费了带宽，<strong>所以cookie应该尽可能的少用</strong>，此外cookie还需要指定作用域，<strong>不可以跨域调用</strong>，限制很多，但是<strong>对于用户识别用户登陆来说，cookie还是比storage好用</strong><ul>
<li>cookie检查登录状态：<ul>
<li>前提须知：cookie会通过每个请求携带传输给后端，后端set-cookie设置的cookie在后续同源请求中会自动携带</li>
<li>登录后，后端将sessionId作为uId传给前端cookie中，每次请求中（包括isLogin请求），后端都可以通过cookie中携带的uId到session中读取相关数据判断登录与否决定返回数据&#x2F;是否处理请求</li>
<li>cookie有效期也由后端set-cookie控制，前端进入每个页面前通过isLogin接口来判断登录状态（该接口不需要另外传参，后端通过cookie就处理了）</li>
<li>进入每个页面之前，前端可调用isLogin接口判断登录与否（vue的route.js中设置了app.router.beforeEach做处理，除了登录页其他都先走isLogin接口判断，无登录则跳转login页）</li>
</ul>
</li>
</ul>
</li>
<li>其他情况下可以用storage，<strong>localstorage可以用来在页面传递参数</strong></li>
<li><strong>sessionstorage可以用来保存一些临时的数据</strong>，防止用户刷新页面后丢失了一些参数。</li>
</ul>
</li>
<li><strong>作用域：</strong><ul>
<li>每个浏览器都会维护自己的存储空间，不会共享</li>
<li>cookie和localStorage：在<strong>同一个浏览器窗口所有同源窗口</strong>中都是共享的<ul>
<li><strong>跨域共享：</strong><ul>
<li>cookie 可以通过设置<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#cookie%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE"><strong>Domian 属性</strong></a> 指定在哪些域之间共享（同一域和<strong>子域</strong>）</li>
<li>sessionStorage &#x2F; localStorage 要跨域则要使用特定的跨域策略，如跨域存储技术&#x2F;<code>document.domiain</code></li>
</ul>
</li>
</ul>
</li>
<li>sessionStorage：在<strong>同一个浏览器页签访问同源页面</strong>是共享的（同一浏览器同源两个页签之间也不共享）<ul>
<li>比如访问<code>www.example.com/home</code>然后跳转<code>www.example.com/rule</code>，他俩是共享的</li>
</ul>
</li>
<li>关于<strong>同源</strong>可参考<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">阮一峰</a>，简单来说就是A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓 <strong>“同源”指的是”三个相同”</strong><ol>
<li><strong>协议</strong>相同</li>
<li><strong>域名</strong>相同</li>
<li><strong>端口</strong>相同</li>
</ol>
</li>
<li>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，<strong>协议</strong>是<code>http://</code>，<strong>域名</strong>是<code>www.example.com</code>，<strong>端口</strong>是<code>80</code>（默认端口可以省略）。它的同源情况如下。<ol>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h2><ol>
<li><strong>cookie数据</strong>存放在客户的<strong>浏览器</strong>上，**<a href="https://huanglizhu.github.io/2020/02/26/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88session%E3%80%81redis%EF%BC%89/#session-%E4%BB%8B%E7%BB%8D">session</a><strong>数据放在</strong>服务器**上。（session可以存放于文件，数据库，内存中）</li>
<li><strong>cookie不是很安全</strong>，server端可以修改cookie并返回给浏览器，浏览器中也可以通过javascript修改cookie（有限制）。别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，<strong>考虑到安全应当使用session</strong>。server端放置信息不会被前端获取到，<strong>更安全</strong>。且server端空间大，<strong>可存储更多信息</strong>。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用redis。</li>
<li><strong>单个cookie</strong>保存的数据<strong>不能超过4K</strong>，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>Cookie的最大的作用就是存储sessionId（或者userId、uId之类的，名字不一样，作用都一样）用来唯一标识用户。也可存放不敏感的信息，比如用户设置的<strong>网站主题、地区</strong>。</li>
</ol>
<h3 id="node操作cookie"><a href="#node操作cookie" class="headerlink" title="node操作cookie"></a>node操作cookie</h3><ul>
<li>可参考<a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#%E8%8E%B7%E5%8F%96cookie">博客项目登录（cookie）</a></li>
<li><strong>注意：</strong>当浏览器收到带有 Set-Cookie 头的 HTTP 响应时，它会将该 Cookie 存储在浏览器中。然后，<strong>对于同一域名和路径的后续请求，浏览器会自动在请求头中添加相应的 Cookie 信息</strong><ul>
<li>前提：响应中的 Set-Cookie 头设置了有效的 Cookie 值和属性，例如名称、值、过期时间、路径等。</li>
<li>一般会存一个uid：账号id，通过这个识别不同的用户发出的请求</li>
</ul>
</li>
<li><strong>获取cookie：</strong>可通过<code>req.headers.cookie</code>获取到cookie <strong>（req是http请求）</strong></li>
<li><strong>操作cookie：</strong> <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(`Set-Cookie`,`<span class="attribute">username</span>=<span class="variable">$&#123;data.username&#125;</span>; <span class="attribute">path</span>=/`);</span><br></pre></td></tr></table></figure></li>
<li><strong><a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#%E7%BB%99cookie%E5%81%9A%E9%99%90%E5%88%B6">设置httponly预防XSS攻击</a>：</strong><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(`Set-Cookie`,`httpOnly`)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
<li><strong><a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#%E8%AE%BE%E7%BD%AEcookie%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4%EF%BC%88expires%EF%BC%89">设置cookie过期时间</a>：</strong>完整代码在“博客项目登录（cookie）”中<ol>
<li><code>const d = new Date();</code></li>
<li><code>d.setTime(d.getTime()+(24*60*60*1000));</code>（<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/js/jsref_getTime.asp">getTime()</a>、<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/js/jsref_setTime.asp">setTime()</a>）</li>
<li><code>d.toUTCString()</code>根据格林威治时间 (GMT) 把 Date 对象转换为字符串</li>
<li><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.setHeader(`Set-Cookie`,`expires=$&#123;d.toUTCString()&#125;`)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h3 id="node操作session"><a href="#node操作session" class="headerlink" title="node操作session"></a>node操作session</h3><ul>
<li>可参考<a href="https://huanglizhu.github.io/2020/02/26/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88session%E3%80%81redis%EF%BC%89/#session-%E4%BB%8B%E7%BB%8D">博客项目登录（session、redis）</a></li>
<li>总的来说，从<code>req.headers.cookie</code>获取cookie后放入<code>req.cookie</code>，如无userId则按日期的毫秒数(<code>Date.now()</code>）和随机数(<code>Math.random()</code>)组成的userId放入cookie(注意Set-Cookie回给客户端)，创建全局变量SESSION_DATA，创建空对象<code>SESSION_DATA[userId]=&#123;&#125;</code>，最后把<code>req.session=SESSION_DATA[userId]</code>。接下来登录后把username等信息放入<code>req.session</code>中即存储成功。</li>
<li><strong>koa2操作session：</strong><ul>
<li>完整例子可参考<a href="https://huanglizhu.github.io/2020/03/12/redis%E3%80%81session%E4%B8%8Ejest%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#koa2%E4%BD%BF%E7%94%A8session">redis、session与jest基本使用方法</a></li>
<li><strong>与node的区别：</strong><ul>
<li>使用插件后就<strong>不需要自己去创建cookie和session以及设置他们之间的联系</strong>了，插件配置好session和cookie相关信息后，<strong>每次发送http请求时会自动创建符合要求的cookie给服务端</strong>，服务端<strong>直接设置<code>ctx.session</code>来存储存储用户名和密码等信息</strong>即可。下次用户再访问网页时，服务端就可通过用户请求中的cookie值去获取session对象，进行判断<strong>（服务端不用自己管理cookie，直接用session即可）</strong>。</li>
</ul>
</li>
<li>安装<strong>koa-generic-session插件</strong>：koa <strong>生成session</strong>的一个工具<ul>
<li><a href="https://huanglizhu.github.io/2020/03/07/koa2%E9%87%8D%E6%9E%84%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/#app-js%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6-%E9%85%8D%E7%BD%AEsession%E5%92%8Credis">session配置中</a>可以<strong>设置cookie相关字段</strong>，配置好后，每次用户发送http请求时，都会创建一个符合配置关键词前缀的cookie，根据用户请求中的cookie获取session数据</li>
</ul>
</li>
<li>使用插件完成session配置后，可以从**<code>ctx.session</code>获取session**</li>
<li><strong>流程：</strong>用户每次访问网页时就会创建一个 符合<a href="https://huanglizhu.github.io/2020/03/12/redis%E3%80%81session%E4%B8%8Ejest%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/#koa2%E4%BD%BF%E7%94%A8session">session配置中</a>前缀的cookie(cookie对象的属性值是session对象的对象名)，然后服务端会有一系列操作往session中存储用户名和密码等，那么下次用户再访问网页时，服务端就可通过用户请求中的cookie值去获取session对象，进行判断</li>
</ul>
</li>
</ul>
<hr>
<h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h2 id="怎么看网站的性能如何"><a href="#怎么看网站的性能如何" class="headerlink" title="怎么看网站的性能如何"></a>怎么看网站的性能如何</h2><p>检测页面加载时间一般有两种方式</p>
<ol>
<li>一种是<strong>被动去测</strong>：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析</li>
<li>另一种<strong>主动监测</strong>的方式，即<strong>主动的搭建分布式受控环境</strong>，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说<strong>性能极客</strong></li>
</ol>
<hr>
<h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><ul>
<li>可参考<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">JS 运行环境</a></li>
<li><strong>加快请求速度</strong>：<a href="https://huanglizhu.github.io/2020/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%883%EF%BC%89/#%E8%AF%B4%E4%B8%80%E4%B8%8Bweb-worker">web worker多线程</a>，react中<a href="https://huanglizhu.github.io/2020/04/14/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%88%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89/#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6%EF%BC%88%E6%87%92%E5%8A%A0%E8%BD%BD%EF%BC%89">异步组件（懒加载）</a> <ol>
<li><strong>减少资源体积：压缩代码</strong><ul>
<li>比如使用<strong>webpack在production环境下</strong>进行打包时，就会<strong>自动压缩代码</strong>至1&#x2F;3的大小，在浏览器上进行反解析再进行渲染。</li>
</ul>
</li>
<li><strong>减少访问次数</strong>：<ul>
<li><a href="https://huanglizhu.github.io/2019/12/06/CSS%E9%9D%9E%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F%EF%BC%9A%E8%83%8C%E6%99%AF/#%E9%9B%AA%E7%A2%A7%E5%9B%BE">雪碧图</a></li>
<li><strong>合并代码</strong>：比如webpack中，在index.js中引入a.js、b.js，打包后只生成一个bundle.js，这就是合并代码。（加载3次3kb的文件不如加载1次9kb快，这<strong>和网络请求有关系</strong>）</li>
<li><strong>SSR服务器端渲染</strong>：不需要通过ajax发送请求。</li>
<li><strong>缓存</strong>：原本需要发送多个请求的数据直接在缓存中获取即可减少访问次数。<ul>
<li>离线数据缓存localStorage。</li>
<li><strong>尽量命中强缓存</strong>，结合<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E7%BC%93%E5%AD%98">webpack的内容哈希值输出文件名</a>，减少http请求。（具体见下方<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">“前端缓存最佳实践”</a>）</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用更快的网络：CDN</strong><ul>
<li>CDN是<strong>分区域</strong>的，也就是使用CDN的时候上海和北京对同一个网站的IP地址是不同的。<strong>CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求</strong>，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了</li>
<li><strong>图片、js等静态资源</strong>采用CDN是很快的，我们经常使用的<strong>bootstrap就是使用的CDN</strong></li>
</ul>
</li>
</ol>
</li>
<li><strong>渲染</strong>：<ul>
<li><strong>CSS放在head中，JS放在body最下面</strong></li>
<li><strong>尽早开始执行JS</strong>，用<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#window-onload%E5%92%8CDOMContentLoaded">DOMContentLoaded</a>触发</li>
<li>**<a href="https://huanglizhu.github.io/2020/02/07/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%883%EF%BC%89/#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD">懒加载</a>**（图片懒加载，上滑加载更多）</li>
<li>对<strong>DOM查询进行缓存</strong>（DOM操作很耗性能）</li>
<li>**频繁DOM操作，<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E5%A4%9A%E4%B8%AADOM%E6%93%8D%E4%BD%9C%E5%90%88%E5%B9%B6">合并</a>**到一起插入DOM结构</li>
<li>让渲染更流畅：**<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E8%8A%82%E6%B5%81-throttle">节流throttle</a> <a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E9%98%B2%E6%8A%96-debounce">防抖debounce</a>**</li>
</ul>
</li>
<li><strong>减少回流、重绘：</strong><ul>
<li>**<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E5%A4%9A%E4%B8%AADOM%E6%93%8D%E4%BD%9C%E5%90%88%E5%B9%B6">合并DOM操作</a>**：比如我们要向页面添加多个img元素，如果单独加进去就会频繁的回流+重绘，此时我们就可以使用<code>document.createDocumentFragment()</code>将多个img合并到Fragment中再统一加入。</li>
<li><strong>避免频繁读取会引发回流&#x2F;重绘的属性(见上)<strong>，如果确实需要多次使用，就用一个</strong>变量缓存</strong>起来。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上，对具有<strong>复杂动画的元素</strong>使用<strong>绝对定位</strong>，使它<strong>脱离文档流</strong>，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="说一下浏览器缓存"><a href="#说一下浏览器缓存" class="headerlink" title="说一下浏览器缓存"></a>说一下浏览器缓存</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Aaron1Tall/p/11041884.html">前端缓存</a><br><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfgcemkhr3j30m80h1q73.jpg" alt="image.png"></p>
<hr>
<h2 id="强缓存和协商缓存（web性能优化）"><a href="#强缓存和协商缓存（web性能优化）" class="headerlink" title="强缓存和协商缓存（web性能优化）"></a>强缓存和协商缓存（web性能优化）</h2><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yehuozhili/article/details/103268433">nodejs实现强缓存和协商缓存</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/111190645">图解流程详解</a>、<a target="_blank" rel="noopener" href="http://caibaojian.com/browser-cache.html">参考</a>、<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008956069">参考1</a>&#x2F;<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9c95db596df5">参考2</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52916788">前端缓存最佳实践</a>、<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73345909">DNS缓存、CDN缓存、浏览器缓存</a></li>
<li>缓存是<strong>Web性能优化的重要方式</strong>。</li>
<li>缓存分为两种：强缓存和协商缓存，<strong>根据 响应 的header内容来决定</strong>。<ul>
<li>其实请求头也可以设置一点辅助效果，但主要还是要靠请求头，具体看下方“主响应头 辅请求头”</li>
</ul>
</li>
<li><strong>注意：强缓存也会有状态码，是200</strong></li>
<li><strong>区别：</strong>如果浏览器命中<strong>强缓存</strong>，则<strong>在设置好的失效时间内不需要给服务器发请求</strong>；而<strong>协商缓存</strong>最终<strong>由服务器来决定是否使用缓存</strong>，即客户端与服务器之间<strong>存在一次通信</strong>。</li>
<li>总之，<strong>强缓存就是强制从缓存中读取，不管是否更新。而协商缓存就是和 服务器协商是否从缓存取，如有更新则返回新数据。</strong><br><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfg5rybbgxj30q108paaj.jpg" alt="image.png"></li>
<li><strong>强缓存</strong>是利用<strong>http的返回（响应）头中的Expires或者Cache-Control两个字段</strong>来控制的，用来<strong>表示资源的缓存时间</strong>。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。<ul>
<li><strong>Expires</strong>是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串。缺点：由于<strong>失效时间是一个绝对时间</strong>，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</li>
<li><strong>Cache-Control</strong>是http1.1时出现的header信息，主要是利用该字段的<strong>max-age值</strong>来进行判断，它是一个<strong>相对时间</strong>，例如<strong>Cache-Control:max-age&#x3D;3600</strong>，代表着资源的有效期是3600秒。<ul>
<li>Cache-Control除了max-age还有以下<strong>常用字段</strong>：<ul>
<li><strong>no-cache：不使用本地缓存</strong>。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li>
<li><strong>no-store：直接禁止浏览器缓存数据</strong>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li>
<li><strong>public：可以被所有的用户缓存</strong>，包括终端用户和CDN等中间代理服务器。</li>
<li><strong>private（默认）：只能被终端用户的浏览器缓存</strong>，不允许CDN等中继缓存服务器对其缓存。</li>
<li><img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gfgaikdwasj30kv0i112g.jpg" alt="Cache-Control"><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9c95db596df5">图解参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>协商缓存</strong>相关字段有 <strong>http响应头中的Last-Modified&#x2F;请求头中的If-Modified-Since，http响应头中的Etag&#x2F;请求头中的If-None-Match</strong>（<a target="_blank" rel="noopener" href="https://blog.csdn.net/lhl1124281072/article/details/80067764">具体参考</a>）<img src="https://i0.wp.com/ww1.sinaimg.cn/large/005H7IVsgy1gkup59bjmvj30u009igmt.jpg" alt="协商缓存"><ul>
<li><strong>通过响应头的2个字段 设置协商缓存：</strong><ul>
<li><strong>etag</strong>：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。</li>
<li><strong>last-modified</strong>：文件的修改时间，精确到秒</li>
</ul>
</li>
</ul>
</li>
<li><strong>浏览器在第一次请求发生后，再次请求时</strong>：<ul>
<li>浏览器会先获取该资源缓存的header信息，<strong>根据其中的expires和cahe-control</strong>判断<strong>是否命中强缓存</strong>，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；</li>
<li><strong>如果没有命中强缓存</strong>，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（IF-Modified-Since、IF-None-Match，这2个字段值是上次响应头中的Last-Modified和Etag保存而来）,由服务器根据请求中的相关header信息来<strong>对比结果是否命中协商缓存</strong>。</li>
<li><strong>若命中协商缓存</strong>，则服务器返回新的响应header信息（Last-Modified和Etag）更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取（304）；否则返回最新的资源内容（Last-Modified和Etag以及200状态码）</li>
</ul>
</li>
<li><strong>访问缓存优先级</strong><ul>
<li>先在<strong>内存</strong>中查找,如果有,直接加载。</li>
<li>如果内存中不存在,则在硬盘中查找,如果有直接加载。</li>
<li>如果<strong>硬盘</strong>中也没有,那么就进行<strong>网络请求</strong>。</li>
<li>请求获取的资源缓存到硬盘和内存。</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/73345909">DNS缓存、CDN缓存、浏览器缓存</a></li>
<li><strong>补充：后端设置强缓存与协商缓存的方法（<a target="_blank" rel="noopener" href="https://blog.csdn.net/yehuozhili/article/details/103268433">node为例</a>）</strong><ul>
<li><strong>强缓存(10秒有效期）：</strong><ul>
<li><code>res.setHeader(&#39;Expires&#39;,new Date(Date.now()+10*1000).toGMTString())</code></li>
<li><code>res.setHeader(&#39;Cache-Control&#39;,&#39;max-age=10&#39;)</code></li>
</ul>
</li>
<li><strong>协商缓存：</strong><ul>
<li><strong>Last-Modified相关设置：</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端设置Last-Modified后，浏览器请求同一个资源会带if-modified-since的请求头</span></span><br><span class="line"><span class="comment">// 所以服务端还要获取这个请求头的时间进行对比，相等返回304提前关闭请求即可，浏览器会自己去缓存里拿</span></span><br><span class="line">let ctime = 最后一次修改的时间Date对象<span class="selector-class">.toGMTString</span>()</span><br><span class="line">res<span class="selector-class">.setHeader</span>(<span class="string">&#x27;Last-Modified&#x27;</span>,ctime)<span class="comment">//设置</span></span><br><span class="line">let ifModifiedSince =req<span class="selector-class">.headers</span><span class="selector-attr">[<span class="string">&#x27;if-modified-since&#x27;</span>]</span><span class="comment">//获取</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(ifModifiedSince===ctime)</span></span>&#123;</span><br><span class="line">    res.statusCode=<span class="number">304</span></span><br><span class="line">    return res<span class="selector-class">.end</span>()<span class="comment">//直接返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>    - **etag设置：**
</code></pre>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 要稍微复杂点，主要看摘要算法，一般的摘要算法是用md5，由于md5会暴力破解，所以也可以采用sha1或者<span class="built_in">sha256</span>等加盐算法，其中盐值就是相当于自己的一个密码本，要暴力破解必须知道盐值才行。</span><br><span class="line">// 这些算法在nodejs自带的crypto里都有</span><br><span class="line"><span class="keyword">let</span> content = await fs.readFile(currentpath,<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> hash = crypto.createHash(<span class="string">&#x27;md5&#x27;</span>).<span class="keyword">update</span>(content).digest(<span class="string">&#x27;base64&#x27;</span>)</span><br><span class="line"><span class="keyword">res</span>.setHeader(<span class="string">&#x27;Etag&#x27;</span>,hash)</span><br><span class="line"><span class="keyword">let</span> ifNoneMatch =req.headers[<span class="string">&#x27;if-none-match&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span>(ifNoneMatch===hash)&#123;</span><br><span class="line">    <span class="keyword">res</span>.statusCode=<span class="number">304</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">res</span>.end()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="主响应头-辅请求头【待修改】"><a href="#主响应头-辅请求头【待修改】" class="headerlink" title="主响应头 辅请求头【待修改】"></a>主响应头 辅请求头【待修改】</h3><p>请求头中的 <code>Cache-Control</code> 通常用于指示缓存策略的要求，而 <code>max-age</code> 是用于指定资源在缓存中有效的时间长度。尽管在响应头中 <code>Cache-Control: max-age</code> 用于控制缓存的有效期，在请求头中 <code>Cache-Control: max-age</code> 并不是标准用法。下面是详细说明：</p>
<h3 id="请求头中的-Cache-Control-用法"><a href="#请求头中的-Cache-Control-用法" class="headerlink" title="请求头中的 Cache-Control 用法"></a><strong>请求头中的 <code>Cache-Control</code> 用法</strong></h3><ul>
<li><strong><code>Cache-Control: max-age=3600</code></strong> 在请求头中没有标准定义。请求头中的 <code>Cache-Control</code> 通常使用以下值：<ul>
<li>**<code>Cache-Control: no-cache</code>**：要求服务器每次请求都验证缓存的有效性，浏览器会发送请求，即使有缓存。</li>
<li>**<code>Cache-Control: no-store</code>**：禁止缓存，不允许在客户端存储任何缓存。</li>
<li>**<code>Cache-Control: only-if-cached</code>**：浏览器只会使用缓存的资源，如果缓存中没有资源，会返回 <code>504 Gateway Timeout</code> 错误。</li>
<li>**<code>Cache-Control: max-age=0</code>**：指示缓存过期，浏览器应重新请求资源并验证缓存。</li>
</ul>
</li>
</ul>
<h3 id="max-age-的使用"><a href="#max-age-的使用" class="headerlink" title="max-age 的使用"></a><strong><code>max-age</code> 的使用</strong></h3><ul>
<li><p>**响应头中的 <code>max-age</code>**：</p>
<ul>
<li><strong><code>Cache-Control: max-age=3600</code></strong> 在响应头中表示资源在缓存中有效期为 3600 秒（1 小时）。浏览器会在这段时间内使用缓存，不会发起新的网络请求。</li>
</ul>
</li>
<li><p>**请求头中的 <code>max-age</code>**：</p>
<ul>
<li><strong><code>max-age</code></strong> 通常不用于请求头中，因为它是用来指定缓存的存储期限的。请求头中不直接使用 <code>max-age</code>，而是使用其他方式（如 <code>no-cache</code>, <code>no-store</code>）来控制缓存行为。</li>
</ul>
</li>
</ul>
<h3 id="如何控制请求中的缓存"><a href="#如何控制请求中的缓存" class="headerlink" title="如何控制请求中的缓存"></a><strong>如何控制请求中的缓存</strong></h3><p>虽然在请求头中不能直接使用 <code>max-age</code>，可以通过以下方法控制请求中的缓存行为：</p>
<ol>
<li><p>**<code>Cache-Control: no-cache</code>**：</p>
<ul>
<li>强制浏览器每次请求都向服务器验证缓存，即使资源在本地有缓存。</li>
</ul>
</li>
<li><p>**<code>Cache-Control: no-store</code>**：</p>
<ul>
<li>禁止缓存，浏览器不会将请求或响应存储在缓存中。</li>
</ul>
</li>
<li><p>**<code>Cache-Control: max-age=0</code>**：</p>
<ul>
<li>强制浏览器将缓存视为过期，需要重新请求资源以验证缓存。</li>
</ul>
</li>
<li><p>**<code>Cache-Control: only-if-cached</code>**：</p>
<ul>
<li>仅从缓存中获取资源，如果缓存中没有，返回 <code>504 Gateway Timeout</code> 错误。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设你希望每次请求都强制验证缓存是否有效，你可以在请求头中使用：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>no-cache</span><br></pre></td></tr></table></figure>

<p>如果你希望缓存资源每次都重新验证（即使缓存中有资源），也可以使用：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span><span class="punctuation">: </span>max-age=0</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ul>
<li>**请求头中的 <code>Cache-Control</code>**：用于控制如何处理缓存，例如验证缓存是否有效或不允许缓存，但不包括 <code>max-age</code> 的设置。</li>
<li>**响应头中的 <code>Cache-Control: max-age</code>**：用于指定资源在缓存中的有效时间，浏览器根据这个设置来管理缓存的存储。</li>
</ul>
<p>通过正确配置这些头部，你可以有效地控制缓存行为，以适应不同的需求和场景。</p>
<hr>
<h3 id="前端缓存最佳实践"><a href="#前端缓存最佳实践" class="headerlink" title="前端缓存最佳实践"></a>前端缓存最佳实践</h3><ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52916788">前端缓存最佳实践</a>：缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，<strong>最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效</strong>。<ul>
<li><strong>更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在问题了</strong>（webpack打包时会把静态资源的路径加上hash值）</li>
<li>较为合理的缓存方案：<ul>
<li><strong>HTML：使用协商缓存。</strong></li>
<li><strong>CSS&amp;JS&amp;图片：使用强缓存，文件命名带上hash值。</strong></li>
</ul>
</li>
</ul>
</li>
<li>在做前端缓存时，我们<strong>尽可能设置长时间的强缓存</strong>，通过<strong>文件名加hash</strong>的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JavaScript%E5%AD%A6%E4%B9%A0/">JavaScript学习</a>, <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/" rel="tag">JS</a></li></ul>

      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          JS 运行环境
        
      </div>
    </a>
  
  
    <a href="/2020/04/02/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%881%EF%BC%89/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">前端基础-HTTP/HTML/浏览器（1）</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%A6%82%E6%8B%AC"><span class="nav-number">1.1.</span> <span class="nav-text">tcp三次握手，一句话概括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E6%8F%A1%E6%89%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E4%B8%8D%E6%98%AF%E5%9B%9B%E6%AC%A1"><span class="nav-number">1.2.</span> <span class="nav-text">tcp握手为什么是三次不是四次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88tcp%E6%8C%A5%E6%89%8B%E5%8F%AF%E4%BB%A5%E6%98%AF%E4%B8%89%E6%AC%A1-%E5%9B%9B%E6%AC%A1"><span class="nav-number">1.3.</span> <span class="nav-text">为什么tcp挥手可以是三次&#x2F;四次</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8Ctcp%E5%8D%8F%E8%AE%AE%E5%92%8Chttp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">1.4.</span> <span class="nav-text">tcp三次握手和tcp协议和http协议的关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.5.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%9B%BE%E7%89%87url%E8%AE%BF%E9%97%AE%E5%90%8E%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.</span> <span class="nav-text">一个图片url访问后直接下载怎样实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8HTML5%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.1.</span> <span class="nav-text">使用HTML5实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%91%88%E7%8E%B0%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.</span> <span class="nav-text">地址栏输入URL到页面呈现的过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cookie%E7%9B%B8%E5%85%B3"><span class="nav-number">2.</span> <span class="nav-text">cookie相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE"><span class="nav-number">2.1.</span> <span class="nav-text">cookie有哪些字段可以设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83XSS%E6%94%BB%E5%87%BB"><span class="nav-number">2.2.</span> <span class="nav-text">cookie如何防范XSS攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS%E5%92%8Ccsrf%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="nav-number">2.2.1.</span> <span class="nav-text">XSS和csrf网络攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#XSS%E4%B8%8E%E9%98%B2%E8%8C%83"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">XSS与防范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF%E4%B8%8E%E9%98%B2%E8%8C%83"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">CSRF与防范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E4%B9%8B%E5%A4%96%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">2.3.</span> <span class="nav-text">cookie之外的存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie%E3%80%81sessionStorage%E3%80%81localStorage%E5%8C%BA%E5%88%AB"><span class="nav-number">2.3.1.</span> <span class="nav-text">cookie、sessionStorage、localStorage区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie%E5%92%8Csession%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.4.</span> <span class="nav-text">cookie和session的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#node%E6%93%8D%E4%BD%9Ccookie"><span class="nav-number">2.4.1.</span> <span class="nav-text">node操作cookie</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node%E6%93%8D%E4%BD%9Csession"><span class="nav-number">2.4.2.</span> <span class="nav-text">node操作session</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">前端性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E7%9C%8B%E7%BD%91%E7%AB%99%E7%9A%84%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95"><span class="nav-number">3.1.</span> <span class="nav-text">怎么看网站的性能如何</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96"><span class="nav-number">3.2.</span> <span class="nav-text">前端优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%B4%E4%B8%80%E4%B8%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98"><span class="nav-number">3.3.</span> <span class="nav-text">说一下浏览器缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%EF%BC%88web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%89"><span class="nav-number">3.4.</span> <span class="nav-text">强缓存和协商缓存（web性能优化）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%93%8D%E5%BA%94%E5%A4%B4-%E8%BE%85%E8%AF%B7%E6%B1%82%E5%A4%B4%E3%80%90%E5%BE%85%E4%BF%AE%E6%94%B9%E3%80%91"><span class="nav-number">3.4.1.</span> <span class="nav-text">主响应头 辅请求头【待修改】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%AD%E7%9A%84-Cache-Control-%E7%94%A8%E6%B3%95"><span class="nav-number">3.4.2.</span> <span class="nav-text">请求头中的 Cache-Control 用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-age-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.4.3.</span> <span class="nav-text">max-age 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98"><span class="nav-number">3.4.4.</span> <span class="nav-text">如何控制请求中的缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-number">3.4.5.</span> <span class="nav-text">示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.4.7.</span> <span class="nav-text">前端缓存最佳实践</span></a></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
    

                <div class="clearfix container">
                    <div class="site-info">
                        &copy;
                        2025
                            珠 All Rights Reserved.
                                
                                    <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量
                                    <span id="busuanzi_value_site_pv"></span>次
                                    </span>
                                    
                    </div>
                    <div class="site-credit">
                        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
                    </div>
                </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
