<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>前端基础-HTTP/HTML/浏览器（2） | 珠</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="前端,程序员,软件开发,面试,CSS,JavaScript,JS,ES6,HTML,Node.js,React,Vue">
  
  
  
  
  <meta name="description" content="流程tcp三次握手，一句话概括">
<meta name="keywords" content="JS">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础-HTTP&#x2F;HTML&#x2F;浏览器（2）">
<meta property="og:url" content="http://yoursite.com/2020/04/03/前端基础-HTTP HTML 浏览器（2）/index.html">
<meta property="og:site_name" content="珠">
<meta property="og:description" content="流程tcp三次握手，一句话概括">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfcmhhk3a2j30r20suacc.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfijoy3cg6j30k005s436.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfwb4suzlej30oh05uaeb.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfwb58vn0lj30fa08bjt9.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfwbfb4srkj30u30al0u0.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfgcemkhr3j30m80h1q73.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfg5rybbgxj30q108paaj.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfgaikdwasj30kv0i112g.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gkup59bjmvj30u009igmt.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfgn77f2wkj30sf0hggof.jpg">
<meta property="og:updated_time" content="2021-04-26T15:06:06.030Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端基础-HTTP&#x2F;HTML&#x2F;浏览器（2）">
<meta name="twitter:description" content="流程tcp三次握手，一句话概括">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/005H7IVsgy1gfcmhhk3a2j30r20suacc.jpg">
  
    <link rel="alternate" href="/atom.xml" title="珠" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/sx.jpg">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css">
  <link rel="stylesheet" href="/css/fashion.css">
  <link rel="stylesheet" href="/css/glyphs.css">

</head>
</html>


  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


        <header id="allheader" class="site-header" role="banner"  >
                <div class="clearfix container">
                    <div class="site-branding">

                        <h1 class="site-title">
                            
                                    <a href="/" title="珠" rel="home">
                                        珠
                                    </a>
                                    
                        </h1>

                        
                            <div class="site-description">
                                Record every bit of front-end learning.
                            </div>
                            

                                <nav id="main-navigation" class="main-navigation" role="navigation">
                                    <a class="nav-open">Menu</a>
                                    <a class="nav-close">Close</a>

                                    <div class="clearfix sf-menu">
                                        <ul id="main-nav" class="menu sf-js-enabled sf-arrows" style="touch-action: pan-y;">
                                            
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/">
                                                        主页
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/archives">
                                                        归档
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/categories">
                                                        分类
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/tags">
                                                        标签
                                                    </a>
                                                </li>
                                                
                                                <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663">
                                                    <a class="" href="/about">
                                                        关于
                                                    </a>
                                                </li>
                                                
                                        </ul>
                                    </div>
                                </nav>

                    </div>
                </div>
        </header>

  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-前端基础-HTTP HTML 浏览器（2）" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      前端基础-HTTP/HTML/浏览器（2）
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2020/04/03/前端基础-HTTP HTML 浏览器（2）/" class="article-date">
	  <time datetime="2020-04-03T04:29:23.000Z" itemprop="datePublished">四月 3, 2020</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JavaScript学习/">JavaScript学习</a>, <a class="article-category-link" href="/categories/面试题/">面试题</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="tcp三次握手，一句话概括"><a href="#tcp三次握手，一句话概括" class="headerlink" title="tcp三次握手，一句话概括"></a>tcp三次握手，一句话概括</h2><p><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfcmhhk3a2j30r20suacc.jpg" alt="tcp三次握手"></p>
<a id="more"></a>

<ul>
<li>三次握手可以简化为：<strong>C发起 请求连接，S确认 发送给确认响应，C确认并发送HTTP请求</strong></li>
<li>看每次握手的作用：<ol>
<li>第一次握手：S只可以确认自己可以接受C发送的报文段</li>
<li>第二次握手：C可以确认S收到了自己发送的报文段，并且可以确认自己可以接受S发送的报文段</li>
<li>第三次握手：S可以确认C收到了自己发送的报文段</li>
</ol>
</li>
</ul>
<hr>
<h2 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h2><table>
<thead>
<tr>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td><strong>面向连接</strong>的<strong>可靠性传输</strong>（三次握手）</td>
<td><strong>无连接</strong>，即发送数据前不需要先建立链接。</td>
</tr>
<tr>
<td><strong>提供可靠的服务</strong>。通过TCP连接传送的数据，<strong>无差错，不丢失，不重复，且按序到达</strong><br>(因为tcp可靠，面向连接，不会丢失数据因此<strong>适合大数据量的交换</strong>。)</td>
<td>尽最大努力交付，即<strong>不保证可靠交付</strong></td>
</tr>
<tr>
<td>面向<strong>字节流</strong></td>
<td>面向<strong>报文</strong>，且<strong>网络出现拥塞不会使得发送速率降低</strong>（因此会出现丢包，对<strong>实时的应用比如IP电话和视频会议</strong>等）</td>
</tr>
<tr>
<td><strong>TCP只能是1对1</strong></td>
<td>UDP <strong>支持1对1,1对多</strong></td>
</tr>
<tr>
<td>TCP的<strong>首部较大</strong>，为20字节</td>
<td>UDP只有8字节</td>
</tr>
</tbody></table>
<hr>
<h2 id="一个图片url访问后直接下载怎样实现"><a href="#一个图片url访问后直接下载怎样实现" class="headerlink" title="一个图片url访问后直接下载怎样实现"></a>一个图片url访问后直接下载怎样实现</h2><ul>
<li><strong>重点：<a href="https://www.runoob.com/tags/att-a-download.html" target="_blank" rel="noopener"><code>&lt;a&gt;</code>的download 属性</a>定义了下载链接的地址</strong></li>
<li>设置<strong>请求的返回头（HTTP响应报文首部的content-type）</strong>，用于<strong>浏览器解析</strong>的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。</li>
</ul>
<h3 id="使用HTML5实现"><a href="#使用HTML5实现" class="headerlink" title="使用HTML5实现"></a>使用HTML5实现</h3><ul>
<li>HTML5提供的<a href="https://www.runoob.com/html/html5-canvas.html" target="_blank" rel="noopener">Canvas</a>以</li>
<li><a href="https://www.runoob.com/tags/att-a-download.html" target="_blank" rel="noopener"><code>&lt;a&gt;</code>的download 属性</a>定义了下载链接的地址</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/MouseEvent" target="_blank" rel="noopener">MouseEvent()构造器</a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent" target="_blank" rel="noopener">MouseEvent事件</a></li>
<li><strong>注意：如希望 自动触发事件 应使用<a href="https://www.jianshu.com/p/5f9027722204" target="_blank" rel="noopener">dispatchEvent(event)</a>，比<code>xxx.onclick();</code>或<code>xxx.click();</code>好</strong></li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">download<span class="constructor">Iamge(<span class="params">imgsrc</span>, <span class="params">name</span>)</span> &#123;<span class="comment">//下载图片地址和图片名  </span></span><br><span class="line">  <span class="keyword">let</span> image = <span class="keyword">new</span> <span class="constructor">Image()</span>;  </span><br><span class="line">  <span class="comment">// 解决跨域 Canvas 污染问题（允许跨域）  </span></span><br><span class="line">  image.set<span class="constructor">Attribute(<span class="string">"crossOrigin"</span>, <span class="string">"anonymous"</span>)</span>;  </span><br><span class="line">  <span class="comment">// onload 事件在图片加载完成后立即执行</span></span><br><span class="line">  image.onload = <span class="keyword">function</span><span class="literal">()</span> &#123;  </span><br><span class="line">    <span class="keyword">let</span> canvas = document.create<span class="constructor">Element(<span class="string">"canvas"</span>)</span>;  </span><br><span class="line">    canvas.width = image.width;  </span><br><span class="line">    canvas.height = image.height;  </span><br><span class="line">    <span class="keyword">let</span> context = canvas.get<span class="constructor">Context(<span class="string">"2d"</span>)</span>;  <span class="comment">//创建canvas对象</span></span><br><span class="line">    context.draw<span class="constructor">Image(<span class="params">image</span>, 0, 0, <span class="params">image</span>.<span class="params">width</span>, <span class="params">image</span>.<span class="params">height</span>)</span>;  </span><br><span class="line">    <span class="keyword">let</span> url = canvas.<span class="keyword">to</span><span class="constructor">DataURL(<span class="string">"image/png"</span>)</span>; <span class="comment">//得到图片的base64编码数据  </span></span><br><span class="line">    <span class="keyword">let</span> a = document.create<span class="constructor">Element(<span class="string">"a"</span>)</span>; <span class="comment">// 生成一个a元素  </span></span><br><span class="line">    <span class="keyword">let</span> event = <span class="keyword">new</span> <span class="constructor">MouseEvent(<span class="string">"click"</span>)</span>; <span class="comment">// 创建一个单击事件  </span></span><br><span class="line">    a.download = name<span class="operator"> || </span><span class="string">"photo"</span>; <span class="comment">// 设置图片名称  </span></span><br><span class="line">    a.href = url; <span class="comment">// 将生成的URL设置为a.href属性  </span></span><br><span class="line">    a.dispatch<span class="constructor">Event(<span class="params">event</span>)</span>; <span class="comment">// 触发a的单击事件  </span></span><br><span class="line">  &#125;;  </span><br><span class="line">  image.src = imgsrc;  </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="地址栏输入URL到页面呈现的过程"><a href="#地址栏输入URL到页面呈现的过程" class="headerlink" title="地址栏输入URL到页面呈现的过程"></a>地址栏输入URL到页面呈现的过程</h2><p>这是一个必考的面试问题，输入url后，</p>
<ol>
<li><strong>客户端</strong>：<ul>
<li><strong>DNS解析：</strong><ul>
<li>首先需要<strong>找到这个url域名的服务器ip</strong>,为了寻找这个ip，先搜索<strong>浏览器自身的DNS缓存</strong>,如果存在，则域名解析到此完成。</li>
<li>如果浏览器自身的缓存里面没有找到对应的条目，那么会尝试<strong>读取操作系统的hosts文件</strong>看是否存在对应的映射关系,如果存在，则域名解析到此完成。</li>
<li>如果本地hosts文件不存在映射关系，则查找<strong>本地DNS服务器</strong>(ISP服务器,或者自己手动设置的DNS服务器),如果存在,域名到此解析完成。</li>
<li>如果本地DNS服务器还没找到的话,它就会<strong>向根服务器发出请求,进行递归查询</strong>。</li>
</ul>
</li>
<li><strong>建立TCP连接</strong>（三次握手）：<ul>
<li>客户机发送一个<strong>TCP连接请求报文</strong>-》服务器回送一个<strong>TCP确认响应报文</strong>-》客户机向服务器发送一个<strong>包含“HTTP请求”与“TCP确认”的报文</strong></li>
</ul>
</li>
<li><strong>发送http请求</strong>：<ul>
<li>浏览器根据这个ip以及相应的端口号，<strong>构造一个http请求</strong>，这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并<strong>将这个http请求封装在一个tcp包中</strong>，这个tcp包会依次经过<strong>传输层，网络层，数据链路层，物理层</strong>到达服务器。</li>
</ul>
</li>
</ul>
</li>
<li><strong>服务端</strong>：<ul>
<li>服务器解析这个请求来作出响应，<strong>返回相应的html</strong>给浏览器。</li>
</ul>
</li>
<li><strong>客户端</strong>：<ol>
<li><strong>构建DOM树：</strong>浏览器<strong>根据这个html来构建DOM树</strong>，在dom树的构建过程中如果<strong>遇到JS脚本和外部JS连接</strong>，则会<strong>停止构建DOM树和css解析（因为JS有可能修改DOM结构）来执行和下载相应的代码</strong>，这会造成<strong>阻塞</strong>，这就是为什么<strong>推荐JS代码应该放在html代码的后面</strong>。</li>
</ol>
<ul>
<li>js的解析涉及<strong>同步、异步（宏任务与微任务）</strong>，<a href="https://huanglizhu.github.io/2019/09/27/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/#JS的解析（同步、异步）" target="_blank" rel="noopener">事件循环</a></li>
</ul>
<ol start="2">
<li><strong>构建CSS对象模型树CSSOM树：</strong>解析html过程中遇到引入了css，则会在解析html的同时解析css，根据外部样式，内部样式，内联样式<strong>构建一个CSS对象模型树CSSOM树</strong></li>
<li><strong>合并为渲染树：</strong> CSSOM树构建完成后<strong>CSSOM树和DOM树合并为渲染树</strong>，这里主要做的是排除非视觉节点，比如script，meta标签和排除display为none的节点。</li>
<li>最后浏览器<strong>回流后将渲染树绘制到屏幕上显示</strong>。这个过程比较复杂，涉及到两个概念: <strong>reflow(回流)和repain(重绘)</strong>。</li>
</ol>
<ul>
<li><strong><a href="https://huanglizhu.github.io/2019/09/27/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/#%E6%B5%8F%E8%A7%88%E5%99%A8-reflow-%E5%9B%9E%E6%B5%81-%E5%92%8Crepain-%E9%87%8D%E7%BB%98" target="_blank" rel="noopener">回流</a>：</strong>会引起<strong>元素位置/内容变化、布局、隐藏</strong>的就会<strong>reflow(回流)</strong>，如：窗口大小改变、字体大小改变、以及元素位置改变，都会引起周围的元素改变他们以前的位置。</li>
<li><strong><a href="https://huanglizhu.github.io/2019/09/27/%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E6%98%BE%E7%A4%BA%E9%83%BD%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88/#%E6%B5%8F%E8%A7%88%E5%99%A8-reflow-%E5%9B%9E%E6%B5%81-%E5%92%8Crepain-%E9%87%8D%E7%BB%98" target="_blank" rel="noopener">重绘</a>：不会引起位置、布局变化，只是影响元素的外观的</strong>，比如改变背景颜色等，只会<strong>repaint(重绘)</strong>。</li>
</ul>
</li>
<li><strong>另外的HTTP请求：</strong> html文件中会含有 图片、视频、音频、js、jquery、css等其他资源，这些又是另外的HTTP请求。在解析DOM的过程中，遇到这些都会进行并行下载，浏览器对每个域的并行下载数量有一定的限制，一般是4-6个，可能会通过一个网页产生很多的HTTP请求，<strong>请求越少性能越好</strong>。</li>
<li>为提高性能要关注<strong>缓存</strong>（强缓存和协商缓存），缓存一般通过Cache-Control、Last-Modify、Expires等首部字段控制。 <ul>
<li>Cache-Control和Expires的区别在于Cache-Control使用<strong>相对时间</strong>，Expires使用的是基于服务器 端的<strong>绝对时间</strong>，因为存在时差问题，一般采用Cache-Control。</li>
<li>在请求这些有设置了缓存的数据时，如是<strong>强缓存，则不发送请求，直接从缓存中获取数据</strong>。</li>
<li>如是<strong>协商缓存</strong>，则会<strong>发送请求到服务器</strong>，如果上一次 响应设置了ETag值，则会在这次请求的时候作为If-None-Match的值交给服务器<strong>校验</strong>，如果一致，继续校验客户端发送的IF-Modified-Since与服务端的 Last-Modified是否一致，没有设置ETag则直接验证Last-Modified，<strong>都一致则返回304（Not Changed）告知浏览器可以直接从缓存获取，否则返回最新的资源内容</strong>。</li>
</ul>
</li>
<li><strong>连接结束：</strong><ul>
<li>主机向服务器发送一个断开连接的请求（不早了，我该走了）；</li>
<li>服务器接到请求后发送确认收到请求的信号（知道了）；</li>
<li>服务器向主机发送断开通知（我也该走了）；</li>
<li>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；</li>
</ul>
</li>
</ol>
<hr>
<h1 id="cookie相关"><a href="#cookie相关" class="headerlink" title="cookie相关"></a>cookie相关</h1><ul>
<li><strong>补充说明一下cookie的作用</strong>：<ul>
<li><strong>保存用户登录状态</strong>。例如将<strong>用户id</strong>存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。</li>
<li>cookie还可以<strong>设置过期时间</strong>，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户<strong>保持登录状态的时间</strong>：常见选项有一个月、三个 月、一年等。</li>
<li><strong>跟踪用户行为</strong>。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了cookie后就会显得很人性化了，系统能够<strong>记住上一次访问的地区</strong>，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便定制页面。</li>
<li>如果网站提供了换肤或更换布局的功能，那么<strong>可以使用cookie来记录用户的选项，例如：背景色、分辨率等</strong>。当用户下次访问时，仍然可以<strong>保存上一次访问的界面风格</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="cookie有哪些编码方式"><a href="#cookie有哪些编码方式" class="headerlink" title="cookie有哪些编码方式"></a>cookie有哪些编码方式</h2><p>encodeURI（）</p>
<hr>
<h2 id="cookie有哪些字段可以设置"><a href="#cookie有哪些字段可以设置" class="headerlink" title="cookie有哪些字段可以设置"></a>cookie有哪些字段可以设置</h2><ul>
<li><a href="https://www.runoob.com/js/js-cookies.html" target="_blank" rel="noopener">例子</a></li>
<li><strong>name字段</strong>：一个<strong>cookie的名称</strong>。</li>
<li><strong>value字段</strong>：一个<strong>cookie的值</strong>。</li>
<li><strong>Size字段</strong>：此<strong>cookie大小</strong>。</li>
<li><strong>domain字段</strong>：可以访问此cookie的<strong>域名</strong>。<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfijoy3cg6j30k005s436.jpg" alt="域名图示"><ul>
<li><strong>非顶级域名</strong>，如二级域名或者三级域名，设置的cookie的domain <strong>只能为顶级域名或者二级域名或者三级域名本身，不能设置其他二级域名的cookie</strong>，否则cookie无法生成。<ul>
<li><strong>二级域名能读取设置了domain为顶级域名或者自身的cookie，不能读取其他二级域名domain的cookie</strong>。所以要想cookie在多个二级域名中共享，需要<strong>设置domain为顶级域名，这样就可以在所有二级域名里面或者到这个cookie的值</strong>了。</li>
</ul>
</li>
<li><strong>顶级域名：只能设置domain为顶级域名</strong>，不能设置为二级域名或者三级域名，否则cookie无法生成。<ul>
<li><strong>顶级域名只能获取到domain设置为顶级域名的cookie</strong>，其他domain设置为二级域名的无法获取。</li>
</ul>
</li>
</ul>
</li>
<li><strong>path字段</strong>：可以访问此cookie的<strong>页面路径</strong>。比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie。</li>
<li><strong><a href="https://www.runoob.com/js/js-cookies.html" target="_blank" rel="noopener">expires</a>/Max-Age 字段</strong>：此<strong>cookie超时时间</strong>。若设置其值为一个时间，那么当到达此时间后，此cookie失效。<strong>不设置的话默认值是Session，意思是cookie会和session一起失效</strong>。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。<ul>
<li><strong>注意：</strong>其实在浏览器关闭后，session并没有失效，正常来说一个session的存活时间是30分钟，也就是在不操作这个session的情况下，30分钟自动清除。可是实际中浏览器关闭，设置的session也会随之消失，<strong>这里的消失是指你找不到这个session</strong>，不是他没有了，因为<strong>在浏览器重新打开时，浏览器总会自动给你创建一个的新的session</strong>。session并不是唯一的，<strong>每个session都有自己的一个专属sessionId，这个sessionId在浏览器打开时创建，保存在浏览器的cookie中，浏览器关闭，cookie自动清除，sessionId丢失，之前的session找寻不到</strong>！</li>
</ul>
</li>
<li><strong>http字段</strong>：cookie的<strong>httponly属性</strong>。若此属性为true，则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie。（即禁止javascript脚本来访问cookie）</li>
<li><strong>secure 字段</strong>：设置是否<strong>仅在请求为https的时候传递此条cookie</strong></li>
</ul>
<hr>
<h2 id="cookie如何防范XSS攻击"><a href="#cookie如何防范XSS攻击" class="headerlink" title="cookie如何防范XSS攻击"></a>cookie如何防范XSS攻击</h2><ul>
<li>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本</li>
<li>在<strong>HTTP头部配上<code>set-cookie:httponly</code></strong>,禁止javascript脚本来访问cookie。严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。（在node中的设置方法可参考<a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#给cookie做限制" target="_blank" rel="noopener">博客项目登录（cookie）</a>）</li>
<li><strong>设置cookie的secure属性为<code>secure:true</code></strong>,告诉浏览器<strong>仅在请求为https的时候发送cookie</strong></li>
</ul>
<hr>
<h3 id="XSS和csrf网络攻击"><a href="#XSS和csrf网络攻击" class="headerlink" title="XSS和csrf网络攻击"></a>XSS和csrf网络攻击</h3><ul>
<li><strong>区别：</strong> XSS是利用用户对指定网站的信任，CSRF是利用网站对用户的信任。</li>
</ul>
<h4 id="XSS与防范"><a href="#XSS与防范" class="headerlink" title="XSS与防范"></a>XSS与防范</h4><ul>
<li><strong>XSS</strong>：<strong>跨站脚本攻击</strong>，攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取cookie，或者其他用户身份信息。<ul>
<li><strong>存储性</strong>（持久型）：用户输入的带有恶意脚本的数据存储在<strong>服务器端</strong>。当浏览器请求数据时，服务器返回脚本并执行。主要是通过html标签注入，篡改网页，插入恶意的脚本，<strong>前端可能没有经过严格的校验直接就进到数据库</strong>，数据库又通过前端程序又回显到浏览器。<ul>
<li>比如：攻击者在社区或论坛上写下一篇包含恶意 Js代码的文章或评论，文章或评论发表后，所有访问该文章或评论的用户，都会在他们的浏览器中执行这段恶意的 JavaScript 代码。</li>
</ul>
</li>
<li><strong>反射型</strong>（非持久型）：把用户输入的数据”反射”给<strong>浏览器</strong>。通常是，用户点击链接或提交表单时，攻击者向用户访问的网站注入恶意脚本。<ul>
<li>比如：在正常页面上添加一个恶意链接。恶意链接的地址指向localhost:8080。然后攻击者有一个node服务来处理对localhost:8080的请求:当用户点击恶意链接时，页面跳转到攻击者预先准备的localhost:8080页面，执行了 恶意的js 脚本，产生攻击。</li>
</ul>
</li>
</ul>
</li>
<li><strong>XSS预防</strong> : <strong>前端在显示时替换，后端在存储时替换</strong>，都做总不会有错(可参考<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#Cookie如何防范XSS攻击" target="_blank" rel="noopener">XSS网络攻击及防范</a>)<ol>
<li><strong>替换特殊字符</strong>，如<code>&lt;</code>变为<code>&amp;lt；</code> <code>&gt;</code>变为<code>&amp;gt</code>,<code>&lt;script&gt;</code>变为<code>&amp;lt；script&amp;gt；</code>直接显示，而<strong>不会作为脚本执行</strong>(实际工作中可使用<a href="https://www.npmjs.com/package/xss" target="_blank" rel="noopener">XSS工具</a>)<ul>
<li>例子：<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfwb4suzlej30oh05uaeb.jpg" alt="前端在显示时替换特殊字符"><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfwb58vn0lj30fa08bjt9.jpg" alt="显示效果">特殊字符在html中会<strong>被浏览器解析</strong>显示为相应的符号，<strong>故script以字符串形式显示，不会作为脚本执行</strong></li>
</ul>
</li>
<li>在<strong>HTTP头部配上<code>set-cookie:httponly</code></strong>,禁止javascript脚本来访问cookie。严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。（在node中的设置方法可参考<a href="https://huanglizhu.github.io/2020/02/25/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E7%99%BB%E5%BD%95%EF%BC%88cookie%EF%BC%89/#给cookie做限制" target="_blank" rel="noopener">博客项目登录（cookie）</a>）</li>
<li><strong>设置cookie的secure属性为<code>secure:true</code></strong>,告诉浏览器<strong>仅在请求为https的时候发送cookie</strong></li>
</ol>
</li>
<li><strong>XSS工具</strong>：替换特殊字符可使用<a href="https://www.npmjs.com/package/xss" target="_blank" rel="noopener">XSS工具</a><ul>
<li><strong>node使用XSS</strong>的方法可参考博客：<a href="https://huanglizhu.github.io/2020/03/03/%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE%E5%AE%89%E5%85%A8/#xss攻击（xss库（函数）））" target="_blank" rel="noopener">博客项目安全</a></li>
<li><strong>前端使用XSS</strong>的方法可参考官方例子：<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfwbfb4srkj30u30al0u0.jpg" alt="参考官方例子"></li>
</ul>
</li>
</ul>
<h4 id="CSRF与防范"><a href="#CSRF与防范" class="headerlink" title="CSRF与防范"></a>CSRF与防范</h4><ul>
<li><strong>CSRF</strong>：<strong>跨站请求伪造</strong>，攻击者借助用户的 Cookie 骗取服务器的信任，以用户名义伪造请求发送给服务器。如：在请求的url后加入一些恶意的参数。换句话说，<strong>CSRF就是利用用户的登录态发起恶意请求</strong>。<ul>
<li>比如：你登录网站，并在本地存下了，如果在没退出该网站的时候不小心访问了恶意网站，而且这个网站需要你发一些请求等，此时，你是携带cookie进行访问的，那么你的存在cookie里的信息就会被恶意网站捕捉到，那么你的信息就被盗用，导致一些不法分子做一些事情。<ul>
<li>假设某银行网站A以GET请求来发起转账操作，转账的地址为<code>www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000</code>，参数accountNum表示转账的账户，参数money表示转账金额。而某大型论坛B上，一个恶意用户上传了一张图片，而图片的地址栏中填的并不是图片的地址，而是前而所说的砖账地址：<code>&lt;img src=&quot;http://www.xxx.com/transfer.do?accountNum=l000l&amp;money=10000&quot;&gt;</code><br>当你登录网站A后，没有及时登出，这时你访问了论坛B，不幸的事情发生了，你会发现你的账号里面少了10000块…（上述只是举例，转账怎么可能是get请求，为了保险，肯定是post请求，更何况银行的交易付款会有登录密码和支付密码等一系列屏障，流程复杂得多，安全系数也高得多）</li>
</ul>
</li>
<li><strong>防御</strong>：</li>
</ul>
<ol>
<li><strong>使用token验证</strong>：在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，若请求无 token 或者 token 不正确，则认为可能是 CSRF 攻击而拒绝该请求。<ul>
<li>每次请求时 CSRF Token 都是不同的。(<a href="http://www.manongjc.com/detail/9-aymgksshxqyawjp.html" target="_blank" rel="noopener">例子</a>)</li>
<li><strong>例子：</strong><ul>
<li>比如有个网站，点赞是 get 方式请求：<code>http://www.xxxx.com/like?id=12365</code></li>
<li>如果没有验证 token 的话，我只要随便在某个网页发个图，图片地址设置这个 url，对方只要访问这个页面，加载这个图，对方就会自动给 id 为 12365 的帖子点赞了。</li>
<li>如果验证 token，点赞的 get 的可能就是这种：     <a href="http://www.xxxx.com/like?id=12365&amp;token=A23F267AE65" target="_blank" rel="noopener">http://www.xxxx.com/like?id=12365&amp;token=A23F267AE65</a> ，由于每个人的 token 是变化的，你无法预先知道对方的 token，对方加载了 <code>http://www.xxxx.com/like?id=12365</code>，也不会成功</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查https头部的Referer</strong>：在HTTP头中有一个字段叫做Referer,它记录了该HTTP请求的来源地址。通过Referer Check,可以检查是否来自合法的”源”。<ul>
<li>例如：从<a href="http://www.user.com发起的删帖请求，那么Referer值是http://www.user.com" target="_blank" rel="noopener">www.user.com发起的删帖请求，那么Referer值是http://www.user.com</a>, 删帖请求应该被允许；而如果是从CSRF攻击者构造的页面<a href="http://www.attack.com发起删帖请求，" target="_blank" rel="noopener">www.attack.com发起删帖请求，</a> 那么Referer值是<a href="http://www.attack.com" target="_blank" rel="noopener">http://www.attack.com</a>, 删帖请求应该被阻止。</li>
</ul>
</li>
<li><strong>验证码</strong>：验证码会强制用户必须与应用进行交互，才能完成最终请求，但是也不能给网站所有的操作都加上验证码，所以只能作为防御 CSRF 的一种辅助手段，而不能作为最终的解决方案。</li>
<li><strong>使用post接口</strong>，img这些跨域只能接收get请求，设计post请求的需要server端的允许</li>
</ol>
</li>
</ul>
<hr>
<h2 id="除了cookie，还有什么存储方式"><a href="#除了cookie，还有什么存储方式" class="headerlink" title="除了cookie，还有什么存储方式"></a>除了cookie，还有什么存储方式</h2><p>还有localStorage，sessionStorage，indexdDB等</p>
<hr>
<h3 id="cookie、sessionStorage、localStorage的区别"><a href="#cookie、sessionStorage、localStorage的区别" class="headerlink" title="cookie、sessionStorage、localStorage的区别"></a>cookie、sessionStorage、localStorage的区别</h3><ul>
<li><strong>共同点</strong>：都<strong>保存在浏览器端</strong>。</li>
<li><strong>区别：</strong></li>
</ul>
<ol>
<li><strong>生命周期</strong>：<ul>
<li>Cookie：<strong>设置的cookie过期时间之前一直有效</strong>，即使窗口或浏览器关闭。未设置则<strong>默认为关闭浏览器后失效</strong>。(<strong>不是浏览器标签页</strong>，而是整个浏览器)</li>
<li>Localstorage:除非被手动清除，否则<strong>永久保存</strong>，窗口或浏览器关闭也一直保存，因此<strong>用作持久数据</strong>。</li>
<li>Sessionstorage：<strong>仅在当前网页会话下有效</strong>，关闭<strong>页面或浏览器</strong>后就会被清除（刷新页面不会被清除），自然也就不可能持久保持。</li>
</ul>
</li>
<li><strong>存放数据</strong>：<ul>
<li>Cookie：4k左右（cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下）</li>
<li>Localstorage和sessionstorage：可以保存5M的信息</li>
</ul>
</li>
<li><strong>是否跟随http请求发送出去</strong>：<ul>
<li>Cookie：<strong>每次都会携带在http头中</strong>，如果使用cookie保存过多数据会带来性能问题</li>
<li>其他两个：<strong>不会自动把数据发给服务器，仅在客户端即浏览器中保存</strong>，不参与和服务器的通信</li>
</ul>
</li>
<li><strong>API易用性</strong>：<ul>
<li>Cookie：需要程序员自己封装，原生的cookie接口不友好（<a href="https://www.runoob.com/js/js-cookies.html" target="_blank" rel="noopener">document.cookie</a>）</li>
<li>其他两个：即可采用原生接口（<a href="https://www.runoob.com/jsref/prop-win-sessionstorage.html" target="_blank" rel="noopener">getItem、setItem、removeItem、clear</a>），亦可再次封装</li>
</ul>
</li>
<li><strong>应用场景</strong>：<ul>
<li>从安全性来说，因为每次http请求都回携带cookie信息，这样子浪费了带宽，<strong>所以cookie应该尽可能的少用</strong>，此外cookie还需要指定作用域，<strong>不可以跨域调用</strong>，限制很多，但是<strong>对于用户识别用户登陆来说，cookie还是比storage好用</strong></li>
<li>其他情况下可以用storage，<strong>localstorage可以用来在页面传递参数</strong></li>
<li><strong>sessionstorage可以用来保存一些临时的数据</strong>，防止用户刷新页面后丢失了一些参数。</li>
</ul>
</li>
<li><strong>作用域：</strong><ul>
<li>cookie和localStorage：在所有<strong>同源窗口</strong>中都是共享的</li>
<li>sessionStorage：在<strong>同一个浏览器窗口</strong>是共享的（不同浏览器、同一个页面也是不共享的）</li>
<li>关于<strong>同源</strong>可参考<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">阮一峰</a>，简单来说就是A网页设置的 Cookie，B网页不能打开，除非这两个网页”同源”。所谓<strong>“同源”指的是”三个相同”</strong>。<ol>
<li><strong>协议</strong>相同</li>
<li><strong>域名</strong>相同</li>
<li><strong>端口</strong>相同</li>
</ol>
</li>
<li>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，<strong>协议</strong>是<code>http://</code>，<strong>域名</strong>是<code>www.example.com</code>，<strong>端口</strong>是<code>80</code>（默认端口可以省略）。它的同源情况如下。<ol>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
</ol>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Cookie和session的区别"><a href="#Cookie和session的区别" class="headerlink" title="Cookie和session的区别"></a>Cookie和session的区别</h2><ol>
<li><strong>cookie数据</strong>存放在客户的<strong>浏览器</strong>上，<strong>session</strong>数据放在<strong>服务器</strong>上。（session可以存放于文件，数据库，内存中）</li>
<li><strong>cookie不是很安全</strong>，server端可以修改cookie并返回给浏览器，浏览器中也可以通过javascript修改cookie（有限制）。别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，<strong>考虑到安全应当使用session</strong>。server端放置信息不会被前端获取到，<strong>更安全</strong>。且server端空间大，<strong>可存储更多信息</strong>。</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用redis。</li>
<li><strong>单个cookie</strong>保存的数据<strong>不能超过4K</strong>，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>Cookie的最大的作用就是存储sessionId用来唯一标识用户。也可存放不敏感的信息，比如用户设置的<strong>网站主题、地区</strong>。</li>
</ol>
<hr>
<h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h2 id="怎么看网站的性能如何"><a href="#怎么看网站的性能如何" class="headerlink" title="怎么看网站的性能如何"></a>怎么看网站的性能如何</h2><p>检测页面加载时间一般有两种方式</p>
<ol>
<li>一种是<strong>被动去测</strong>：就是在被检测的页面置入脚本或探针，当用户访问网页时，探针自动采集数据并传回数据库进行分析</li>
<li>另一种<strong>主动监测</strong>的方式，即<strong>主动的搭建分布式受控环境</strong>，模拟用户发起页面访问请求，主动采集性能数据并分析，在检测的精准度上，专业的第三方工具效果更佳，比如说<strong>性能极客</strong></li>
</ol>
<hr>
<h2 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h2><ul>
<li>可参考<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="noopener">JS 运行环境</a></li>
<li><strong>加快请求速度</strong>：<a href="https://huanglizhu.github.io/2020/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%883%EF%BC%89/#说一下web-worker" target="_blank" rel="noopener">web worker多线程</a>，react中<a href="https://huanglizhu.github.io/2020/04/14/React%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB%EF%BC%88%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89/#异步组件（懒加载）" target="_blank" rel="noopener">异步组件（懒加载）</a> <ol>
<li><strong>减少资源体积：压缩代码</strong><ul>
<li>比如使用<strong>webpack在production环境下</strong>进行打包时，就会<strong>自动压缩代码</strong>至1/3的大小，在浏览器上进行反解析再进行渲染。</li>
</ul>
</li>
<li><strong>减少访问次数</strong>：<ul>
<li><a href="https://huanglizhu.github.io/2019/12/06/CSS%E9%9D%9E%E5%B8%83%E5%B1%80%E6%A0%B7%E5%BC%8F%EF%BC%9A%E8%83%8C%E6%99%AF/#雪碧图" target="_blank" rel="noopener">雪碧图</a></li>
<li><strong>合并代码</strong>：比如webpack中，在index.js中引入a.js、b.js，打包后只生成一个bundle.js，这就是合并代码。（加载3次3kb的文件不如加载1次9kb快，这<strong>和网络请求有关系</strong>）</li>
<li><strong>SSR服务器端渲染</strong>：不需要通过ajax发送请求。</li>
<li><strong>缓存</strong>：原本需要发送多个请求的数据直接在缓存中获取即可减少访问次数。<ul>
<li>离线数据缓存localStorage。</li>
<li><strong>尽量命中强缓存</strong>，结合<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#缓存" target="_blank" rel="noopener">webpack的内容哈希值输出文件名</a>，减少http请求。（具体见下方<a href="https://huanglizhu.github.io/2020/04/03/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-HTTP%20HTML%20%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%882%EF%BC%89/#前端缓存最佳实践" target="_blank" rel="noopener">“前端缓存最佳实践”</a>）</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用更快的网络：CDN</strong><ul>
<li>CDN是<strong>分区域</strong>的，也就是使用CDN的时候上海和北京对同一个网站的IP地址是不同的。<strong>CDN会选择一个离用户最近的CDN边缘节点来响应用户的请求</strong>，这样海南移动用户的请求就不会千里迢迢跑到北京电信机房的服务器（假设源站部署在北京电信机房）上了</li>
<li><strong>图片、js等静态资源</strong>采用CDN是很快的，我们经常使用的<strong>bootstrap就是使用的CDN</strong></li>
</ul>
</li>
</ol>
</li>
<li><strong>渲染</strong>：<ul>
<li><strong>CSS放在head中，JS放在body最下面</strong></li>
<li><strong>尽早开始执行JS</strong>，用<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#window-onload%E5%92%8CDOMContentLoaded" target="_blank" rel="noopener">DOMContentLoaded</a>触发</li>
<li><strong><a href="https://huanglizhu.github.io/2020/02/07/JS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%883%EF%BC%89/#%E5%9B%BE%E7%89%87%E7%9A%84%E6%87%92%E5%8A%A0%E8%BD%BD" target="_blank" rel="noopener">懒加载</a></strong>（图片懒加载，上滑加载更多）</li>
<li>对<strong>DOM查询进行缓存</strong>（DOM操作很耗性能）</li>
<li><strong>频繁DOM操作，<a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E5%A4%9A%E4%B8%AADOM%E6%93%8D%E4%BD%9C%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">合并</a></strong>到一起插入DOM结构</li>
<li>让渲染更流畅：<strong><a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E8%8A%82%E6%B5%81-throttle" target="_blank" rel="noopener">节流throttle</a> <a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E9%98%B2%E6%8A%96-debounce" target="_blank" rel="noopener">防抖debounce</a></strong></li>
</ul>
</li>
<li><strong>减少回流、重绘：</strong><ul>
<li><strong><a href="https://huanglizhu.github.io/2020/04/04/JS%20%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/#%E5%A4%9A%E4%B8%AADOM%E6%93%8D%E4%BD%9C%E5%90%88%E5%B9%B6" target="_blank" rel="noopener">合并DOM操作</a></strong>：比如我们要向页面添加多个img元素，如果单独加进去就会频繁的回流+重绘，此时我们就可以使用<code>document.createDocumentFragment()</code>将多个img合并到Fragment中再统一加入。</li>
<li><strong>避免频繁读取会引发回流/重绘的属性(见上)</strong>，如果确实需要多次使用，就用一个<strong>变量缓存</strong>起来。</li>
<li>将动画效果应用到position属性为absolute或fixed的元素上，对具有<strong>复杂动画的元素</strong>使用<strong>绝对定位</strong>，使它<strong>脱离文档流</strong>，否则会引起父元素及后续元素频繁回流。</li>
</ul>
</li>
</ul>
<hr>
<h2 id="说一下浏览器缓存"><a href="#说一下浏览器缓存" class="headerlink" title="说一下浏览器缓存"></a>说一下浏览器缓存</h2><p><a href="https://www.cnblogs.com/Aaron1Tall/p/11041884.html" target="_blank" rel="noopener">前端缓存</a><br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfgcemkhr3j30m80h1q73.jpg" alt="image.png"></p>
<hr>
<h2 id="强缓存和协商缓存（web性能优化）"><a href="#强缓存和协商缓存（web性能优化）" class="headerlink" title="强缓存和协商缓存（web性能优化）"></a>强缓存和协商缓存（web性能优化）</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/111190645" target="_blank" rel="noopener">图解流程详解</a>、<a href="http://caibaojian.com/browser-cache.html" target="_blank" rel="noopener">参考</a>、<a href="https://segmentfault.com/a/1190000008956069" target="_blank" rel="noopener">参考1</a>/<a href="https://www.jianshu.com/p/9c95db596df5" target="_blank" rel="noopener">参考2</a>、<a href="https://zhuanlan.zhihu.com/p/52916788" target="_blank" rel="noopener">前端缓存最佳实践</a>、<a href="https://zhuanlan.zhihu.com/p/73345909" target="_blank" rel="noopener">DNS缓存、CDN缓存、浏览器缓存</a></li>
<li>缓存是<strong>Web性能优化的重要方式</strong>。</li>
<li>缓存分为两种：强缓存和协商缓存，<strong>根据响应的header内容来决定</strong>。</li>
<li><strong>注意：强缓存也会有状态码，是200</strong></li>
<li><strong>区别：</strong>如果浏览器命中<strong>强缓存</strong>，则<strong>在设置好的失效时间内不需要给服务器发请求</strong>；而<strong>协商缓存</strong>最终<strong>由服务器来决定是否使用缓存</strong>，即客户端与服务器之间<strong>存在一次通信</strong>。</li>
<li>总之，<strong>强缓存就是强制从缓存中读取，不管是否更新。而协商缓存就是和 服务器协商是否从缓存取，如有更新则返回新数据。</strong><br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfg5rybbgxj30q108paaj.jpg" alt="image.png"></li>
<li><strong>强缓存</strong>是利用<strong>http的返回（响应）头中的Expires或者Cache-Control两个字段</strong>来控制的，用来<strong>表示资源的缓存时间</strong>。如果cache-control与expires同时存在的话，cache-control的优先级高于expires。<ul>
<li><strong>Expires</strong>是http1.0时的规范，它的值为一个绝对时间的GMT格式的时间字符串。缺点：由于<strong>失效时间是一个绝对时间</strong>，所以当服务器与客户端时间偏差较大时，就会导致缓存混乱。</li>
<li><strong>Cache-Control</strong>是http1.1时出现的header信息，主要是利用该字段的<strong>max-age值</strong>来进行判断，它是一个<strong>相对时间</strong>，例如<strong>Cache-Control:max-age=3600</strong>，代表着资源的有效期是3600秒。<ul>
<li>Cache-Control除了max-age还有以下<strong>常用字段</strong>：<ul>
<li><strong>no-cache：不使用本地缓存</strong>。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。</li>
<li><strong>no-store：直接禁止浏览器缓存数据</strong>，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。</li>
<li><strong>public：可以被所有的用户缓存</strong>，包括终端用户和CDN等中间代理服务器。</li>
<li><strong>private（默认）：只能被终端用户的浏览器缓存</strong>，不允许CDN等中继缓存服务器对其缓存。</li>
<li><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfgaikdwasj30kv0i112g.jpg" alt="Cache-Control"><a href="https://www.jianshu.com/p/9c95db596df5" target="_blank" rel="noopener">图解参考</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>协商缓存</strong>相关字段有 <strong>http响应头中的Last-Modified/请求头中的If-Modified-Since，http响应头中的Etag/请求头中的If-None-Match</strong>（<a href="https://blog.csdn.net/lhl1124281072/article/details/80067764" target="_blank" rel="noopener">具体参考</a>）<img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gkup59bjmvj30u009igmt.jpg" alt="协商缓存"><ul>
<li><strong>通过响应头的2个字段 设置协商缓存：</strong><ul>
<li><strong>etag</strong>：每个文件有一个，改动文件了就变了，就是个文件hash，每个文件唯一，就像用webpack打包的时候，每个资源都会有这个东西，如： app.js打包后变为 app.c20abbde.js，加个唯一hash，也是为了解决缓存问题。</li>
<li><strong>last-modified</strong>：文件的修改时间，精确到秒</li>
</ul>
</li>
</ul>
</li>
<li><strong>浏览器在第一次请求发生后，再次请求时</strong>：<ul>
<li>浏览器会先获取该资源缓存的header信息，<strong>根据其中的expires和cahe-control</strong>判断<strong>是否命中强缓存</strong>，若命中则直接从缓存中获取资源，包括缓存的header信息，本次请求不会与服务器进行通信；</li>
<li><strong>如果没有命中强缓存</strong>，浏览器会发送请求到服务器，该请求会携带第一次请求返回的有关缓存的header字段信息（IF-Modified-Since、IF-None-Match，这2个字段值是上次响应头中的Last-Modified和Etag保存而来）,由服务器根据请求中的相关header信息来<strong>对比结果是否命中协商缓存</strong>。</li>
<li><strong>若命中协商缓存</strong>，则服务器返回新的响应header信息（Last-Modified和Etag）更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取（304）；否则返回最新的资源内容（Last-Modified和Etag以及200状态码）</li>
</ul>
</li>
<li><strong>访问缓存优先级</strong><ul>
<li>先在<strong>内存</strong>中查找,如果有,直接加载。</li>
<li>如果内存中不存在,则在硬盘中查找,如果有直接加载。</li>
<li>如果<strong>硬盘</strong>中也没有,那么就进行<strong>网络请求</strong>。</li>
<li>请求获取的资源缓存到硬盘和内存。</li>
</ul>
</li>
<li><a href="https://zhuanlan.zhihu.com/p/73345909" target="_blank" rel="noopener">DNS缓存、CDN缓存、浏览器缓存</a><br><img src="http://ww1.sinaimg.cn/large/005H7IVsgy1gfgn77f2wkj30sf0hggof.jpg" alt="image.png"></li>
</ul>
<hr>
<h3 id="前端缓存最佳实践"><a href="#前端缓存最佳实践" class="headerlink" title="前端缓存最佳实践"></a>前端缓存最佳实践</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/52916788" target="_blank" rel="noopener">前端缓存最佳实践</a>：缓存的意义就在于减少请求，更多地使用本地的资源，给用户更好的体验的同时，也减轻服务器压力。所以，<strong>最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效</strong>。<ul>
<li><strong>更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在问题了</strong>（webpack打包时会把静态资源的路径加上hash值）</li>
<li>较为合理的缓存方案：<ul>
<li><strong>HTML：使用协商缓存。</strong></li>
<li><strong>CSS&amp;JS&amp;图片：使用强缓存，文件命名带上hash值。</strong></li>
</ul>
</li>
</ul>
</li>
<li>在做前端缓存时，我们<strong>尽可能设置长时间的强缓存</strong>，通过<strong>文件名加hash</strong>的方式来做版本更新。在代码分包的时候，应该将一些不常变的公共库独立打包出来，使其能够更持久的缓存。</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/JavaScript学习/">JavaScript学习</a>, <a class="article-category-link" href="/categories/面试题/">面试题</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/04/JS 运行环境/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          JS 运行环境
        
      </div>
    </a>
  
  
    <a href="/2020/04/02/前端基础-HTTP HTML 浏览器（1）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">前端基础-HTTP/HTML/浏览器（1）</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#流程"><span class="nav-number">1.</span> <span class="nav-text">流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcp三次握手，一句话概括"><span class="nav-number">1.1.</span> <span class="nav-text">tcp三次握手，一句话概括</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP和UDP的区别"><span class="nav-number">1.2.</span> <span class="nav-text">TCP和UDP的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#一个图片url访问后直接下载怎样实现"><span class="nav-number">1.3.</span> <span class="nav-text">一个图片url访问后直接下载怎样实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用HTML5实现"><span class="nav-number">1.3.1.</span> <span class="nav-text">使用HTML5实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#地址栏输入URL到页面呈现的过程"><span class="nav-number">1.4.</span> <span class="nav-text">地址栏输入URL到页面呈现的过程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#cookie相关"><span class="nav-number">2.</span> <span class="nav-text">cookie相关</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie有哪些编码方式"><span class="nav-number">2.1.</span> <span class="nav-text">cookie有哪些编码方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie有哪些字段可以设置"><span class="nav-number">2.2.</span> <span class="nav-text">cookie有哪些字段可以设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cookie如何防范XSS攻击"><span class="nav-number">2.3.</span> <span class="nav-text">cookie如何防范XSS攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#XSS和csrf网络攻击"><span class="nav-number">2.3.1.</span> <span class="nav-text">XSS和csrf网络攻击</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#XSS与防范"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">XSS与防范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSRF与防范"><span class="nav-number">2.3.1.2.</span> <span class="nav-text">CSRF与防范</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#除了cookie，还有什么存储方式"><span class="nav-number">2.4.</span> <span class="nav-text">除了cookie，还有什么存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie、sessionStorage、localStorage的区别"><span class="nav-number">2.4.1.</span> <span class="nav-text">cookie、sessionStorage、localStorage的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cookie和session的区别"><span class="nav-number">2.5.</span> <span class="nav-text">Cookie和session的区别</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#前端性能优化"><span class="nav-number">3.</span> <span class="nav-text">前端性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#怎么看网站的性能如何"><span class="nav-number">3.1.</span> <span class="nav-text">怎么看网站的性能如何</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#前端优化"><span class="nav-number">3.2.</span> <span class="nav-text">前端优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#说一下浏览器缓存"><span class="nav-number">3.3.</span> <span class="nav-text">说一下浏览器缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#强缓存和协商缓存（web性能优化）"><span class="nav-number">3.4.</span> <span class="nav-text">强缓存和协商缓存（web性能优化）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#前端缓存最佳实践"><span class="nav-number">3.4.1.</span> <span class="nav-text">前端缓存最佳实践</span></a></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">主页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
    <a href="/tags" class="mobile-nav-link">标签</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
    

                <div class="clearfix container">
                    <div class="site-info">
                        &copy;
                        2021
                            珠 All Rights Reserved.
                                
                                    <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次 本站总访问量
                                    <span id="busuanzi_value_site_pv"></span>次
                                    </span>
                                    
                    </div>
                    <div class="site-credit">
                        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
                    </div>
                </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    




  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
